//******************************************************************************************************************************************************************************************//
//                                                                                                                                                                                          //
// Written by Peter O.                                                                                                                                                                      //
//                                                                                                                                                                                          //
// Any copyright is dedicated to the Public Domain.                                                                                                                                         //
// http://creativecommons.org/publicdomain/zero/1.0/                                                                                                                                        //
// If you like this, you should donate to Peter O. at: http://peteroupc.github.io/                                                                                                          //
//                                                                                                                                                                                          //
//******************************************************************************************************************************************************************************************//
using System;
using System.Collections.Generic;
using System.Text;

namespace Neos.IdentityServer.MultiFactor.WebAuthN.Library.Cbor
{
    internal static class BigNumberFlags
    {
        internal const int FlagNegative = 1;
        internal const int FlagQuietNaN = 4;
        internal const int FlagSignalingNaN = 8;
        internal const int FlagInfinity = 2;
        internal const int FlagSpecial = FlagQuietNaN | FlagSignalingNaN |
          FlagInfinity;
        internal const int FlagNaN = FlagQuietNaN | FlagSignalingNaN;
        internal const int LostDigitsFlags = EContext.FlagLostDigits |
          EContext.FlagInexact | EContext.FlagRounded;
        internal const int FiniteOnly = 0;
        internal const int FiniteAndNonFinite = 1;
    }

    internal sealed class BitShiftAccumulator : IShiftAccumulator
    {
        private const int SmallBitLength = 32;
        private int bitLeftmost;

        public int LastDiscardedDigit
        {
            get
            {
                return this.bitLeftmost;
            }
        }

        private int bitsAfterLeftmost;

        public int OlderDiscardedDigits
        {
            get
            {
                return this.bitsAfterLeftmost;
            }
        }

        private EInteger shiftedBigInt;
        private FastInteger knownBitLength;

        public FastInteger GetDigitLength()
        {
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            return FastInteger.CopyFrozen(this.knownBitLength);
        }

        public FastInteger OverestimateDigitLength()
        {
            return this.GetDigitLength();
        }

        private static void VerifyKnownLength()
        {
        }

        public void ShiftToDigits(
          FastInteger bits,
          FastInteger preShift,
          bool truncate)
        {
            if (bits.Sign < 0)
            {
                throw new ArgumentException("bits's sign(" + bits.Sign +
                  ") is less than 0");
            }
            if (preShift != null && preShift.Sign > 0)
            {
                this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
                // DebugUtility.Log("bits=" + bits + " pre=" + preShift + " known=" +
                // (//kbl) + " [" + this.shiftedBigInt + "]");
                if (this.knownBitLength.CompareTo(bits) <= 0)
                {
                    // Known digit length is already small enough
                    // NOTE: For BitShiftAccumulator, truncating and shifting
                    // are the same, unlike in DigitShiftAccumulator
                    this.ShiftRight(preShift);
                    VerifyKnownLength();
                    return;
                }
                else
                {
                    FastInteger bitDiff = this.knownBitLength.Copy()
                      .Subtract(bits);
                    // DebugUtility.Log("bitDiff=" + bitDiff);
                    int cmp = bitDiff.CompareTo(preShift);
                    if (cmp <= 0)
                    {
                        // NOTE: For BitShiftAccumulator, truncating and shifting
                        // are the same, unlike in DigitShiftAccumulator
                        this.ShiftRight(preShift);
                        VerifyKnownLength();
                        return;
                    }
                    else
                    {
                        // NOTE: For BitShiftAccumulator, truncating and shifting
                        // are the same, unlike in DigitShiftAccumulator
                        this.ShiftRight(bitDiff);
                        VerifyKnownLength();
                        return;
                    }
                }
            }
            if (bits.CanFitInInt32())
            {
                this.ShiftToDigitsInt(bits.ToInt32());
                VerifyKnownLength();
            }
            else
            {
                this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
                EInteger bigintDiff = this.knownBitLength.ToEInteger();
                EInteger bitsBig = bits.ToEInteger();
                bigintDiff -= (EInteger)bitsBig;
                if (bigintDiff.Sign > 0)
                {
                    // current length is greater than the
                    // desired bit length
                    this.ShiftRight(FastInteger.FromBig(bigintDiff));
                }
                VerifyKnownLength();
            }
        }

        private int shiftedSmall;
        private bool isSmall;

        public EInteger ShiftedInt
        {
            get
            {
                return this.isSmall ? ((EInteger)this.shiftedSmall) :
                  this.shiftedBigInt;
            }
        }

        public FastInteger ShiftedIntFast
        {
            get
            {
                return this.isSmall ? new FastInteger(this.shiftedSmall) :
                  FastInteger.FromBig(this.shiftedBigInt);
            }
        }

        public int ShiftedIntMod(int mod)
        {
            if (mod < 1)
            {
                throw new ArgumentException("mod (" + mod +
                   ") is not greater or equal to 1");
            }
            switch (mod)
            {
                case 1:
                    return 0;
                case 2:
                    return this.isSmall ? (this.shiftedSmall & 1) :
                      (this.shiftedBigInt.IsEven ? 0 : 1);
                default:
                    return this.isSmall ? (this.shiftedSmall % mod) :
                      this.shiftedBigInt.Mod(mod).ToInt32Checked();
            }
        }

        private FastInteger discardedBitCount;

        public FastInteger DiscardedDigitCount
        {
            get
            {
                return this.discardedBitCount;
            }
        }

        public BitShiftAccumulator(
          EInteger bigint,
          int lastDiscarded,
          int olderDiscarded)
        {
            if (bigint.Sign < 0)
            {
                throw new ArgumentException("bigint's sign(" + bigint.Sign +
                  ") is less than 0");
            }
            if (bigint.CanFitInInt32())
            {
                this.isSmall = true;
                this.shiftedSmall = (int)bigint;
            }
            else
            {
                this.shiftedBigInt = bigint;
            }
            this.discardedBitCount = new FastInteger(0);
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = (lastDiscarded != 0) ? 1 : 0;
        }

        public BitShiftAccumulator(
          int smallint,
          int lastDiscarded,
          int olderDiscarded)
        {
            this.shiftedSmall = smallint;
            if (this.shiftedSmall < 0)
            {
                throw new ArgumentException("shiftedSmall(" + this.shiftedSmall +
                  ") is less than 0");
            }
            this.isSmall = true;
            this.discardedBitCount = new FastInteger(0);
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = (lastDiscarded != 0) ? 1 : 0;
        }

        public static BitShiftAccumulator FromInt32(int smallNumber)
        {
            if (smallNumber < 0)
            {
                throw new ArgumentException("smallNumber(" + smallNumber +
                  ") is less than 0");
            }
            var bsa = new BitShiftAccumulator(EInteger.Zero, 0, 0);
            bsa.shiftedSmall = smallNumber;
            bsa.discardedBitCount = new FastInteger(0);
            bsa.isSmall = true;
            return bsa;
        }

        public void TruncateOrShiftRight(FastInteger fastint, bool truncate)
        {
            this.ShiftRight(fastint);
        }

        public void ShiftRight(FastInteger fastint)
        {
            if (fastint.Sign <= 0)
            {
                return;
            }
            if (fastint.CanFitInInt32())
            {
                this.ShiftRightInt(fastint.ToInt32());
            }
            else
            {
                EInteger bi = fastint.ToEInteger();
                while (bi.Sign > 0)
                {
                    var count = 1000000;
                    if (bi.CompareTo((EInteger)1000000) < 0)
                    {
                        count = (int)bi;
                    }
                    this.ShiftRightInt(count);
                    bi -= (EInteger)count;
                    if (this.isSmall ? this.shiftedSmall == 0 :
                      this.shiftedBigInt.IsZero)
                    {
                        break;
                    }
                }
            }
        }

        private void ShiftRightBig(int bits)
        {
            if (bits <= 0)
            {
                return;
            }
            if (this.shiftedBigInt.IsZero)
            {
                this.discardedBitCount.AddInt(bits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownBitLength = new FastInteger(1);
                return;
            }
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            this.discardedBitCount.AddInt(bits);
            int cmp = this.knownBitLength.CompareToInt(bits);
            if (cmp < 0)
            {
                // too few bits
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitsAfterLeftmost |= this.shiftedBigInt.IsZero ? 0 : 1;
                this.bitLeftmost = 0;
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownBitLength = new FastInteger(1);
            }
            else
            {
                // enough bits in the current value
                int bs = bits;
                this.knownBitLength.SubtractInt(bits);
                if (bs == 1)
                {
                    bool odd = !this.shiftedBigInt.IsEven;
                    this.shiftedBigInt >>= 1;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = odd ? 1 : 0;
                }
                else
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    long lowestSet = this.shiftedBigInt.GetLowBitAsInt64();
                    if (lowestSet == Int64.MaxValue)
                    {
                        EInteger lowestSetBit = this.shiftedBigInt.GetLowBitAsEInteger();
                        if (lowestSetBit.CompareTo(bs - 1) < 0)
                        {
                            // One of the discarded bits after
                            // the last one is set
                            this.bitsAfterLeftmost |= 1;
                            this.bitLeftmost = this.shiftedBigInt.GetSignedBit(bs - 1) ? 1 :
              0;
                        }
                        else if (lowestSetBit.CompareTo(bs - 1) > 0)
                        {
                            // Means all discarded bits are zero
                            this.bitLeftmost = 0;
                        }
                        else
                        {
                            // Only the last discarded bit is set
                            this.bitLeftmost = 1;
                        }
                    }
                    else
                    {
                        if (lowestSet < bs - 1)
                        {
                            // One of the discarded bits after
                            // the last one is set
                            this.bitsAfterLeftmost |= 1;
                            this.bitLeftmost = this.shiftedBigInt.GetSignedBit(bs - 1) ? 1 :
              0;
                        }
                        else if (lowestSet > bs - 1)
                        {
                            // Means all discarded bits are zero
                            this.bitLeftmost = 0;
                        }
                        else
                        {
                            // Only the last discarded bit is set
                            this.bitLeftmost = 1;
                        }
                    }
                    this.shiftedBigInt >>= bs;
                }
                if (this.knownBitLength.CompareToInt(SmallBitLength) < 0)
                {
                    // Shifting to small number of bits,
                    // convert to small integer
                    this.isSmall = true;
                    this.shiftedSmall = (int)this.shiftedBigInt;
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        private FastInteger CalcKnownBitLength()
        {
            if (this.isSmall)
            {
                int kb = SmallBitLength;
                for (int i = SmallBitLength - 1; i >= 0; --i)
                {
                    if ((this.shiftedSmall & (1 << i)) != 0)
                    {
                        break;
                    }
                    --kb;
                }
                // Make sure bit length is 1 if value is 0
                if (kb == 0)
                {
                    ++kb;
                }
                return new FastInteger(kb);
            }
            if (this.shiftedBigInt.IsZero)
            {
                {
                    return new FastInteger(1);
                }
            }
            long sbe = this.shiftedBigInt.GetSignedBitLengthAsInt64();
            return (sbe < Int32.MaxValue) ? new FastInteger((int)sbe) :
      FastInteger.FromBig(this.shiftedBigInt.GetSignedBitLengthAsEInteger());
        }

        private void ShiftBigToBits(int bits)
        {
            // Shifts a number until it reaches the given number of bits,
            // gathering information on whether the last bit discarded is set and
            // whether the discarded bits to the right of that bit are set. Assumes
            // that the big integer being shifted is positive.
            if (this.knownBitLength != null)
            {
                if (this.knownBitLength.CompareToInt(bits) <= 0)
                {
                    return;
                }
            }
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            if (this.knownBitLength.CompareToInt(bits) <= 0)
            {
                return;
            }
            // Shift by the difference in bit length
            if (this.knownBitLength.CompareToInt(bits) > 0)
            {
                var bs = 0;
                if (this.knownBitLength.CanFitInInt32())
                {
                    bs = this.knownBitLength.ToInt32();
                    bs -= bits;
                }
                else
                {
                    FastInteger bitShift =
                      this.knownBitLength.Copy().SubtractInt(bits);
                    if (!bitShift.CanFitInInt32())
                    {
                        this.ShiftRight(bitShift);
                        return;
                    }
                    bs = bitShift.ToInt32();
                }
                this.knownBitLength.SetInt(bits);
                this.discardedBitCount.AddInt(bs);
                if (bs == 1)
                {
                    bool odd = !this.shiftedBigInt.IsEven;
                    this.shiftedBigInt >>= 1;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = odd ? 1 : 0;
                }
                else
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    long lowestSet = this.shiftedBigInt.GetLowBitAsInt64();
                    if (lowestSet == Int64.MaxValue)
                    {
                        EInteger lowestSetBit = this.shiftedBigInt.GetLowBitAsEInteger();
                        if (lowestSetBit.CompareTo(bs - 1) < 0)
                        {
                            // One of the discarded bits after
                            // the last one is set
                            this.bitsAfterLeftmost |= 1;
                            this.bitLeftmost = this.shiftedBigInt.GetSignedBit(bs - 1) ? 1 :
              0;
                        }
                        else if (lowestSetBit.CompareTo(bs - 1) > 0)
                        {
                            // Means all discarded bits are zero
                            this.bitLeftmost = 0;
                        }
                        else
                        {
                            // Only the last discarded bit is set
                            this.bitLeftmost = 1;
                        }
                    }
                    else
                    {
                        if (lowestSet < bs - 1)
                        {
                            // One of the discarded bits after
                            // the last one is set
                            this.bitsAfterLeftmost |= 1;
                            this.bitLeftmost = this.shiftedBigInt.GetSignedBit(bs - 1) ? 1 :
              0;
                        }
                        else if (lowestSet > bs - 1)
                        {
                            // Means all discarded bits are zero
                            this.bitLeftmost = 0;
                        }
                        else
                        {
                            // Only the last discarded bit is set
                            this.bitLeftmost = 1;
                        }
                    }
                    this.shiftedBigInt >>= bs;
                }
                if (bits < SmallBitLength)
                {
                    // Shifting to small number of bits,
                    // convert to small integer
                    this.isSmall = true;
                    this.shiftedSmall = (int)this.shiftedBigInt;
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        public void ShiftRightInt(int bits)
        {
            // <summary>Shifts a number to the right, gathering information on
            // whether the last bit discarded is set and whether the discarded
            // bits to the right of that bit are set. Assumes that the big integer
            // being shifted is positive.</summary>
            if (this.isSmall)
            {
                this.ShiftRightSmall(bits);
            }
            else
            {
                this.ShiftRightBig(bits);
            }
        }

        private void ShiftRightSmall(int bits)
        {
            if (bits <= 0)
            {
                return;
            }
            if (this.shiftedSmall == 0)
            {
                this.discardedBitCount.AddInt(bits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownBitLength = new FastInteger(1);
                return;
            }
            int kb = SmallBitLength;
            for (int i = SmallBitLength - 1; i >= 0; --i)
            {
                if ((this.shiftedSmall & (1 << i)) != 0)
                {
                    break;
                }
                --kb;
            }
            var shift = (int)Math.Min(kb, bits);
            bool shiftingMoreBits = bits > kb;
            kb -= shift;
            this.knownBitLength = new FastInteger(kb);
            this.discardedBitCount.AddInt(bits);
            this.bitsAfterLeftmost |= this.bitLeftmost;
            // Get the bottommost shift minus 1 bits
            this.bitsAfterLeftmost |= (shift > 1 && (this.shiftedSmall <<
                  (SmallBitLength - shift + 1)) != 0) ? 1 : 0;
            // Get the bit just above that bit
            this.bitLeftmost = (int)((this.shiftedSmall >> (shift - 1)) & 0x01);
            this.shiftedSmall >>= shift;
            if (shiftingMoreBits)
            {
                // Shifted more bits than the bit length
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
            }
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
        }
        public void ShiftToDigitsInt(int bits)
        {
            if (bits < 0)
            {
                throw new ArgumentException("bits(" + bits + ") is less than 0");
            }
            if (this.isSmall)
            {
                this.ShiftSmallToBits(bits);
            }
            else
            {
                this.ShiftBigToBits(bits);
            }
        }

        private void ShiftSmallToBits(int bits)
        {
            if (this.knownBitLength != null)
            {
                if (this.knownBitLength.CompareToInt(bits) <= 0)
                {
                    return;
                }
            }
            this.knownBitLength = this.knownBitLength ?? this.CalcKnownBitLength();
            if (this.knownBitLength.CompareToInt(bits) <= 0)
            {
                return;
            }
            int kbl = this.knownBitLength.ToInt32();
            // Shift by the difference in bit length
            if (kbl > bits)
            {
                int bitShift = kbl - (int)bits;
                var shift = (int)bitShift;
                this.knownBitLength = new FastInteger(bits);
                this.discardedBitCount.AddInt(bitShift);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                // Get the bottommost shift minus 1 bits
                this.bitsAfterLeftmost |= (shift > 1 && (this.shiftedSmall <<
                      (SmallBitLength - shift + 1)) != 0) ? 1 : 0;
                // Get the bit just above that bit
                this.bitLeftmost = (int)((this.shiftedSmall >> (shift - 1)) & 0x01);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                this.shiftedSmall >>= shift;
            }
            else
            {
                this.knownBitLength = new FastInteger(kbl);
            }
        }
    }

    internal sealed class DigitShiftAccumulator : IShiftAccumulator
    {
        private static readonly long[] TenPowersLong = {
      1L, 10L, 100L, 1000L, 10000L, 100000L,
      1000000L, 10000000L, 100000000L,
      1000000000L,
      10000000000L,
      100000000000L,
      1000000000000L,
      10000000000000L,
      100000000000000L,
      1000000000000000L,
      10000000000000000L,
      100000000000000000L,
      1000000000000000000L,
    };

        private static readonly EInteger ValueTen = (EInteger)10;

        private static readonly int[] ValueTenPowers = {
      1, 10, 100, 1000, 10000, 100000,
      1000000, 10000000, 100000000,
    };

        private int bitLeftmost;

        private int bitsAfterLeftmost;
        private FastInteger discardedDigitCount;
        private bool isSmall;
        private FastInteger knownDigitLength;

        private EInteger shiftedBigInt;

        private int shiftedSmall;

        public override string ToString()
        {
            return "[this.bitLeftmost=" + this.bitLeftmost +
              ", this.bitsAfterLeftmost=" + this.bitsAfterLeftmost +
              ", this.discardedDigitCount=" + this.discardedDigitCount +
              ", this.isSmall=" + this.isSmall + ", this.knownDigitLength=" +
              this.knownDigitLength + ", this.shiftedBigInt=" +
              this.shiftedBigInt + ", this.shiftedSmall=" +
              this.shiftedSmall + "]";
        }

        public DigitShiftAccumulator(
          EInteger bigint,
          int lastDiscarded,
          int olderDiscarded)
        {
            if (bigint.CanFitInInt32())
            {
                this.shiftedSmall = (int)bigint;
                if (this.shiftedSmall < 0)
                {
                    throw new ArgumentException("shiftedSmall(" + this.shiftedSmall +
                      ") is less than 0");
                }
                this.isSmall = true;
            }
            else
            {
                this.shiftedBigInt = bigint;
                this.isSmall = false;
            }
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = lastDiscarded;
        }

        public DigitShiftAccumulator(
          int smallint,
          int lastDiscarded,
          int olderDiscarded)
        {
            this.shiftedSmall = smallint;
            if (this.shiftedSmall < 0)
            {
                throw new ArgumentException("shiftedSmall(" + this.shiftedSmall +
                  ") is less than 0");
            }
            this.isSmall = true;
            this.bitsAfterLeftmost = (olderDiscarded != 0) ? 1 : 0;
            this.bitLeftmost = lastDiscarded;
        }

        public FastInteger DiscardedDigitCount
        {
            get
            {
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                return this.discardedDigitCount;
            }
        }

        public int LastDiscardedDigit
        {
            get
            {
                return this.bitLeftmost;
            }
        }

        public int OlderDiscardedDigits
        {
            get
            {
                return this.bitsAfterLeftmost;
            }
        }

        public EInteger ShiftedInt
        {
            get
            {
                return this.isSmall ? ((EInteger)this.shiftedSmall) :
                  this.shiftedBigInt;
            }
        }

        public int ShiftedIntMod(int mod)
        {
#if DEBUG
            if (mod < 1)
            {
                throw new ArgumentException("mod (" + mod +
                   ") is not greater or equal to 1");
            }
#endif
            switch (mod)
            {
                case 1:
                    return 0;
                case 2:
                    return this.isSmall ? (this.shiftedSmall & 1) :
                      (this.shiftedBigInt.IsEven ? 0 : 1);
                default:
                    return this.isSmall ? (this.shiftedSmall % mod) :
                      this.shiftedBigInt.Mod(mod).ToInt32Checked();
            }
        }

        public FastInteger ShiftedIntFast
        {
            get
            {
                return this.isSmall ? new FastInteger(this.shiftedSmall) :
                  FastInteger.FromBig(this.shiftedBigInt);
            }
        }

        public FastInteger GetDigitLength()
        {
            this.knownDigitLength = this.knownDigitLength ??
              this.CalcKnownDigitLength();
            return this.knownDigitLength;
        }

        public FastInteger OverestimateDigitLength()
        {
            // If digit length is known, return it
            if (this.knownDigitLength != null)
            {
                return this.knownDigitLength;
            }
            if (this.isSmall)
            {
                // Can easily be calculated without estimation
                return this.GetDigitLength();
            }
            else
            {
                return NumberUtility.DecimalDigitLengthBounds(this.shiftedBigInt)[1];
            }
        }

        private FastInteger UnderestimateDigitLength()
        {
            // If digit length is known, return it
            if (this.knownDigitLength != null)
            {
                return this.knownDigitLength;
            }
            if (this.isSmall)
            {
                // Can easily be calculated without estimation
                return this.GetDigitLength();
            }
            else
            {
                return NumberUtility.DecimalDigitLengthBounds(this.shiftedBigInt)[0];
            }
        }

        public void ShiftRight(FastInteger fastint)
        {
            if (fastint == null)
            {
                throw new ArgumentNullException(nameof(fastint));
            }
            if (fastint.CanFitInInt32())
            {
                int fi = fastint.ToInt32();
                if (fi < 0)
                {
                    return;
                }
                this.ShiftRightInt(fi);
            }
            else
            {
                if (fastint.Sign <= 0)
                {
                    return;
                }
                EInteger digitsToShift = fastint.ToEInteger();
                while (digitsToShift.Sign > 0)
                {
                    if (digitsToShift.CompareTo(1000000) >= 0 &&
                       (this.isSmall ||
                        this.shiftedBigInt.GetUnsignedBitLengthAsEInteger()
                         .CompareTo(digitsToShift) < 0))
                    {
                        // Bit length is less than digits to shift, and digits to shift is >= 1000000,
                        // so whole number would be shifted
                        this.discardedDigitCount = this.discardedDigitCount ?? new
            FastInteger(0);
                        this.discardedDigitCount.AddBig(digitsToShift);
                        this.bitsAfterLeftmost |= this.bitLeftmost;
                        this.bitsAfterLeftmost |= (this.isSmall ? this.shiftedSmall == 0 :
            this.shiftedBigInt.IsZero) ? 0 : 1;
                        this.bitLeftmost = 0;
                        this.knownDigitLength = new FastInteger(1);
                        this.isSmall = true;
                        this.shiftedSmall = 0;
                        return;
                    }
                    var count = 1000000;
                    if (digitsToShift.CompareTo(1000000) < 0)
                    {
                        count = (int)digitsToShift;
                    }
                    this.ShiftRightInt(count);
                    digitsToShift -= (EInteger)count;
                    if (this.isSmall ? this.shiftedSmall == 0 :
                      this.shiftedBigInt.IsZero)
                    {
                        return;
                    }
                }
            }
        }

        public void ShiftRightInt(int digits)
        {
            // <summary>Shifts a number to the right, gathering information on
            // whether the last digit discarded is set and whether the discarded
            // digits to the right of that digit are set. Assumes that the big
            // integer being shifted is positive.</summary>
            if (this.isSmall)
            {
                this.ShiftRightSmall(digits);
            }
            else
            {
                this.ShiftRightBig(digits, false, false);
            }
        }

        public void ShiftToDigits(
          FastInteger bits,
          FastInteger preShift,
          bool truncate)
        {
#if DEBUG
            if (bits.Sign < 0)
            {
                throw new ArgumentException("bits's sign(" + bits.Sign +
                  ") is less than 0");
            }
#endif
            if (preShift != null && preShift.Sign > 0)
            {
                FastInteger kdl = this.knownDigitLength ?? this.CalcKnownDigitLength();
                this.knownDigitLength = kdl;
                // DebugUtility.Log("bits=" + bits + " pre=" + preShift + " known=" +
                // (//kdl) + " [" + this.shiftedBigInt + "]");
                if (kdl.CompareTo(bits) <= 0)
                {
                    // Known digit length is already small enough
                    this.TruncateOrShiftRight(preShift, truncate);
                    return;
                }
                else
                {
                    FastInteger bitDiff = kdl.Copy().Subtract(bits);
                    // DebugUtility.Log("bitDiff=" + bitDiff);
                    int cmp = bitDiff.CompareTo(preShift);
                    if (cmp <= 0)
                    {
                        // Difference between desired digit length and current
                        // length is smaller than the shift, make it the shift
                        this.TruncateOrShiftRight(preShift, truncate);
                        return;
                    }
                    else
                    {
                        this.TruncateOrShiftRight(bitDiff, truncate);
                        return;
                    }
                }
            }
            if (bits.CanFitInInt32())
            {
                int intval = bits.ToInt32();
                if (intval < 0)
                {
                    throw new ArgumentException("intval(" + intval + ") is less than " +
                      "0");
                }
                if (this.isSmall)
                {
                    this.ShiftToDigitsSmall(intval);
                }
                else
                {
                    this.ShiftToDigitsBig(intval, truncate);
                }
            }
            else
            {
                FastInteger kdl = this.knownDigitLength ?? this.CalcKnownDigitLength();
                this.knownDigitLength = kdl;
                EInteger bigintDiff = kdl.ToEInteger();
                EInteger bitsBig = bits.ToEInteger();
                bigintDiff -= (EInteger)bitsBig;
                if (bigintDiff.Sign > 0)
                {
                    // current length is greater than the
                    // desired bit length
                    this.ShiftRight(FastInteger.FromBig(bigintDiff));
                }
            }
        }

        public bool TruncateRightExact(FastInteger fastint)
        {
            if (fastint == null)
            {
                throw new ArgumentNullException(nameof(fastint));
            }
            if (fastint.CanFitInInt32())
            {
                if (fastint.Sign < 0)
                {
                    return (this.bitLeftmost | this.bitsAfterLeftmost) == 0;
                }
                if (!this.isSmall && !this.shiftedBigInt.CanFitInInt64())
                {
#if DEBUG
                    if (this.shiftedBigInt == null)
                    {
                        throw new InvalidOperationException();
                    }
#endif
                    int a = fastint.ToInt32();
                    if (a > 10)
                    {
                        this.ShiftRightBig(10, true, true);
                        if ((this.bitLeftmost | this.bitsAfterLeftmost) != 0)
                        {
                            return false;
                        }
                        if (this.isSmall)
                        {
                            this.ShiftRightInt(a - 10);
                        }
                        else
                        {
                            this.ShiftRightBig(a - 10, true, true);
                        }
                    }
                    else
                    {
                        this.ShiftRightBig(a, true, true);
                    }
                    return (this.bitLeftmost | this.bitsAfterLeftmost) == 0;
                }
            }
            this.TruncateOrShiftRight(fastint, true);
            return (this.bitLeftmost | this.bitsAfterLeftmost) == 0;
        }

        public void TruncateRightSimple(FastInteger fastint)
        {
            if (fastint == null)
            {
                throw new ArgumentNullException(nameof(fastint));
            }
            if (fastint.CanFitInInt32())
            {
                if (fastint.Sign < 0)
                {
                    return;
                }
                if (!this.isSmall && !this.shiftedBigInt.CanFitInInt64())
                {
                    this.ShiftRightBig(fastint.ToInt32(), true, true);
                    return;
                }
            }
            this.TruncateOrShiftRight(fastint, true);
        }

        public void TruncateOrShiftRight(FastInteger fastint, bool truncate)
        {
            // 'Truncate' is true if the caller doesn't care about the exact identity
            // of the last digit and the discarded digits.
            if (fastint == null)
            {
                throw new ArgumentNullException(nameof(fastint));
            }
            if (truncate && fastint.CanFitInInt32())
            {
                int fi = fastint.ToInt32();
                if (fi < 0)
                {
                    return;
                }
                if (!this.isSmall)
                {
                    if (this.shiftedBigInt.CanFitInInt64())
                    {
                        this.TruncateRightLong(this.shiftedBigInt.ToInt64Checked(), fi);
                    }
                    else
                    {
                        this.ShiftRightBig(fi, true, false);
                    }
                }
                else
                {
                    this.TruncateRightSmall(fi);
                }
            }
            else
            {
                this.ShiftRight(fastint);
            }
        }

        private static int FastParseLong(string str, int offset, int length)
        {
            // Assumes the string is length 9 or less and contains
            // only the digits '0' through '9'
            if (length > 9)
            {
                throw new ArgumentException("length(" + length + ") is more than " +
                  "9 ");
            }
            var ret = 0;
            for (var i = 0; i < length; ++i)
            {
                var digit = (int)(str[offset + i] - '0');
                ret *= 10;
                ret += digit;
            }
            return ret;
        }

        private static EInteger DivideByPowerOfTen(EInteger ei, int pow)
        {
            // if (pow > 100) {
            // int mid = pow / 2;
            // ei = DivideByPowerOfTen(ei, pow - mid);
            // return DivideByPowerOfTen(ei, mid);
            // } else {
            return ei.Divide(NumberUtility.FindPowerOfTen(pow));
            // }
        }

        private FastInteger CalcKnownDigitLength()
        {
            if (this.isSmall)
            {
                int kb = NumberUtility.DecimalDigitLength(this.shiftedSmall);
                return new FastInteger(kb);
            }
            else
            {
                long digits = this.shiftedBigInt.GetDigitCountAsInt64();
                if (digits == Int64.MaxValue)
                {
                    return
         FastInteger.FromBig(this.shiftedBigInt.GetDigitCountAsEInteger());
                }
                else if (digits < Int32.MaxValue)
                {
                    return new FastInteger((int)digits);
                }
                else
                {
                    return FastInteger.FromBig(EInteger.FromInt64(digits));
                }
            }
        }

        private void UpdateKnownLengthInt(int digits)
        {
            if (this.knownDigitLength != null)
            {
                this.knownDigitLength.SubtractInt(digits);
                if (this.knownDigitLength.CompareToInt(1) < 0)
                {
                    this.knownDigitLength.SetInt(1);
                }
            }
        }

        private void UpdateKnownLength(FastInteger digitsShiftedFast)
        {
            if (this.knownDigitLength != null)
            {
                this.knownDigitLength.Subtract(digitsShiftedFast);
                if (this.knownDigitLength.CompareToInt(1) < 0)
                {
                    this.knownDigitLength.SetInt(1);
                }
            }
        }

        private void ShiftRightBig(int digits, bool truncate, bool simple)
        {
#if DEBUG
            if (this.shiftedBigInt == null)
            {
                throw new InvalidOperationException();
            }
#endif
            if (digits <= 0)
            {
                return;
            }
            // DebugUtility.Log("ShiftRightBig "+digits+" "+truncate+" "+
            // simple+" "+this);
            if (this.shiftedBigInt.IsZero)
            {
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (truncate)
            {
                EInteger bigquo;
                {
                    // To avoid having to calculate a very big power of 10,
                    // or the digit length of a very big integer,
                    // check the digit count to see if doing so can be avoided
                    EInteger bigBitLength =
                      this.shiftedBigInt.GetUnsignedBitLengthAsEInteger();
                    var bigPower = false;
                    if (digits > 50 &&
                        bigBitLength.CompareTo(100) > 0 &&
                        bigBitLength.Add(5).CompareTo(digits) < 0)
                    {
                        // Has much fewer bits than digits to shift, so all of them
                        // will be shifted to the right
                        bigPower = true;
                    }
                    else
                    {
                        // NOTE: Overflowing bigBitLength will be MaxValue, which is OK
                        // for the use of this variable
                        int bitLength = bigBitLength.CanFitInInt32() ?
                          bigBitLength.ToInt32Checked() : Int32.MaxValue;
                        // 10^48 has 160 bits; 10^98 has 326; bit length is cheaper
                        // to calculate than base-10 digit length
                        if ((digits > 50 && bitLength < 160) ||
                            (digits > 100 && bitLength < 326))
                        {
                            bigPower = true;
                        }
                        else
                        {
                            FastInteger digitsUpperBound = this.OverestimateDigitLength();
                            bigPower = digitsUpperBound.Copy().SubtractInt(digits)
                              .CompareToInt(-2) < 0;
                        }
                    }
                    if (bigPower)
                    {
                        // Power of 10 to be divided would be much bigger
                        this.discardedDigitCount = this.discardedDigitCount ??
                          new FastInteger(0);
                        this.discardedDigitCount.AddInt(digits);
                        this.bitsAfterLeftmost |= this.bitLeftmost;
                        this.bitsAfterLeftmost |= this.shiftedBigInt.IsZero ? 0 : 1;
                        this.bitLeftmost = 0;
                        this.knownDigitLength = new FastInteger(1);
                        this.isSmall = true;
                        this.shiftedSmall = 0;
                        return;
                    }
                }
                if (!simple || (this.ShiftedIntMod(2) == 0 && this.bitLeftmost == 0))
                {
                    EInteger[] quorem = this.shiftedBigInt.DivRem(
                        NumberUtility.FindPowerOfTen(digits));
                    bigquo = quorem[0];
                    this.bitLeftmost |= quorem[1].IsZero ? 0 : 1;
                }
                else
                {
                    this.bitLeftmost = 1;
                    bigquo = this.shiftedBigInt.Divide(
                        NumberUtility.FindPowerOfTen(digits));
                }
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.discardedDigitCount = this.discardedDigitCount == null ?
                  new FastInteger(digits) : this.discardedDigitCount.AddInt(digits);
                if (bigquo.IsZero)
                {
                    // Shifted all the way to 0
                    this.isSmall = true;
                    this.shiftedBigInt = null;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                }
                else if (bigquo.CanFitInInt32())
                {
                    this.isSmall = true;
                    this.shiftedSmall = bigquo.ToInt32Unchecked();
                    this.shiftedBigInt = null;
                    this.UpdateKnownLengthInt(digits);
                }
                else
                {
                    this.isSmall = false;
                    this.shiftedBigInt = bigquo;
                    this.UpdateKnownLengthInt(digits);
                }
                return;
            }
            if (digits == 1)
            {
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem = this.shiftedBigInt.DivRem((EInteger)10);
                bigquo = divrem[0];
                bigrem = divrem[1];
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (int)bigrem;
                this.shiftedBigInt = bigquo;
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.UpdateKnownLengthInt(digits);
                return;
            }
            if (digits >= 2 && digits <= 8)
            {
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem =
                  this.shiftedBigInt.DivRem(NumberUtility.FindPowerOfTen(digits));
                bigquo = divrem[0];
                bigrem = divrem[1];
                var intRem = (int)bigrem;
                int smallPower = ValueTenPowers[digits - 1];
                int leftBit = intRem / smallPower;
                int otherBits = intRem - (leftBit * smallPower);
                this.bitsAfterLeftmost |= otherBits | this.bitLeftmost;
                this.bitLeftmost = leftBit;
                this.shiftedBigInt = bigquo;
                this.discardedDigitCount = (this.discardedDigitCount != null) ?
                  this.discardedDigitCount.AddInt(digits) : new FastInteger(digits);
                this.UpdateKnownLengthInt(digits);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                if (this.shiftedBigInt.CanFitInInt32())
                {
                    this.isSmall = true;
                    this.shiftedSmall = this.shiftedBigInt.ToInt32Unchecked();
                    this.shiftedBigInt = null;
                }
                return;
            }
            this.knownDigitLength = this.knownDigitLength ??
              this.CalcKnownDigitLength();
            // DebugUtility.Log("kdl="+this.knownDigitLength);
            if (new FastInteger(digits).Decrement().CompareTo(
               this.knownDigitLength) >= 0)
            {
                // Shifting more bits than available
                this.bitsAfterLeftmost |= this.shiftedBigInt.IsZero ? 0 : 1;
                this.isSmall = true;
                this.shiftedSmall = 0;
                this.knownDigitLength = new FastInteger(1);
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                return;
            }
            if (this.shiftedBigInt.CanFitInInt32())
            {
                this.isSmall = true;
                this.shiftedSmall = (int)this.shiftedBigInt;
                this.ShiftRightSmall(digits);
                return;
            }
            if (this.shiftedBigInt.CanFitInInt64())
            {
                this.ShiftRightLong(this.shiftedBigInt.ToInt64Unchecked(), digits);
                return;
            }
            EInteger sbi = this.shiftedBigInt;
            EInteger[] divrem1 = sbi.DivRem(NumberUtility.FindPowerOfTen(
              digits - 1));
            EInteger[] divrem2 = divrem1[0].DivRem(10);
            // DebugUtility.Log("divrem " + (// divrem1[0]) + " " + divrem1[1] + " / " +
            // divrem2[0] + " " + (divrem2[1]));
            this.bitsAfterLeftmost |= this.bitLeftmost;
            this.bitsAfterLeftmost |= divrem1[1].IsZero ? 0 : 1;
            this.bitLeftmost = divrem2[1].ToInt32Checked();
            this.discardedDigitCount = (this.discardedDigitCount != null) ?
                this.discardedDigitCount.AddInt(digits) : new FastInteger(digits);
            this.UpdateKnownLengthInt(digits);
            if (divrem2[0].CanFitInInt32())
            {
                this.isSmall = true;
                this.shiftedSmall = divrem2[0].ToInt32Checked();
            }
            else
            {
                this.isSmall = false;
                this.shiftedBigInt = divrem2[0];
            }
        }

        private void ShiftRightLong(long shiftedLong, int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (shiftedLong == 0)
            {
                this.shiftedSmall = 0;
                this.isSmall = true;
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }

            if (digits >= 2 && digits <= 8)
            {
                if (shiftedLong >= ValueTenPowers[digits])
                {
                    long bigPower = ValueTenPowers[digits];
                    long smallPower = ValueTenPowers[digits - 1];
                    this.discardedDigitCount = this.discardedDigitCount ?? new
          FastInteger(
                        0);
                    this.discardedDigitCount.AddInt(digits);
                    long div = shiftedLong / bigPower;
                    long rem = shiftedLong - (div * bigPower);
                    long rem2 = rem / smallPower;
                    this.bitLeftmost = (int)rem2;
                    this.bitsAfterLeftmost |= ((rem - (rem2 * smallPower)) == 0) ? 0 : 1;
                    this.isSmall = div <= Int32.MaxValue;
                    if (this.isSmall)
                    {
                        this.shiftedSmall = (int)div;
                        this.knownDigitLength = (div < 10) ? new FastInteger(1) :
                          new FastInteger(NumberUtility.DecimalDigitLength(div));
                    }
                    else
                    {
                        this.shiftedBigInt = EInteger.FromInt64(div);
                        this.knownDigitLength = (div < 10) ? new FastInteger(1) :
                          this.CalcKnownDigitLength();
                    }
                    return;
                }
                else if (this.shiftedSmall >= ValueTenPowers[digits - 1])
                {
                    int smallPower = ValueTenPowers[digits - 1];
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    long rem = shiftedLong;
                    long rem2 = rem / smallPower;
                    this.bitLeftmost = (int)rem2;
                    this.bitsAfterLeftmost |= ((rem - (rem2 * smallPower)) == 0) ? 0 : 1;
                    this.isSmall = true;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
                else
                {
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    this.bitLeftmost = 0;
                    this.bitsAfterLeftmost |= (shiftedLong == 0) ? 0 : 1;
                    this.isSmall = true;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
            }
            this.knownDigitLength = new FastInteger(
              NumberUtility.DecimalDigitLength(shiftedLong));
            if (this.discardedDigitCount != null)
            {
                this.discardedDigitCount.AddInt(digits);
            }
            else
            {
                this.discardedDigitCount = new FastInteger(digits);
            }
            var digitsShifted = 0;
            while (digits > 0)
            {
                if (shiftedLong == 0)
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = 0;
                    break;
                }
                else
                {
                    long newShift = (shiftedLong < 43698) ? ((shiftedLong * 26215) >>
                        18) : (shiftedLong / 10);
                    var digit = (int)(shiftedLong - (newShift * 10));
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = digit;
                    --digits;
                    ++digitsShifted;
                    shiftedLong = newShift;
                }
            }
            this.isSmall = shiftedLong <= Int32.MaxValue;
            if (this.isSmall)
            {
                this.shiftedSmall = (int)shiftedLong;
            }
            else
            {
                this.shiftedBigInt = EInteger.FromInt64(shiftedLong);
            }
            this.UpdateKnownLengthInt(digitsShifted);
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
        }

        private void ShiftToDigitsBig(int digits, bool truncate)
        {
            // Shifts a number until it reaches the given number of digits,
            // gathering information on whether the last digit discarded is set
            // and whether the discarded digits to the right of that digit are set.
            // Assumes that the big integer being shifted is positive.
            // 'Truncate' is true if the caller doesn't care about the exact identity
            // of the last digit and the discarded digits.
            if (this.knownDigitLength != null)
            {
                if (this.knownDigitLength.CompareToInt(digits) <= 0)
                {
                    return;
                }
            }
            // DebugUtility.Log("ShiftToDigitsBig(" + digits + ")");
            // var sw = new System.Diagnostics.Stopwatch();sw.Restart();
            string str;
            FastInteger estDigitLength = this.UnderestimateDigitLength();
            bool haveKnownDigitLength = this.knownDigitLength != null;
#if DEBUG
            // if (this.CalcKnownDigitLength().CompareTo(estDigitLength) < 0) {
            // throw new InvalidOperationException();
            // }
#endif
            if (estDigitLength.CompareToInt(digits) <= 0)
            {
                if (!haveKnownDigitLength)
                {
                    this.GetDigitLength();
                    this.ShiftToDigitsBig(digits, truncate);
                }
#if DEBUG
                if (this.knownDigitLength.CompareToInt(digits) > 0)
                {
                    throw new InvalidOperationException();
                }
#endif
                return;
            }
            FastInteger digitDiff = estDigitLength.Copy().SubtractInt(digits);
            if (truncate && digitDiff.CanFitInInt32())
            {
                // DebugUtility.Log("d=" + sw.ElapsedMilliseconds + " ms");
                this.TruncateOrShiftRight(digitDiff, truncate);
                if (!haveKnownDigitLength)
                {
                    this.GetDigitLength();
                    this.ShiftToDigitsBig(digits, truncate);
                }
#if DEBUG
                if (this.knownDigitLength.CompareToInt(digits) > 0)
                {
                    throw new InvalidOperationException();
                }
#endif
                return;
            }
            if (digitDiff.CompareToInt(1) == 0)
            {
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem = this.shiftedBigInt.DivRem(ValueTen);
                bigquo = divrem[0];
                bigrem = divrem[1];
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (int)bigrem;
                this.shiftedBigInt = bigquo;
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.Add(digitDiff);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                if (!haveKnownDigitLength)
                {
                    this.GetDigitLength();
                    this.ShiftToDigitsBig(digits, truncate);
                }
                else
                {
                    this.UpdateKnownLength(digitDiff);
                }
#if DEBUG
                if (this.knownDigitLength.CompareToInt(digits) > 0)
                {
                    throw new InvalidOperationException();
                }
#endif
                return;
            }
            if (digitDiff.CompareToInt(9) <= 0)
            {
                EInteger bigrem;
                int diffInt = digitDiff.ToInt32();
                EInteger radixPower = NumberUtility.FindPowerOfTen(diffInt);
                EInteger bigquo;
                EInteger[] divrem = this.shiftedBigInt.DivRem(radixPower);
                bigquo = divrem[0];
                bigrem = divrem[1];
                var rem = (int)bigrem;
                this.bitsAfterLeftmost |= this.bitLeftmost;
                for (var i = 0; i < diffInt; ++i)
                {
                    if (i == diffInt - 1)
                    {
                        this.bitLeftmost = rem % 10;
                    }
                    else
                    {
                        int intQuot = (rem < 43698) ? ((rem * 26215) >> 18) : (rem / 10);
                        this.bitsAfterLeftmost |= rem - (intQuot * 10);
                        rem = intQuot;
                    }
                }
                this.shiftedBigInt = bigquo;
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.Add(digitDiff);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                if (!haveKnownDigitLength)
                {
                    this.GetDigitLength();
                    this.ShiftToDigitsBig(digits, truncate);
                }
                else
                {
                    this.UpdateKnownLength(digitDiff);
                }
#if DEBUG
                if (this.knownDigitLength.CompareToInt(digits) > 0)
                {
                    throw new InvalidOperationException();
                }
#endif
                return;
            }
            // DebugUtility.Log("e1=" + sw.ElapsedMilliseconds + " ms");
            if (digitDiff.CanFitInInt32())
            {
#if DEBUG
                if (!(digitDiff.CompareToInt(2) > 0))
                {
                    throw new ArgumentException(
                      "doesn't satisfy digitDiff.CompareToInt(2)>0");
                }
#endif
                EInteger bigrem = null;
                EInteger bigquo;
                EInteger[] divrem;
                EInteger radixPower;
                int power = digitDiff.ToInt32() - 1;
                if (!this.shiftedBigInt.IsEven || this.bitsAfterLeftmost != 0)
                {
                    // DebugUtility.Log("f=" + sw.ElapsedMilliseconds + " ms [pow=" + power +
                    // "]");
                    bigquo = this.shiftedBigInt;
                    // DebugUtility.Log("fa=" + sw.ElapsedMilliseconds + " ms [" + (//
                    // (!this.shiftedBigInt.IsEven || this.bitsAfterLeftmost != 0)) + "]");
                    this.bitsAfterLeftmost |= 1;
                    bigquo = bigquo.Divide(NumberUtility.FindPowerOfTen(power));
                    // DebugUtility.Log("faa=" + sw.ElapsedMilliseconds + " ms");
                }
                else
                {
                    // DebugUtility.Log("fb=" + sw.ElapsedMilliseconds + " ms [pow=" + power +
                    // "]");
                    radixPower = NumberUtility.FindPowerOfTen(power);
                    // DebugUtility.Log("fc=" + sw.ElapsedMilliseconds + " ms [" + (//
                    // (!this.shiftedBigInt.IsEven || this.bitsAfterLeftmost != 0)) + "]");
                    divrem = this.shiftedBigInt.DivRem(radixPower);
                    bigquo = divrem[0];
                    bigrem = divrem[1];
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    if (!bigrem.IsZero)
                    {
                        this.bitsAfterLeftmost |= 1;
                    }
                }
                // DebugUtility.Log("g=" + sw.ElapsedMilliseconds + " ms");
                EInteger bigquo2;
                divrem = bigquo.DivRem(ValueTen);
                bigquo2 = divrem[0];
                bigrem = divrem[1];
                this.bitLeftmost = (int)bigrem;
                this.shiftedBigInt = bigquo2;
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.Add(digitDiff);
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
                // DebugUtility.Log("h=" + sw.ElapsedMilliseconds + " ms");
                if (!haveKnownDigitLength)
                {
                    this.GetDigitLength();
                    this.ShiftToDigitsBig(digits, truncate);
                }
                else
                {
                    this.UpdateKnownLength(digitDiff);
                }
#if DEBUG
                if (this.knownDigitLength.CompareToInt(digits) > 0)
                {
                    throw new InvalidOperationException();
                }
#endif
                return;
            }
            str = this.shiftedBigInt.ToString();
            // DebugUtility.Log("sdb=" + str + " digits="+digits);
            // NOTE: Will be 1 if the value is 0
            int digitLength = str.Length;
            this.knownDigitLength = new FastInteger(digitLength);
            // Shift by the difference in digit length
            if (digitLength > digits)
            {
                int digitShift = digitLength - digits;
                this.UpdateKnownLengthInt(digitShift);
                var newLength = (int)(digitLength - digitShift);
                // Console.WriteLine("dlen= " + digitLength + " dshift=" +
                // digitShift + " newlen= " + newLength);
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                if (digitShift <= Int32.MaxValue)
                {
                    this.discardedDigitCount.AddInt((int)digitShift);
                }
                else
                {
                    this.discardedDigitCount.AddBig((EInteger)digitShift);
                }
                for (int i = str.Length - 1; i >= 0; --i)
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = (int)(str[i] - '0');
                    --digitShift;
                    if (digitShift <= 0)
                    {
                        break;
                    }
                }
                if (newLength <= 9)
                {
                    this.isSmall = true;
                    this.shiftedSmall = FastParseLong(str, 0, newLength);
                }
                else
                {
                    this.shiftedBigInt = EInteger.FromSubstring(str, 0, newLength);
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
#if DEBUG
            if (this.knownDigitLength.CompareToInt(digits) > 0)
            {
                throw new InvalidOperationException();
            }
#endif
        }

        private void ShiftToDigitsSmall(int digits)
        {
            var kb = 0;
            int v2 = this.shiftedSmall;
            kb = (v2 >= 1000000000) ? 10 : ((v2 >= 100000000) ? 9 : ((v2 >=
                    10000000) ? 8 : ((v2 >= 1000000) ? 7 : ((v2 >= 100000) ? 6 :
                      ((v2 >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ? 3 : ((v2
                      >= 10) ? 2 : 1))))))));
            this.knownDigitLength = new FastInteger(kb);
            if (kb > digits)
            {
                var digitShift = (int)(kb - digits);
                this.UpdateKnownLengthInt(digitShift);
                this.discardedDigitCount = this.discardedDigitCount != null ?
                  this.discardedDigitCount.AddInt(digitShift) :
                  new FastInteger(digitShift);
                for (var i = 0; i < digitShift; ++i)
                {
                    var digit = (int)(this.shiftedSmall % 10);
                    this.shiftedSmall /= 10;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = digit;
                }
                this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
            }
        }

        private void TruncateRightLong(long shiftedLong, int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (shiftedLong == 0 || digits >= 21)
            {
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = shiftedLong == 0 ? 0 : 1;
                this.shiftedSmall = 0;
                this.isSmall = true;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 1 && digits <= TenPowersLong.Length - 1)
            {
                if (shiftedLong >= TenPowersLong[digits])
                {
                    long bigPower = TenPowersLong[digits];
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    long quo = shiftedLong / bigPower;
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = (shiftedLong & 1) == 1 ? 1 :
                      (shiftedLong - (quo * bigPower) == 0 ? 0 : 1);
                    shiftedLong = quo;
                    this.isSmall = shiftedLong <= Int32.MaxValue;
                    if (this.isSmall)
                    {
                        this.shiftedSmall = (int)shiftedLong;
                    }
                    else
                    {
                        this.shiftedBigInt = EInteger.FromInt64(shiftedLong);
                    }
                    this.UpdateKnownLengthInt(digits);
                    return;
                }
                else
                {
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = shiftedLong == 0 ? 0 : 1;
                    shiftedLong = 0;
                    this.isSmall = shiftedLong <= Int32.MaxValue;
                    if (this.isSmall)
                    {
                        this.shiftedSmall = (int)shiftedLong;
                    }
                    else
                    {
                        this.shiftedBigInt = EInteger.FromInt64(shiftedLong);
                    }
                    this.UpdateKnownLengthInt(digits);
                    return;
                }
            }
            this.ShiftRightInt(digits);
        }

        private void ShiftRightSmall(int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (this.shiftedSmall == 0)
            {
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 2 && digits <= 8)
            {
                if (this.shiftedSmall >= ValueTenPowers[digits])
                {
                    int bigPower = ValueTenPowers[digits];
                    int smallPower = ValueTenPowers[digits - 1];
                    this.discardedDigitCount = this.discardedDigitCount ?? new
          FastInteger(
                        0);
                    this.discardedDigitCount.AddInt(digits);
                    int div = this.shiftedSmall / bigPower;
                    int rem = this.shiftedSmall - (div * bigPower);
                    int rem2 = rem / smallPower;
                    this.bitLeftmost = rem2;
                    this.bitsAfterLeftmost |= rem - (rem2 * smallPower);
                    this.shiftedSmall = div;
                    this.knownDigitLength = (div < 10) ? new FastInteger(1) :
                      this.CalcKnownDigitLength();
                    return;
                }
                else if (this.shiftedSmall >= ValueTenPowers[digits - 1])
                {
                    int smallPower = ValueTenPowers[digits - 1];
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    int rem = this.shiftedSmall;
                    int rem2 = rem / smallPower;
                    this.bitLeftmost = rem2;
                    this.bitsAfterLeftmost |= rem - (rem2 * smallPower);
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
                else
                {
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    int rem = this.shiftedSmall;
                    this.bitLeftmost = 0;
                    this.bitsAfterLeftmost |= rem;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
            }
            int v2 = this.shiftedSmall;
            int kb = (v2 >= 1000000000) ? 10 : ((v2 >= 100000000) ? 9 : ((v2 >=
                    10000000) ? 8 : ((v2 >= 1000000) ? 7 : ((v2 >= 100000) ? 6 :
                      ((v2 >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ? 3 : ((v2
                      >= 10) ? 2 : 1))))))));
            this.knownDigitLength = new FastInteger(kb);
            if (this.discardedDigitCount != null)
            {
                this.discardedDigitCount.AddInt(digits);
            }
            else
            {
                this.discardedDigitCount = new FastInteger(digits);
            }
            var digitsShifted = 0;
            while (digits > 0)
            {
                if (this.shiftedSmall == 0)
                {
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = 0;
                    this.knownDigitLength = new FastInteger(1);
                    break;
                }
                else
                {
                    var digit = (int)(this.shiftedSmall % 10);
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = digit;
                    --digits;
                    ++digitsShifted;
                    this.shiftedSmall /= 10;
                }
            }
            this.UpdateKnownLengthInt(digitsShifted);
            this.bitsAfterLeftmost = (this.bitsAfterLeftmost != 0) ? 1 : 0;
        }

        private void TruncateRightSmall(int digits)
        {
            if (digits <= 0)
            {
                return;
            }
            if (this.shiftedSmall == 0 || digits >= 11)
            {
                this.discardedDigitCount = this.discardedDigitCount ?? new
        FastInteger(0);
                this.discardedDigitCount.AddInt(digits);
                this.bitsAfterLeftmost |= this.bitLeftmost;
                this.bitLeftmost = (this.shiftedSmall == 0) ? 0 : 1;
                this.shiftedSmall = 0;
                this.knownDigitLength = new FastInteger(1);
                return;
            }
            if (digits >= 1 && digits <= 8)
            {
                if (this.shiftedSmall >= ValueTenPowers[digits])
                {
                    int bigPower = ValueTenPowers[digits];
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    if ((this.shiftedSmall & 1) == 1)
                    {
                        this.bitLeftmost = 1;
                        this.shiftedSmall /= bigPower;
                    }
                    else
                    {
                        int quo = this.shiftedSmall / bigPower;
                        int rem = this.shiftedSmall - (quo * bigPower);
                        this.shiftedSmall = quo;
                        this.bitLeftmost |= (rem == 0) ? 0 : 1;
                    }
                    this.UpdateKnownLengthInt(digits);
                    return;
                }
                else
                {
                    if (this.discardedDigitCount != null)
                    {
                        this.discardedDigitCount.AddInt(digits);
                    }
                    else
                    {
                        this.discardedDigitCount = new FastInteger(digits);
                    }
                    this.bitsAfterLeftmost |= this.bitLeftmost;
                    this.bitLeftmost = (this.shiftedSmall == 0) ? 0 : 1;
                    this.shiftedSmall = 0;
                    this.knownDigitLength = new FastInteger(1);
                    return;
                }
            }
            this.ShiftRightSmall(digits);
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EContext"]/*'/>
    public sealed class EContext
    {
        /// <summary>Signals that the exponent was adjusted to fit the exponent
        /// range.</summary>
        public const int FlagClamped = 32;

        /// <summary>Signals a division of a nonzero number by zero.</summary>
        public const int FlagDivideByZero = 128;

        /// <summary>Signals that the result was rounded to a different
        /// mathematical value, but as close as possible to the
        /// original.</summary>
        public const int FlagInexact = 1;

        /// <summary>Signals an invalid operation.</summary>
        public const int FlagInvalid = 64;

        /// <summary>Signals that an operand was rounded to a different
        /// mathematical value before an operation.</summary>
        public const int FlagLostDigits = 256;

        /// <summary>Signals that the result is non-zero and the exponent is
        /// higher than the highest exponent allowed.</summary>
        public const int FlagOverflow = 16;

        /// <summary>Signals that the result was rounded to fit the precision;
        /// either the value or the exponent may have changed from the
        /// original.</summary>
        public const int FlagRounded = 2;

        /// <summary>Signals that the result's exponent, before rounding, is
        /// lower than the lowest exponent allowed.</summary>
        public const int FlagSubnormal = 4;

        /// <summary>Signals that the result's exponent, before rounding, is
        /// lower than the lowest exponent allowed, and the result was rounded
        /// to a different mathematical value, but as close as possible to the
        /// original.</summary>
        public const int FlagUnderflow = 8;

        /// <summary>A basic arithmetic context, 9 digits precision, rounding
        /// mode half-up, unlimited exponent range. The default rounding mode
        /// is HalfUp.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Basic =
          EContext.ForPrecisionAndRounding(9, ERounding.HalfUp);

        /// <summary>An arithmetic context for Java's BigDecimal format. The
        /// default rounding mode is HalfUp.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext BigDecimalJava =
          new EContext(0, ERounding.HalfUp, 0, 0, true)
        .WithExponentClamp(true).WithAdjustExponent(false)
        .WithBigExponentRange(
          EInteger.Zero - (EInteger)Int32.MaxValue,
          EInteger.One + (EInteger)Int32.MaxValue);

        /// <summary>An arithmetic context for the IEEE-754-2008 binary128
        /// format, 113 bits precision. The default rounding mode is
        /// HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary128 =
          EContext.ForPrecisionAndRounding(113, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-16382, 16383);

        /// <summary>An arithmetic context for the IEEE-754-2008 binary16
        /// format, 11 bits precision. The default rounding mode is
        /// HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary16 =
          EContext.ForPrecisionAndRounding(11, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-14, 15);

        /// <summary>An arithmetic context for the IEEE-754-2008 binary32
        /// format, 24 bits precision. The default rounding mode is
        /// HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary32 =
          EContext.ForPrecisionAndRounding(24, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-126, 127);

        /// <summary>An arithmetic context for the IEEE-754-2008 binary64
        /// format, 53 bits precision. The default rounding mode is
        /// HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Binary64 =
          EContext.ForPrecisionAndRounding(53, ERounding.HalfEven)
          .WithExponentClamp(true).WithExponentRange(-1022, 1023);

        /// <summary>An arithmetic context for the.NET Framework decimal format
        /// (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ), 96
        /// bits precision, and a valid exponent range of -28 to 0. The default
        /// rounding mode is HalfEven. (The <c>"Cli"</c> stands for "Common
        /// Language Infrastructure", which defined this format as the .NET
        /// Framework decimal format in version 1, but leaves it unspecified in
        /// later versions.).</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext CliDecimal =
          new EContext(96, ERounding.HalfEven, 0, 28, true)
        .WithPrecisionInBits(true);

        /// <summary>An arithmetic context for the IEEE-754-2008 decimal128
        /// format. The default rounding mode is HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Decimal128 =
          new EContext(34, ERounding.HalfEven, -6143, 6144, true);

        /// <summary>An arithmetic context for the IEEE-754-2008 decimal32
        /// format. The default rounding mode is HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Decimal32 =
          new EContext(7, ERounding.HalfEven, -95, 96, true);

        /// <summary>An arithmetic context for the IEEE-754-2008 decimal64
        /// format. The default rounding mode is HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Decimal64 =
          new EContext(16, ERounding.HalfEven, -383, 384, true);

        /// <summary>No specific (theoretical) limit on precision. Rounding
        /// mode HalfUp.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext Unlimited =
          EContext.ForPrecision(0);

        /// <summary>No specific (theoretical) limit on precision. Rounding
        /// mode HalfEven.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Security",
      "CA2104",
      Justification = "This PrecisionContext is immutable")]
#endif
        public static readonly EContext UnlimitedHalfEven =
          EContext.ForPrecision(0).WithRounding(ERounding.HalfEven);

        private EContext(
          bool adjustExponent,
          EInteger bigintPrecision,
          bool clampNormalExponents,
          EInteger exponentMax,
          EInteger exponentMin,
          int flags,
          bool hasExponentRange,
          bool hasFlags,
          bool precisionInBits,
          ERounding rounding,
          bool simplified,
          int traps)
        {
            if (bigintPrecision == null)
            {
                throw new ArgumentNullException(nameof(bigintPrecision));
            }
            if (exponentMin == null)
            {
                throw new ArgumentNullException(nameof(exponentMin));
            }
            if (exponentMax == null)
            {
                throw new ArgumentNullException(nameof(exponentMax));
            }
            if (bigintPrecision.Sign < 0)
            {
                throw new ArgumentException("precision(" + bigintPrecision +
                  ") is less than 0");
            }
            if (exponentMin.CompareTo(exponentMax) > 0)
            {
                throw new ArgumentException("exponentMinSmall(" + exponentMin +
                  ") is more than " + exponentMax);
            }
            this.adjustExponent = adjustExponent;
            this.bigintPrecision = bigintPrecision;
            this.clampNormalExponents = clampNormalExponents;
            this.exponentMax = exponentMax;
            this.exponentMin = exponentMin;
            this.flags = flags;
            this.hasExponentRange = hasExponentRange;
            this.hasFlags = hasFlags;
            this.precisionInBits = precisionInBits;
            this.rounding = rounding;
            this.simplified = simplified;
            this.traps = traps;
        }

        private readonly bool adjustExponent;

        private readonly EInteger bigintPrecision;

        private readonly bool clampNormalExponents;
        private readonly EInteger exponentMax;

        private readonly EInteger exponentMin;

        private readonly bool hasExponentRange;
        private readonly bool hasFlags;

        private readonly bool precisionInBits;

        private readonly ERounding rounding;

        private readonly bool simplified;

        private readonly int traps;

        private int flags;

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.EContext'/> class.</summary>
        /// <param name='precision'>The value of the Precision
        /// property.</param>
        /// <param name='rounding'>The value of the Rounding property.</param>
        /// <param name='exponentMinSmall'>The value of the EMin
        /// property.</param>
        /// <param name='exponentMaxSmall'>The value of the EMax
        /// property.</param>
        /// <param name='clampNormalExponents'>The value of the
        /// ClampNormalExponents property.</param>
        public EContext(
          int precision,
          ERounding rounding,
          int exponentMinSmall,
          int exponentMaxSmall,
          bool clampNormalExponents) : this(
              true,
              EInteger.FromInt32(precision),
              clampNormalExponents,
              EInteger.FromInt32(exponentMaxSmall),
              EInteger.FromInt32(exponentMinSmall),
              0,
              true,
              false,
              false,
              rounding,
              false,
              0)
        {
        }

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.EContext'/> class,.</summary>
        /// <param name='bigintPrecision'>The value of the Precision
        /// property.</param>
        /// <param name='rounding'>The value of the Rounding property.</param>
        /// <param name='exponentMin'>The value of the EMin property.</param>
        /// <param name='exponentMax'>The value of the EMax property.</param>
        /// <param name='clampNormalExponents'>The value of the
        /// ClampNormalExponents property.</param>
        public EContext(
          EInteger bigintPrecision,
          ERounding rounding,
          EInteger exponentMin,
          EInteger exponentMax,
          bool clampNormalExponents) : this(
              true,
              bigintPrecision,
              clampNormalExponents,
              exponentMax,
              exponentMin,
              0,
              true,
              false,
              false,
              rounding,
              false,
              0)
        {
        }

        /// <summary>Gets a value indicating whether the EMax and EMin
        /// properties refer to the number's Exponent property adjusted to the
        /// number's precision, or just the number's Exponent property. The
        /// default value is true, meaning that EMax and EMin refer to the
        /// adjusted exponent. Setting this value to false (using
        /// WithAdjustExponent) is useful for modeling floating point
        /// representations with an integer significand and an integer
        /// exponent, such as Java's BigDecimal.</summary>
        /// <value><c>true</c> if the EMax and EMin properties refer to the
        /// number's Exponent property adjusted to the number's precision, or
        /// false if they refer to just the number's Exponent property.</value>
        public bool AdjustExponent
        {
            get
            {
                return this.adjustExponent;
            }
        }

        /// <summary>Gets a value indicating whether a converted number's
        /// Exponent property will not be higher than EMax + 1 - Precision. If
        /// a number's exponent is higher than that value, but not high enough
        /// to cause overflow, the exponent is clamped to that value and enough
        /// zeros are added to the number's significand to account for the
        /// adjustment. If HasExponentRange is false, this value is always
        /// false.</summary>
        /// <value>If true, a converted number's Exponent property will not be
        /// higher than EMax + 1 - Precision.</value>
        public bool ClampNormalExponents
        {
            get
            {
                return this.hasExponentRange && this.clampNormalExponents;
            }
        }

        /// <summary>Gets the highest exponent possible when a converted number
        /// is expressed in scientific notation with one nonzero digit before
        /// the radix point. For example, with a precision of 3 and an EMax of
        /// 100, the maximum value possible is 9.99E + 100. (This is not the
        /// same as the highest possible Exponent property.) If
        /// HasExponentRange is false, this value will be 0.</summary>
        /// <value>The highest exponent possible when a converted number is
        /// expressed in scientific notation with one nonzero digit before the
        /// radix point. For example, with a precision of 3 and an EMax of 100,
        /// the maximum value possible is 9.99E + 100. (This is not the same as
        /// the highest possible Exponent property.) If HasExponentRange is
        /// false, this value will be 0.</value>
        public EInteger EMax
        {
            get
            {
                return this.hasExponentRange ? this.exponentMax : EInteger.Zero;
            }
        }

        /// <summary>Gets the lowest exponent possible when a converted number
        /// is expressed in scientific notation with one nonzero digit before
        /// the radix point. For example, with a precision of 3 and an EMin of
        /// -100, the next value that comes after 0 is 0.001E-100. (If
        /// AdjustExponent is false, this property specifies the lowest
        /// possible Exponent property instead.) If HasExponentRange is false,
        /// this value will be 0.</summary>
        /// <value>The lowest exponent possible when a converted number is
        /// expressed in scientific notation with one nonzero digit before the
        /// radix point. For example, with a precision of 3 and an EMin of
        /// -100, the next value that comes after 0 is 0.001E-100. (If
        /// AdjustExponent is false, this property specifies the lowest
        /// possible Exponent property instead.) If HasExponentRange is false,
        /// this value will be 0.</value>
        public EInteger EMin
        {
            get
            {
                return this.hasExponentRange ? this.exponentMin : EInteger.Zero;
            }
        }

        /// <summary>Gets or sets the flags that are set from converting
        /// numbers according to this arithmetic context. If <c>HasFlags</c> is
        /// false, this value will be 0. This value is a combination of bit
        /// fields. To retrieve a particular flag, use the AND operation on the
        /// return value of this method. For example: <c>(this.Flags
        /// &amp;EContext.FlagInexact) != 0</c> returns <c>true</c> if the
        /// Inexact flag is set.</summary>
        /// <value>The flags that are set from converting numbers according to
        /// this arithmetic context. If <c>HasFlags</c> is false, this value
        /// will be 0. This value is a combination of bit fields. To retrieve a
        /// particular flag, use the AND operation on the return value of this
        /// method. For example: <c>(this.Flags &amp;EContext.FlagInexact)
        /// !=0</c> returns <c>true</c> if the Inexact flag is set.</value>
        public int Flags
        {
            get
            {
                return this.flags;
            }

            set
            {
                if (!this.HasFlags)
                {
                    throw new InvalidOperationException("Can't set flags");
                }
                this.flags = value;
            }
        }

        /// <summary>Gets a value indicating whether this context defines a
        /// minimum and maximum exponent. If false, converted exponents can
        /// have any exponent and operations can't cause overflow or
        /// underflow.</summary>
        /// <value><c>true</c> if this context defines a minimum and maximum
        /// exponent; otherwise, <c>false</c>.. If false, converted exponents
        /// can have any exponent and operations can't cause overflow or
        /// underflow. <c>true</c> if this context defines a minimum and
        /// maximum exponent; otherwise, <c>false</c>.</value>
        public bool HasExponentRange
        {
            get
            {
                return this.hasExponentRange;
            }
        }

        /// <summary>Gets a value indicating whether this context has a mutable
        /// Flags field.</summary>
        /// <value><c>true</c> if this context has a mutable Flags field;
        /// otherwise, <c>false</c>.</value>
        public bool HasFlags
        {
            get
            {
                return this.hasFlags;
            }
        }

        /// <summary>Gets a value indicating whether this context defines a
        /// maximum precision. This is the same as whether this context's
        /// Precision property is zero.</summary>
        /// <value><c>true</c> if this context defines a maximum precision;
        /// otherwise, <c>false</c>.</value>
        public bool HasMaxPrecision
        {
            get
            {
                return !this.bigintPrecision.IsZero;
            }
        }

        /// <summary>Gets a value indicating whether this context's Precision
        /// property is in bits, rather than digits. The default is
        /// false.</summary>
        /// <value><c>true</c> if this context's Precision property is in bits,
        /// rather than digits; otherwise, <c>false</c>.. The default is
        /// false. <c>true</c> if this context's Precision property is in bits,
        /// rather than digits; otherwise, <c>false</c>. The default is
        /// false.</value>
        public bool IsPrecisionInBits
        {
            get
            {
                return this.precisionInBits;
            }
        }

        /// <summary>Gets a value indicating whether to use a "simplified"
        /// arithmetic. In the simplified arithmetic, infinity, not-a-number,
        /// and subnormal numbers are not allowed, and negative zero is treated
        /// the same as positive zero. For further details, see
        /// <a
        ///   href='http://speleotrove.com/decimal/dax3274.html'><c>http://speleotrove.com/decimal/dax3274.html</c></a>
        /// .</summary>
        /// <value><c>true</c> if to use a "simplified" arithmetic; otherwise,
        /// <c>false</c> In the simplified arithmetic, infinity, not-a-number,
        /// and subnormal numbers are not allowed, and negative zero is treated
        /// the same as positive zero. For further details, see
        /// <a
        ///   href='http://speleotrove.com/decimal/dax3274.html'><c>http://speleotrove.com/decimal/dax3274.html</c></a>
        /// . <c>true</c> if a "simplified" arithmetic will be used; otherwise,
        /// <c>false</c>.</value>
        public bool IsSimplified
        {
            get
            {
                return this.simplified;
            }
        }

        /// <summary>Gets the maximum length of a converted number in digits,
        /// ignoring the radix point and exponent. For example, if precision is
        /// 3, a converted number's significand can range from 0 to 999 (up to
        /// three digits long). If 0, converted numbers can have any precision.
        /// <para>Not-a-number (NaN) values can carry an optional number, its
        /// payload, that serves as its "diagnostic information", In general,
        /// if an operation requires copying an NaN's payload, only up to as
        /// many digits of that payload as the precision given in this context,
        /// namely the least significant digits, are copied.</para></summary>
        /// <value>The maximum length of a converted number in digits, ignoring
        /// the radix point and exponent. For example, if precision is 3, a
        /// converted number's significand can range from 0 to 999 (up to three
        /// digits long). If 0, converted numbers can have any
        /// precision.</value>
        public EInteger Precision
        {
            get
            {
                return this.bigintPrecision;
            }
        }

        /// <summary>Gets the desired rounding mode when converting numbers
        /// that can't be represented in the given precision and exponent
        /// range.</summary>
        /// <value>The desired rounding mode when converting numbers that can't
        /// be represented in the given precision and exponent range.</value>
        public ERounding Rounding
        {
            get
            {
                return this.rounding;
            }
        }

        /// <summary>Gets the traps that are set for each flag in the context.
        /// Whenever a flag is signaled, even if <c>HasFlags</c> is false, and
        /// the flag's trap is enabled, the operation will throw a
        /// TrapException.
        /// <para>For example, if Traps equals <c>FlagInexact</c> and
        /// FlagSubnormal, a TrapException will be thrown if an operation's
        /// return value is not the same as the exact result (FlagInexact) or
        /// if the return value's exponent is lower than the lowest allowed
        /// (FlagSubnormal).</para></summary>
        /// <value>The traps that are set for each flag in the context.
        /// Whenever a flag is signaled, even if <c>HasFlags</c> is false, and
        /// the flag's trap is enabled, the operation will throw a
        /// TrapException.
        /// <para>For example, if Traps equals <c>FlagInexact</c> and
        /// FlagSubnormal, a TrapException will be thrown if an operation's
        /// return value is not the same as the exact result (FlagInexact) or
        /// if the return value's exponent is lower than the lowest allowed
        /// (FlagSubnormal).</para>.</value>
        public int Traps
        {
            get
            {
                return this.traps;
            }
        }

        /// <summary>Creates a new arithmetic context using the given maximum
        /// number of digits, an unlimited exponent range, and the HalfUp
        /// rounding mode.</summary>
        /// <param name='precision'>Maximum number of digits
        /// (precision).</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public static EContext ForPrecision(int precision)
        {
            return new EContext(
              precision,
              ERounding.HalfUp,
              0,
              0,
              false).WithUnlimitedExponents();
        }

        /// <summary>Creates a new EContext object initialized with an
        /// unlimited exponent range, and the given rounding mode and maximum
        /// precision.</summary>
        /// <param name='precision'>Maximum number of digits
        /// (precision).</param>
        /// <param name='rounding'>The parameter <paramref name='rounding'/> is
        /// an ERounding object.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public static EContext ForPrecisionAndRounding(
          int precision,
          ERounding rounding)
        {
            return new EContext(
              precision,
              rounding,
              0,
              0,
              false).WithUnlimitedExponents();
        }

        private static readonly EContext ForRoundingHalfEven = new EContext(
          0,
          ERounding.HalfEven,
          0,
          0,
          false).WithUnlimitedExponents();

        private static readonly EContext ForRoundingDown = new EContext(
          0,
          ERounding.Down,
          0,
          0,
          false).WithUnlimitedExponents();

        /// <summary>Creates a new EContext object initialized with an
        /// unlimited precision, an unlimited exponent range, and the given
        /// rounding mode.</summary>
        /// <param name='rounding'>The rounding mode for the new precision
        /// context.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public static EContext ForRounding(ERounding rounding)
        {
            if (rounding == ERounding.HalfEven)
            {
                return ForRoundingHalfEven;
            }
            if (rounding == ERounding.Down)
            {
                return ForRoundingDown;
            }
            return new EContext(
              0,
              rounding,
              0,
              0,
              false).WithUnlimitedExponents();
        }

        /// <summary>Initializes a new EContext that is a copy of another
        /// EContext.</summary>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext Copy()
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Determines whether a number can have the given Exponent
        /// property under this arithmetic context.</summary>
        /// <param name='exponent'>An arbitrary-precision integer indicating
        /// the desired exponent.</param>
        /// <returns><c>true</c> if a number can have the given Exponent
        /// property under this arithmetic context; otherwise, <c>false</c>.
        /// If this context allows unlimited precision, returns true for the
        /// exponent EMax and any exponent less than EMax.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='exponent'/> is null.</exception>
        public bool ExponentWithinRange(EInteger exponent)
        {
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (!this.HasExponentRange)
            {
                return true;
            }
            if (this.bigintPrecision.IsZero)
            {
                // Only check EMax, since with an unlimited
                // precision, any exponent less than EMin will exceed EMin if
                // the significand is the right size
                // TODO: In next major version, perhaps correct this to check
                // EMin here as well if AdjustExponent is true
                return exponent.CompareTo(this.EMax) <= 0;
            }
            else
            {
                EInteger bigint = exponent;
                if (this.adjustExponent)
                {
                    bigint = bigint.Add(this.bigintPrecision).Subtract(1);
                }
                return (bigint.CompareTo(this.EMin) >= 0) &&
        (exponent.CompareTo(this.EMax) <= 0);
            }
        }

        /// <summary>Returns this object in a text form intended to be read by
        /// humans. The value returned by this method is not intended to be
        /// parsed by computer programs, and the exact text of the value may
        /// change at any time between versions of this library.</summary>
        /// <returns>A string representation of this object.</returns>
        public override string ToString()
        {
            return "[PrecisionContext ExponentMax=" + this.exponentMax +
              ", Traps=" + this.traps + ", ExponentMin=" + this.exponentMin +
              ", HasExponentRange=" + this.hasExponentRange + ", BigintPrecision=" +
              this.bigintPrecision + ", Rounding=" + this.rounding +
              ", ClampNormalExponents=" + this.clampNormalExponents +
              ", AdjustExponent=" + this.adjustExponent + ", Flags=" +
              this.flags + ", HasFlags=" + this.hasFlags + ", IsSimplified=" +
      this.simplified +
              "]";
        }

        /// <summary>Gets a value indicating whether this context has a mutable
        /// Flags field, one or more trap enablers, or both.</summary>
        /// <value><c>true</c> if this context has a mutable Flags field, one
        /// or more trap enablers, or both; otherwise, <c>false</c>.</value>
        public bool HasFlagsOrTraps
        {
            get
            {
                return this.HasFlags || this.Traps != 0;
            }
        }

        /// <summary>Copies this EContext and sets the copy's "AdjustExponent"
        /// property to the given value.</summary>
        /// <param name='adjustExponent'>The new value of the "AdjustExponent"
        /// property for the copy.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithAdjustExponent(bool adjustExponent)
        {
            return new EContext(
              adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this arithmetic context and sets the copy's
        /// exponent range.</summary>
        /// <param name='exponentMin'>Desired minimum exponent (EMin).</param>
        /// <param name='exponentMax'>Desired maximum exponent (EMax).</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='exponentMin'/> is null.</exception>
        /// <exception cref='ArgumentException'>ExponentMin greater than
        /// exponentMax".</exception>
        public EContext WithBigExponentRange(
          EInteger exponentMin,
          EInteger exponentMax)
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              exponentMax,
              exponentMin,
              this.flags,
              true,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this EContext with <c>HasFlags</c> set to false, a
        /// Traps value of 0, and a Flags value of 0.</summary>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithNoFlagsOrTraps()
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              0,
              this.hasExponentRange,
              false,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              0);
        }

        /// <summary>Copies this EContext and gives it a particular precision
        /// value.</summary>
        /// <param name='bigintPrecision'>Desired precision. 0 means unlimited
        /// precision.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigintPrecision'/> is null.</exception>
        public EContext WithBigPrecision(EInteger bigintPrecision)
        {
            return new EContext(
              this.adjustExponent,
              bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this EContext with <c>HasFlags</c> set to true and
        /// a Flags value of 0.</summary>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithBlankFlags()
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              0,
              this.hasExponentRange,
              true,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this arithmetic context and sets the copy's
        /// "ClampNormalExponents" flag to the given value.</summary>
        /// <param name='clamp'>The desired value of the "ClampNormalExponents"
        /// flag.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithExponentClamp(bool clamp)
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              clamp,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this arithmetic context and sets the copy's
        /// exponent range.</summary>
        /// <param name='exponentMinSmall'>Desired minimum exponent
        /// (EMin).</param>
        /// <param name='exponentMaxSmall'>Desired maximum exponent
        /// (EMax).</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithExponentRange(
          int exponentMinSmall,
          int exponentMaxSmall)
        {
            return this.WithBigExponentRange(
                EInteger.FromInt32(exponentMinSmall),
                EInteger.FromInt32(exponentMaxSmall));
        }

        /// <summary>Copies this EContext with <c>HasFlags</c> set to false and
        /// a Flags value of 0.</summary>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithNoFlags()
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              0,
              this.hasExponentRange,
              false,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this EContext and gives it a particular precision
        /// value.</summary>
        /// <param name='precision'>Desired precision. 0 means unlimited
        /// precision.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithPrecision(int precision)
        {
            return this.WithBigPrecision(EInteger.FromInt32(precision));
        }

        /// <summary>Copies this EContext and sets the copy's
        /// "IsPrecisionInBits" property to the given value.</summary>
        /// <param name='isPrecisionBits'>The new value of the
        /// "IsPrecisionInBits" property for the copy.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithPrecisionInBits(bool isPrecisionBits)
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              isPrecisionBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this EContext with the specified rounding
        /// mode.</summary>
        /// <param name='rounding'>Desired value of the Rounding
        /// property.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithRounding(ERounding rounding)
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              this.precisionInBits,
              rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Copies this EContext and sets the copy's "IsSimplified"
        /// property to the given value.</summary>
        /// <param name='simplified'>Desired value of the IsSimplified
        /// property.</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithSimplified(bool simplified)
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              simplified,
              this.traps);
        }

        /// <summary>Copies this EContext with Traps set to the given value.
        /// (Also sets HasFlags on the copy to <c>True</c>, but this may
        /// change in version 2.0 of this library.).</summary>
        /// <param name='traps'>Flags representing the traps to enable. See the
        /// property "Traps".</param>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithTraps(int traps)
        {
            // NOTE: Apparently HasFlags must be set to true because
            // some parts of code may treat HasFlags as HasFlagsOrTraps
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              this.hasExponentRange,
              true,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              traps);
        }

        /// <summary>Copies this EContext with an unlimited exponent
        /// range.</summary>
        /// <returns>A context object for arbitrary-precision arithmetic
        /// settings.</returns>
        public EContext WithUnlimitedExponents()
        {
            return new EContext(
              this.adjustExponent,
              this.bigintPrecision,
              this.clampNormalExponents,
              this.exponentMax,
              this.exponentMin,
              this.flags,
              false,
              this.hasFlags,
              this.precisionInBits,
              this.rounding,
              this.simplified,
              this.traps);
        }

        /// <summary>Returns this context if it doesn't set traps, or a context
        /// without traps and with blank flags if it does, so that the
        /// resulting context does not cause trap exceptions to occur. This is
        /// not a general-purpose method; it is intended to support custom
        /// implementations of arithmetic operations.</summary>
        /// <returns>This context if it doesn't set traps, or a context without
        /// traps and with blank flags if it does.</returns>
        public EContext GetNontrapping()
        {
            return (this.Traps == 0) ? this : this.WithTraps(0).WithBlankFlags();
        }

        /// <summary>Throws trap exceptions if the given context has flags set
        /// that also have traps enabled for them in this context, and adds the
        /// given context's flags to this context if HasFlags for this context
        /// is true. This is not a general-purpose method; it is intended to
        /// support custom implementations of arithmetic operations.</summary>
        /// <param name='result'>The result of the operation.</param>
        /// <param name='trappableContext'>An arithmetic context, usually a
        /// context returned by the GetNontrapping method. Can be null.</param>
        /// <typeparam name='T'>Data type for the result of the
        /// operation.</typeparam>
        /// <returns>The parameter <paramref name='result'/> if no trap
        /// exceptions were thrown.</returns>
        public T TriggerTraps<T>(
          T result,
          EContext trappableContext)
        {
            if (trappableContext == null || trappableContext.Flags == 0)
            {
                return result;
            }
            if (this.HasFlags)
            {
                this.flags |= trappableContext.Flags;
            }
            int traps = this.Traps & trappableContext.Flags;
            if (traps == 0)
            {
                return result;
            }
            int mutexConditions = traps & (~(
                  EContext.FlagClamped | EContext.FlagInexact |
                  EContext.FlagRounded | EContext.FlagSubnormal));
            if (mutexConditions != 0)
            {
                for (var i = 0; i < 32; ++i)
                {
                    int flag = mutexConditions & (1 << i);
                    if (flag != 0)
                    {
                        throw new ETrapException(traps, flag, this, result);
                    }
                }
            }
            if ((traps & EContext.FlagSubnormal) != 0)
            {
                throw new ETrapException(
                  traps,
                  traps & EContext.FlagSubnormal,
                  this,
                  result);
            }
            if ((traps & EContext.FlagInexact) != 0)
            {
                throw new ETrapException(
                  traps,
                  traps & EContext.FlagInexact,
                  this,
                  result);
            }
            if ((traps & EContext.FlagRounded) != 0)
            {
                throw new ETrapException(
                  traps,
                  traps & EContext.FlagRounded,
                  this,
                  result);
            }
            if ((traps & EContext.FlagClamped) != 0)
            {
                throw new ETrapException(
                  traps,
                  traps & EContext.FlagClamped,
                  this,
                  result);
            }
            return result;
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EDecimal"]/*'/>
    /// <summary>
    ///  Represents an arbitrary-precision decimal
    /// floating-point number. (The "E" stands for "extended",
    /// meaning that instances of this class can be values
    /// other than numbers proper, such as infinity and
    /// not-a-number.)
    /// <para><b>About decimal arithmetic</b>
    /// </para>
    /// <para>Decimal (base-10) arithmetic, such as that provided by this
    /// class, is appropriate for calculations involving such real-world
    /// data as prices and other sums of money, tax rates, and
    /// measurements. These calculations often involve multiplying or
    /// dividing one decimal with another decimal, or performing other
    /// operations on decimal numbers. Many of these calculations also rely
    /// on rounding behavior in which the result after rounding is an
    /// arbitrary-precision decimal number (for example, multiplying a
    /// price by a premium rate, then rounding, should result in a decimal
    /// amount of money).</para>
    /// <para>On the other hand, most implementations of <c>float</c>
    ///  and
    /// <c>double</c>
    ///  , including in C# and Java, store numbers in a binary
    /// (base-2) floating-point format and use binary floating-point
    /// arithmetic. Many decimal numbers can't be represented exactly in
    /// binary floating-point format (regardless of its length). Applying
    /// binary arithmetic to numbers intended to be decimals can sometimes
    /// lead to unintuitive results, as is shown in the description for the
    /// FromDouble() method of this class.</para>
    /// <para><b>About EDecimal instances</b>
    /// </para>
    /// <para>Each instance of this class consists of an integer
    /// significand and an integer exponent, both arbitrary-precision. The
    /// value of the number equals significand * 10^exponent.</para>
    /// <para>The significand is the value of the digits that make up a
    /// number, ignoring the decimal point and exponent. For example, in
    /// the number 2356.78, the significand is 235678. The exponent is
    /// where the "floating" decimal point of the number is located. A
    /// positive exponent means "move it to the right", and a negative
    /// exponent means "move it to the left." In the example 2, 356.78, the
    /// exponent is -2, since it has 2 decimal places and the decimal point
    /// is "moved to the left by 2." Therefore, in the arbitrary-precision
    /// decimal representation, this number would be stored as 235678 *
    /// 10^-2.</para>
    /// <para>The significand and exponent format preserves trailing zeros
    /// in the number's value. This may give rise to multiple ways to store
    /// the same value. For example, 1.00 and 1 would be stored
    /// differently, even though they have the same value. In the first
    /// case, 100 * 10^-2 (100 with decimal point moved left by 2), and in
    /// the second case, 1 * 10^0 (1 with decimal point moved 0).</para>
    /// <para>This class also supports values for negative zero,
    /// not-a-number (NaN) values, and infinity. <b>Negative zero</b>
    ///  is
    /// generally used when a negative number is rounded to 0; it has the
    /// same mathematical value as positive zero. <b>Infinity</b>
    ///  is
    /// generally used when a non-zero number is divided by zero, or when a
    /// very high or very low number can't be represented in a given
    /// exponent range. <b>Not-a-number</b>
    ///  is generally used to signal
    /// errors.</para>
    /// <para>This class implements the General Decimal Arithmetic
    /// Specification version 1.70 except part of chapter 6(
    /// <c>http://speleotrove.com/decimal/decarith.html</c>
    ///  ).</para>
    /// <para><b>Errors and Exceptions</b>
    /// </para>
    /// <para>Passing a signaling NaN to any arithmetic operation shown
    /// here will signal the flag FlagInvalid and return a quiet NaN, even
    /// if another operand to that operation is a quiet NaN, unless the
    /// operation's documentation expressly states that another result
    /// happens when a signaling NaN is passed to that operation.</para>
    /// <para>Passing a quiet NaN to any arithmetic operation shown here
    /// will return a quiet NaN, unless the operation's documentation
    /// expressly states that another result happens when a quiet NaN is
    /// passed to that operation. Invalid operations will also return a
    /// quiet NaN, as stated in the individual methods.</para>
    /// <para>Unless noted otherwise, passing a null arbitrary-precision
    /// decimal argument to any method here will throw an exception.</para>
    /// <para>When an arithmetic operation signals the flag FlagInvalid,
    /// FlagOverflow, or FlagDivideByZero, it will not throw an exception
    /// too, unless the flag's trap is enabled in the arithmetic context
    /// (see EContext's Traps property).</para>
    /// <para>If an operation requires creating an intermediate value that
    /// might be too big to fit in memory (or might require more than 2
    /// gigabytes of memory to store -- due to the current use of a 32-bit
    /// integer internally as a length), the operation may signal an
    /// invalid-operation flag and return not-a-number (NaN). In certain
    /// rare cases, the CompareTo method may throw OutOfMemoryException
    /// (called OutOfMemoryError in Java) in the same circumstances.</para>
    /// <para><b>Serialization</b>
    /// </para>
    /// <para>An arbitrary-precision decimal value can be serialized
    /// (converted to a stable format) in one of the following ways:</para>
    /// <list><item>By calling the toString() method, which will always
    /// return distinct strings for distinct arbitrary-precision decimal
    /// values.</item>
    ///  <item>By calling the UnsignedMantissa, Exponent, and
    /// IsNegative properties, and calling the IsInfinity, IsQuietNaN, and
    /// IsSignalingNaN methods. The return values combined will uniquely
    /// identify a particular arbitrary-precision decimal value.</item>
    /// </list>
    /// <para><b>Thread safety</b>
    /// </para>
    /// <para>Instances of this class are immutable, so they are inherently
    /// safe for use by multiple threads. Multiple instances of this object
    /// with the same properties are interchangeable, so they should not be
    /// compared using the "==" operator (which might only check if each
    /// side of the operator is the same instance).</para>
    /// <para><b>Comparison considerations</b>
    /// </para>
    /// <para>This class's natural ordering (under the CompareTo method) is
    /// not consistent with the Equals method. This means that two values
    /// that compare as equal under the CompareTo method might not be equal
    /// under the Equals method. The CompareTo method compares the
    /// mathematical values of the two instances passed to it (and
    /// considers two different NaN values as equal), while two instances
    /// with the same mathematical value, but different exponents, will be
    /// considered unequal under the Equals method.</para>
    /// <para><b>Security note</b>
    /// </para>
    /// <para>It is not recommended to implement security-sensitive
    /// algorithms using the methods in this class, for several
    /// reasons:</para>
    /// <list><item><c>EDecimal</c>
    ///  objects are immutable, so they can't be
    /// modified, and the memory they occupy is not guaranteed to be
    /// cleared in a timely fashion due to garbage collection. This is
    /// relevant for applications that use many-digit-long numbers as
    /// secret parameters.</item>
    ///  <item>The methods in this class
    /// (especially those that involve arithmetic) are not guaranteed to be
    /// "constant-time" (non-data-dependent) for all relevant inputs.
    /// Certain attacks that involve encrypted communications have
    /// exploited the timing and other aspects of such communications to
    /// derive keying material or cleartext indirectly.</item>
    ///  </list>
    /// <para>Applications should instead use dedicated security libraries
    /// to handle big numbers in security-sensitive algorithms.</para>
    /// <para><b>Reproducibility note</b>
    /// </para>
    /// <para>Some applications, such as simulations, care about results
    /// that are reproducible, bit for bit, across computers and across
    /// runs of the application. Bruce Dawson, in "Floating-Point
    /// Determinism" ( <c>https://randomascii.wordpress.com/</c>
    /// <c>2013/07/16/floating-point-determinism/</c>
    ///  ), identified many
    /// reproducibility issues with floating-point numbers, and here is how
    /// they relate to the EDecimal and EFloat classes of this
    /// library:</para>
    /// <list><item>Runtime floating-point settings: All the settings that
    /// change how EDecimal and EFloat behave are given as parameters to
    /// the appropriate methods, especially via EContext objects, which
    /// specify the precision, rounding, and exponent range of numbers,
    /// among other things. The EDecimal and EFloat classes avoid the use
    /// of "native" floating-point data types (except for methods that
    /// convert to or from <c>float</c>
    ///  , <c>double</c>
    ///  , or
    /// <c>System.Decimal</c>
    ///  ). Such "native" types are often subject to
    /// runtime settings that change how floating-point math behaves with
    /// them, and these settings are often not accessible to .NET or Java
    /// code.</item>
    ///  <item>Non-associativity and intermediate precisions:
    /// In general, EDecimal and EFloat use "unlimited" precision in their
    /// calculations unless specified otherwise by an EContext object.
    /// However, by limiting the precision of EDecimal, EFloat, and other
    /// floating-point numbers in this way, operations such as addition and
    /// multiplication on three or more numbers can be
    /// <i>non-associative</i>
    ///  , meaning the result can change depending on
    /// the order in which those numbers are added or multiplied. This
    /// property means that if an algorithm does not ensure such numbers
    /// are added or multiplied in the same order every time, its results
    /// may not be reproducible across computers or across runs of the
    /// application. This non-associativity problem can happen, for
    /// example, if an application splits a calculation across several
    /// threads and combines their results in the end. The problems with an
    /// unspecified order of operations (in the same line of code) and
    /// intermediate precisions (problems present in C and C++, for
    /// example) don't exist with method calls to EDecimal and EFloat
    /// methods, especially since they require limited-precision support to
    /// be declared explicitly via EContext.</item>
    ///  <item>fmadd
    /// instruction: EDecimal and EFloat include a MultiplyAndAdd method
    /// with the same semantics as in the General Decimal Arithmetic
    /// Specification, which requires delivering correctly rounded results
    /// for this method.</item>
    ///  <item>Square root estimate: Not applicable
    /// since EDecimal and EFloat don't include any estimates to square
    /// root.</item>
    ///  <item>Transcendental functions: This includes
    /// logarithms, exponentials, and the Pi method. For these functions,
    /// results are not guaranteed to always be correctly rounded. When
    /// using transcendentals, an application that cares about
    /// reproducibility should choose one version of this library and stick
    /// to it; this at least has the advantage that the implementation will
    /// be the same across computers, unlike with "native" floating-point
    /// types where the choice of implementation is often not within the
    /// application's control.</item>
    ///  <item>Conversions: Conversions
    /// between EDecimal or EFloat and text strings have the same
    /// implementation across computers for the same version of this
    /// library (see also the advice for transcendentals above). But as for
    /// the ToDouble, ToSingle, FromDouble, and FromSingle methods, note
    /// that some implementations of Java and.NET may or may not support
    /// preserving the value of subnormal numbers (numbers other than zero
    /// with the lowest possible exponent) or the payloads held in a
    /// not-a-number (NaN) value of float or double; thus these methods
    /// should not be considered reproducible across computers.</item>
    /// <item>Compiler differences: Not applicable where these classes
    /// don't use "native" floating-point types.</item>
    ///  <item>Uninitialized
    /// data; per-processor code: Not applicable.</item>
    ///  </list>
    /// <para><b>Forms of numbers</b>
    /// </para>
    /// <para>There are several other types of numbers that are mentioned
    /// in this class and elsewhere in this documentation. For reference,
    /// they are specified here.</para>
    /// <para><b>Unsigned integer</b>
    ///  : An integer that's always 0 or
    /// greater, with the following maximum values:</para>
    /// <list><item>8-bit unsigned integer, or <i>byte</i>
    ///  : 255.</item>
    /// <item>16-bit unsigned integer: 65535.</item>
    ///  <item>32-bit unsigned
    /// integer: (2 <sup>32</sup>
    ///  -1).</item>
    ///  <item>64-bit unsigned
    /// integer: (2 <sup>64</sup>
    ///  -1).</item>
    ///  </list>
    /// <para><b>Signed integer</b>
    ///  : An integer in <i>two's-complement
    /// form</i>
    ///  , with the following ranges:</para>
    /// <list><item>8-bit signed integer: -128 to 127.</item>
    ///  <item>16-bit
    /// signed integer: -32768 to 32767.</item>
    ///  <item>32-bit signed
    /// integer: -2 <sup>31</sup>
    ///  to (2 <sup>31</sup>
    ///  - 1).</item>
    /// <item>64-bit signed integer: -2 <sup>63</sup>
    ///  to (2 <sup>63</sup>
    ///  -
    /// 1).</item>
    ///  </list>
    /// <para><b>Two's complement form</b>
    ///  : In <i>two's-complement
    /// form</i>
    ///  , nonnegative numbers have the highest (most significant)
    /// bit set to zero, and negative numbers have that bit (and all bits
    /// beyond) set to one, and a negative number is stored in such form by
    /// decreasing its absolute value by 1 and swapping the bits of the
    /// resulting number.</para>
    /// <para><b>64-bit floating-point number</b>
    ///  : A 64-bit binary
    /// floating-point number, in the form <i>significand</i>
    ///  * 2
    /// <sup><i>exponent</i>
    ///  </sup>
    /// . The significand is 53 bits long
    /// (Precision) and the exponent ranges from -1074 (EMin) to 971
    /// (EMax). The number is stored in the following format (commonly
    /// called the IEEE 754 format):</para>
    /// <code>|C|BBB...BBB|AAAAAA...AAAAAA|</code>
    /// <list><item>A. Low 52 bits (Precision minus 1 bits): Lowest bits of
    /// the significand.</item>
    ///  <item>B. Next 11 bits: Exponent area:
    /// <list><item>If all bits are ones, the final stored value is
    /// infinity (positive or negative depending on the C bit) if all bits
    /// in area A are zeros, or not-a-number (NaN) otherwise.</item>
    /// <item>If all bits are zeros, the final stored value is a subnormal
    /// number, the exponent is EMin, and the highest bit of the
    /// significand is zero.</item>
    ///  <item>If any other number, the exponent
    /// is this value reduced by 1, then raised by EMin, and the highest
    /// bit of the significand is one.</item>
    ///  </list>
    ///  </item>
    ///  <item>C.
    /// Highest bit: If one, this is a negative number.</item>
    ///  </list>
    /// <para>The elements described above are in the same order as the
    /// order of each bit of each element, that is, either most significant
    /// first or least significant first.</para>
    /// <para><b>32-bit binary floating-point number</b>
    ///  : A 32-bit binary
    /// number which is stored similarly to a <i>64-bit floating-point
    /// number</i>
    ///  , except that:</para>
    /// <list><item>Precision is 24 bits.</item>
    ///  <item>EMin is -149.</item>
    /// <item>EMax is 104.</item>
    ///  <item>A. The low 23 bits (Precision minus
    /// 1 bits) are the lowest bits of the significand.</item>
    ///  <item>B. The
    /// next 8 bits are the exponent area.</item>
    ///  <item>C. If the highest
    /// bit is one, this is a negative number.</item>
    ///  </list>
    /// <para><b>.NET Framework decimal</b>
    ///  : A 128-bit decimal
    /// floating-point number, in the form <i>significand</i>
    ///  * 10 <sup>-
    /// <i>scale</i>
    ///  </sup>
    ///  , where the scale ranges from 0 to 28. The
    /// number is stored in the following format:</para>
    /// <list><item>Low 96 bits are the significand, as a 96-bit unsigned
    /// integer (all 96-bit values are allowed, up to (2 <sup>96</sup>
    /// -1)).</item>
    ///  <item>Next 16 bits are unused.</item>
    ///  <item>Next 8
    /// bits are the scale, stored as an 8-bit unsigned integer.</item>
    /// <item>Next 7 bits are unused.</item>
    ///  <item>If the highest bit is
    /// one, it's a negative number.</item>
    ///  </list>
    /// <para>The elements described above are in the same order as the
    /// order of each bit of each element, that is, either most significant
    /// first or least significant first.</para>
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
        "Microsoft.Design",
        "CA1036",
        Justification = "Awaiting advice at dotnet/dotnet-api-docs#2937.")]
    public sealed partial class EDecimal : IComparable<EDecimal>,
      IEquatable<EDecimal>
    {
        private const int RepeatDivideThreshold = 10000;
        internal const int MaxSafeInt = 214748363;

        //----------------------------------------------------------------

        /// <summary>A not-a-number value.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal NaN = CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            (byte)BigNumberFlags.FlagQuietNaN);

        /// <summary>Negative infinity, less than any other number.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal NegativeInfinity =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);

        /// <summary>Represents the number negative zero.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal NegativeZero =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagNegative);

        /// <summary>Represents the number 1.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal One = new EDecimal(
          FastIntegerFixed.FromInt32(1),
          FastIntegerFixed.Zero,
          (byte)0);

        /// <summary>Positive infinity, greater than any other
        /// number.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal PositiveInfinity =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagInfinity);

        /// <summary>A not-a-number value that signals an invalid operation
        /// flag when it's passed as an argument to any arithmetic operation in
        /// arbitrary-precision decimal.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal SignalingNaN =
          CreateWithFlags(
            EInteger.Zero,
            EInteger.Zero,
            BigNumberFlags.FlagSignalingNaN);

        /// <summary>Represents the number 10.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal Ten = new EDecimal(
          FastIntegerFixed.FromInt32(10),
          FastIntegerFixed.Zero,
          (byte)0);

        /// <summary>Represents the number 0.</summary>
#if CODE_ANALYSIS
    [System.Diagnostics.CodeAnalysis.SuppressMessage ("Microsoft.Security",
        "CA2104", Justification = "EDecimal is immutable")]
#endif
        public static readonly EDecimal Zero = new EDecimal(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)0);

        private const int CacheFirst = -24;
        private const int CacheLast = 128;
        private static readonly EDecimal[] Cache = EDecimalCache(CacheFirst,
            CacheLast);

        internal static EDecimal FromCache(int v)
        {
            return Cache[v - CacheFirst];
        }

        private static EDecimal[] EDecimalCache(int first, int last)
        {
#if DEBUG
            if (first < -65535)
            {
                throw new ArgumentException("first (" + first + ") is not greater" +
                  "\u0020or equal" + "\u0020to " + (-65535));
            }
            if (first > 65535)
            {
                throw new ArgumentException("first (" + first + ") is not less or" +
                  "\u0020equal to" + "\u002065535");
            }
            if (last < -65535)
            {
                throw new ArgumentException("last (" + last + ") is not greater or" +
                  "\u0020equal" + "\u0020to " + (-65535));
            }
            if (last > 65535)
            {
                throw new ArgumentException("last (" + last + ") is not less or" +
                  "\u0020equal to" + "65535");
            }
#endif

            var cache = new EDecimal[(last - first) + 1];
            int i;
            for (i = first; i <= last; ++i)
            {
                if (i == 0)
                {
                    cache[i - first] = Zero;
                }
                else if (i == 1)
                {
                    cache[i - first] = One;
                }
                else if (i == 10)
                {
                    cache[i - first] = Ten;
                }
                else
                {
                    cache[i - first] = new EDecimal(
                      FastIntegerFixed.FromInt32(Math.Abs(i)),
                      FastIntegerFixed.Zero,
                      (byte)(i < 0 ? BigNumberFlags.FlagNegative : 0));
                }
            }
            return cache;
        }

        private static readonly DecimalMathHelper HelperValue = new
        DecimalMathHelper();

        private static readonly IRadixMath<EDecimal> ExtendedMathValue = new
        RadixMath<EDecimal>(HelperValue);
        //----------------------------------------------------------------
        private static readonly IRadixMath<EDecimal> MathValue = new
        TrappableRadixMath<EDecimal>(
          new ExtendedOrSimpleRadixMath<EDecimal>(HelperValue));

        private static readonly int[] ValueTenPowers = {
      1, 10, 100, 1000, 10000, 100000,
      1000000, 10000000, 100000000,
      1000000000,
    };

        private readonly FastIntegerFixed unsignedMantissa;
        private readonly FastIntegerFixed exponent;
        private readonly byte flags;

        internal EDecimal(
          FastIntegerFixed unsignedMantissa,
          FastIntegerFixed exponent,
          byte flags)
        {
#if DEBUG
            if (unsignedMantissa == null)
            {
                throw new ArgumentNullException(nameof(unsignedMantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (unsignedMantissa.Sign < 0)
            {
                throw new ArgumentException("unsignedMantissa is less than 0.");
            }
#endif
            this.unsignedMantissa = unsignedMantissa;
            this.exponent = exponent;
            this.flags = flags;
        }

        /// <summary>Creates a copy of this arbitrary-precision binary
        /// number.</summary>
        /// <returns>An arbitrary-precision decimal floating-point
        /// number.</returns>
        public EDecimal Copy()
        {
            return new EDecimal(
                this.unsignedMantissa.Copy(),
                this.exponent.Copy(),
                this.flags);
        }

        /// <summary>Gets this object's exponent. This object's value will be
        /// an integer if the exponent is positive or zero.</summary>
        /// <value>This object's exponent. This object's value will be an
        /// integer if the exponent is positive or zero.</value>
        public EInteger Exponent
        {
            get
            {
                return this.exponent.ToEInteger();
            }
        }

        /// <summary>Gets a value indicating whether this object is finite (not
        /// infinity or NaN).</summary>
        /// <value><c>true</c> if this object is finite (not infinity or NaN);
        /// otherwise, <c>false</c>.</value>
        public bool IsFinite
        {
            get
            {
                return (this.flags & (BigNumberFlags.FlagInfinity |
                      BigNumberFlags.FlagNaN)) == 0;
            }
        }

        /// <summary>Gets a value indicating whether this object is negative,
        /// including negative zero.</summary>
        /// <value><c>true</c> if this object is negative, including negative
        /// zero; otherwise, <c>false</c>.</value>
        public bool IsNegative
        {
            get
            {
                return (this.flags & BigNumberFlags.FlagNegative) != 0;
            }
        }

        /// <summary>Gets a value indicating whether this object's value equals
        /// 0.</summary>
        /// <value><c>true</c> if this object's value equals 0; otherwise,
        /// <c>false</c>. <c>true</c> if this object's value equals 0;
        /// otherwise, <c>false</c>.</value>
        public bool IsZero
        {
            get
            {
                return ((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                  this.unsignedMantissa.IsValueZero;
            }
        }

        /// <summary>Returns whether this object's value is an
        /// integer.</summary>
        /// <returns><c>true</c> if this object's value is an integer;
        /// otherwise, <c>false</c>.</returns>
        public bool IsInteger()
        {
            if (!this.IsFinite)
            {
                return false;
            }
            if (this.IsZero || this.exponent.CompareToInt(0) >= 0)
            {
                return true;
            }
            else
            {
                EDecimal r = this.Reduce(null);
                return r.exponent.CompareToInt(0) >= 0;
            }
        }

        /// <summary>Gets this object's unscaled value, or significand, and
        /// makes it negative if this object is negative. If this value is
        /// not-a-number (NaN), that value's absolute value is the NaN's
        /// "payload" (diagnostic information).</summary>
        /// <value>This object's unscaled value. Will be negative if this
        /// object's value is negative (including a negative NaN).</value>
        public EInteger Mantissa
        {
            get
            {
                return this.IsNegative ? this.unsignedMantissa.ToEInteger().Negate() :
                  this.unsignedMantissa.ToEInteger();
            }
        }

        /// <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
        /// if zero.</summary>
        /// <value>This value's sign: -1 if negative; 1 if positive; 0 if
        /// zero.</value>
        public int Sign
        {
            get
            {
                return (((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                    this.unsignedMantissa.IsValueZero) ? 0 : (((this.flags &
                        BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
            }
        }

        /// <summary>Gets the absolute value of this object's unscaled value,
        /// or significand. If this value is not-a-number (NaN), that value is
        /// the NaN's "payload" (diagnostic information).</summary>
        /// <value>The absolute value of this object's unscaled value.</value>
        public EInteger UnsignedMantissa
        {
            get
            {
                return this.unsignedMantissa.ToEInteger();
            }
        }

        internal static EDecimal ChangeExponent(EDecimal ret, EInteger exponent)
        {
            return new EDecimal(
                ret.unsignedMantissa,
                FastIntegerFixed.FromBig(exponent),
                (byte)ret.flags);
        }

        /// <summary>Returns a number with the value
        /// <c>exponent*10^significand</c>.</summary>
        /// <param name='mantissaSmall'>Desired value for the
        /// significand.</param>
        /// <param name='exponentSmall'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        public static EDecimal Create(int mantissaSmall, int exponentSmall)
        {
            if (exponentSmall == 0 && mantissaSmall >= CacheFirst &&
              mantissaSmall <= CacheLast)
            {
                return Cache[mantissaSmall - CacheFirst];
            }
            if (mantissaSmall < 0)
            {
                if (mantissaSmall == Int32.MinValue)
                {
                    FastIntegerFixed fi = FastIntegerFixed.FromInt64(Int32.MinValue);
                    return new EDecimal(
                        fi.Negate(),
                        FastIntegerFixed.FromInt32(exponentSmall),
                        (byte)BigNumberFlags.FlagNegative);
                }
                return new EDecimal(
                    FastIntegerFixed.FromInt32(-mantissaSmall),
                    FastIntegerFixed.FromInt32(exponentSmall),
                    (byte)BigNumberFlags.FlagNegative);
            }
            else if (mantissaSmall == 0)
            {
                return new EDecimal(
                    FastIntegerFixed.Zero,
                    FastIntegerFixed.FromInt32(exponentSmall),
                    (byte)0);
            }
            else
            {
                return new EDecimal(
                    FastIntegerFixed.FromInt32(mantissaSmall),
                    FastIntegerFixed.FromInt32(exponentSmall),
                    (byte)0);
            }
        }

        /// <summary>Creates a number with the value
        /// <c>exponent*10^significand</c>.</summary>
        /// <param name='mantissa'>Desired value for the significand.</param>
        /// <param name='exponentSmall'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='mantissa'/> is null.</exception>
        public static EDecimal Create(
          EInteger mantissa,
          int exponentSmall)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (mantissa.CanFitInInt32())
            {
                int mantissaSmall = mantissa.ToInt32Checked();
                return Create(mantissaSmall, exponentSmall);
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EDecimal(
                sign < 0 ? fi.Negate() : fi,
                FastIntegerFixed.FromInt32(exponentSmall),
                (byte)((sign < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Creates a number with the value
        /// <c>exponent*10^significand</c>.</summary>
        /// <param name='mantissa'>Desired value for the significand.</param>
        /// <param name='exponentLong'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='mantissa'/> is null.</exception>
        public static EDecimal Create(
          EInteger mantissa,
          long exponentLong)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (mantissa.CanFitInInt64())
            {
                long mantissaLong = mantissa.ToInt64Checked();
                return Create(mantissaLong, exponentLong);
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EDecimal(
                sign < 0 ? fi.Negate() : fi,
                FastIntegerFixed.FromInt64(exponentLong),
                (byte)((sign < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Creates a number with the value
        /// <c>exponent*10^significand</c>.</summary>
        /// <param name='mantissa'>Desired value for the significand.</param>
        /// <param name='exponent'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='mantissa'/> or <paramref name='exponent'/> is
        /// null.</exception>
        public static EDecimal Create(
          EInteger mantissa,
          EInteger exponent)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (mantissa.CanFitInInt32() && exponent.IsZero)
            {
                int mantissaSmall = mantissa.ToInt32Checked();
                return Create(mantissaSmall, 0);
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EDecimal(
                sign < 0 ? fi.Negate() : fi,
                FastIntegerFixed.FromBig(exponent),
                (byte)((sign < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Creates a number with the value
        /// <c>exponent*10^significand</c>.</summary>
        /// <param name='mantissaLong'>Desired value for the
        /// significand.</param>
        /// <param name='exponentSmall'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        public static EDecimal Create(
          long mantissaLong,
          int exponentSmall)
        {
            return Create(mantissaLong, (long)exponentSmall);
        }

        /// <summary>Creates a number with the value
        /// <c>exponent*10^significand</c>.</summary>
        /// <param name='mantissaLong'>Desired value for the
        /// significand.</param>
        /// <param name='exponentLong'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        public static EDecimal Create(
          long mantissaLong,
          long exponentLong)
        {
            if (mantissaLong >= Int32.MinValue && mantissaLong <= Int32.MaxValue &&
              exponentLong >= Int32.MinValue && exponentLong <= Int32.MaxValue)
            {
                return Create((int)mantissaLong, (int)exponentLong);
            }
            else if (mantissaLong == Int64.MinValue)
            {
                FastIntegerFixed fi = FastIntegerFixed.FromInt64(mantissaLong);
                return new EDecimal(
                    fi.Negate(),
                    FastIntegerFixed.FromInt64(exponentLong),
                    (byte)((mantissaLong < 0) ? BigNumberFlags.FlagNegative : 0));
            }
            else
            {
                FastIntegerFixed fi = FastIntegerFixed.FromInt64(Math.Abs(
                      mantissaLong));
                return new EDecimal(
                    fi,
                    FastIntegerFixed.FromInt64(exponentLong),
                    (byte)((mantissaLong < 0) ? BigNumberFlags.FlagNegative : 0));
            }
        }

        /// <summary>Creates a not-a-number arbitrary-precision decimal
        /// number.</summary>
        /// <param name='diag'>An integer, 0 or greater, to use as diagnostic
        /// information associated with this object. If none is needed, should
        /// be zero. To get the diagnostic information from another
        /// arbitrary-precision decimal floating-point number, use that
        /// object's <c>UnsignedMantissa</c> property.</param>
        /// <returns>A quiet not-a-number.</returns>
        public static EDecimal CreateNaN(EInteger diag)
        {
            return CreateNaN(diag, false, false, null);
        }

        /// <summary>Creates a not-a-number arbitrary-precision decimal
        /// number.</summary>
        /// <param name='diag'>An integer, 0 or greater, to use as diagnostic
        /// information associated with this object. If none is needed, should
        /// be zero. To get the diagnostic information from another
        /// arbitrary-precision decimal floating-point number, use that
        /// object's <c>UnsignedMantissa</c> property.</param>
        /// <param name='signaling'>Whether the return value will be signaling
        /// (true) or quiet (false).</param>
        /// <param name='negative'>Whether the return value is
        /// negative.</param>
        /// <param name='ctx'>An arithmetic context to control the precision
        /// (in decimal digits) of the diagnostic information. The rounding and
        /// exponent range of this context will be ignored. Can be null. The
        /// only flag that can be signaled in this context is FlagInvalid,
        /// which happens if diagnostic information needs to be truncated and
        /// too much memory is required to do so.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='diag'/> is null or is less than 0.</exception>
        public static EDecimal CreateNaN(
          EInteger diag,
          bool signaling,
          bool negative,
          EContext ctx)
        {
            if (diag == null)
            {
                throw new ArgumentNullException(nameof(diag));
            }
            if (diag.Sign < 0)
            {
                throw new ArgumentException("Diagnostic information must be 0 or" +
                  "\u0020greater," + "\u0020 was: " + diag);
            }
            if (diag.IsZero && !negative)
            {
                return signaling ? SignalingNaN : NaN;
            }
            var flags = 0;
            if (negative)
            {
                flags |= BigNumberFlags.FlagNegative;
            }
            if (ctx != null && ctx.HasMaxPrecision)
            {
                flags |= BigNumberFlags.FlagQuietNaN;
                var ef = new EDecimal(
                  FastIntegerFixed.FromBig(diag),
                  FastIntegerFixed.Zero,
                  (byte)flags).RoundToPrecision(ctx);

                int newFlags = ef.flags;
                newFlags &= ~BigNumberFlags.FlagQuietNaN;
                newFlags |= signaling ? BigNumberFlags.FlagSignalingNaN :
                  BigNumberFlags.FlagQuietNaN;
                return new EDecimal(
                    ef.unsignedMantissa,
                    ef.exponent,
                    (byte)newFlags);
            }
            flags |= signaling ? BigNumberFlags.FlagSignalingNaN :
              BigNumberFlags.FlagQuietNaN;
            return new EDecimal(
                FastIntegerFixed.FromBig(diag),
                FastIntegerFixed.Zero,
                (byte)flags);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 64-bit binary floating-point number. This method computes the exact
        /// value of the floating point number, not an approximation, as is
        /// often the case by converting the floating point number to a string
        /// first. Remember, though, that the exact value of a 64-bit binary
        /// floating-point number is not always the value that results when
        /// passing a literal decimal number (for example, calling
        /// <c>EDecimal.FromDouble(0.1)</c> ), since not all decimal numbers
        /// can be converted to exact binary numbers (in the example given, the
        /// resulting arbitrary-precision decimal will be the value of the
        /// closest "double" to 0.1, not 0.1 exactly). To create an
        /// arbitrary-precision decimal number from a decimal value, use
        /// FromString instead in most cases (for example:
        /// <c>EDecimal.FromString("0.1")</c> ).</summary>
        /// <param name='dbl'>The parameter <paramref name='dbl'/> is a 64-bit
        /// floating-point number.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as <paramref name='dbl'/>.</returns>
        public static EDecimal FromDouble(double dbl)
        {
            long lvalue = BitConverter.ToInt64(
                BitConverter.GetBytes((double)dbl),
                0);
            return FromDoubleBits(lvalue);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 64-bit binary floating-point number, encoded in the IEEE 754
        /// binary64 format. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the floating point number to a string first.
        /// Remember, though, that the exact value of a 64-bit binary
        /// floating-point number is not always the value that results when
        /// passing a literal decimal number, since not all decimal numbers can
        /// be converted to exact binary numbers (in the example given, the
        /// resulting arbitrary-precision decimal will be the value of the
        /// closest "double" to 0.1, not 0.1 exactly). To create an
        /// arbitrary-precision decimal number from a decimal value, use
        /// FromString instead in most cases.</summary>
        /// <param name='dblBits'>The parameter <paramref name='dblBits'/> is a
        /// 64-bit signed integer.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as <paramref name='dblBits'/>.</returns>
        public static EDecimal FromDoubleBits(long dblBits)
        {
            var value = new int[] {
        unchecked((int)(dblBits & 0xffffffffL)),
        unchecked((int)((dblBits >> 32) & 0xffffffffL)),
      };
            var floatExponent = (int)((value[1] >> 20) & 0x7ff);
            bool neg = (value[1] >> 31) != 0;
            long lvalue;
            if (floatExponent == 2047)
            {
                if ((value[1] & 0xfffff) == 0 && value[0] == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (value[1] & 0x80000) != 0;
                value[1] &= 0x7ffff;
                lvalue = unchecked((value[0] & 0xffffffffL) | ((long)value[1] << 32));
                int flags = (neg ? BigNumberFlags.FlagNegative : 0) | (quiet ?
                    BigNumberFlags.FlagQuietNaN : BigNumberFlags.FlagSignalingNaN);
                return lvalue == 0 ? (quiet ? NaN : SignalingNaN) :
                  new EDecimal(
                    FastIntegerFixed.FromInt64(lvalue),
                    FastIntegerFixed.Zero,
                    (byte)flags);
            }
            value[1] &= 0xfffff;

            // Mask out the exponent and sign
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                value[1] |= 0x100000;
            }
            if ((value[1] | value[0]) != 0)
            {
                floatExponent += NumberUtility.ShiftAwayTrailingZerosTwoElements(
                    value);
            }
            else
            {
                return neg ? EDecimal.NegativeZero : EDecimal.Zero;
            }
            floatExponent -= 1075;
            lvalue = unchecked((value[0] & 0xffffffffL) | ((long)value[1] << 32));
            if (floatExponent == 0)
            {
                if (neg)
                {
                    lvalue = -lvalue;
                }
                return EDecimal.FromInt64(lvalue);
            }
            if (floatExponent > 0)
            {
                // Value is an integer
                var bigmantissa = (EInteger)lvalue;
                bigmantissa <<= floatExponent;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.FromEInteger(bigmantissa);
            }
            else
            {
                // Value has a fractional part
                var bigmantissa = (EInteger)lvalue;
                EInteger bigexp = NumberUtility.FindPowerOfFive(-floatExponent);
                bigmantissa *= (EInteger)bigexp;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.Create(bigmantissa, (EInteger)floatExponent);
            }
        }

        /// <summary>Converts an arbitrary-precision integer to an arbitrary
        /// precision decimal.</summary>
        /// <param name='bigint'>An arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision decimal number with the exponent
        /// set to 0.</returns>
        public static EDecimal FromEInteger(EInteger bigint)
        {
            return EDecimal.Create(bigint, EInteger.Zero);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to an arbitrary precision decimal.</summary>
        /// <param name='ef'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        [Obsolete("Renamed to FromEFloat.")]
        public static EDecimal FromExtendedFloat(EFloat ef)
        {
            return FromEFloat(ef);
        }

        /// <summary>Creates an arbitrary-precision decimal number from an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='bigfloat'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigfloat'/> is null.</exception>
        public static EDecimal FromEFloat(EFloat bigfloat)
        {
            if (bigfloat == null)
            {
                throw new ArgumentNullException(nameof(bigfloat));
            }
            if (bigfloat.IsNaN() || bigfloat.IsInfinity())
            {
                int flags = (bigfloat.IsNegative ? BigNumberFlags.FlagNegative : 0) |
                  (bigfloat.IsInfinity() ? BigNumberFlags.FlagInfinity : 0) |
                  (bigfloat.IsQuietNaN() ? BigNumberFlags.FlagQuietNaN : 0) |
                  (bigfloat.IsSignalingNaN() ? BigNumberFlags.FlagSignalingNaN : 0);
                return CreateWithFlags(
                    bigfloat.UnsignedMantissa,
                    bigfloat.Exponent,
                    flags);
            }
            EInteger bigintExp = bigfloat.Exponent;
            EInteger bigSignedMantissa = bigfloat.Mantissa;
            if (bigSignedMantissa.IsZero)
            {
                return bigfloat.IsNegative ? EDecimal.NegativeZero :
                  EDecimal.Zero;
            }
            if (bigintExp.IsZero)
            {
                // Integer
                return EDecimal.FromEInteger(bigSignedMantissa);
            }
            if (bigintExp.Sign > 0)
            {
                // Scaled integer
                FastInteger intcurexp = FastInteger.FromBig(bigintExp);
                EInteger bigmantissa = bigSignedMantissa;
                bool neg = bigmantissa.Sign < 0;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                while (intcurexp.Sign > 0)
                {
                    var shift = 1000000;
                    if (intcurexp.CompareToInt(1000000) < 0)
                    {
                        shift = intcurexp.ToInt32();
                    }
                    bigmantissa <<= shift;
                    intcurexp.AddInt(-shift);
                }
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.FromEInteger(bigmantissa);
            }
            else
            {
                // Fractional number
                EInteger bigmantissa = bigSignedMantissa;
                EInteger negbigintExp = -(EInteger)bigintExp;
                negbigintExp = NumberUtility.FindPowerOfFiveFromBig(negbigintExp);
                bigmantissa *= (EInteger)negbigintExp;
                return EDecimal.Create(bigmantissa, bigintExp);
            }
        }

        /// <summary>Converts a boolean value (true or false) to an
        /// arbitrary-precision decimal number.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>The number 1 if <paramref name='boolValue'/> is true;
        /// otherwise, 0.</returns>
        public static EDecimal FromBoolean(bool boolValue)
        {
            return boolValue ? EDecimal.One : EDecimal.Zero;
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 32-bit signed integer.</summary>
        /// <param name='valueSmaller'>The parameter <paramref
        /// name='valueSmaller'/> is a 32-bit signed integer.</param>
        /// <returns>An arbitrary-precision decimal number with the exponent
        /// set to 0.</returns>
        public static EDecimal FromInt32(int valueSmaller)
        {
            if (valueSmaller >= CacheFirst && valueSmaller <= CacheLast)
            {
                return Cache[valueSmaller - CacheFirst];
            }
            if (valueSmaller == Int32.MinValue)
            {
                return Create((EInteger)valueSmaller, EInteger.Zero);
            }
            if (valueSmaller < 0)
            {
                return new EDecimal(
                    FastIntegerFixed.FromInt32(valueSmaller).Negate(),
                    FastIntegerFixed.Zero,
                    (byte)BigNumberFlags.FlagNegative);
            }
            else
            {
                return new EDecimal(
                    FastIntegerFixed.FromInt32(valueSmaller),
                    FastIntegerFixed.Zero,
                    (byte)0);
            }
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 64-bit signed integer.</summary>
        /// <param name='valueSmall'>The parameter <paramref
        /// name='valueSmall'/> is a 64-bit signed integer.</param>
        /// <returns>An arbitrary-precision decimal number with the exponent
        /// set to 0.</returns>
        public static EDecimal FromInt64(long valueSmall)
        {
            if (valueSmall >= CacheFirst && valueSmall <= CacheLast)
            {
                return Cache[(int)(valueSmall - CacheFirst)];
            }
            if (valueSmall > Int32.MinValue && valueSmall <= Int32.MaxValue)
            {
                if (valueSmall < 0)
                {
                    return new EDecimal(
                        FastIntegerFixed.FromInt32((int)valueSmall).Negate(),
                        FastIntegerFixed.Zero,
                        (byte)BigNumberFlags.FlagNegative);
                }
                else
                {
                    return new EDecimal(
                        FastIntegerFixed.FromInt32((int)valueSmall),
                        FastIntegerFixed.Zero,
                        (byte)0);
                }
            }
            var bigint = (EInteger)valueSmall;
            return EDecimal.Create(bigint, EInteger.Zero);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 32-bit binary floating-point number. This method computes the exact
        /// value of the floating point number, not an approximation, as is
        /// often the case by converting the floating point number to a string
        /// first. Remember, though, that the exact value of a 32-bit binary
        /// floating-point number is not always the value that results when
        /// passing a literal decimal number (for example, calling
        /// <c>EDecimal.FromSingle(0.1f)</c> ), since not all decimal numbers
        /// can be converted to exact binary numbers (in the example given, the
        /// resulting arbitrary-precision decimal will be the the value of the
        /// closest "float" to 0.1, not 0.1 exactly). To create an
        /// arbitrary-precision decimal number from a decimal value, use
        /// FromString instead in most cases (for example:
        /// <c>EDecimal.FromString("0.1")</c> ).</summary>
        /// <param name='flt'>The parameter <paramref name='flt'/> is a 32-bit
        /// binary floating-point number.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as <paramref name='flt'/>.</returns>
        public static EDecimal FromSingle(float flt)
        {
            int value = BitConverter.ToInt32(BitConverter.GetBytes((float)flt), 0);
            return FromSingleBits(value);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 32-bit binary floating-point number encoded in the IEEE 754
        /// binary32 format. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the floating point number to a string first.
        /// Remember, though, that the exact value of a 32-bit binary
        /// floating-point number is not always the value that results when
        /// passing a literal decimal number, since not all decimal numbers can
        /// be converted to exact binary numbers (in the example given, the
        /// resulting arbitrary-precision decimal will be the the value of the
        /// closest "float" to 0.1, not 0.1 exactly). To create an
        /// arbitrary-precision decimal number from a decimal value, use
        /// FromString instead in most cases.</summary>
        /// <param name='value'>A 32-bit binary floating-point number encoded
        /// in the IEEE 754 binary32 format.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as <paramref name='value'/>.</returns>
        public static EDecimal FromSingleBits(int value)
        {
            bool neg = (value >> 31) != 0;
            var floatExponent = (int)((value >> 23) & 0xff);
            int valueFpMantissa = value & 0x7fffff;
            if (floatExponent == 255)
            {
                if (valueFpMantissa == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (valueFpMantissa & 0x400000) != 0;
                valueFpMantissa &= 0x3fffff;
                value = (neg ? BigNumberFlags.FlagNegative : 0) |
                  (quiet ? BigNumberFlags.FlagQuietNaN :
                    BigNumberFlags.FlagSignalingNaN);
                return valueFpMantissa == 0 ? (quiet ? NaN : SignalingNaN) :
                  new EDecimal(
                    FastIntegerFixed.FromInt32(valueFpMantissa),
                    FastIntegerFixed.Zero,
                    (byte)value);
            }
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                valueFpMantissa |= 1 << 23;
            }
            if (valueFpMantissa == 0)
            {
                return neg ? EDecimal.NegativeZero : EDecimal.Zero;
            }
            floatExponent -= 150;
            while ((valueFpMantissa & 1) == 0)
            {
                ++floatExponent;
                valueFpMantissa >>= 1;
            }
            if (floatExponent == 0)
            {
                if (neg)
                {
                    valueFpMantissa = -valueFpMantissa;
                }
                return EDecimal.FromInt64(valueFpMantissa);
            }
            if (floatExponent > 0)
            {
                // Value is an integer
                var bigmantissa = (EInteger)valueFpMantissa;
                bigmantissa <<= floatExponent;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.FromEInteger(bigmantissa);
            }
            else
            {
                // Value has a fractional part
                var bigmantissa = (EInteger)valueFpMantissa;
                EInteger bigexponent = NumberUtility.FindPowerOfFive(-floatExponent);
                bigmantissa *= (EInteger)bigexponent;
                if (neg)
                {
                    bigmantissa = -(EInteger)bigmantissa;
                }
                return EDecimal.Create(bigmantissa, (EInteger)floatExponent);
            }
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// sequence of <c>char</c> s that represents a number. See
        /// <c>FromString(String, int, int, EContext)</c> for more information.
        /// Note that calling the overload that takes an EContext is often much
        /// faster than creating the EDecimal then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</summary>
        /// <param name='chars'>A sequence that represents a number.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of <c>char</c> s.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='chars'/> is not a correctly formatted number
        /// sequence.</exception>
        public static EDecimal FromString(char[] chars)
        {
            return FromString(chars, 0, chars == null ? 0 : chars.Length, null);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// sequence of <c>char</c> s that represents a number. See
        /// <c>FromString(String, int, int, EContext)</c> for more
        /// information.</summary>
        /// <param name='chars'>A sequence of <c>char</c> s that represents a
        /// number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. Note that providing a context is often much faster
        /// than creating the EDecimal without a context then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of <c>char</c> s.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        public static EDecimal FromString(char[] chars, EContext ctx)
        {
            return FromString(chars, 0, chars == null ? 0 : chars.Length, ctx);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// sequence of <c>char</c> s that represents a number. See
        /// <c>FromString(String, int, int, EContext)</c> for more information.
        /// Note that calling the overload that takes an EContext is often much
        /// faster than creating the EDecimal then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</summary>
        /// <param name='chars'>A sequence that represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='chars'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='chars'/> (but not more than <paramref
        /// name='chars'/> 's length).</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of <c>char</c> s.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='chars'/> is not a correctly formatted number
        /// sequence.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='chars'/> 's length, or <paramref
        /// name='chars'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EDecimal FromString(
          char[] chars,
          int offset,
          int length)
        {
            return FromString(chars, offset, length, null);
        }

        /// <summary>
        /// <para>Creates an arbitrary-precision decimal number from a sequence
        /// of <c>char</c> s that represents a number.</para>
        /// <para>The format of the sequence generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if the minus sign, the value is negative.)</item>
        /// <item>One or more digits, with a single optional decimal point
        /// (".", U+002E) before or after those digits or between two of them.
        /// These digits may begin with any number of zeros.</item>
        /// <item>Optionally, "E"/"e" followed by an optional (positive
        /// exponent) or "-" (negative exponent) and followed by one or more
        /// digits specifying the exponent (these digits may begin with any
        /// number of zeros).</item></list>
        /// <para>The sequence can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits
        /// (these digits may begin with any number of zeros), or signaling NaN
        /// ("sNaN" /"-sNaN") followed by any number of digits (these digits
        /// may begin with any number of zeros), all where the letters can be
        /// any combination of basic upper-case and/or basic lower-case
        /// letters.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='chars'>A sequence of <c>char</c> s, a portion of which
        /// represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='chars'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='chars'/> (but not more than <paramref
        /// name='chars'/> 's length).</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. Note that providing a context is often much faster
        /// than creating the EDecimal without a context then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of <c>char</c> s.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='chars'/> 's length, or <paramref
        /// name='chars'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EDecimal FromString(
          char[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            return EDecimalCharArrayString.FromString(chars, offset, length, ctx);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// sequence of bytes (interpreted as text) that represents a number.
        /// See <c>FromString(String, int, int, EContext)</c> for more
        /// information. Note that calling the overload that takes an EContext
        /// is often much faster than creating the EDecimal then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</summary>
        /// <param name='bytes'>A sequence that represents a number.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of bytes (interpreted as text).</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='bytes'/> is not a correctly formatted number
        /// sequence.</exception>
        public static EDecimal FromString(byte[] bytes)
        {
            return FromString(bytes, 0, bytes == null ? 0 : bytes.Length, null);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// sequence of bytes (interpreted as text) that represents a number.
        /// See <c>FromString(String, int, int, EContext)</c> for more
        /// information.</summary>
        /// <param name='bytes'>A sequence of bytes (interpreted as text) that
        /// represents a number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. Note that providing a context is often much faster
        /// than creating the EDecimal without a context then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of bytes (interpreted as text).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        public static EDecimal FromString(byte[] bytes, EContext ctx)
        {
            return FromString(bytes, 0, bytes == null ? 0 : bytes.Length, ctx);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// sequence of bytes (interpreted as text) that represents a number.
        /// See <c>FromString(String, int, int, EContext)</c> for more
        /// information. Note that calling the overload that takes an EContext
        /// is often much faster than creating the EDecimal then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</summary>
        /// <param name='bytes'>A sequence that represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='bytes'/> begins.</param>
        /// <param name='length'>The length, in bytes, of the desired portion
        /// of <paramref name='bytes'/> (but not more than <paramref
        /// name='bytes'/> 's length).</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of bytes (interpreted as text).</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='bytes'/> is not a correctly formatted number
        /// sequence.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='bytes'/> 's length, or <paramref
        /// name='bytes'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EDecimal FromString(
          byte[] bytes,
          int offset,
          int length)
        {
            return FromString(bytes, offset, length, null);
        }

        /// <summary>
        /// <para>Creates an arbitrary-precision decimal number from a sequence
        /// of bytes (interpreted as text) that represents a number. Each byte
        /// in the sequence has to be a code point in the Basic Latin range
        /// (0x00 to 0x7f or U+0000 to U+007F) of the Unicode Standard.</para>
        /// <para>The format of the sequence generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if the minus sign, the value is negative.)</item>
        /// <item>One or more digits, with a single optional decimal point
        /// (".", U+002E) before or after those digits or between two of them.
        /// These digits may begin with any number of zeros.</item>
        /// <item>Optionally, "E"/"e" followed by an optional (positive
        /// exponent) or "-" (negative exponent) and followed by one or more
        /// digits specifying the exponent (these digits may begin with any
        /// number of zeros).</item></list>
        /// <para>The sequence can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits
        /// (these digits may begin with any number of zeros), or signaling NaN
        /// ("sNaN" /"-sNaN") followed by any number of digits (these digits
        /// may begin with any number of zeros), all where the letters can be
        /// any combination of basic upper-case and/or basic lower-case
        /// letters.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='bytes'>A sequence of bytes (interpreted as text), a
        /// portion of which represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='bytes'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='bytes'/> (but not more than <paramref
        /// name='bytes'/> 's length).</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. Note that providing a context is often much faster
        /// than creating the EDecimal without a context then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given sequence of bytes (interpreted as text).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='bytes'/> 's length, or <paramref
        /// name='bytes'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EDecimal FromString(
          byte[] bytes,
          int offset,
          int length,
          EContext ctx)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            return EDecimalByteArrayString.FromString(bytes, offset, length, ctx);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a text
        /// string that represents a number. See <c>FromString(String, int,
        /// int, EContext)</c> for more information. Note that calling the
        /// overload that takes an EContext is often much faster than creating
        /// the EDecimal then calling <c>RoundToPrecision</c> on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</summary>
        /// <param name='str'>A string that represents a number.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given string.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='str'/> is not a correctly formatted number
        /// string.</exception>
        public static EDecimal FromString(string str)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, null);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a text
        /// string that represents a number. See <c>FromString(String, int,
        /// int, EContext)</c> for more information.</summary>
        /// <param name='str'>A string that represents a number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. Note that providing a context is often much faster
        /// than creating the EDecimal without a context then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given string.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        public static EDecimal FromString(string str, EContext ctx)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, ctx);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a text
        /// string that represents a number. See <c>FromString(String, int,
        /// int, EContext)</c> for more information. Note that calling the
        /// overload that takes an EContext is often much faster than creating
        /// the EDecimal then calling <c>RoundToPrecision</c> on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</summary>
        /// <param name='str'>A string that represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='str'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='str'/> (but not more than <paramref
        /// name='str'/> 's length).</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given string.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='str'/> is not a correctly formatted number
        /// string.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='str'/> 's length, or <paramref
        /// name='str'/> 's length minus <paramref name='offset'/> is less than
        /// <paramref name='length'/>.</exception>
        public static EDecimal FromString(
          string str,
          int offset,
          int length)
        {
            return FromString(str, offset, length, null);
        }

        /// <summary>
        /// <para>Creates an arbitrary-precision decimal number from a text
        /// string that represents a number.</para>
        /// <para>The format of the string generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if the minus sign, the value is negative.)</item>
        /// <item>One or more digits, with a single optional decimal point
        /// (".", U+002E) before or after those digits or between two of them.
        /// These digits may begin with any number of zeros.</item>
        /// <item>Optionally, "E"/"e" followed by an optional (positive
        /// exponent) or "-" (negative exponent) and followed by one or more
        /// digits specifying the exponent (these digits may begin with any
        /// number of zeros).</item></list>
        /// <para>The string can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits
        /// (these digits may begin with any number of zeros), or signaling NaN
        /// ("sNaN" /"-sNaN") followed by any number of digits (these digits
        /// may begin with any number of zeros), all where the letters can be
        /// any combination of basic upper-case and/or basic lower-case
        /// letters.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='str'>A text string, a portion of which represents a
        /// number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='str'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='str'/> (but not more than <paramref
        /// name='str'/> 's length).</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. Note that providing a context is often much faster
        /// than creating the EDecimal without a context then calling
        /// <c>RoundToPrecision</c> on that EDecimal, especially if the context
        /// specifies a precision limit and exponent range.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as the given string.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='str'/> 's length, or <paramref
        /// name='str'/> 's length minus <paramref name='offset'/> is less than
        /// <paramref name='length'/>.</exception>
        public static EDecimal FromString(
          string str,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return EDecimalTextString.FromString(str, offset, length, ctx);
        }

        internal static EDecimal SignalUnderflow(EContext ec, bool negative, bool
          zeroSignificand)
        {
            EInteger eTiny = ec.EMin.Subtract(ec.Precision.Subtract(1));
            eTiny = eTiny.Subtract(2); // subtract 2 from proper eTiny to
                                       // trigger underflow (2, rather than 1, because of HalfUp mode)
            EDecimal ret = EDecimal.Create(
                zeroSignificand ? EInteger.Zero : EInteger.One,
                eTiny);
            if (negative)
            {
                ret = ret.Negate();
            }
            return ret.RoundToPrecision(ec);
        }

        internal static EDecimal SignalOverflow(EContext ec, bool negative, bool
          zeroSignificand)
        {
            if (zeroSignificand)
            {
                EDecimal ret = EDecimal.Create(EInteger.Zero, ec.EMax);
                if (negative)
                {
                    ret = ret.Negate();
                }
                return ret.RoundToPrecision(ec);
            }
            else
            {
                return GetMathValue(ec).SignalOverflow(ec, negative);
            }
        }

        // 1 = Overflow; 2 = Underflow, adjust significand to 1; 0 = None;
        // 3 = Underflow, adjust significant to have precision
        internal static int CheckOverflowUnderflow(
          EContext ec,
          int precisionInt,
          EInteger exponent)
        {
            // NOTE: precisionInt is an Int32 because the maximum supported
            // length of a string fits in an Int32
            // NOTE: Not guaranteed to catch all overflows or underflows.
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (precisionInt < 0)
            {
                throw new ArgumentException("doesn't satisfy precision.Sign>= 0");
            }
            // "Precision" is the number of digits in a number starting with
            // the first nonzero digit
            if (ec == null || !ec.HasExponentRange)
            {
                return 0;
            }
            if (ec.AdjustExponent)
            {
                // If precision is in bits, this is too difficult to determine,
                // so ignore precision
                if (ec.IsPrecisionInBits)
                {
                    if (exponent.CompareTo(ec.EMax) > 0)
                    {
                        return 1; // Overflow
                    }
                }
                else
                {
                    EInteger adjExponent = exponent.Add(precisionInt).Subtract(1);
                    if (adjExponent.CompareTo(ec.EMax) > 0)
                    {
                        return 1; // Overflow
                    }
                    if (ec.HasMaxPrecision)
                    {
                        EInteger etiny = ec.EMin.Subtract(ec.Precision.Subtract(1));
                        etiny = etiny.Subtract(1); // Buffer in case of rounding
                                                   // DebugUtility.Log("adj: adjexp=" + adjExponent + " exp=" + exponent + "
                                                   // etiny="+etiny);
                        if (adjExponent.CompareTo(etiny) < 0)
                        {
                            return 2; // Underflow to zero
                        }
                    }
                    else
                    {
                        EInteger etiny = ec.EMin.Subtract(precisionInt - 1);
                        etiny = etiny.Subtract(1); // Buffer in case of rounding
                                                   // DebugUtility.Log("adj: adjexp=" + adjExponent + " exp=" + exponent + "
                                                   // etiny="+etiny);
                        if (adjExponent.CompareTo(etiny) < 0)
                        {
                            return 3; // Underflow to zero
                        }
                    }
                }
            }
            else
            {
                // Exponent range is independent of precision
                if (exponent.CompareTo(ec.EMax) > 0)
                {
                    return 1; // Overflow
                }
                if (!ec.IsPrecisionInBits)
                {
                    EInteger adjExponent = exponent.Add(precisionInt).Subtract(1);
                    EInteger etiny = ec.HasMaxPrecision ?
                      ec.EMin.Subtract(ec.Precision.Subtract(1)) :
                      ec.EMin.Subtract(precisionInt - 1);
                    etiny = etiny.Subtract(1); // Buffer in case of rounding
                                               // DebugUtility.Log("noadj: adjexp=" + adjExponent + " exp=" + exponent + "
                                               // etiny="+etiny);
                    if (adjExponent.CompareTo(etiny) < 0)
                    {
                        return 2; // Underflow to zero
                    }
                }
            }
            return 0;
        }

        /// <summary>Gets the greater value between two decimal
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The larger value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the positive zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the larger exponent. If the two numbers are negative and
        /// have the same value, returns the one with the smaller
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal Max(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return GetMathValue(ctx).Max(first, second, ctx);
        }

        /// <summary>Gets the greater value between two decimal
        /// numbers.</summary>
        /// <param name='first'>An arbitrary-precision decimal number.</param>
        /// <param name='second'>Another arbitrary-precision decimal
        /// number.</param>
        /// <returns>The larger value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the positive zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the larger exponent. If the two numbers are negative and
        /// have the same value, returns the one with the smaller
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal Max(
          EDecimal first,
          EDecimal second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return Max(first, second, null);
        }

        /// <summary>Gets the greater value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Max.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The larger value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal MaxMagnitude(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return GetMathValue(ctx).MaxMagnitude(first, second, ctx);
        }

        /// <summary>Gets the greater value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Max.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The larger value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal MaxMagnitude(
          EDecimal first,
          EDecimal second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MaxMagnitude(first, second, null);
        }

        /// <summary>Gets the lesser value between two decimal
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The smaller value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the negative zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the smaller exponent. If the two numbers are negative and
        /// have the same value, returns the one with the larger
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal Min(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return GetMathValue(ctx).Min(first, second, ctx);
        }

        /// <summary>Gets the lesser value between two decimal
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The smaller value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the negative zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the smaller exponent. If the two numbers are negative and
        /// have the same value, returns the one with the larger
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal Min(
          EDecimal first,
          EDecimal second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return Min(first, second, null);
        }

        /// <summary>Gets the lesser value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Min.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The smaller value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal MinMagnitude(
          EDecimal first,
          EDecimal second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return GetMathValue(ctx).MinMagnitude(first, second, ctx);
        }

        /// <summary>Gets the lesser value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Min.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The smaller value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EDecimal MinMagnitude(
          EDecimal first,
          EDecimal second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MinMagnitude(first, second, null);
        }

        /// <summary>Finds the constant π, the circumference of a circle
        /// divided by its diameter.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as π can never be represented
        /// exactly.</i>.</param>
        /// <returns>The constant π rounded to the given precision. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public static EDecimal PI(EContext ctx)
        {
            return GetMathValue(ctx).Pi(ctx);
        }

        /// <summary>Finds the absolute value of this object (if it's negative,
        /// it becomes positive).</summary>
        /// <returns>An arbitrary-precision decimal number. Returns signaling
        /// NaN if this value is signaling NaN. (In this sense, this method is
        /// similar to the "copy-abs" operation in the General Decimal
        /// Arithmetic Specification, except this method does not necessarily
        /// return a copy of this object.).</returns>
        public EDecimal Abs()
        {
            if (this.IsNegative)
            {
                var er = new EDecimal(
                  this.unsignedMantissa,
                  this.exponent,
                  (byte)(this.flags & ~BigNumberFlags.FlagNegative));
                return er;
            }
            return this;
        }

        /// <summary>Returns a number with the same value as this one, but
        /// copying the sign (positive or negative) of another number. (This
        /// method is similar to the "copy-sign" operation in the General
        /// Decimal Arithmetic Specification, except this method does not
        /// necessarily return a copy of this object.).</summary>
        /// <param name='other'>A number whose sign will be copied.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='other'/> is null.</exception>
        public EDecimal CopySign(EDecimal other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.IsNegative)
            {
                return other.IsNegative ? this : this.Negate();
            }
            else
            {
                return other.IsNegative ? this.Negate() : this;
            }
        }

        /// <summary>Finds the absolute value of this object (if it's negative,
        /// it becomes positive).</summary>
        /// <param name='context'>An arithmetic context to control the
        /// precision, rounding, and exponent range of the result. If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the precision is
        /// unlimited and no rounding is needed.</param>
        /// <returns>The absolute value of this object. Signals FlagInvalid and
        /// returns quiet NaN if this value is signaling NaN.</returns>
        public EDecimal Abs(EContext context)
        {
            return ((context == null || context == EContext.UnlimitedHalfEven) ?
                ExtendedMathValue : MathValue).Abs(this, context);
        }

        /// <summary>Adds this arbitrary-precision decimal floating-point
        /// number and another arbitrary-precision decimal floating-point
        /// number and returns the result. The exponent for the result is the
        /// lower of this arbitrary-precision decimal floating-point number's
        /// exponent and the other arbitrary-precision decimal floating-point
        /// number's exponent.</summary>
        /// <param name='otherValue'>An arbitrary-precision decimal
        /// number.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number plus another
        /// arbitrary-precision decimal floating-point number. If this
        /// arbitrary-precision decimal floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        public EDecimal Add(EDecimal otherValue)
        {
            if (this.IsFinite && otherValue != null && otherValue.IsFinite &&
              ((this.flags | otherValue.flags) & BigNumberFlags.FlagNegative) == 0 &&
              this.exponent.CompareTo(otherValue.exponent) == 0)
            {
                FastIntegerFixed result = FastIntegerFixed.Add(
                    this.unsignedMantissa,
                    otherValue.unsignedMantissa);
                return new EDecimal(result, this.exponent, (byte)0);
            }
            return this.Add(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <summary>Adds this arbitrary-precision decimal floating-point
        /// number and another arbitrary-precision decimal floating-point
        /// number and returns the result.</summary>
        /// <param name='otherValue'>The number to add to.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number plus another
        /// arbitrary-precision decimal floating-point number. If this
        /// arbitrary-precision decimal floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        public EDecimal Add(
          EDecimal otherValue,
          EContext ctx)
        {
            return GetMathValue(ctx).Add(this, otherValue, ctx);
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='other'>An arbitrary-precision decimal number.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value or if <paramref name='other'/> is null, or 0 if both
        /// values are equal.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareTo(EDecimal other)
        {
            return this.CompareToValue(other);
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareTo(int intOther)
        {
            return this.CompareToValue(EDecimal.FromInt32(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object is a quiet NaN or signaling NaN, this method
        /// will not trigger an error. Instead, NaN will compare greater than
        /// any other number, including infinity.</para></summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareToValue(int intOther)
        {
            return this.CompareToValue(EDecimal.FromInt32(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 64-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareTo(long intOther)
        {
            return this.CompareToValue(EDecimal.FromInt64(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object is a quiet NaN or signaling NaN, this method
        /// will not trigger an error. Instead, NaN will compare greater than
        /// any other number, including infinity.</para></summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 64-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareToValue(long intOther)
        {
            return this.CompareToValue(EDecimal.FromInt64(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object or the other object is a quiet NaN or
        /// signaling NaN, this method will not trigger an error. Instead, NaN
        /// will compare greater than any other number, including infinity. Two
        /// different NaN values will be considered equal.</para></summary>
        /// <param name='other'>An arbitrary-precision decimal number.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value or if <paramref name='other'/> is null, or 0 if both
        /// values are equal.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToValue(EDecimal other)
        {
            return ExtendedMathValue.CompareTo(this, other);
        }

        /// <summary>Compares an arbitrary-precision binary floating-point
        /// number with this instance.</summary>
        /// <param name='other'>The other object to compare. Can be
        /// null.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less; or a positive number if this instance is greater.
        /// Returns 0 if both values are NaN (even signaling NaN) and 1 if this
        /// value is NaN (even signaling NaN) and the other isn't, or if the
        /// other value is null.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToBinary(EFloat other)
        {
            return CompareEDecimalToEFloat(this, other);
        }
        private static int CompareEDecimalToEFloat(EDecimal ed, EFloat ef)
        {
            if (ef == null)
            {
                return 1;
            }
            if (ed.IsNaN())
            {
                return ef.IsNaN() ? 0 : 1;
            }
            int signA = ed.Sign;
            int signB = ef.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (ed.IsInfinity())
            {
                if (ef.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return ed.IsNegative ? -1 : 1;
            }
            if (ef.IsInfinity())
            {
                return ef.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!ed.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy this.IsFinite");
            }
            if (!ef.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy other.IsFinite");
            }
#endif
            // DebugUtility.Log("efexp=" + ef.Exponent);
            if (ef.Exponent.CompareTo((EInteger)(-1000)) < 0)
            {
                // For very low exponents (less than -1000), the conversion to
                // decimal can take very long, so try this approach
                if (ef.Abs(null).CompareTo(EFloat.One) < 0)
                {
                    // Abs less than 1
                    if (ed.Abs(null).CompareTo(EDecimal.One) >= 0)
                    {
                        // Abs 1 or more
                        return (signA > 0) ? 1 : -1;
                    }
                }
                // DebugUtility.Log("edexp=" + ed.Exponent + ", efexp=" +
                // ef.Exponent);
                EInteger bitCount = ef.Mantissa.GetUnsignedBitLengthAsEInteger();
                EInteger absexp = ef.Exponent.Abs();
                if (absexp.CompareTo(bitCount) > 0)
                {
                    // Float's absolute value is less than 1, so do a trial comparison
                    // using a different EFloat with the same significand but
                    // with an exponent changed to be closer to 0
                    EFloat trial = EFloat.Create(ef.Mantissa, EInteger.FromInt32(
                          -1000));
                    int trialcmp = CompareEDecimalToEFloat(ed, trial);
                    // DebugUtility.Log("trialcmp result="+trialcmp);
                    if (ef.Sign < 0 && trialcmp < 0)
                    {
                        // if float and decimal are negative and
                        // decimal is less than trial float (which in turn is
                        // less than the actual float), then the decimal is
                        // less than the actual float
                        return -1;
                    }
                    if (ef.Sign > 0 && trialcmp > 0)
                    {
                        // if float and decimal are positive and
                        // decimal is greater than trial float (which in turn is
                        // greater than the actual float), then the decimal is
                        // greater than the actual float
                        return 1;
                    }
                }
                EInteger[] thisAdjExpBounds = GetAdjustedExponentDecimalBounds(ed);
                EInteger otherAdjExp = GetAdjustedExponentBinary(ef);
                // DebugUtility.Log("taexp=" + thisAdjExp + ", oaexp=" + otherAdjExp);
                // DebugUtility.Log("td=" + ed.ToDouble() + ", tf=" + ef.ToDouble());
                if (thisAdjExpBounds[0].Sign < 0 &&
                  thisAdjExpBounds[0].CompareTo(-1000) >= 0 &&
                  otherAdjExp.CompareTo(-4000) < 0)
                {
                    // With these exponent combinations, the binary's absolute
                    // value is less than the decimal's
                    return (signA > 0) ? 1 : -1;
                }
                if (thisAdjExpBounds[1].Sign < 0 &&
                  thisAdjExpBounds[1].CompareTo(-1000) < 0 &&
                  otherAdjExp.CompareTo(-1000) < 0)
                {
                    // Check the ratio of the negative binary exponent to
                    // the negative decimal exponent.
                    // If the ratio times 1000, rounded down, is less than 3321, the
                    // binary's absolute value is
                    // greater. If it's greater than 3322, the decimal's absolute value is
                    // greater.
                    // (If the two absolute values are equal, the ratio will approach
                    // ln(10)/ln(2), or about 3.32193, as the exponents get higher and
                    // higher.) If it's 3321 to 3322, the two numbers being compared may or may
                    // not be equal. This check assumes that both exponents are less than
                    // -1000, when the ratio between exponents of equal values is
                    // close to ln(10)/ln(2).
                    EInteger ratio;
                    EInteger adjexp;
                    EInteger divisor1 = thisAdjExpBounds[0].Add(1).Abs();
                    EInteger divisor2 = thisAdjExpBounds[1].Add(1).Abs();
                    otherAdjExp = otherAdjExp.Add(1).Abs();
                    adjexp = EInteger.Min(divisor1, divisor2);
                    ratio = otherAdjExp.Multiply(1000).Divide(adjexp);
                    // DebugUtility.Log("taexp=" + adjexp + ", oaexp=" +
                    // otherAdjExp + " ratio=" + ratio);
                    if (ratio.CompareTo(3321) < 0)
                    {
                        // Binary abs. value is greater
                        return (signA > 0) ? -1 : 1;
                    }
                    adjexp = EInteger.Max(divisor1, divisor2);
                    ratio = otherAdjExp.Multiply(1000).Divide(adjexp);
                    if (ratio.CompareTo(3322) > 0)
                    {
                        return (signA > 0) ? 1 : -1;
                    }
                }
            }
            if (ef.Exponent.CompareTo(1000) > 0)
            {
                // Very high exponents
                EInteger bignum = EInteger.One.ShiftLeft(999);
                if (ed.Abs(null).CompareToValue(EDecimal.FromEInteger(bignum)) <=
                  0)
                {
                    // this object's absolute value is less
                    return (signA > 0) ? -1 : 1;
                }
                // NOTE: The following check assumes that both
                // operands are nonzero
                EInteger[] thisAdjExpBounds = GetAdjustedExponentDecimalBounds(ed);
                EInteger otherAdjExp = GetAdjustedExponentBinary(ef);
                if (thisAdjExpBounds[0].Sign > 0 &&
                  thisAdjExpBounds[0].CompareTo(otherAdjExp) >= 0)
                {
                    // This object's adjusted exponent lower bound
                    // is greater and is positive;
                    // so this (decimal) object's absolute value is greater,
                    // since exponents have a greater value in decimal than in binary
                    return (signA > 0) ? 1 : -1;
                }
                if (thisAdjExpBounds[1].Sign > 0 &&
                  thisAdjExpBounds[1].CompareTo(1000) < 0 &&
                  otherAdjExp.CompareTo(4000) >= 0)
                {
                    // With these exponent combinations (using the adjusted exponent
                    // upper bound), the binary's absolute
                    // value is greater than the decimal's
                    return (signA > 0) ? -1 : 1;
                }
                if (thisAdjExpBounds[0].Sign > 0 &&
                  thisAdjExpBounds[0].CompareTo(1000) >= 0 &&
                  otherAdjExp.CompareTo(1000) >= 0)
                {
                    // Check the ratio of the binary exponent to the decimal exponent.
                    // If the ratio times 1000, rounded down, is less than 3321, the
                    // decimal's absolute value is
                    // greater. If it's 3322 or greater, the binary's absolute value is
                    // greater.
                    // (If the two absolute values are equal, the ratio will approach
                    // ln(10)/ln(2), or about 3.32193, as the exponents get higher and
                    // higher.) This check assumes that both exponents are 1000 or
                    // greater, when the ratio between exponents of equal values is
                    // close to ln(10)/ln(2).
                    EInteger ratio;
                    EInteger adjexp;
                    EInteger divisor1 = thisAdjExpBounds[0].Add(1);
                    EInteger divisor2 = thisAdjExpBounds[1].Add(1);
                    otherAdjExp = otherAdjExp.Add(1);
                    adjexp = EInteger.Min(divisor1, divisor2);
                    ratio = otherAdjExp.Multiply(1000).Divide(adjexp);
                    if (ratio.CompareTo(3321) < 0)
                    {
                        // Decimal abs. value is greater
                        return (signA > 0) ? 1 : -1;
                    }
                    adjexp = EInteger.Max(divisor1, divisor2);
                    ratio = otherAdjExp.Multiply(1000).Divide(adjexp);
                    if (ratio.CompareTo(3322) >= 0)
                    {
                        return (signA > 0) ? -1 : 1;
                    }
                }
            }
            EDecimal otherDec = EDecimal.FromEFloat(ef);
            /* DebugUtility.Log("Traditional compare");
            DebugUtility.Log("ef="+ef);
            string ed0=""+ed;
            string od0=""+otherDec;
            if (!ed0.Equals(od0)) {
              DebugUtility.Log("ed="+ed0);
              DebugUtility.Log("od="+od0);
            }
            */
            return ed.CompareTo(otherDec);
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, treating quiet NaN as signaling.
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object or the other object is a quiet NaN or
        /// signaling NaN, this method will return a quiet NaN and will signal
        /// a FlagInvalid flag.</para></summary>
        /// <param name='other'>An arbitrary-precision decimal number.</param>
        /// <param name='ctx'>An arithmetic context. The precision, rounding,
        /// and exponent range are ignored. If <c>HasFlags</c> of the context
        /// is true, will store the flags resulting from the operation (the
        /// flags are in addition to the pre-existing flags). Can be
        /// null.</param>
        /// <returns>Quiet NaN if this object or the other object is NaN, or 0
        /// if both objects have the same value, or -1 if this object is less
        /// than the other value, or a 1 if this object is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public EDecimal CompareToSignal(
          EDecimal other,
          EContext ctx)
        {
            return GetMathValue(ctx).CompareToWithContext(this, other, true, ctx);
        }

        /// <summary>Compares the absolute values of this object and another
        /// object, imposing a total ordering on all possible values (ignoring
        /// their signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero and positive zero are considered equal.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item></list></summary>
        /// <param name='other'>An arbitrary-precision decimal number to
        /// compare with this one.</param>
        /// <returns>The number 0 if both objects have the same value (ignoring
        /// their signs), or -1 if this object is less than the other value
        /// (ignoring their signs), or 1 if this object is greater (ignoring
        /// their signs).
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotalMagnitude(EDecimal other)
        {
            if (other == null)
            {
                return 1;
            }
            var valueIThis = 0;
            var valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return 1;
            }
            else if (valueIThis < valueIOther)
            {
                return -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                    other.unsignedMantissa);
                return cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.Abs().CompareTo(other.Abs());
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                        other.exponent);
                    return cmp;
                }
                return cmp;
            }
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision decimal number to
        /// compare with this one.</param>
        /// <param name='ctx'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater. Does not signal flags if either value is signaling NaN.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotal(EDecimal other, EContext ctx)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsSignalingNaN() || other.IsSignalingNaN())
            {
                return this.CompareToTotal(other);
            }
            if (ctx != null && ctx.IsSimplified)
            {
                return this.RoundToPrecision(ctx)
                  .CompareToTotal(other.RoundToPrecision(ctx));
            }
            else
            {
                return this.CompareToTotal(other);
            }
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values (ignoring their
        /// signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision decimal number to
        /// compare with this one.</param>
        /// <param name='ctx'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects have the same value (ignoring
        /// their signs), or -1 if this object is less than the other value
        /// (ignoring their signs), or 1 if this object is greater (ignoring
        /// their signs). Does not signal flags if either value is signaling
        /// NaN.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotalMagnitude(EDecimal other, EContext ctx)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsSignalingNaN() || other.IsSignalingNaN())
            {
                return this.CompareToTotalMagnitude(other);
            }
            if (ctx != null && ctx.IsSimplified)
            {
                return this.RoundToPrecision(ctx)
                  .CompareToTotalMagnitude(other.RoundToPrecision(ctx));
            }
            else
            {
                return this.CompareToTotalMagnitude(other);
            }
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision decimal number to
        /// compare with this one.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotal(EDecimal other)
        {
            if (other == null)
            {
                return -1;
            }
            bool neg1 = this.IsNegative;
            bool neg2 = other.IsNegative;
            if (neg1 != neg2)
            {
                return neg1 ? -1 : 1;
            }
            var valueIThis = 0;
            var valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return neg1 ? -1 : 1;
            }
            else if (valueIThis < valueIOther)
            {
                return neg1 ? 1 : -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                    other.unsignedMantissa);
                return neg1 ? -cmp : cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.CompareTo(other);
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                        other.exponent);
                    return neg1 ? -cmp : cmp;
                }
                return cmp;
            }
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object.
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object or the other object is a quiet NaN or
        /// signaling NaN, this method returns a quiet NaN, and will signal a
        /// FlagInvalid flag if either is a signaling NaN.</para></summary>
        /// <param name='other'>An arbitrary-precision decimal number.</param>
        /// <param name='ctx'>An arithmetic context. The precision, rounding,
        /// and exponent range are ignored. If <c>HasFlags</c> of the context
        /// is true, will store the flags resulting from the operation (the
        /// flags are in addition to the pre-existing flags). Can be
        /// null.</param>
        /// <returns>Quiet NaN if this object or the other object is NaN, or 0
        /// if both objects have the same value, or -1 if this object is less
        /// than the other value, or 1 if this object is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public EDecimal CompareToWithContext(
          EDecimal other,
          EContext ctx)
        {
            return GetMathValue(ctx).CompareToWithContext(this, other, false, ctx);
        }

        /// <summary>Divides this arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns the result; returns NaN instead if the result would
        /// have a nonterminating decimal expansion (including 1/3, 1/12, 1/7,
        /// 2/3, and so on); if this is not desired, use DivideToExponent, or
        /// use the Divide overload that takes an EContext.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The result of dividing this arbitrary-precision decimal
        /// floating-point number by another arbitrary-precision decimal
        /// floating-point number. Returns infinity if the divisor (this
        /// arbitrary-precision decimal floating-point number) is 0 and the
        /// dividend (the other arbitrary-precision decimal floating-point
        /// number) is nonzero. Returns not-a-number (NaN) if the divisor and
        /// the dividend are 0. Returns NaN if the result can't be exact
        /// because it would have a nonterminating binary expansion (examples
        /// include 1 divided by any multiple of 3, such as 1/3 or 1/12). If
        /// this is not desired, use DivideToExponent instead, or use the
        /// Divide overload that takes an <c>EContext</c> (such as
        /// <c>EContext.Decimal128</c> ) instead.</returns>
        public EDecimal Divide(EDecimal divisor)
        {
            return this.Divide(
                divisor,
                EContext.ForRounding(ERounding.None));
        }

        /// <summary>Divides this arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The result of dividing this arbitrary-precision decimal
        /// floating-point number by another arbitrary-precision decimal
        /// floating-point number. Signals FlagDivideByZero and returns
        /// infinity if the divisor (this arbitrary-precision decimal
        /// floating-point number) is 0 and the dividend (the other
        /// arbitrary-precision decimal floating-point number) is nonzero.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the divisor
        /// and the dividend are 0; or, either <paramref name='ctx'/> is null
        /// or <paramref name='ctx'/> 's precision is 0, and the result would
        /// have a nonterminating decimal expansion (examples include 1 divided
        /// by any multiple of 3, such as 1/3 or 1/12); or, the rounding mode
        /// is ERounding.None and the result is not exact.</returns>
        public EDecimal Divide(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).Divide(this, divisor, ctx);
        }

        /// <summary>Calculates the quotient and remainder using the
        /// DivideToIntegerNaturalScale and the formula in
        /// RemainderNaturalScale.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>A 2 element array consisting of the quotient and remainder
        /// in that order.</returns>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EDecimal[] DivideAndRemainderNaturalScale(EDecimal
          divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <summary>Calculates the quotient and remainder using the
        /// DivideToIntegerNaturalScale and the formula in
        /// RemainderNaturalScale.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only in the division portion of the remainder
        /// calculation; as a result, it's possible for the remainder to have a
        /// higher precision than given in this context. Flags will be set on
        /// the given context only if the context's <c>HasFlags</c> is true and
        /// the integer part of the division result doesn't fit the precision
        /// and exponent range without rounding. Can be null, in which the
        /// precision is unlimited and no additional rounding, other than the
        /// rounding down to an integer after division, is needed.</param>
        /// <returns>A 2 element array consisting of the quotient and remainder
        /// in that order.</returns>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EDecimal[] DivideAndRemainderNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            return this.DivRemNaturalScale(divisor, ctx);
        }

        /// <summary>Divides this arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns a two-item array containing the result of the division
        /// and the remainder, in that order. The result of division is
        /// calculated as though by <c>DivideToIntegerNaturalScale</c>, and
        /// the remainder is calculated as though by
        /// <c>RemainderNaturalScale</c>.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision decimal floating-point number,
        /// and the second is the remainder as an arbitrary-precision decimal
        /// floating-point number. The result of division is the result of the
        /// method on the two operands, and the remainder is the result of the
        /// Remainder method on the two operands.</returns>
        public EDecimal[] DivRemNaturalScale(EDecimal
          divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <summary>Divides this arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns a two-item array containing the result of the division
        /// and the remainder, in that order. The result of division is
        /// calculated as though by <c>DivideToIntegerNaturalScale</c>, and
        /// the remainder is calculated as though by
        /// <c>RemainderNaturalScale</c>.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only in the division portion of the remainder
        /// calculation; as a result, it's possible for the remainder to have a
        /// higher precision than given in this context. Flags will be set on
        /// the given context only if the context's <c>HasFlags</c> is true and
        /// the integer part of the division result doesn't fit the precision
        /// and exponent range without rounding. Can be null, in which the
        /// precision is unlimited and no additional rounding, other than the
        /// rounding down to an integer after division, is needed.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision decimal floating-point number,
        /// and the second is the remainder as an arbitrary-precision decimal
        /// floating-point number. The result of division is the result of the
        /// method on the two operands, and the remainder is the result of the
        /// Remainder method on the two operands.</returns>
        public EDecimal[] DivRemNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            var result = new EDecimal[2];
            result[0] = this.DivideToIntegerNaturalScale(divisor, null);
            result[1] = this.Subtract(
                result[0].Multiply(divisor, null),
                ctx);
            result[0] = result[0].RoundToPrecision(ctx);
            return result;
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentSmall'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// rounding mode to use if the result must be scaled down to have the
        /// same exponent as this value. If the precision given in the context
        /// is other than 0, calls the Quantize method with both arguments
        /// equal to the result of the operation (and can signal FlagInvalid
        /// and return NaN if the result doesn't fit the given precision). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the context defines an exponent range and the
        /// desired exponent is outside that range. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the rounding mode is ERounding.None
        /// and the result is not exact.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          long desiredExponentSmall,
          EContext ctx)
        {
            return this.DivideToExponent(
                divisor,
                (EInteger)desiredExponentSmall,
                ctx);
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent (expressed as a 32-bit signed integer) to the
        /// result, using the half-even rounding mode.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentInt'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// rounding mode to use if the result must be scaled down to have the
        /// same exponent as this value. If the precision given in the context
        /// is other than 0, calls the Quantize method with both arguments
        /// equal to the result of the operation (and can signal FlagInvalid
        /// and return NaN if the result doesn't fit the given precision). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the context defines an exponent range and the
        /// desired exponent is outside that range. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the rounding mode is ERounding.None
        /// and the result is not exact.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          int desiredExponentInt,
          EContext ctx)
        {
            return this.DivideToExponent(
                divisor,
                (EInteger)desiredExponentInt,
                ctx);
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentSmall'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          long desiredExponentSmall,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                (EInteger)desiredExponentSmall,
                EContext.ForRounding(rounding));
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent (expressed as a 32-bit signed integer) to the
        /// result, using the half-even rounding mode.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentInt'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          int desiredExponentInt,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                (EInteger)desiredExponentInt,
                EContext.ForRounding(rounding));
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='exponent'>The desired exponent. A negative number
        /// places the cutoff point to the right of the usual decimal point (so
        /// a negative number means the number of decimal places to round to).
        /// A positive number places the cutoff point to the left of the usual
        /// decimal point.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// rounding mode to use if the result must be scaled down to have the
        /// same exponent as this value. If the precision given in the context
        /// is other than 0, calls the Quantize method with both arguments
        /// equal to the result of the operation (and can signal FlagInvalid
        /// and return NaN if the result doesn't fit the given precision). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the context defines an exponent range and the
        /// desired exponent is outside that range. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the rounding mode is ERounding.None
        /// and the result is not exact.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          EInteger exponent,
          EContext ctx)
        {
            return GetMathValue(ctx).DivideToExponent(this, divisor, exponent, ctx);
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent to the result, using the half-even rounding
        /// mode.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='exponent'>The desired exponent. A negative number
        /// places the cutoff point to the right of the usual decimal point (so
        /// a negative number means the number of decimal places to round to).
        /// A positive number places the cutoff point to the left of the usual
        /// decimal point.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          EInteger exponent)
        {
            return this.DivideToExponent(divisor, exponent, ERounding.HalfEven);
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent (expressed as a 64-bit signed integer) to the
        /// result, using the half-even rounding mode.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentSmall'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          long desiredExponentSmall)
        {
            return this.DivideToExponent(
                divisor,
                desiredExponentSmall,
                ERounding.HalfEven);
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent (expressed as a 32-bit signed integer) to the
        /// result, using the half-even rounding mode.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentInt'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          int desiredExponentInt)
        {
            return this.DivideToExponent(
                divisor,
                desiredExponentInt,
                ERounding.HalfEven);
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and gives
        /// a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponent'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual decimal
        /// point (so a negative number means the number of decimal places to
        /// round to). A positive number places the cutoff point to the left of
        /// the usual decimal point.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Returns not-a-number (NaN) if the divisor and the dividend
        /// are 0. Returns NaN if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EDecimal DivideToExponent(
          EDecimal divisor,
          EInteger desiredExponent,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                desiredExponent,
                EContext.ForRounding(rounding));
        }

        /// <summary>Divides two arbitrary-precision decimal numbers, and
        /// returns the integer part of the result, rounded down, with the
        /// preferred exponent set to this value's exponent minus the divisor's
        /// exponent.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The integer part of the quotient of the two objects.
        /// Signals FlagDivideByZero and returns infinity if the divisor is 0
        /// and the dividend is nonzero. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the divisor and the dividend are 0.</returns>
        public EDecimal DivideToIntegerNaturalScale(EDecimal
          divisor)
        {
            return this.DivideToIntegerNaturalScale(
                divisor,
                EContext.ForRounding(ERounding.Down));
        }

        /// <summary>Divides this object by another object, and returns the
        /// integer part of the result (which is initially rounded down), with
        /// the preferred exponent set to this value's exponent minus the
        /// divisor's exponent.</summary>
        /// <param name='divisor'>The parameter <paramref name='divisor'/> is
        /// an arbitrary-precision decimal floating-point number.</param>
        /// <param name='ctx'>The parameter <paramref name='ctx'/> is an
        /// EContext object.</param>
        /// <returns>The integer part of the quotient of the two objects.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the return
        /// value would overflow the exponent range. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EDecimal DivideToIntegerNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).DivideToIntegerNaturalScale(
                this,
                divisor,
                ctx);
        }

        /// <summary>Divides this object by another object, and returns the
        /// integer part of the result, with the exponent set to 0.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision. The rounding and exponent range settings of this context
        /// are ignored. If <c>HasFlags</c> of the context is true, will also
        /// store the flags resulting from the operation (the flags are in
        /// addition to the pre-existing flags). Can be null, in which case the
        /// precision is unlimited.</param>
        /// <returns>The integer part of the quotient of the two objects. The
        /// exponent will be set to 0. Signals FlagDivideByZero and returns
        /// infinity if the divisor is 0 and the dividend is nonzero. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the divisor and the
        /// dividend are 0, or if the result doesn't fit the given
        /// precision.</returns>
        public EDecimal DivideToIntegerZeroScale(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).DivideToIntegerZeroScale(this, divisor, ctx);
        }

        /// <summary>Divides this object by another decimal number and returns
        /// a result with the same exponent as this object (the
        /// dividend).</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two numbers. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EDecimal DivideToSameExponent(
          EDecimal divisor,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                this.exponent.ToEInteger(),
                EContext.ForRounding(rounding));
        }

        /// <summary>Determines whether this object's significand, exponent,
        /// and properties are equal to those of another object. Not-a-number
        /// values are considered equal if the rest of their properties are
        /// equal.</summary>
        /// <param name='other'>An arbitrary-precision decimal number.</param>
        /// <returns><c>true</c> if this object's significand and exponent are
        /// equal to those of another object; otherwise, <c>false</c>.</returns>
        public bool Equals(EDecimal other)
        {
            return this.EqualsInternal(other);
        }

        /// <summary>Determines whether this object's significand, exponent,
        /// and properties are equal to those of another object and that other
        /// object is an arbitrary-precision decimal number. Not-a-number
        /// values are considered equal if the rest of their properties are
        /// equal.</summary>
        /// <param name='obj'>The parameter <paramref name='obj'/> is an
        /// arbitrary object.</param>
        /// <returns><c>true</c> if the objects are equal; otherwise,
        /// <c>false</c>. In this method, two objects are not equal if they
        /// don't have the same type or if one is null and the other
        /// isn't.</returns>
        public override bool Equals(object obj)
        {
            return this.EqualsInternal(obj as EDecimal);
        }

        /// <summary>Finds e (the base of natural logarithms) raised to the
        /// power of this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the exponential function's
        /// results are generally not exact.</i> (Unlike in the General Decimal
        /// Arithmetic Specification, any rounding mode is allowed.).</param>
        /// <returns>Exponential of this object. If this object's value is 1,
        /// returns an approximation to " e" within the given precision.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public EDecimal Exp(EContext ctx)
        {
            return GetMathValue(ctx).Exp(this, ctx);
        }

        /// <summary>Finds e (the base of natural logarithms) raised to the
        /// power of this object's value, and subtracts the result by 1 and
        /// returns the final result, in a way that avoids loss of precision if
        /// the true result is very close to 0.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the exponential function's
        /// results are generally not exact.</i> (Unlike in the General Binary
        /// Arithmetic Specification, any rounding mode is allowed.).</param>
        /// <returns>Exponential of this object, minus 1. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the parameter <paramref
        /// name='ctx'/> is null or the precision is unlimited (the context's
        /// Precision property is 0).</returns>
        public EDecimal ExpM1(EContext ctx)
        {
            EDecimal value = this;
            if (value.IsNaN())
            {
                return value.Plus(ctx);
            }
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return EDecimal.SignalingNaN.Plus(ctx);
            }
            if (ctx.Traps != 0)
            {
                EContext tctx = ctx.GetNontrapping();
                EDecimal ret = value.ExpM1(tctx);
                return ctx.TriggerTraps(ret, tctx);
            }
            else if (ctx.IsSimplified)
            {
                EContext tmpctx = ctx.WithSimplified(false).WithBlankFlags();
                EDecimal ret = value.PreRound(ctx).ExpM1(tmpctx);
                if (ctx.HasFlags)
                {
                    int flags = ctx.Flags;
                    ctx.Flags = flags | tmpctx.Flags;
                }
                // Console.WriteLine("{0} {1} [{4} {5}] -> {2}
                // [{3}]",value,baseValue,ret,ret.RoundToPrecision(ctx),
                // value.Quantize(value, ctx), baseValue.Quantize(baseValue, ctx));
                return ret.RoundToPrecision(ctx);
            }
            else
            {
                if (value.CompareTo(-1) == 0)
                {
                    return EDecimal.NegativeInfinity;
                }
                else if (value.IsPositiveInfinity())
                {
                    return EDecimal.PositiveInfinity;
                }
                else if (value.IsNegativeInfinity())
                {
                    return EDecimal.FromInt32(-1).Plus(ctx);
                }
                else if (value.CompareTo(0) == 0)
                {
                    return EDecimal.FromInt32(0).Plus(ctx);
                }
                int flags = ctx.Flags;
                EContext tmpctx = null;
                EDecimal ret;
                {
                    EInteger prec = ctx.Precision.Add(3);
                    tmpctx = ctx.WithBigPrecision(prec).WithBlankFlags();
                    if (value.Abs().CompareTo(EDecimal.Create(5, -1)) < 0)
                    {
                        ret = value.Exp(tmpctx).Add(EDecimal.FromInt32(-1), ctx);
                        EDecimal oldret = ret;
                        while (true)
                        {
                            prec = prec.Add(ctx.Precision).Add(3);
                            tmpctx = ctx.WithBigPrecision(prec).WithBlankFlags();
                            ret = value.Exp(tmpctx).Add(EDecimal.FromInt32(-1), ctx);
                            if (ret.CompareTo(0) != 0 && ret.CompareTo(oldret) == 0)
                            {
                                break;
                            }
                            oldret = ret;
                        }
                    }
                    else
                    {
                        ret = value.Exp(tmpctx).Add(EDecimal.FromInt32(-1), ctx);
                    }
                    flags |= tmpctx.Flags;
                }
                if (ctx.HasFlags)
                {
                    flags |= ctx.Flags;
                    ctx.Flags = flags;
                }
                return ret;
            }
        }

        /// <summary>Calculates this object's hash code. No application or
        /// process IDs are used in the hash code calculation.</summary>
        /// <returns>A 32-bit signed integer.</returns>
        public override int GetHashCode()
        {
            var hashCode = 964453631;
            unchecked
            {
                hashCode += 964453723 * this.exponent.GetHashCode();
                hashCode += 964453939 * this.unsignedMantissa.GetHashCode();
                hashCode += 964453967 * this.flags;
            }
            return hashCode;
        }

        /// <summary>Gets a value indicating whether this object is positive or
        /// negative infinity.</summary>
        /// <returns><c>true</c> if this object is positive or negative
        /// infinity; otherwise, <c>false</c>.</returns>
        public bool IsInfinity()
        {
            return (this.flags & BigNumberFlags.FlagInfinity) != 0;
        }

        /// <summary>Gets a value indicating whether this object is not a
        /// number (NaN).</summary>
        /// <returns><c>true</c> if this object is not a number (NaN);
        /// otherwise, <c>false</c>.</returns>
        public bool IsNaN()
        {
            return (this.flags & (BigNumberFlags.FlagQuietNaN |
                  BigNumberFlags.FlagSignalingNaN)) != 0;
        }

        /// <summary>Returns whether this object is negative
        /// infinity.</summary>
        /// <returns><c>true</c> if this object is negative infinity;
        /// otherwise, <c>false</c>.</returns>
        public bool IsNegativeInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNegative)) == (BigNumberFlags.FlagInfinity |
                BigNumberFlags.FlagNegative);
        }

        /// <summary>Returns whether this object is positive
        /// infinity.</summary>
        /// <returns><c>true</c> if this object is positive infinity;
        /// otherwise, <c>false</c>.</returns>
        public bool IsPositiveInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNegative)) == BigNumberFlags.FlagInfinity;
        }

        /// <summary>Gets a value indicating whether this object is a quiet
        /// not-a-number value.</summary>
        /// <returns><c>true</c> if this object is a quiet not-a-number value;
        /// otherwise, <c>false</c>.</returns>
        public bool IsQuietNaN()
        {
            return (this.flags & BigNumberFlags.FlagQuietNaN) != 0;
        }

        /// <summary>Gets a value indicating whether this object is a signaling
        /// not-a-number value.</summary>
        /// <returns><c>true</c> if this object is a signaling not-a-number
        /// value; otherwise, <c>false</c>.</returns>
        public bool IsSignalingNaN()
        {
            return (this.flags & BigNumberFlags.FlagSignalingNaN) != 0;
        }

        /// <summary>Finds the natural logarithm of this object, that is, the
        /// power (exponent) that e (the base of natural logarithms) must be
        /// raised to in order to equal this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the ln function's results are
        /// generally not exact.</i> (Unlike in the General Decimal Arithmetic
        /// Specification, any rounding mode is allowed.).</param>
        /// <returns>Ln(this object). Signals the flag FlagInvalid and returns
        /// NaN if this object is less than 0 (the result would be a complex
        /// number with a real part equal to Ln of this object's absolute value
        /// and an imaginary part equal to pi, but the return value is still
        /// NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null or the precision is
        /// unlimited (the context's Precision property is 0). Signals no flags
        /// and returns negative infinity if this object's value is
        /// 0.</returns>
        public EDecimal Log(EContext ctx)
        {
            return GetMathValue(ctx).Ln(this, ctx);
        }

        /// <summary>Finds the base-10 logarithm of this object, that is, the
        /// power (exponent) that the number 10 must be raised to in order to
        /// equal this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the ln function's results are
        /// generally not exact.</i> (Unlike in the General Decimal Arithmetic
        /// Specification, any rounding mode is allowed.).</param>
        /// <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
        /// returns not-a-number (NaN) if this object is less than 0. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public EDecimal Log10(EContext ctx)
        {
            return this.LogN(EDecimal.FromInt32(10), ctx);
        }

        /// <summary>Adds 1 to this object's value and finds the natural
        /// logarithm of the result, in a way that avoids loss of precision
        /// when this object's value is between 0 and 1.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the ln function's results are
        /// generally not exact.</i> (Unlike in the General Binary Arithmetic
        /// Specification, any rounding mode is allowed.).</param>
        /// <returns>Ln(1+(this object)). Signals the flag FlagInvalid and
        /// returns NaN if this object is less than -1 (the result would be a
        /// complex number with a real part equal to Ln of 1 plus this object's
        /// absolute value and an imaginary part equal to pi, but the return
        /// value is still NaN.). Signals FlagInvalid and returns not-a-number
        /// (NaN) if the parameter <paramref name='ctx'/> is null or the
        /// precision is unlimited (the context's Precision property is 0).
        /// Signals no flags and returns negative infinity if this object's
        /// value is 0.</returns>
        public EDecimal Log1P(EContext ctx)
        {
            EDecimal value = this;
            if (value.IsNaN())
            {
                return value.Plus(ctx);
            }
            if (ctx == null || !ctx.HasMaxPrecision ||
              (value.CompareTo(-1) < 0))
            {
                return EDecimal.SignalingNaN.Plus(ctx);
            }
            if (ctx.Traps != 0)
            {
                EContext tctx = ctx.GetNontrapping();
                EDecimal ret = value.Log1P(tctx);
                return ctx.TriggerTraps(ret, tctx);
            }
            else if (ctx.IsSimplified)
            {
                EContext tmpctx = ctx.WithSimplified(false).WithBlankFlags();
                EDecimal ret = value.PreRound(ctx).Log1P(tmpctx);
                if (ctx.HasFlags)
                {
                    int flags = ctx.Flags;
                    ctx.Flags = flags | tmpctx.Flags;
                }
                // Console.WriteLine("{0} {1} [{4} {5}] -> {2}
                // [{3}]",value,baseValue,ret,ret.RoundToPrecision(ctx),
                // value.Quantize(value, ctx), baseValue.Quantize(baseValue, ctx));
                return ret.RoundToPrecision(ctx);
            }
            else
            {
                if (value.CompareTo(-1) == 0)
                {
                    return EDecimal.NegativeInfinity;
                }
                else if (value.IsPositiveInfinity())
                {
                    return EDecimal.PositiveInfinity;
                }
                if (value.CompareTo(0) == 0)
                {
                    return EDecimal.FromInt32(0).Plus(ctx);
                }
                int flags = ctx.Flags;
                EContext tmpctx = null;
                EDecimal ret;
                // DebugUtility.Log("cmp=" +
                // value.CompareTo(EDecimal.Create(1, -1)) +
                // " add=" + value.Add(EDecimal.FromInt32(1)));
                if (value.CompareTo(EDecimal.Create(5, -1)) < 0)
                {
                    ret = value.Add(EDecimal.FromInt32(1)).Log(ctx);
                }
                else
                {
                    tmpctx = ctx.WithBigPrecision(ctx.Precision.Add(3)).WithBlankFlags();
                    ret = value.Add(EDecimal.FromInt32(1), tmpctx).Log(ctx);
                    flags |= tmpctx.Flags;
                }
                if (ctx.HasFlags)
                {
                    flags |= ctx.Flags;
                    ctx.Flags = flags;
                }
                return ret;
            }
        }

        /// <summary>Finds the base-N logarithm of this object, that is, the
        /// power (exponent) that the number N must be raised to in order to
        /// equal this object's value.</summary>
        /// <param name='baseValue'>The parameter <paramref name='baseValue'/>
        /// is a Numbers.EDecimal object.</param>
        /// <param name='ctx'>The parameter <paramref name='ctx'/> is a
        /// Numbers.EContext object.</param>
        /// <returns>Ln(this object)/Ln(baseValue). Signals the flag
        /// FlagInvalid and returns not-a-number (NaN) if this object is less
        /// than 0. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null or the precision is
        /// unlimited (the context's Precision property is 0).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='baseValue'/> is null.</exception>
        public EDecimal LogN(EDecimal baseValue, EContext ctx)
        {
            EDecimal value = this;
            if (baseValue == null)
            {
                throw new ArgumentNullException(nameof(baseValue));
            }
            if (value.IsNaN())
            {
                return value.Plus(ctx);
            }
            if (baseValue.IsNaN())
            {
                return baseValue.Plus(ctx);
            }
            if (ctx == null || !ctx.HasMaxPrecision ||
              (value.IsNegative && !value.IsZero) ||
              (baseValue.IsNegative && !baseValue.IsZero))
            {
                return EDecimal.SignalingNaN.Plus(ctx);
            }
            if (ctx.Traps != 0)
            {
                EContext tctx = ctx.GetNontrapping();
                EDecimal ret = value.LogN(baseValue, tctx);
                return ctx.TriggerTraps(ret, tctx);
            }
            else if (ctx.IsSimplified)
            {
                EContext tmpctx = ctx.WithSimplified(false).WithBlankFlags();
                EDecimal ret = value.PreRound(ctx).LogN(baseValue.PreRound(ctx),
                    tmpctx);
                if (ctx.HasFlags)
                {
                    int flags = ctx.Flags;
                    ctx.Flags = flags | tmpctx.Flags;
                }
                // Console.WriteLine("{0} {1} [{4} {5}] -> {2}
                // [{3}]",value,baseValue,ret,ret.RoundToPrecision(ctx),
                // value.Quantize(value, ctx), baseValue.Quantize(baseValue, ctx));
                return ret.RoundToPrecision(ctx);
            }
            else
            {
                if (value.IsZero)
                {
                    return baseValue.CompareTo(1) < 0 ? EDecimal.PositiveInfinity :
                      EDecimal.NegativeInfinity;
                }
                else if (value.IsPositiveInfinity())
                {
                    return baseValue.CompareTo(1) < 0 ? EDecimal.NegativeInfinity :
                      EDecimal.PositiveInfinity;
                }
                if (baseValue.CompareTo(10) == 0)
                {
                    EDecimal ev = value.Reduce(null);
                    if (ev.UnsignedMantissa.CompareTo(1) == 0)
                    {
                        return EDecimal.FromEInteger(ev.Exponent).Plus(ctx);
                    }
                }
                else if (value.CompareTo(1) == 0)
                {
                    return EDecimal.FromInt32(0).Plus(ctx);
                }
                else if (value.CompareTo(baseValue) == 0)
                {
                    return EDecimal.FromInt32(1).Plus(ctx);
                }
                int flags = ctx.Flags;
                EContext tmpctx =
                  ctx.WithBigPrecision(ctx.Precision.Add(5)).WithBlankFlags();
                EDecimal ret = value.Log(tmpctx).Divide(baseValue.Log(tmpctx), ctx);
                if (ret.IsInteger() && !ret.IsZero)
                {
                    flags |= EContext.FlagRounded | EContext.FlagInexact;
                    if (baseValue.Pow(ret).CompareToValue(value) == 0)
                    {
                        EDecimal rtmp = ret.Quantize(EDecimal.FromInt32(1),
                            ctx.WithNoFlags());
                        if (!rtmp.IsNaN())
                        {
                            flags &= ~(EContext.FlagRounded | EContext.FlagInexact);
                            ret = rtmp;
                        }
                    }
                }
                else
                {
                    flags |= tmpctx.Flags;
                }
                if (ctx.HasFlags)
                {
                    flags |= ctx.Flags;
                    ctx.Flags = flags;
                }
                return ret;
            }
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the left.</summary>
        /// <param name='places'>The number of decimal places to move the
        /// decimal point to the left. If this number is negative, instead
        /// moves the decimal point to the right by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EDecimal MovePointLeft(int places)
        {
            return this.MovePointLeft((EInteger)places, null);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the left.</summary>
        /// <param name='places'>The number of decimal places to move the
        /// decimal point to the left. If this number is negative, instead
        /// moves the decimal point to the right by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EDecimal MovePointLeft(int places, EContext ctx)
        {
            return this.MovePointLeft((EInteger)places, ctx);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the left.</summary>
        /// <param name='bigPlaces'>The number of decimal places to move the
        /// decimal point to the left. If this number is negative, instead
        /// moves the decimal point to the right by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EDecimal MovePointLeft(EInteger bigPlaces)
        {
            return this.MovePointLeft(bigPlaces, null);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the left.</summary>
        /// <param name='bigPlaces'>The number of decimal places to move the
        /// decimal point to the left. If this number is negative, instead
        /// moves the decimal point to the right by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EDecimal MovePointLeft(
          EInteger bigPlaces,
          EContext ctx)
        {
            return (!this.IsFinite) ? this.RoundToPrecision(ctx) :
              this.MovePointRight(-(EInteger)bigPlaces, ctx);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the right.</summary>
        /// <param name='places'>The number of decimal places to move the
        /// decimal point to the right. If this number is negative, instead
        /// moves the decimal point to the left by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EDecimal MovePointRight(int places)
        {
            return this.MovePointRight((EInteger)places, null);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the right.</summary>
        /// <param name='places'>The number of decimal places to move the
        /// decimal point to the right. If this number is negative, instead
        /// moves the decimal point to the left by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EDecimal MovePointRight(int places, EContext ctx)
        {
            return this.MovePointRight((EInteger)places, ctx);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the right.</summary>
        /// <param name='bigPlaces'>The number of decimal places to move the
        /// decimal point to the right. If this number is negative, instead
        /// moves the decimal point to the left by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EDecimal MovePointRight(EInteger bigPlaces)
        {
            return this.MovePointRight(bigPlaces, null);
        }

        /// <summary>Returns a number similar to this number but with the
        /// decimal point moved to the right.</summary>
        /// <param name='bigPlaces'>The number of decimal places to move the
        /// decimal point to the right. If this number is negative, instead
        /// moves the decimal point to the left by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EDecimal MovePointRight(
          EInteger bigPlaces,
          EContext ctx)
        {
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            if (bigExp.Sign > 0)
            {
                EInteger mant = this.unsignedMantissa.ToEInteger();
                EInteger bigPower = NumberUtility.FindPowerOfTenFromBig(bigExp);
                mant *= bigPower;
                return CreateWithFlags(
                    mant,
                    EInteger.Zero,
                    this.flags).RoundToPrecision(ctx);
            }
            return CreateWithFlags(
                this.unsignedMantissa,
                FastIntegerFixed.FromBig(bigExp),
                this.flags).RoundToPrecision(ctx);
        }

        /// <summary>Multiplies this arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns the result. The exponent for the result is this
        /// arbitrary-precision decimal floating-point number's exponent plus
        /// the other arbitrary-precision decimal floating-point number's
        /// exponent.</summary>
        /// <param name='otherValue'>Another decimal number.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number times another
        /// arbitrary-precision decimal floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public EDecimal Multiply(EDecimal otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsFinite && otherValue.IsFinite)
            {
                int newflags = otherValue.flags ^ this.flags;
                if (this.unsignedMantissa.CanFitInInt32() &&
                  otherValue.unsignedMantissa.CanFitInInt32())
                {
                    int integerA = this.unsignedMantissa.ToInt32();
                    int integerB = otherValue.unsignedMantissa.ToInt32();
                    long longA = ((long)integerA) * ((long)integerB);
                    FastIntegerFixed exp = FastIntegerFixed.Add(
                        this.exponent,
                        otherValue.exponent);
                    if ((longA >> 31) == 0)
                    {
                        return new EDecimal(
                            FastIntegerFixed.FromInt32((int)longA),
                            exp,
                            (byte)newflags);
                    }
                    else
                    {
                        return new EDecimal(
                            FastIntegerFixed.FromBig((EInteger)longA),
                            exp,
                            (byte)newflags);
                    }
                }
                else
                {
                    EInteger eintA = this.unsignedMantissa.ToEInteger().Multiply(
                        otherValue.unsignedMantissa.ToEInteger());
                    return new EDecimal(
                        FastIntegerFixed.FromBig(eintA),
                        FastIntegerFixed.Add(this.exponent, otherValue.exponent),
                        (byte)newflags);
                }
            }
            return this.Multiply(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <summary>Multiplies this arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns the result.</summary>
        /// <param name='op'>Another decimal number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number times another
        /// arbitrary-precision decimal floating-point number.</returns>
        public EDecimal Multiply(EDecimal op, EContext ctx)
        {
            return GetMathValue(ctx).Multiply(this, op, ctx);
        }

        /// <summary>Adds this arbitrary-precision decimal floating-point
        /// number and a 64-bit signed integer and returns the result. The
        /// exponent for the result is the lower of this arbitrary-precision
        /// decimal floating-point number's exponent and the other 64-bit
        /// signed integer's exponent.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number plus a 64-bit
        /// signed integer. If this arbitrary-precision decimal floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EDecimal Add(long longValue)
        {
            return this.Add(EDecimal.FromInt64(longValue));
        }

        /// <summary>Subtracts a 64-bit signed integer from this
        /// arbitrary-precision decimal floating-point number and returns the
        /// result. The exponent for the result is the lower of this
        /// arbitrary-precision decimal floating-point number's exponent and
        /// the other 64-bit signed integer's exponent.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number minus a 64-bit
        /// signed integer. If this arbitrary-precision decimal floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EDecimal Subtract(long longValue)
        {
            return this.Subtract(EDecimal.FromInt64(longValue));
        }

        /// <summary>Multiplies this arbitrary-precision decimal floating-point
        /// number by a 64-bit signed integer and returns the result. The
        /// exponent for the result is this arbitrary-precision decimal
        /// floating-point number's exponent plus the other 64-bit signed
        /// integer's exponent.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number times a 64-bit
        /// signed integer.</returns>
        public EDecimal Multiply(long longValue)
        {
            return this.Multiply(EDecimal.FromInt64(longValue));
        }

        /// <summary>Divides this arbitrary-precision decimal floating-point
        /// number by a 64-bit signed integer and returns the result; returns
        /// NaN instead if the result would have a nonterminating decimal
        /// expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
        /// not desired, use DivideToExponent, or use the Divide overload that
        /// takes an EContext.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The result of dividing this arbitrary-precision decimal
        /// floating-point number by a 64-bit signed integer. Returns infinity
        /// if the divisor (this arbitrary-precision decimal floating-point
        /// number) is 0 and the dividend (the other 64-bit signed integer) is
        /// nonzero. Returns not-a-number (NaN) if the divisor and the dividend
        /// are 0. Returns NaN if the result can't be exact because it would
        /// have a nonterminating binary expansion (examples include 1 divided
        /// by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
        /// use DivideToExponent instead, or use the Divide overload that takes
        /// an <c>EContext</c> (such as <c>EContext.Decimal128</c> )
        /// instead.</returns>
        public EDecimal Divide(long longValue)
        {
            return this.Divide(EDecimal.FromInt64(longValue));
        }

        /// <summary>Adds this arbitrary-precision decimal floating-point
        /// number and a 32-bit signed integer and returns the result. The
        /// exponent for the result is the lower of this arbitrary-precision
        /// decimal floating-point number's exponent and the other 32-bit
        /// signed integer's exponent.</summary>
        /// <param name='intValue'>A 32-bit signed integer to add to this
        /// object.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number plus a 32-bit
        /// signed integer. If this arbitrary-precision decimal floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EDecimal Add(int intValue)
        {
            return this.Add(EDecimal.FromInt32(intValue));
        }

        /// <summary>Subtracts a 32-bit signed integer from this
        /// arbitrary-precision decimal floating-point number and returns the
        /// result. The exponent for the result is the lower of this
        /// arbitrary-precision decimal floating-point number's exponent and
        /// the other 32-bit signed integer's exponent.</summary>
        /// <param name='intValue'>A 32-bit signed integer to subtract from
        /// this object.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number minus a 32-bit
        /// signed integer. If this arbitrary-precision decimal floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EDecimal Subtract(int intValue)
        {
            return (intValue == Int32.MinValue) ?
              this.Subtract(EDecimal.FromInt32(intValue)) : this.Add(-intValue);
        }

        /// <summary>Multiplies this arbitrary-precision decimal floating-point
        /// number by a 32-bit signed integer and returns the result. The
        /// exponent for the result is this arbitrary-precision decimal
        /// floating-point number's exponent plus the other 32-bit signed
        /// integer's exponent.</summary>
        /// <param name='intValue'>A 32-bit signed integer to multiply this
        /// object by.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number times a 32-bit
        /// signed integer.</returns>
        public EDecimal Multiply(int intValue)
        {
            return this.Multiply(EDecimal.FromInt32(intValue));
        }

        /// <summary>Divides this arbitrary-precision decimal floating-point
        /// number by a 32-bit signed integer and returns the result; returns
        /// NaN instead if the result would have a nonterminating decimal
        /// expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
        /// not desired, use DivideToExponent, or use the Divide overload that
        /// takes an EContext.</summary>
        /// <param name='intValue'>A 32-bit signed integer, the divisor, to
        /// divide this object by.</param>
        /// <returns>The result of dividing this arbitrary-precision decimal
        /// floating-point number by a 32-bit signed integer. Returns infinity
        /// if the divisor (this arbitrary-precision decimal floating-point
        /// number) is 0 and the dividend (the other 32-bit signed integer) is
        /// nonzero. Returns not-a-number (NaN) if the divisor and the dividend
        /// are 0. Returns NaN if the result can't be exact because it would
        /// have a nonterminating binary expansion (examples include 1 divided
        /// by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
        /// use DivideToExponent instead, or use the Divide overload that takes
        /// an <c>EContext</c> (such as <c>EContext.Decimal128</c> )
        /// instead.</returns>
        public EDecimal Divide(int intValue)
        {
            return this.Divide(EDecimal.FromInt32(intValue));
        }

        /// <summary>Multiplies by one decimal number, and then adds another
        /// decimal number.</summary>
        /// <param name='multiplicand'>The value to multiply.</param>
        /// <param name='augend'>The value to add.</param>
        /// <returns>An arbitrary-precision decimal floating-point
        /// number.</returns>
        public EDecimal MultiplyAndAdd(
          EDecimal multiplicand,
          EDecimal augend)
        {
            return this.MultiplyAndAdd(multiplicand, augend, null);
        }

        /// <summary>Multiplies by one value, and then adds another
        /// value.</summary>
        /// <param name='op'>The value to multiply.</param>
        /// <param name='augend'>The value to add.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. If the precision doesn't indicate a simplified
        /// arithmetic, rounding and precision/exponent adjustment is done only
        /// once, namely, after multiplying and adding.</param>
        /// <returns>The result thisValue * multiplicand + augend.</returns>
        public EDecimal MultiplyAndAdd(
          EDecimal op,
          EDecimal augend,
          EContext ctx)
        {
            return GetMathValue(ctx).MultiplyAndAdd(this, op, augend, ctx);
        }

        /// <summary>Multiplies by one value, and then subtracts another
        /// value.</summary>
        /// <param name='op'>The value to multiply.</param>
        /// <param name='subtrahend'>The value to subtract.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. If the precision doesn't indicate a simplified
        /// arithmetic, rounding and precision/exponent adjustment is done only
        /// once, namely, after multiplying and subtracting.</param>
        /// <returns>The result thisValue * multiplicand -
        /// subtrahend.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='op'/> or <paramref name='subtrahend'/> is null.</exception>
        public EDecimal MultiplyAndSubtract(
          EDecimal op,
          EDecimal subtrahend,
          EContext ctx)
        {
            if (op == null)
            {
                throw new ArgumentNullException(nameof(op));
            }
            if (subtrahend == null)
            {
                throw new ArgumentNullException(nameof(subtrahend));
            }
            EDecimal negated = subtrahend;
            if ((subtrahend.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = subtrahend.flags ^ BigNumberFlags.FlagNegative;
                negated = CreateWithFlags(
                    subtrahend.unsignedMantissa,
                    subtrahend.exponent,
                    newflags);
            }
            return GetMathValue(ctx)
              .MultiplyAndAdd(this, op, negated, ctx);
        }

        /// <summary>Gets an object with the same value as this one, but with
        /// the sign reversed.</summary>
        /// <returns>An arbitrary-precision decimal number. If this value is
        /// positive zero, returns negative zero. Returns signaling NaN if this
        /// value is signaling NaN. (In this sense, this method is similar to
        /// the "copy-negate" operation in the General Decimal Arithmetic
        /// Specification, except this method does not necessarily return a
        /// copy of this object.).</returns>
        public EDecimal Negate()
        {
            return new EDecimal(
                this.unsignedMantissa,
                this.exponent,
                (byte)(this.flags ^ BigNumberFlags.FlagNegative));
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but with the sign reversed.</summary>
        /// <param name='context'>An arithmetic context to control the
        /// precision, rounding, and exponent range of the result. If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the precision is
        /// unlimited and rounding isn't needed.</param>
        /// <returns>An arbitrary-precision decimal number. If this value is
        /// positive zero, returns positive zero. Signals FlagInvalid and
        /// returns quiet NaN if this value is signaling NaN.</returns>
        public EDecimal Negate(EContext context)
        {
            return ((context == null || context == EContext.UnlimitedHalfEven) ?
                ExtendedMathValue : MathValue).Negate(this, context);
        }

        /// <summary>Finds the largest value that's smaller than the given
        /// value.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision and exponent range of the result. The rounding mode from
        /// this context is ignored. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags).</param>
        /// <returns>Returns the largest value that's less than the given
        /// value. Returns negative infinity if the result is negative
        /// infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null, the precision is 0, or
        /// <paramref name='ctx'/> has an unlimited exponent range.</returns>
        public EDecimal NextMinus(EContext ctx)
        {
            return GetMathValue(ctx).NextMinus(this, ctx);
        }

        /// <summary>Finds the smallest value that's greater than the given
        /// value.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision and exponent range of the result. The rounding mode from
        /// this context is ignored. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags).</param>
        /// <returns>Returns the smallest value that's greater than the given
        /// value.Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null, the precision is 0, or
        /// <paramref name='ctx'/> has an unlimited exponent range.</returns>
        public EDecimal NextPlus(EContext ctx)
        {
            return GetMathValue(ctx).NextPlus(this, ctx);
        }

        /// <summary>Finds the next value that is closer to the other object's
        /// value than this object's value. Returns a copy of this value with
        /// the same sign as the other value if both values are
        /// equal.</summary>
        /// <param name='otherValue'>An arbitrary-precision decimal number that
        /// the return value will approach.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision and exponent range of the result. The rounding mode from
        /// this context is ignored. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags).</param>
        /// <returns>Returns the next value that is closer to the other object'
        /// s value than this object's value. Signals FlagInvalid and returns
        /// NaN if the parameter <paramref name='ctx'/> is null, the precision
        /// is 0, or <paramref name='ctx'/> has an unlimited exponent
        /// range.</returns>
        public EDecimal NextToward(
          EDecimal otherValue,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .NextToward(this, otherValue, ctx);
        }

        /// <summary>Rounds this object's value to a given precision, using the
        /// given rounding mode and range of exponent, and also converts
        /// negative zero to positive zero. The idiom
        /// <c>EDecimal.SignalingNaN.Plus(ctx)</c> is useful for triggering an
        /// invalid operation and returning not-a-number (NaN) for custom
        /// arithmetic operations.</summary>
        /// <param name='ctx'>A context for controlling the precision, rounding
        /// mode, and exponent range. Can be null, in which case the precision
        /// is unlimited and rounding isn't needed.</param>
        /// <returns>The closest value to this object's value, rounded to the
        /// specified precision. If <paramref name='ctx'/> is null or the
        /// precision and exponent range are unlimited, returns the same value
        /// as this object (or a quiet NaN if this object is a signaling
        /// NaN).</returns>
        public EDecimal Plus(EContext ctx)
        {
            return GetMathValue(ctx).Plus(this, ctx);
        }

        /// <summary>Raises this object's value to the given
        /// exponent.</summary>
        /// <param name='exponent'>An arbitrary-precision decimal number
        /// expressing the exponent to raise this object's value to.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>This^exponent. Signals the flag FlagInvalid and returns
        /// NaN if this object and exponent are both 0; or if this value is
        /// less than 0 and the exponent either has a fractional part or is
        /// infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null or the precision is
        /// unlimited (the context's Precision property is 0), and the exponent
        /// has a fractional part.</returns>
        public EDecimal Pow(EDecimal exponent, EContext ctx)
        {
            return GetMathValue(ctx).Power(this, exponent, ctx);
        }

        /// <summary>Raises this object's value to the given exponent, using
        /// unlimited precision.</summary>
        /// <param name='exponent'>An arbitrary-precision decimal number
        /// expressing the exponent to raise this object's value to.</param>
        /// <returns>This^exponent. Returns not-a-number (NaN) if the exponent
        /// has a fractional part.</returns>
        public EDecimal Pow(EDecimal exponent)
        {
            return this.Pow(exponent, null);
        }

        /// <summary>Raises this object's value to the given
        /// exponent.</summary>
        /// <param name='exponentSmall'>The exponent to raise this object's
        /// value to.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>This^exponent. Signals the flag FlagInvalid and returns
        /// NaN if this object and exponent are both 0.</returns>
        public EDecimal Pow(int exponentSmall, EContext ctx)
        {
            return this.Pow(EDecimal.FromInt64(exponentSmall), ctx);
        }

        /// <summary>Raises this object's value to the given
        /// exponent.</summary>
        /// <param name='exponentSmall'>The exponent to raise this object's
        /// value to.</param>
        /// <returns>This^exponent. Returns not-a-number (NaN) if this object
        /// and exponent are both 0.</returns>
        public EDecimal Pow(int exponentSmall)
        {
            return this.Pow(EDecimal.FromInt64(exponentSmall), null);
        }

        /// <summary>Finds the number of digits in this number's significand.
        /// Returns 1 if this value is 0, and 0 if this value is infinity or
        /// not-a-number (NaN).</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        public EInteger Precision()
        {
            if (!this.IsFinite)
            {
                return EInteger.Zero;
            }
            return this.IsZero ? EInteger.One :
              this.unsignedMantissa.ToEInteger().GetDigitCountAsEInteger();
        }

        /// <summary>
        ///  Returns an arbitrary-precision decimal number with the
        /// same value but a new exponent.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of decimal places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// decimal places is desired, it's better to use the RoundToExponent
        /// and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b>
        ///  This method can be used to implement
        /// fixed-point decimal arithmetic, in which each decimal number has a
        /// fixed number of digits after the decimal point. The following code
        /// example returns a fixed-point number with up to 20 digits before
        /// and exactly 5 digits after the decimal point:</para>
        /// <code> &#x2f;&#x2a; After performing arithmetic operations, adjust
        /// &#x2f;&#x2a; the number to 5&#x2a;&#x2f;&#x2a;&#x2f;
        /// &#x2f;&#x2a;&#x2a;&#x2f;
        /// digits after the decimal point number = number.Quantize(
        /// EInteger.FromInt32(-5), &#x2f;&#x2a; five digits after the decimal
        /// point&#x2a;&#x2f;
        /// EContext.ForPrecision(25) &#x2f;&#x2a; 25-digit
        /// precision);&#x2a;&#x2f;</code>
        /// <para>A fixed-point decimal arithmetic in which no digits come
        /// after the decimal point (a desired exponent of 0) is considered an
        /// "integer arithmetic".</para>
        /// </summary>
        /// <param name='desiredExponent'>The desired exponent for the result.
        /// The exponent is the number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c>
        ///  of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as this object but with the exponent changed. Signals FlagInvalid
        /// and returns not-a-number (NaN) if this object is infinity, if the
        /// rounded result can't fit the given precision, or if the context
        /// defines an exponent range and the given exponent is outside that
        /// range.</returns>
        public EDecimal Quantize(
          EInteger desiredExponent,
          EContext ctx)
        {
            return this.Quantize(
                EDecimal.Create(EInteger.One, desiredExponent),
                ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this one but a new exponent.
        /// <para><b>Remark:</b> This method can be used to implement
        /// fixed-point decimal arithmetic, in which a fixed number of digits
        /// come after the decimal point. A fixed-point decimal arithmetic in
        /// which no digits come after the decimal point (a desired exponent of
        /// 0) is considered an "integer arithmetic" .</para></summary>
        /// <param name='desiredExponentInt'>The desired exponent for the
        /// result. The exponent is the number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='rounding'>A rounding mode to use in case the result
        /// needs to be rounded to fit the given exponent.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as this object but with the exponent changed. Returns not-a-number
        /// (NaN) if this object is infinity, or if the rounding mode is
        /// ERounding.None and the result is not exact.</returns>
        public EDecimal Quantize(
          int desiredExponentInt,
          ERounding rounding)
        {
            EDecimal ret = this.RoundToExponentFast(
                desiredExponentInt,
                rounding);
            if (ret != null)
            {
                return ret;
            }
            return this.Quantize(
                EDecimal.Create(EInteger.One, (EInteger)desiredExponentInt),
                EContext.ForRounding(rounding));
        }

        /// <summary>
        ///  Returns an arbitrary-precision decimal number with the
        /// same value but a new exponent.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of decimal places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// decimal places is desired, it's better to use the RoundToExponent
        /// and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b>
        ///  This method can be used to implement
        /// fixed-point decimal arithmetic, in which each decimal number has a
        /// fixed number of digits after the decimal point. The following code
        /// example returns a fixed-point number with up to 20 digits before
        /// and exactly 5 digits after the decimal point:</para>
        /// <code>/* After performing arithmetic operations, adjust the number to 5
        /// digits
        /// after the decimal point */ number = number.Quantize(-5, /* five digits
        /// after the decimal point */EContext.ForPrecision(25) /* 25-digit
        /// precision*/);</code>
        /// <para>A fixed-point decimal arithmetic in which no digits come
        /// after the decimal point (a desired exponent of 0) is considered an
        /// "integer arithmetic".</para>
        /// </summary>
        /// <param name='desiredExponentInt'>The desired exponent for the
        /// result. The exponent is the number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c>
        ///  of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as this object but with the exponent changed. Signals FlagInvalid
        /// and returns not-a-number (NaN) if this object is infinity, if the
        /// rounded result can't fit the given precision, or if the context
        /// defines an exponent range and the given exponent is outside that
        /// range.</returns>
        public EDecimal Quantize(
          int desiredExponentInt,
          EContext ctx)
        {
            if (ctx == null ||
              (!ctx.HasExponentRange && !ctx.HasFlagsOrTraps &&
                !ctx.HasMaxPrecision && !ctx.IsSimplified))
            {
                EDecimal ret = this.RoundToExponentFast(
                    desiredExponentInt,
                    ctx == null ? ERounding.HalfEven : ctx.Rounding);
                if (ret != null)
                {
                    return ret;
                }
            }
            return this.Quantize(
                EDecimal.Create(EInteger.One, (EInteger)desiredExponentInt),
                ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but with the same exponent as another
        /// decimal number.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of decimal places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// decimal places is desired, it's better to use the RoundToExponent
        /// and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b> This method can be used to implement
        /// fixed-point decimal arithmetic, in which a fixed number of digits
        /// come after the decimal point. A fixed-point decimal arithmetic in
        /// which no digits come after the decimal point (a desired exponent of
        /// 0) is considered an "integer arithmetic" .</para></summary>
        /// <param name='otherValue'>An arbitrary-precision decimal number
        /// containing the desired exponent of the result. The significand is
        /// ignored. The exponent is the number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousands-place (10^3, 1000). A value of 0 rounds the number to
        /// an integer. The following examples for this parameter express a
        /// desired exponent of 3: <c>10e3</c>, <c>8888e3</c>, <c>4.56e5</c>.</param>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as this object but with the exponent changed. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding, or if the arithmetic context defines an
        /// exponent range and the given exponent is outside that
        /// range.</returns>
        public EDecimal Quantize(
          EDecimal otherValue,
          EContext ctx)
        {
            return GetMathValue(ctx).Quantize(this, otherValue, ctx);
        }

        /// <summary>Returns an object with the same numerical value as this
        /// one but with trailing zeros removed from its significand. For
        /// example, 1.00 becomes 1.
        /// <para>If this object's value is 0, changes the exponent to
        /// 0.</para></summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>This value with trailing zeros removed. Note that if the
        /// result has a very high exponent and the context says to clamp high
        /// exponents, there may still be some trailing zeros in the
        /// significand.</returns>
        public EDecimal Reduce(EContext ctx)
        {
            return GetMathValue(ctx).Reduce(this, ctx);
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision decimal floating-point number is divided by
        /// another arbitrary-precision decimal floating-point number. The
        /// remainder is the number that remains when the absolute value of
        /// this arbitrary-precision decimal floating-point number is divided
        /// (as though by DivideToIntegerZeroScale) by the absolute value of
        /// the other arbitrary-precision decimal floating-point number; the
        /// remainder has the same sign (positive or negative) as this
        /// arbitrary-precision decimal floating-point number.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result, and of the
        /// intermediate integer division. If <c>HasFlags</c> of the context is
        /// true, will also store the flags resulting from the operation (the
        /// flags are in addition to the pre-existing flags). Can be null, in
        /// which the precision is unlimited.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision decimal floating-point number is divided by
        /// another arbitrary-precision decimal floating-point number. Signals
        /// FlagDivideByZero and returns infinity if the divisor (this
        /// arbitrary-precision decimal floating-point number) is 0 and the
        /// dividend (the other arbitrary-precision decimal floating-point
        /// number) is nonzero. Signals FlagInvalid and returns not-a-number
        /// (NaN) if the divisor and the dividend are 0, or if the result of
        /// the division doesn't fit the given precision.</returns>
        public EDecimal Remainder(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).Remainder(this, divisor, ctx, true);
        }

        /// <summary>Finds the remainder that results when dividing two
        /// arbitrary-precision decimal numbers, except the intermediate
        /// division is not adjusted to fit the precision of the given
        /// arithmetic context. The value of this object is divided by the
        /// absolute value of the other object; the remainder has the same sign
        /// (positive or negative) as this object's value.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result, but not also
        /// of the intermediate integer division. If <c>HasFlags</c> of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which the precision is unlimited.</param>
        /// <returns>The remainder of the two numbers. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the divisor is 0, or if the result
        /// doesn't fit the given precision.</returns>
        public EDecimal RemainderNoRoundAfterDivide(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx).Remainder(this, divisor, ctx, false);
        }

        /// <summary>Calculates the remainder of a number by the formula
        /// <c>"this" - (("this" / "divisor") * "divisor")</c>.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        public EDecimal RemainderNaturalScale(EDecimal divisor)
        {
            return this.RemainderNaturalScale(divisor, null);
        }

        /// <summary>Calculates the remainder of a number by the formula "this"
        /// - (("this" / "divisor") * "divisor").</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only in the division portion of the remainder
        /// calculation; as a result, it's possible for the return value to
        /// have a higher precision than given in this context. Flags will be
        /// set on the given context only if the context's <c>HasFlags</c> is
        /// true and the integer part of the division result doesn't fit the
        /// precision and exponent range without rounding. Can be null, in
        /// which the precision is unlimited and no additional rounding, other
        /// than the rounding down to an integer after division, is
        /// needed.</param>
        /// <returns>An arbitrary-precision decimal number.</returns>
        public EDecimal RemainderNaturalScale(
          EDecimal divisor,
          EContext ctx)
        {
            return this.Subtract(
              this.DivideToIntegerNaturalScale(divisor, null).Multiply(divisor, null),
              ctx);
        }

        /// <summary>Finds the distance to the closest multiple of the given
        /// divisor, based on the result of dividing this object's value by
        /// another object's value.
        /// <list type=''>
        /// <item>If this and the other object divide evenly, the result is
        /// 0.</item>
        /// <item>If the remainder's absolute value is less than half of the
        /// divisor's absolute value, the result has the same sign as this
        /// object and will be the distance to the closest multiple.</item>
        /// <item>If the remainder's absolute value is more than half of the
        /// divisor's absolute value, the result has the opposite sign of this
        /// object and will be the distance to the closest multiple.</item>
        /// <item>If the remainder's absolute value is exactly half of the
        /// divisor's absolute value, the result has the opposite sign of this
        /// object if the quotient, rounded down, is odd, and has the same sign
        /// as this object if the quotient, rounded down, is even, and the
        /// result's absolute value is half of the divisor's absolute
        /// value.</item></list> This function is also known as the "IEEE
        /// Remainder" function.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision. The rounding and exponent range settings of this context
        /// are ignored (the rounding mode is always treated as HalfEven). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which the precision is
        /// unlimited.</param>
        /// <returns>The distance of the closest multiple. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the divisor is 0, or either the
        /// result of integer division (the quotient) or the remainder wouldn't
        /// fit the given precision.</returns>
        public EDecimal RemainderNear(
          EDecimal divisor,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .RemainderNear(this, divisor, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to a new exponent if
        /// necessary. The resulting number's Exponent property will not
        /// necessarily be the given exponent; use the Quantize method instead
        /// to give the result a particular exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable in the given precision. If the result
        /// can't fit the precision, additional digits are discarded to make it
        /// fit. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to the given exponent when rounding, and the given
        /// exponent is outside of the valid range of the arithmetic
        /// context.</returns>
        public EDecimal RoundToExponent(
          EInteger exponent,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentSimple(this, exponent, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to a new exponent if
        /// necessary, using the HalfEven rounding mode. The resulting number's
        /// Exponent property will not necessarily be the given exponent; use
        /// the Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable for the given exponent.</returns>
        public EDecimal RoundToExponent(
          EInteger exponent)
        {
            return this.RoundToExponent(
                exponent,
                EContext.ForRounding(ERounding.HalfEven));
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to a new exponent if
        /// necessary, using the given rounding mode. The resulting number's
        /// Exponent property will not necessarily be the given exponent; use
        /// the Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='rounding'>Desired mode for rounding this number's
        /// value.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable for the given exponent.</returns>
        public EDecimal RoundToExponent(
          EInteger exponent,
          ERounding rounding)
        {
            return this.RoundToExponent(
                exponent,
                EContext.ForRounding(rounding));
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to a new exponent if
        /// necessary, using the HalfEven rounding mode. The resulting number's
        /// Exponent property will not necessarily be the given exponent; use
        /// the Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable for the given exponent.</returns>
        public EDecimal RoundToExponent(
          int exponentSmall)
        {
            return this.RoundToExponent(exponentSmall, ERounding.HalfEven);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to a new exponent if
        /// necessary. The resulting number's Exponent property will not
        /// necessarily be the given exponent; use the Quantize method instead
        /// to give the result a particular exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable in the given precision. If the result
        /// can't fit the precision, additional digits are discarded to make it
        /// fit. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to the given exponent when rounding, and the given
        /// exponent is outside of the valid range of the arithmetic
        /// context.</returns>
        public EDecimal RoundToExponent(
          int exponentSmall,
          EContext ctx)
        {
            if (ctx == null ||
              (!ctx.HasExponentRange && !ctx.HasFlagsOrTraps &&
                !ctx.HasMaxPrecision && !ctx.IsSimplified))
            {
                EDecimal ret = this.RoundToExponentFast(
                    exponentSmall,
                    ctx == null ? ERounding.HalfEven : ctx.Rounding);
                if (ret != null)
                {
                    return ret;
                }
            }
            return this.RoundToExponent((EInteger)exponentSmall, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to a new exponent if
        /// necessary. The resulting number's Exponent property will not
        /// necessarily be the given exponent; use the Quantize method instead
        /// to give the result a particular exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='rounding'>The desired mode to use to round the given
        /// number to the given exponent.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the given
        /// negative number of decimal places.</returns>
        public EDecimal RoundToExponent(
          int exponentSmall,
          ERounding rounding)
        {
            EDecimal ret = this.RoundToExponentFast(
                exponentSmall,
                rounding);
            if (ret != null)
            {
                return ret;
            }
            return this.RoundToExponent(
                exponentSmall,
                EContext.ForRounding(rounding));
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to the given exponent
        /// represented as an arbitrary-precision integer, and signals an
        /// inexact flag if the result would be inexact. The resulting number's
        /// Exponent property will not necessarily be the given exponent; use
        /// the Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable in the given precision. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the result can't fit
        /// the given precision without rounding. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the arithmetic context defines an
        /// exponent range, the new exponent must be changed to the given
        /// exponent when rounding, and the given exponent is outside of the
        /// valid range of the arithmetic context.</returns>
        public EDecimal RoundToExponentExact(
          EInteger exponent,
          EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentExact(this, exponent, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to the given exponent
        /// represented as a 32-bit signed integer, and signals an inexact flag
        /// if the result would be inexact. The resulting number's Exponent
        /// property will not necessarily be the given exponent; use the
        /// Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable in the given precision. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the result can't fit
        /// the given precision without rounding. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the arithmetic context defines an
        /// exponent range, the new exponent must be changed to the given
        /// exponent when rounding, and the given exponent is outside of the
        /// valid range of the arithmetic context.</returns>
        public EDecimal RoundToExponentExact(
          int exponentSmall,
          EContext ctx)
        {
            return this.RoundToExponentExact((EInteger)exponentSmall, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to the given exponent
        /// represented as a 32-bit signed integer, and signals an inexact flag
        /// if the result would be inexact. The resulting number's Exponent
        /// property will not necessarily be the given exponent; use the
        /// Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='rounding'>Desired mode for rounding this object's
        /// value.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest value representable using the given exponent.</returns>
        public EDecimal RoundToExponentExact(
          int exponentSmall,
          ERounding rounding)
        {
            return this.RoundToExponentExact(
                (EInteger)exponentSmall,
                EContext.Unlimited.WithRounding(rounding));
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to an integer, and signals an
        /// inexact flag if the result would be inexact. The resulting number's
        /// Exponent property will not necessarily be 0; use the Quantize
        /// method instead to give the result an exponent of 0.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest integer representable in the given precision. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the result can't fit
        /// the given precision without rounding. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the arithmetic context defines an
        /// exponent range, the new exponent must be changed to 0 when
        /// rounding, and 0 is outside of the valid range of the arithmetic
        /// context.</returns>
        public EDecimal RoundToIntegerExact(EContext ctx)
        {
            return GetMathValue(ctx).RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to an integer, without adding
        /// the <c>FlagInexact</c> or <c>FlagRounded</c> flags. The resulting
        /// number's Exponent property will not necessarily be 0; use the
        /// Quantize method instead to give the result an exponent of
        /// 0.</summary>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags), except that this
        /// function will never add the <c>FlagRounded</c> and
        /// <c>FlagInexact</c> flags (the only difference between this and
        /// RoundToExponentExact). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest integer representable in the given precision. If the result
        /// can't fit the precision, additional digits are discarded to make it
        /// fit. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to 0 when rounding, and 0 is outside of the valid range
        /// of the arithmetic context.</returns>
        public EDecimal RoundToIntegerNoRoundedFlag(EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to an integer, and signals an
        /// inexact flag if the result would be inexact.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest integer representable in the given precision. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the result can't fit
        /// the given precision without rounding. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the arithmetic context defines an
        /// exponent range, the new exponent must be changed to 0 when
        /// rounding, and 0 is outside of the valid range of the arithmetic
        /// context.</returns>
        [Obsolete("Renamed to RoundToIntegerExact.")]
        public EDecimal RoundToIntegralExact(EContext ctx)
        {
            return GetMathValue(ctx).RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but rounded to an integer, without adding
        /// the <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags), except that this
        /// function will never add the <c>FlagRounded</c> and
        /// <c>FlagInexact</c> flags (the only difference between this and
        /// RoundToExponentExact). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>An arbitrary-precision decimal number rounded to the
        /// closest integer representable in the given precision. If the result
        /// can't fit the precision, additional digits are discarded to make it
        /// fit. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to 0 when rounding, and 0 is outside of the valid range
        /// of the arithmetic context.</returns>
        [Obsolete("Renamed to RoundToIntegerNoRoundedFlag.")]
        public EDecimal RoundToIntegralNoRoundedFlag(EContext ctx)
        {
            return GetMathValue(ctx)
              .RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <summary>Rounds this object's value to a given precision, using the
        /// given rounding mode and range of exponent.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The closest value to this object's value, rounded to the
        /// specified precision. Returns the same value as this object if
        /// <paramref name='ctx'/> is null or the precision and exponent range
        /// are unlimited.</returns>
        public EDecimal RoundToPrecision(EContext ctx)
        {
            return GetMathValue(ctx).RoundToPrecision(this, ctx);
        }

        /// <summary>Returns a number in which the value of this object is
        /// rounded to fit the maximum precision allowed if it has more
        /// significant digits than the maximum precision. The maximum
        /// precision allowed is given in an arithmetic context. This method is
        /// designed for preparing operands to a custom arithmetic operation in
        /// accordance with the "simplified" arithmetic given in Appendix A of
        /// the General Decimal Arithmetic Specification.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Signals the
        /// flag LostDigits if the input number has greater precision than
        /// allowed and was rounded to a different numerical value in order to
        /// fit the precision.</param>
        /// <returns>This object rounded to the given precision. Returns this
        /// object and signals no flags if <paramref name='ctx'/> is null or
        /// specifies an unlimited precision, if this object is infinity or
        /// not-a-number (including signaling NaN), or if the number's value
        /// has no more significant digits than the maximum precision given in
        /// <paramref name='ctx'/>.</returns>
        public EDecimal PreRound(EContext ctx)
        {
            return NumberUtility.PreRound(this, ctx, GetMathValue(ctx));
        }

        /// <summary>Returns a number similar to this number but with the scale
        /// adjusted.</summary>
        /// <param name='places'>The power of 10 to scale by.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='places'/>. For example, if <paramref name='places'/> is 5,
        /// "78E-2" becomes "78E+3" and has a bigger value.</returns>
        public EDecimal ScaleByPowerOfTen(int places)
        {
            return this.ScaleByPowerOfTen((EInteger)places, null);
        }

        /// <summary>Returns a number similar to this number but with the scale
        /// adjusted.</summary>
        /// <param name='places'>The power of 10 to scale by.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>A number whose exponent is generally increased by
        /// <paramref name='places'/>. For example, in general, if <paramref
        /// name='places'/> is 5, "78E-2" becomes "78E+3" and has a bigger
        /// value.</returns>
        public EDecimal ScaleByPowerOfTen(int places, EContext ctx)
        {
            return this.ScaleByPowerOfTen((EInteger)places, ctx);
        }

        /// <summary>Returns a number similar to this number but with the scale
        /// adjusted.</summary>
        /// <param name='bigPlaces'>The power of 10 to scale by.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='bigPlaces'/>. For example, if <paramref name='bigPlaces'/>
        /// is 5, "78E-2" becomes "78E+3" and has a bigger value.</returns>
        public EDecimal ScaleByPowerOfTen(EInteger bigPlaces)
        {
            return this.ScaleByPowerOfTen(bigPlaces, null);
        }

        /// <summary>Returns a number similar to this number but with its scale
        /// adjusted.</summary>
        /// <param name='bigPlaces'>The power of 10 to scale by.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>A number whose exponent is generally increased by
        /// <paramref name='bigPlaces'/>. For example, in general, if
        /// <paramref name='bigPlaces'/> is 5, "78E-2" becomes "78E+3" and has
        /// a bigger value.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigPlaces'/> is null.</exception>
        public EDecimal ScaleByPowerOfTen(
          EInteger bigPlaces,
          EContext ctx)
        {
            if (bigPlaces == null)
            {
                throw new ArgumentNullException(nameof(bigPlaces));
            }
            if (bigPlaces.IsZero)
            {
                return this.RoundToPrecision(ctx);
            }
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            return CreateWithFlags(
                this.unsignedMantissa,
                FastIntegerFixed.FromBig(bigExp),
                this.flags).RoundToPrecision(ctx);
        }

        /// <summary>Finds the square root of this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the square root function's
        /// results are generally not exact for many inputs.</i> (Unlike in the
        /// General Decimal Arithmetic Specification, any rounding mode is
        /// allowed.).</param>
        /// <returns>The square root. Signals the flag FlagInvalid and returns
        /// NaN if this object is less than 0 (the square root would be a
        /// complex number, but the return value is still NaN). Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public EDecimal Sqrt(EContext ctx)
        {
            return GetMathValue(ctx).SquareRoot(this, ctx);
        }

        /// <summary>Finds the square root of this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the square root function's
        /// results are generally not exact for many inputs.</i> (Unlike in the
        /// General Decimal Arithmetic Specification, any rounding mode is
        /// allowed.).</param>
        /// <returns>The square root. Signals the flag FlagInvalid and returns
        /// NaN if this object is less than 0 (the square root would be a
        /// complex number, but the return value is still NaN). Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        [Obsolete("Renamed to Sqrt.")]
        public EDecimal SquareRoot(EContext ctx)
        {
            return GetMathValue(ctx).SquareRoot(this, ctx);
        }

        /// <summary>Subtracts an arbitrary-precision decimal floating-point
        /// number from this arbitrary-precision decimal floating-point number
        /// and returns the result. The exponent for the result is the lower of
        /// this arbitrary-precision decimal floating-point number's exponent
        /// and the other arbitrary-precision decimal floating-point number's
        /// exponent.</summary>
        /// <param name='otherValue'>The number to subtract from this
        /// instance's value.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number minus another
        /// arbitrary-precision decimal floating-point number. If this
        /// arbitrary-precision decimal floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        public EDecimal Subtract(EDecimal otherValue)
        {
            return this.Subtract(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <summary>Subtracts an arbitrary-precision decimal floating-point
        /// number from this arbitrary-precision decimal floating-point number
        /// and returns the result.</summary>
        /// <param name='otherValue'>The number to subtract from this
        /// instance's value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision decimal floating-point number minus another
        /// arbitrary-precision decimal floating-point number. If this
        /// arbitrary-precision decimal floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public EDecimal Subtract(
          EDecimal otherValue,
          EContext ctx)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            EDecimal negated = otherValue;
            if ((otherValue.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = otherValue.flags ^ BigNumberFlags.FlagNegative;
                negated = CreateWithFlags(
                    otherValue.unsignedMantissa,
                    otherValue.exponent,
                    newflags);
            }
            return this.Add(negated, ctx);
        }

        private static long IntegerToDoubleBits(long v, int expshift, bool neg)
        {
            int nexp = expshift;
            while (v < (1L << 52))
            {
                v <<= 1;
                --nexp;
            }
            // Clear the high bits where the exponent and sign are
            v &= 0xfffffffffffffL;
            // NOTE: Assumed not to be subnormal
            v |= (long)(nexp + 1075) << 52;
            if (neg)
            {
                v |= unchecked((long)(1L << 63));
            }
            return v;
        }

        private static int IntegerToSingleBits(int iv, int expshift, bool neg)
        {
            int nexp = expshift;
            while (iv < (1 << 23))
            {
                iv <<= 1;
                --nexp;
            }
            // Clear the high bits where the exponent and sign are
            iv &= 0x7fffff;
            // NOTE: Assumed not to be subnormal
            iv |= (nexp + 150) << 23;
            if (neg)
            {
                iv |= 1 << 31;
            }
            return iv;
        }

        /// <summary>Converts this value to its closest equivalent as a 64-bit
        /// floating-point number encoded in the IEEE 754 binary64 format,
        /// using the half-even rounding mode.
        /// <para>If this value is a NaN, sets the high bit of the binary64
        /// value's significand area for a quiet NaN, and clears it for a
        /// signaling NaN. Then the other bits of the significand area are set
        /// to the lowest bits of this object's unsigned significand, and the
        /// next-highest bit of the significand area is set if those bits are
        /// all zeros and this is a signaling NaN.</para></summary>
        /// <returns>The closest 64-bit floating-point number to this value,
        /// encoded in the IEEE 754 binary64 format. The return value can be
        /// positive infinity or negative infinity, encoded in the IEEE 754
        /// binary64 format, if this value exceeds the range of a 64-bit
        /// floating point number.</returns>
        public long ToDoubleBits()
        {
            if (this.IsPositiveInfinity())
            {
                return unchecked((long)0x7ff0000000000000L);
            }
            if (this.IsNegativeInfinity())
            {
                return unchecked((long)0xfff0000000000000L);
            }
            if (this.IsNegative && this.IsZero)
            {
                return 1L << 63;
            }
            if (this.IsZero)
            {
                return 0;
            }
            if (this.IsFinite)
            {
                if (this.exponent.CompareToInt(0) == 0 &&
                  this.unsignedMantissa.CanFitInInt64())
                {
                    long v = this.unsignedMantissa.ToInt64();
                    if (v < (1L << 53))
                    {
                        // This integer fits exactly in double
                        return IntegerToDoubleBits(v, 0, this.IsNegative);
                    }
                }
                if (this.exponent.CompareToInt(0) < 0 &&
                  this.exponent.CompareToInt(-8) >= 0 &&
                  this.unsignedMantissa.CanFitInInt32())
                {
                    int m = this.unsignedMantissa.ToInt32();
                    int iex = -this.exponent.ToInt32();
                    int vtp = ValueTenPowers[iex];
                    if (m != Int32.MinValue)
                    {
                        if (m % vtp == 0)
                        {
                            // Will fit in double without rounding
                            // DebugUtility.Log("m=" + m + " vtp=" + vtp);
                            return IntegerToDoubleBits(m / vtp, 0, this.IsNegative);
                        }
                        // Shift significand to be a 53-bit number (which
                        // can fit exactly in a double)
                        long am = Math.Abs(m);
                        var expshift = 0;
                        while (am < (1 << 52))
                        {
                            am <<= 1;
                            --expshift;
                        }
                        int divdCount = NumberUtility.BitLength(m);
                        int divsCount = NumberUtility.BitLength(vtp);
                        int dividendShift = (divdCount <= divsCount) ? ((divsCount -
                              divdCount) + 53 + 1) : Math.Max(0,
                            (53 + 1) - (divdCount - divsCount));
                        long lquo = -1;
                        long lrem = -1;
                        if (divsCount + dividendShift > 63)
                        {
                            EInteger eim = EInteger.FromInt32(m).ShiftLeft(dividendShift);
                            EInteger[] divrem3 = eim.DivRem(EInteger.FromInt32(vtp));
                            EInteger equo = divrem3[0];
                            EInteger erem = divrem3[1];
                            if (equo.CanFitInInt64() && erem.CanFitInInt64())
                            {
                                lquo = equo.ToInt64Checked();
                                lrem = erem.ToInt64Checked();
                            }
                        }
                        else
                        {
                            long ldividend = ((long)m) << dividendShift;
                            lquo = ldividend / vtp;
                            lrem = ldividend - (lquo * vtp);
                        }
                        int nexp = -dividendShift;
                        if (lquo >= (1L << 53))
                        {
                            while (lquo >= (1L << 54))
                            {
                                lrem |= lquo & 1L;
                                lquo >>= 1;
                                ++nexp;
                            }
                            if ((lquo & 3L) == 3 && lrem == 0)
                            {
                                lquo >>= 1;
                                ++lquo;
                                ++nexp;
                            }
                            else if ((lquo & 1L) != 0 && lrem != 0)
                            {
                                lquo >>= 1;
                                ++lquo;
                                ++nexp;
                            }
                            else
                            {
                                lquo >>= 1;
                                ++nexp;
                            }
                            while (lquo >= (1L << 53))
                            {
                                lquo >>= 1;
                                ++nexp;
                            }
                            // Clear the high bits where the exponent and sign are
                            lquo &= 0xfffffffffffffL;
                            // NOTE: Assumed not to be subnormal
                            lquo |= (long)(nexp + 1075) << 52;
                            if (this.IsNegative)
                            {
                                lquo |= unchecked((long)(1L << 63));
                            }
                            return lquo;
                        }
                    }
                }
                if (this.exponent.CompareToInt(309) > 0)
                {
                    // Very high exponent, treat as infinity
                    return this.IsNegative ? unchecked((long)0xfff0000000000000L) :
                      0x7ff0000000000000L;
                }
            }
            return this.ToEFloat(EContext.Binary64).ToDoubleBits();
        }

        /// <summary>Converts this value to its closest equivalent as a 64-bit
        /// floating-point number, using the half-even rounding mode.
        /// <para>If this value is a NaN, sets the high bit of the 64-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <returns>The closest 64-bit floating-point number to this value.
        /// The return value can be positive infinity or negative infinity if
        /// this value exceeds the range of a 64-bit floating point
        /// number.</returns>
        public double ToDouble()
        {
            long value = this.ToDoubleBits();
            return BitConverter.ToDouble(BitConverter.GetBytes((long)value), 0);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// discarding the fractional part in this value. Note that depending
        /// on the value, especially the exponent, generating the
        /// arbitrary-precision integer may require a huge amount of memory.
        /// Use the ToSizedEInteger method to convert a number to an EInteger
        /// only if the integer fits in a bounded bit range; that method will
        /// throw an exception on overflow.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='NotSupportedException'>There is not enough memory
        /// to store the value as an EInteger.</exception>
        public EInteger ToEInteger()
        {
            return this.ToEIntegerInternal(false);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// checking whether the fractional part of the value would be lost.
        /// Note that depending on the value, especially the exponent,
        /// generating the arbitrary-precision integer may require a huge
        /// amount of memory. Use the ToSizedEIntegerIfExact method to convert
        /// a number to an EInteger only if the integer fits in a bounded bit
        /// range; that method will throw an exception on overflow.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        [Obsolete("Renamed to ToEIntegerIfExact.")]
        public EInteger ToEIntegerExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// checking whether the fractional part of the value would be lost.
        /// Note that depending on the value, especially the exponent,
        /// generating the arbitrary-precision integer may require a huge
        /// amount of memory. Use the ToSizedEIntegerIfExact method to convert
        /// a number to an EInteger only if the integer fits in a bounded bit
        /// range; that method will throw an exception on overflow.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        public EInteger ToEIntegerIfExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <summary>Same as ToString(), except that when an exponent is used
        /// it will be a multiple of 3.</summary>
        /// <returns>A text string.</returns>
        public string ToEngineeringString()
        {
            return this.ToStringInternal(1);
        }

        /// <summary>Creates a binary floating-point number from this object's
        /// value. Note that if the binary floating-point number contains a
        /// negative exponent, the resulting value might not be exact, in which
        /// case the resulting binary floating-point number will be an
        /// approximation of this decimal number's value, using the half-even
        /// rounding mode.</summary>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        [Obsolete("Renamed to ToEFloat.")]
        public EFloat ToExtendedFloat()
        {
            return this.ToEFloat(EContext.UnlimitedHalfEven);
        }

        /// <summary>Creates a binary floating-point number from this object's
        /// value. Note that if the binary floating-point number contains a
        /// negative exponent, the resulting value might not be exact, in which
        /// case the resulting binary floating-point number will be an
        /// approximation of this decimal number's value, using the half-even
        /// rounding mode.</summary>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat ToEFloat()
        {
            return this.ToEFloat(EContext.UnlimitedHalfEven);
        }

        /// <summary>Converts this value to a string as though with the
        /// ToString method, but without using exponential notation.</summary>
        /// <returns>A text string.</returns>
        public string ToPlainString()
        {
            return this.ToStringInternal(2);
        }

        /// <summary>Converts this value to its closest equivalent as a 32-bit
        /// floating-point number encoded in the IEEE 754 binary32 format,
        /// using the half-even rounding mode.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN.</para></summary>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value, encoded in the IEEE 754 binary32 format. The return value
        /// can be positive infinity or negative infinity if this value exceeds
        /// the range of a 32-bit floating point number.</returns>
        public int ToSingleBits()
        {
            if (this.IsPositiveInfinity())
            {
                return 0x7f800000;
            }
            if (this.IsNegativeInfinity())
            {
                return unchecked((int)0xff800000);
            }
            if (this.IsNegative && this.IsZero)
            {
                return (int)1 << 31;
            }
            if (this.IsZero)
            {
                return 0;
            }
            if (this.IsFinite)
            {
                if (this.exponent.CompareToInt(0) == 0 &&
                  this.unsignedMantissa.CanFitInInt32())
                {
                    int v = this.unsignedMantissa.ToInt32();
                    if (v < (1 << 24))
                    {
                        // This integer fits exactly in float
                        return IntegerToSingleBits(v, 0, this.IsNegative);
                    }
                }
                if (this.exponent.CompareToInt(0) < 0 &&
                  this.exponent.CompareToInt(-6) >= 0 &&
                  this.unsignedMantissa.CanFitInInt32())
                {
                    int m = this.unsignedMantissa.ToInt32();
                    int iex = -this.exponent.ToInt32();
                    int vtp = ValueTenPowers[iex];
                    if (m >= -(1 << 23) && m < (1 << 23))
                    {
                        if (m % vtp == 0)
                        {
                            return IntegerToSingleBits(m / vtp, 0, this.IsNegative);
                        }
                        // Shift significand to be a 24-bit number (which
                        // can fit exactly in a single)
                        long am = Math.Abs(m);
                        while (am < (1 << 23))
                        {
                            am <<= 1;
                        }
                        int divdCount = NumberUtility.BitLength(m);
                        int divsCount = NumberUtility.BitLength(vtp);
                        int dividendShift = (divdCount <= divsCount) ? ((divsCount -
                              divdCount) + 24 + 1) : Math.Max(0,
                            (24 + 1) - (divdCount - divsCount));
                        long lquo = -1;
                        long lrem = -1;
                        if (divsCount + dividendShift > 63)
                        {
                            EInteger eim = EInteger.FromInt32(m).ShiftLeft(dividendShift);
                            EInteger[] divrem3 = eim.DivRem(EInteger.FromInt32(vtp));
                            EInteger equo = divrem3[0];
                            EInteger erem = divrem3[1];
                            if (equo.CanFitInInt64() && erem.CanFitInInt64())
                            {
                                lquo = equo.ToInt64Checked();
                                lrem = erem.ToInt64Checked();
                            }
                        }
                        else
                        {
                            long ldividend = ((long)m) << dividendShift;
                            lquo = ldividend / vtp;
                            lrem = ldividend - (lquo * vtp);
                        }
                        int nexp = -dividendShift;
                        if (lquo >= (1L << 24))
                        {
                            while (lquo >= (1L << 25))
                            {
                                lrem |= lquo & 1L;
                                lquo >>= 1;
                                ++nexp;
                            }
                            if ((lquo & 3L) == 3 && lrem == 0)
                            {
                                lquo >>= 1;
                                ++lquo;
                                ++nexp;
                            }
                            else if ((lquo & 1L) != 0 && lrem != 0)
                            {
                                lquo >>= 1;
                                ++lquo;
                                ++nexp;
                            }
                            else
                            {
                                lquo >>= 1;
                                ++nexp;
                            }
                            while (lquo >= (1L << 24))
                            {
                                lquo >>= 1;
                                ++nexp;
                            }
                            var smallmantissa = (int)(lquo & 0x7fffff);
                            // NOTE: Assumed not to be subnormal
                            smallmantissa |= (nexp + 150) << 23;
                            if (this.IsNegative)
                            {
                                smallmantissa |= 1 << 31;
                            }
                            return smallmantissa;
                        }
                    }
                }
                if (this.exponent.CompareToInt(39) > 0)
                {
                    // Very high exponent, treat as infinity
                    return this.IsNegative ? unchecked((int)0xff800000) :
                      0x7f800000;
                }
            }
            return this.ToEFloat(EContext.Binary32).ToSingleBits();
        }

        /// <summary>Converts this value to its closest equivalent as a 32-bit
        /// floating-point number, using the half-even rounding mode.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value. The return value can be positive infinity or negative
        /// infinity if this value exceeds the range of a 32-bit floating point
        /// number.</returns>
        public float ToSingle()
        {
            int sb = this.ToSingleBits();
            return BitConverter.ToSingle(BitConverter.GetBytes(sb), 0);
        }

        /// <summary>Converts this value to a string. Returns a value
        /// compatible with this class's FromString method.</summary>
        /// <returns>A string representation of this object. The text string
        /// will be in exponential notation if the exponent is greater than 0
        /// or if the number's first nonzero digit is more than five digits
        /// after the decimal point.</returns>
        public override string ToString()
        {
            return this.ToStringInternal(0);
        }

        /// <summary>Returns the unit in the last place. The significand will
        /// be 1 and the exponent will be this number's exponent. Returns 1
        /// with an exponent of 0 if this number is infinity or not-a-number
        /// (NaN).</summary>
        /// <returns>An arbitrary-precision decimal number.</returns>
        public EDecimal Ulp()
        {
            return (!this.IsFinite) ? EDecimal.One :
              EDecimal.Create(EInteger.One, this.Exponent);
        }

        internal static EDecimal CreateWithFlags(
          FastIntegerFixed mantissa,
          FastIntegerFixed exponent,
          int flags)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
#if DEBUG
            if (!(mantissa.Sign >= 0))
            {
                throw new ArgumentException("doesn't satisfy mantissa.Sign >= 0");
            }
#endif
            return new EDecimal(
                mantissa,
                exponent,
                (byte)flags);
        }

        internal static EDecimal CreateWithFlags(
          EInteger mantissa,
          EInteger exponent,
          int flags)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
#if DEBUG
            if (!(mantissa.Sign >= 0))
            {
                throw new ArgumentException("doesn't satisfy mantissa.Sign >= 0");
            }
#endif
            return new EDecimal(
                FastIntegerFixed.FromBig(mantissa),
                FastIntegerFixed.FromBig(exponent),
                (byte)flags);
        }
        private static bool AppendString(
          StringBuilder builder,
          char c,
          FastInteger count)
        {
            if (count.CompareToInt(Int32.MaxValue) > 0 || count.Sign < 0)
            {
                throw new NotSupportedException();
            }
            int icount = count.ToInt32();
            if (icount > RepeatDivideThreshold)
            {
                var sb2 = new StringBuilder(RepeatDivideThreshold);
                for (var i = 0; i < RepeatDivideThreshold; ++i)
                {
                    builder.Append(c);
                }
                string sb2str = sb2.ToString();
                int rem, count2;
                count2 = icount / RepeatDivideThreshold;
                rem = icount % RepeatDivideThreshold;
                for (var i = 0; i < count2; ++i)
                {
                    builder.Append(sb2str);
                }
                for (var i = 0; i < rem; ++i)
                {
                    builder.Append(c);
                }
            }
            else
            {
                for (var i = 0; i < icount; ++i)
                {
                    builder.Append(c);
                }
            }
            return true;
        }

        internal static IRadixMath<EDecimal> GetMathValue(EContext ctx)
        {
            if (ctx == null || ctx == EContext.UnlimitedHalfEven)
            {
                return ExtendedMathValue;
            }
            return (!ctx.IsSimplified && ctx.Traps == 0) ? ExtendedMathValue :
              MathValue;
        }

        private bool EqualsInternal(EDecimal otherValue)
        {
            return (otherValue != null) && (this.flags == otherValue.flags &&
                this.unsignedMantissa.Equals(otherValue.unsignedMantissa) &&
                this.exponent.Equals(otherValue.exponent));
        }

        private static EInteger[] GetAdjustedExponentDecimalBounds(
          EDecimal ed)
        {
            if (!ed.IsFinite)
            {
                return new EInteger[] { EInteger.Zero, EInteger.Zero };
            }
            if (ed.IsZero)
            {
                return new EInteger[] { EInteger.Zero, EInteger.Zero };
            }
            EInteger retEInt = ed.Exponent;
            EInteger[] sigPrecBounds = NumberUtility.DecimalDigitLengthBoundsAsEI(
                ed.UnsignedMantissa);
            EInteger eia = retEInt.Add(sigPrecBounds[0].Subtract(1));
            EInteger eib = retEInt.Add(sigPrecBounds[1].Subtract(1));
            return new EInteger[] {
        EInteger.Min(eia, eib),
        EInteger.Max(eia, eib),
      };
        }

        private static EInteger GetAdjustedExponentBinary(EFloat ef)
        {
            if (!ef.IsFinite)
            {
                return EInteger.Zero;
            }
            if (ef.IsZero)
            {
                return EInteger.Zero;
            }
            EInteger retEInt = ef.Exponent;
            EInteger valueEiPrecision =
              ef.UnsignedMantissa.GetSignedBitLengthAsEInteger();
            retEInt = retEInt.Add(valueEiPrecision.Subtract(1));
            return retEInt;
        }

        private EDecimal RoundToExponentFast(
          int exponentSmall,
          ERounding rounding)
        {
            if (this.IsFinite && this.exponent.CanFitInInt32() &&
              this.unsignedMantissa.CanFitInInt32())
            {
                int thisExponentSmall = this.exponent.ToInt32();
                if (thisExponentSmall == exponentSmall)
                {
                    return this;
                }
                if (thisExponentSmall >= -100 && thisExponentSmall <= 100 &&
                  exponentSmall >= -100 && exponentSmall <= 100)
                {
                    if (rounding == ERounding.Down)
                    {
                        int diff = exponentSmall - thisExponentSmall;
                        if (diff >= 1 && diff <= 9)
                        {
                            int thisMantissaSmall = this.unsignedMantissa.ToInt32();
                            thisMantissaSmall /= ValueTenPowers[diff];
                            return new EDecimal(
                                FastIntegerFixed.FromInt32(thisMantissaSmall),
                                FastIntegerFixed.FromInt32(exponentSmall),
                                this.flags);
                        }
                    }
                    else if (rounding == ERounding.HalfEven)
                    {
                        int diff = exponentSmall - thisExponentSmall;
                        int thisMantissaSmall = this.unsignedMantissa.ToInt32();
                        if (diff >= 1 && diff <= 9 && thisMantissaSmall != Int32.MaxValue)
                        {
                            int pwr = ValueTenPowers[diff - 1];
                            int div = thisMantissaSmall / pwr;
                            int div2 = (div > 43698) ? (div / 10) : ((div * 26215) >> 18);
                            // var div2 = (int)(((long)div*3435973837L) >> 35); // Division by 10
                            int rem = div - (div2 * 10);
                            if (rem > 5)
                            {
                                ++div2;
                            }
                            else if (rem == 5)
                            {
                                if ((div2 & 1) == 1 || (thisMantissaSmall - (div * pwr)) != 0)
                                {
                                    ++div2;
                                }
                            }
                            return new EDecimal(
                                FastIntegerFixed.FromInt32(div2),
                                FastIntegerFixed.FromInt32(exponentSmall),
                                this.flags);
                        }
                    }
                }
            }
            return null;
        }

        private bool IsIntegerPartZero()
        {
            // Returns whether the number, once its fractional part
            // is discarded, is zero.
            if (!this.IsFinite)
            {
                return false;
            }
            if (this.unsignedMantissa.IsValueZero)
            {
                return true;
            }
            int sign = this.Exponent.Sign;
            if (sign >= 0)
            {
                return false;
            }
            else
            {
                EInteger umantissa = this.UnsignedMantissa;
                EInteger[] bounds =
                  NumberUtility.DecimalDigitLengthBoundsAsEI(umantissa);
                EInteger digitCountUpper = bounds[1];
                EInteger digitCountLower = bounds[0];
                EInteger bigexponent = this.Exponent;
                return (digitCountUpper.CompareTo(bigexponent.Abs()) < 0) ? true :
                  ((digitCountLower.CompareTo(bigexponent.Abs()) > 0) ? false :
                    (this.CompareTo(-1) > 0 && this.CompareTo(1) < 0));
            }
        }

        private EInteger ToEIntegerInternal(bool exact)
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            int sign = this.Exponent.Sign;
            if (this.IsZero)
            {
                return EInteger.Zero;
            }
            if (sign == 0)
            {
                EInteger bigmantissa = this.Mantissa;
                return bigmantissa;
            }
            if (sign > 0)
            {
                EInteger exponent = this.Exponent;
                EInteger exponentBitSize = exponent.GetUnsignedBitLengthAsEInteger();
                if (exponentBitSize.CompareTo(64) > 0)
                {
                    throw new NotSupportedException(
                      "Not enough memory to store as EInteger.");
                }
                EInteger bigmantissa = this.Mantissa;
                EInteger bigexponent =
                  NumberUtility.FindPowerOfTenFromBig(this.Exponent);
                bigmantissa *= (EInteger)bigexponent;
                return bigmantissa;
            }
            else
            {
                if (exact && !this.unsignedMantissa.IsEvenNumber)
                {
                    // Mantissa is odd and will have to shift a nonzero
                    // number of digits, so can't be an exact integer
                    throw new ArithmeticException("Not an exact integer");
                }
                FastInteger bigexponent = this.exponent.ToFastInteger().Negate();
                EInteger bigmantissa = this.unsignedMantissa.ToEInteger();
                var acc = new DigitShiftAccumulator(bigmantissa, 0, 0);
                if (exact)
                {
                    if (!acc.TruncateRightExact(bigexponent))
                    {
                        // Some digits were discarded
                        throw new ArithmeticException("Not an exact integer");
                    }
                }
                else
                {
                    acc.TruncateRightSimple(bigexponent);
                }
                bigmantissa = acc.ShiftedInt;
                if (this.IsNegative)
                {
                    bigmantissa = -bigmantissa;
                }
                return bigmantissa;
            }
        }

        private static EInteger PowerOfRadixBitsLowerBound(EInteger e)
        {
            return e.Abs().Multiply(332).Divide(100).Add(1);
        }
        private static EInteger PowerOfRadixBitsUpperBound(EInteger e)
        {
            return e.Abs().Multiply(333).Divide(100).Add(1);
        }

        /// <summary>Converts this value to an arbitrary-precision integer by
        /// discarding its fractional part and checking whether the resulting
        /// integer overflows the given signed bit count.</summary>
        /// <param name='maxBitLength'>The maximum number of signed bits the
        /// integer can have. The integer's value may not be less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN), or this number's value, once converted to an
        /// integer by discarding its fractional part, is less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
        public EInteger ToSizedEInteger(int maxBitLength)
        {
            return this.ToSizedEInteger(maxBitLength, false);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// only if this number's value is an exact integer and that integer
        /// does not overflow the given signed bit count.</summary>
        /// <param name='maxBitLength'>The maximum number of signed bits the
        /// integer can have. The integer's value may not be less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN), or this number's value, once converted to an
        /// integer by discarding its fractional part, is less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        public EInteger ToSizedEIntegerIfExact(int maxBitLength)
        {
            return this.ToSizedEInteger(maxBitLength, true);
        }

        private EInteger ToSizedEInteger(int maxBitLength, bool exact)
        {
            if (maxBitLength < 0)
            {
                throw new ArgumentException("maxBitLength (" + maxBitLength +
                  ") is not greater or equal to 0");
            }
            if (!this.IsFinite || this.IsZero)
            {
                return exact ? this.ToEIntegerIfExact() : this.ToEInteger();
            }
            EInteger mant = this.Mantissa;
            EInteger exp = this.Exponent;
            if (exp.Sign > 0)
            {
                // x * 10^y
                long imantbits = mant.GetSignedBitLengthAsInt64();
                if (imantbits >= maxBitLength)
                {
                    throw new OverflowException("Value out of range");
                }
                if (exp.CompareTo(0x100000) < 0 && imantbits < 0x100000)
                {
                    // Lower bound of bit count in 10^exp based on ln(10^exp)/ln(2)
                    long expBitsLowerBound = (exp.ToInt64Checked() * 332 / 100) + 1;
                    if ((imantbits - 1) + expBitsLowerBound > maxBitLength)
                    {
                        throw new OverflowException("Value out of range");
                    }
                }
                else if (exp.CompareTo(maxBitLength) > 0)
                {
                    // Digits in exp is more than max bit length, so out of range
                    throw new OverflowException("Value out of range");
                }
                else
                {
                    EInteger mantbits = mant.GetSignedBitLengthAsEInteger();
                    if (mantbits.Subtract(1).Add(PowerOfRadixBitsLowerBound(exp))
                      .CompareTo(maxBitLength) > 0)
                    {
                        throw new OverflowException("Value out of range");
                    }
                }
                mant = exact ? this.ToEIntegerIfExact() : this.ToEInteger();
            }
            else if (exp.Sign < 0)
            {
                // x * 10^-y. Check for trivial overflow cases before
                // running ToEInteger.
                exp = exp.Abs();
                long imantbits = mant.GetSignedBitLengthAsInt64();
                if (exp.CompareTo(0x100000) < 0 && imantbits < 0x100000)
                {
                    long expBitsUpperBound = (exp.ToInt64Checked() * 333 / 100) + 1;
                    long expBitsLowerBound = (exp.ToInt64Checked() * 332 / 100) + 1;
                    if (imantbits - 1 - expBitsUpperBound > maxBitLength)
                    {
                        throw new OverflowException("Value out of range");
                    }
                    if (imantbits + 1 < expBitsLowerBound)
                    {
                        // Less than one, so not exact
                        if (exact)
                        {
                            throw new ArithmeticException("Not an exact integer");
                        }
                        else
                        {
                            return EInteger.FromInt32(0);
                        }
                    }
                }
                else if (imantbits < 0x100000 && exp.CompareTo(0x400000) >= 0)
                {
                    // (mant / 10^exp) would be less than one, so not exact
                    if (exact)
                    {
                        throw new ArithmeticException("Not an exact integer");
                    }
                    else
                    {
                        return EInteger.FromInt32(0);
                    }
                }
                else
                {
                    EInteger mantbits = mant.GetSignedBitLengthAsEInteger();
                    if (mantbits.Subtract(1).Subtract(PowerOfRadixBitsUpperBound(exp))
                      .CompareTo(maxBitLength) > 0)
                    {
                        throw new OverflowException("Value out of range");
                    }
                }
                mant = exact ? this.ToEIntegerIfExact() : this.ToEInteger();
            }
            if (mant.GetSignedBitLengthAsEInteger().CompareTo(maxBitLength) > 0)
            {
                throw new OverflowException("Value out of range");
            }
            return mant;
        }

        private static bool HasTerminatingBinaryExpansion(EInteger
          den)
        {
            if (den.IsZero)
            {
                return false;
            }
            if (den.GetUnsignedBit(0) && den.CompareTo(EInteger.One) != 0)
            {
                return false;
            }
            // NOTE: Equivalent to (den >> lowBit(den)) == 1
            return den.GetUnsignedBitLengthAsEInteger()
              .Equals(den.GetLowBitAsEInteger().Add(1));
        }

        private EFloat WithThisSign(EFloat ef)
        {
            return this.IsNegative ? ef.Negate() : ef;
        }

        /// <summary>Creates a binary floating-point number from this object's
        /// value. Note that if the binary floating-point number contains a
        /// negative exponent, the resulting value might not be exact, in which
        /// case the resulting binary floating-point number will be an
        /// approximation of this decimal number's value.</summary>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. The precision is in
        /// bits, and an example of this parameter is <c>EContext.Binary64</c>. Can be null.</param>
        /// <returns>An arbitrary-precision float floating-point
        /// number.</returns>
        public EFloat ToEFloat(EContext ec)
        {
            EInteger bigintExp = this.Exponent;
            EInteger bigUnsignedMantissa = this.UnsignedMantissa;
            if (this.IsNaN())
            {
                return EFloat.CreateNaN(
                    this.UnsignedMantissa,
                    this.IsSignalingNaN(),
                    this.IsNegative,
                    ec);
            }
            if (this.IsPositiveInfinity())
            {
                return EFloat.PositiveInfinity.RoundToPrecision(ec);
            }
            if (this.IsNegativeInfinity())
            {
                return EFloat.NegativeInfinity.RoundToPrecision(ec);
            }
            if (bigUnsignedMantissa.IsZero)
            {
                return this.IsNegative ? EFloat.NegativeZero.RoundToPrecision(ec) :
                  EFloat.Zero.RoundToPrecision(ec);
            }
            if (bigintExp.IsZero)
            {
                // Integer
                // DebugUtility.Log("Integer");
                return this.WithThisSign(EFloat.FromEInteger(bigUnsignedMantissa))
                  .RoundToPrecision(ec);
            }
            EContext b64 = EContext.Binary64;
            if (ec != null && ec.HasMaxPrecision &&
              ec.HasExponentRange &&
              !ec.IsSimplified && ec.EMax.CompareTo(b64.EMax) <= 0 &&
              ec.EMin.CompareTo(b64.EMin) >= 0 &&
              ec.Precision.CompareTo(b64.Precision) <= 0)
            {
                // Quick check for overflow or underflow
                EInteger[] bounds =
                  NumberUtility.DecimalDigitLengthBoundsAsEI(bigUnsignedMantissa);
                EInteger digitCountUpper = bounds[1];
                EInteger adjexpLowerBound = bigintExp;
                EInteger adjexpUpperBound = bigintExp.Add(
                    digitCountUpper.Subtract(1));
                if (adjexpUpperBound.CompareTo(-326) < 0)
                {
                    // Underflow to zero
                    EInteger eTiny = ec.EMin.Subtract(ec.Precision.Subtract(1));
                    eTiny = eTiny.Subtract(2); // subtract 2 from proper eTiny to
                                               // trigger underflow (2, rather than 1, because of HalfUp mode)
                    EFloat ret = EFloat.Create(EInteger.FromInt32(
                          this.IsNegative ? -1 : 1),
                        eTiny);
                    return ret.RoundToPrecision(ec);
                }
                else if (adjexpLowerBound.CompareTo(309) > 0)
                {
                    return EFloat.GetMathValue().SignalOverflow(ec, this.IsNegative);
                }
                EInteger digitCountLower = bounds[0];
                if (bigintExp.Sign >= 0 &&
                  digitCountLower.Subtract(2).CompareTo(309) > 0)
                {
                    return EFloat.GetMathValue().SignalOverflow(ec, this.IsNegative);
                }
                else if (digitCountLower.Add(bigintExp).Subtract(2).CompareTo(309) >
                0)
                {
                    return EFloat.GetMathValue().SignalOverflow(ec, this.IsNegative);
                }
            }
            if (bigintExp.Sign > 0)
            {
                // Scaled integer
                // --- Optimizations for Binary32 and Binary64
                if (ec == EContext.Binary32)
                {
                    if (bigintExp.CompareTo(39) > 0)
                    {
                        return this.IsNegative ? EFloat.NegativeInfinity :
                          EFloat.PositiveInfinity;
                    }
                }
                else if (ec == EContext.Binary64)
                {
                    if (bigintExp.CompareTo(309) > 0)
                    {
                        return this.IsNegative ? EFloat.NegativeInfinity :
                          EFloat.PositiveInfinity;
                    }
                }
                // --- End optimizations for Binary32 and Binary64
                // DebugUtility.Log("Scaled integer");
                EInteger bigmantissa = bigUnsignedMantissa;
                bigintExp = NumberUtility.FindPowerOfTenFromBig(bigintExp);
                bigmantissa *= (EInteger)bigintExp;
                return this.WithThisSign(EFloat.FromEInteger(bigmantissa))
                  .RoundToPrecision(ec);
            }
            else
            {
                // Fractional number
                // DebugUtility.Log("Fractional");
                EInteger scale = bigintExp;
                EInteger bigmantissa = bigUnsignedMantissa;
                EInteger negscale = -scale;
                EInteger divisor = NumberUtility.FindPowerOfTenFromBig(negscale);
                ec = ec ?? EContext.UnlimitedHalfEven;
                if (ec.HasMaxPrecision)
                {
                    EFloat efNum = EFloat.FromEInteger(bigmantissa);
                    if (this.Sign < 0)
                    {
                        efNum = efNum.Negate();
                    }
                    EFloat efDen = EFloat.FromEInteger(divisor);
                    return efNum.Divide(efDen, ec);
                }
                else if (!ec.HasFlagsOrTraps)
                {
                    EFloat efNum = EFloat.FromEInteger(bigmantissa);
                    if (this.Sign < 0)
                    {
                        efNum = efNum.Negate();
                    }
                    EFloat efDen = EFloat.FromEInteger(divisor);
                    EFloat ret = efNum.Divide(efDen, ec);
                    if (!ret.IsNaN())
                    {
                        return ret;
                    }
                    EInteger bitprec = bigmantissa.GetUnsignedBitLengthAsEInteger();
                    bitprec = EInteger.Max(bitprec, EInteger.FromInt32(53));
                    return efNum.Divide(
                        efDen,
                        ec.WithBigPrecision(bitprec));
                }
                else if (ec.Traps != 0)
                {
                    EContext tctx = ec.GetNontrapping();
                    EFloat ret = this.ToEFloat(tctx);
                    return ec.TriggerTraps(ret, tctx);
                }
                else
                {
                    EContext tmpctx = ec.WithBlankFlags();
                    EFloat efNum = EFloat.FromEInteger(bigmantissa);
                    if (this.Sign < 0)
                    {
                        efNum = efNum.Negate();
                    }
                    EFloat efDen = EFloat.FromEInteger(divisor);
                    EFloat ret = efNum.Divide(efDen, tmpctx);
                    if (!ret.IsNaN())
                    {
                        ec.Flags |= tmpctx.Flags;
                        return ret;
                    }
                    EInteger bitprec = bigmantissa.GetUnsignedBitLengthAsEInteger();
                    bitprec = EInteger.Max(bitprec, EInteger.FromInt32(53));
                    tmpctx = ec.WithBigPrecision(bitprec).WithBlankFlags();
                    ret = efNum.Divide(efDen, tmpctx);
                    ec.Flags |= tmpctx.Flags;
                    return ret;
                }
            }
        }

        private string ToStringInternal(int mode)
        {
            bool negative = (this.flags & BigNumberFlags.FlagNegative) != 0;
            if (!this.IsFinite)
            {
                if ((this.flags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return negative ? "-Infinity" : "Infinity";
                }
                if ((this.flags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.unsignedMantissa.IsValueZero ?
                      (negative ? "-sNaN" : "sNaN") :
                      (negative ? "-sNaN" + this.unsignedMantissa :
                        "sNaN" + this.unsignedMantissa);
                }
                if ((this.flags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    return this.unsignedMantissa.IsValueZero ? (negative ?
                        "-NaN" : "NaN") : (negative ? "-NaN" + this.unsignedMantissa :
                        "NaN" + this.unsignedMantissa);
                }
            }
            int scaleSign = -this.exponent.Sign;
            string mantissaString;
            if (scaleSign == 0)
            {
                mantissaString = this.unsignedMantissa.ToString();
                return negative ? "-" + mantissaString : mantissaString;
            }
            bool iszero = this.unsignedMantissa.IsValueZero;
            if (mode == 2 && iszero && scaleSign < 0)
            {
                // special case for zero in plain
                mantissaString = this.unsignedMantissa.ToString();
                return negative ? "-" + mantissaString : mantissaString;
            }
            if (mode == 0 && this.unsignedMantissa.CanFitInInt32() &&
              this.exponent.CanFitInInt32())
            {
                int intExp = this.exponent.ToInt32();
                int intMant = this.unsignedMantissa.ToInt32();
                if (intMant < 1000 && intExp == -2)
                {
                    int a, b, c;
                    var i = 0;
                    a = intMant % 10;
                    intMant /= 10;
                    b = intMant % 10;
                    intMant /= 10;
                    c = intMant;
                    int clength = (negative ? 1 : 0) + 4;
                    var chars = new char[clength];
                    if (negative)
                    {
                        chars[i++] = '-';
                    }
                    chars[i++] = (char)(0x30 + c);
                    chars[i++] = '.';
                    chars[i++] = (char)(0x30 + b);
                    chars[i++] = (char)(0x30 + a);
                    return new String(chars, 0, clength);
                }
                else if (intMant < 100 && intExp == -1)
                {
                    int a, b;
                    var i = 0;
                    a = intMant % 10;
                    intMant /= 10;
                    b = intMant;
                    int clength = (negative ? 1 : 0) + 3;
                    var chars = new char[clength];
                    if (negative)
                    {
                        chars[i++] = '-';
                    }
                    chars[i++] = (char)(0x30 + b);
                    chars[i++] = '.';
                    chars[i++] = (char)(0x30 + a);
                    return new String(chars, 0, clength);
                }
            }
            mantissaString = this.unsignedMantissa.ToString();
            if (mode == 0 && mantissaString.Length < 100 &&
              this.exponent.CanFitInInt32())
            {
                int intExp = this.exponent.ToInt32();
                if (intExp > -100 && intExp < 100)
                {
                    int adj = (intExp + mantissaString.Length) - 1;
                    if (scaleSign >= 0 && adj >= -6)
                    {
                        if (scaleSign > 0)
                        {
                            int ms = mantissaString.Length;
                            int dp = intExp + ms;
                            if (dp < 0)
                            {
                                dp = -dp;
                                int clength = 2 + dp + (negative ? 1 : 0) + ms;
                                var chars = new char[clength];
                                var i = 0;
                                if (negative)
                                {
                                    chars[i++] = '-';
                                }
                                chars[i++] = '0';
                                chars[i++] = '.';
                                for (var j = 0; j < dp; ++j)
                                {
                                    chars[i++] = '0';
                                }
                                for (var j = 0; j < ms; ++j)
                                {
                                    chars[i++] = mantissaString[j];
                                }
                                return new String(chars, 0, clength);
                            }
                            else if (dp == 0)
                            {
                                int clength = 2 + (negative ? 1 : 0) + ms;
                                var chars = new char[clength];
                                var i = 0;
                                if (negative)
                                {
                                    chars[i++] = '-';
                                }
                                chars[i++] = '0';
                                chars[i++] = '.';
                                for (var j = 0; j < ms; ++j)
                                {
                                    chars[i++] = mantissaString[j];
                                }
                                return new String(chars, 0, clength);
                            }
                            else if (dp > 0 && dp <= ms)
                            {
                                int clength = 1 + (negative ? 1 : 0) + ms;
                                var chars = new char[clength];
                                var i = 0;
                                var j = 0;
                                if (negative)
                                {
                                    chars[i++] = '-';
                                }
                                for (j = 0; j < dp; ++j)
                                {
                                    chars[i++] = mantissaString[j];
                                }
                                chars[i++] = '.';
                                for (j = dp; j < ms; ++j)
                                {
                                    chars[i++] = mantissaString[j];
                                }
                                return new String(chars, 0, clength);
                            }
                        }
                    }
                }
            }
            StringBuilder builder = null;
            FastInteger adjustedExponent = FastInteger.FromBig(this.Exponent);
            var builderLength = new FastInteger(mantissaString.Length);
            FastInteger thisExponent = adjustedExponent.Copy();
            adjustedExponent.Add(builderLength).Decrement();
            var decimalPointAdjust = new FastInteger(1);
            var threshold = new FastInteger(-6);
            if (mode == 1)
            {
                // engineering string adjustments
                FastInteger newExponent = adjustedExponent.Copy();
                bool adjExponentNegative = adjustedExponent.Sign < 0;
                int intphase = adjustedExponent.Copy().Abs().Remainder(3).ToInt32();
                if (iszero && (adjustedExponent.CompareTo(threshold) < 0 || scaleSign <
                    0))
                {
                    if (intphase == 1)
                    {
                        if (adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Increment();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(2);
                        }
                    }
                    else if (intphase == 2)
                    {
                        if (!adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Increment();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(2);
                        }
                    }
                    threshold.Increment();
                }
                else
                {
                    if (intphase == 1)
                    {
                        if (!adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Decrement();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(-2);
                        }
                    }
                    else if (intphase == 2)
                    {
                        if (adjExponentNegative)
                        {
                            decimalPointAdjust.Increment();
                            newExponent.Decrement();
                        }
                        else
                        {
                            decimalPointAdjust.AddInt(2);
                            newExponent.AddInt(-2);
                        }
                    }
                }
                adjustedExponent = newExponent;
            }
            if (mode == 2 || (adjustedExponent.CompareTo(threshold) >= 0 &&
                scaleSign >= 0))
            {
                if (scaleSign > 0)
                {
                    FastInteger decimalPoint = thisExponent.Copy().Add(builderLength);
                    int cmp = decimalPoint.CompareToInt(0);
                    builder = null;
                    if (cmp < 0)
                    {
                        var tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                          0 ? Int32.MaxValue : tmpFast.ToInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append("0.");
                        AppendString(builder, '0', decimalPoint.Copy().Negate());
                        builder.Append(mantissaString);
                    }
                    else if (cmp == 0)
                    {
#if DEBUG
                        if (!decimalPoint.CanFitInInt32())
                        {
                            throw new ArgumentException("doesn't satisfy" +
                              "\u0020decimalPoint.CanFitInInt32()");
                        }
                        if (decimalPoint.ToInt32() != 0)
                        {
                            throw new ArgumentException("doesn't satisfy" +
                              "\u0020decimalPoint.ToInt32() == 0");
                        }
#endif

                        var tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                          0 ? Int32.MaxValue : tmpFast.ToInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append("0.");
                        builder.Append(mantissaString);
                    }
                    else if (decimalPoint.CompareToInt(mantissaString.Length) > 0)
                    {
                        FastInteger insertionPoint = builderLength;
                        if (!insertionPoint.CanFitInInt32())
                        {
                            throw new NotSupportedException();
                        }
                        int tmpInt = insertionPoint.ToInt32();
                        if (tmpInt < 0)
                        {
                            tmpInt = 0;
                        }
                        var tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                          0 ? Int32.MaxValue : tmpFast.ToInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString, 0, tmpInt);
                        AppendString(
                          builder,
                          '0',
                          decimalPoint.Copy().SubtractInt(builder.Length));
                        builder.Append('.');
                        builder.Append(
                          mantissaString,
                          tmpInt,
                          mantissaString.Length - tmpInt);
                    }
                    else
                    {
                        if (!decimalPoint.CanFitInInt32())
                        {
                            throw new NotSupportedException();
                        }
                        int tmpInt = decimalPoint.ToInt32();
                        if (tmpInt < 0)
                        {
                            tmpInt = 0;
                        }
                        var tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                          0 ? Int32.MaxValue : tmpFast.ToInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString, 0, tmpInt);
                        builder.Append('.');
                        builder.Append(
                          mantissaString,
                          tmpInt,
                          mantissaString.Length - tmpInt);
                    }
                    return builder.ToString();
                }
                if (mode == 2 && scaleSign < 0)
                {
                    FastInteger negscale = thisExponent.Copy();
                    builder = new StringBuilder();
                    if (negative)
                    {
                        builder.Append('-');
                    }
                    builder.Append(mantissaString);
                    AppendString(builder, '0', negscale);
                    return builder.ToString();
                }
                return (!negative) ? mantissaString : ("-" + mantissaString);
            }
            else
            {
                if (mode == 1 && iszero && decimalPointAdjust.CompareToInt(1) > 0)
                {
                    builder = new StringBuilder();
                    if (negative)
                    {
                        builder.Append('-');
                    }
                    builder.Append(mantissaString);
                    builder.Append('.');
                    AppendString(
                      builder,
                      '0',
                      decimalPointAdjust.Copy().Decrement());
                }
                else
                {
                    FastInteger tmp = decimalPointAdjust.Copy();
                    int cmp = tmp.CompareToInt(mantissaString.Length);
                    if (cmp > 0)
                    {
                        tmp.SubtractInt(mantissaString.Length);
                        builder = new StringBuilder();
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString);
                        AppendString(builder, '0', tmp);
                    }
                    else if (cmp < 0)
                    {
                        // Insert a decimal point at the right place
                        if (!tmp.CanFitInInt32())
                        {
                            throw new NotSupportedException();
                        }
                        int tmpInt = tmp.ToInt32();
                        if (tmp.Sign < 0)
                        {
                            tmpInt = 0;
                        }
                        var tmpFast = new FastInteger(mantissaString.Length).AddInt(6);
                        builder = new StringBuilder(tmpFast.CompareToInt(Int32.MaxValue) >
                          0 ? Int32.MaxValue : tmpFast.ToInt32());
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString, 0, tmpInt);
                        builder.Append('.');
                        builder.Append(
                          mantissaString,
                          tmpInt,
                          mantissaString.Length - tmpInt);
                    }
                    else if (adjustedExponent.Sign == 0 && !negative)
                    {
                        return mantissaString;
                    }
                    else if (adjustedExponent.Sign == 0 && negative)
                    {
                        return "-" + mantissaString;
                    }
                    else
                    {
                        builder = new StringBuilder();
                        if (negative)
                        {
                            builder.Append('-');
                        }
                        builder.Append(mantissaString);
                    }
                }
                if (adjustedExponent.Sign != 0)
                {
                    builder.Append(adjustedExponent.Sign < 0 ? "E-" : "E+");
                    adjustedExponent.Abs();
                    builder.Append(adjustedExponent.ToString());
                }
                return builder.ToString();
            }
        }

        private sealed class DecimalMathHelper : IRadixMathHelper<EDecimal>
        {
            /// <summary>This is an internal method.</summary>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetRadix()
            {
                return 10;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision decimal number.</param>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetSign(EDecimal value)
            {
                return value.Sign;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision decimal number.</param>
            /// <returns>An arbitrary-precision integer.</returns>
            public EInteger GetMantissa(EDecimal value)
            {
                return value.unsignedMantissa.ToEInteger();
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision decimal number.</param>
            /// <returns>An arbitrary-precision integer.</returns>
            public EInteger GetExponent(EDecimal value)
            {
                return value.exponent.ToEInteger();
            }

            public FastIntegerFixed GetMantissaFastInt(EDecimal value)
            {
                return value.unsignedMantissa;
            }

            public FastIntegerFixed GetExponentFastInt(EDecimal value)
            {
                return value.exponent;
            }

            public FastInteger GetDigitLength(EInteger ei)
            {
                long i64 = ei.GetDigitCountAsInt64();
                if (i64 != Int64.MaxValue)
                {
                    return FastInteger.FromInt64(i64);
                }
                else
                {
                    return FastInteger.FromBig(ei.GetDigitCountAsEInteger());
                }
            }

            public IShiftAccumulator CreateShiftAccumulatorWithDigits(
              EInteger bigint,
              int lastDigit,
              int olderDigits)
            {
                return new DigitShiftAccumulator(bigint, lastDigit, olderDigits);
            }

            public IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(
              FastIntegerFixed fastInt,
              int lastDigit,
              int olderDigits)
            {
                if (fastInt.CanFitInInt32())
                {
                    return new DigitShiftAccumulator(
                        fastInt.ToInt32(),
                        lastDigit,
                        olderDigits);
                }
                else
                {
                    return new DigitShiftAccumulator(
                        fastInt.ToEInteger(),
                        lastDigit,
                        olderDigits);
                }
            }
            public FastInteger DivisionShift(
              EInteger num,
              EInteger den)
            {
                if (den.IsZero)
                {
                    return null;
                }
                EInteger gcd = den.Gcd(EInteger.FromInt32(10));
                if (gcd.CompareTo(EInteger.One) == 0)
                {
                    return null;
                }
                if (den.IsZero)
                {
                    return null;
                }
                // Eliminate factors of 2
                EInteger elowbit = den.GetLowBitAsEInteger();
                den = den.ShiftRight(elowbit);
                // Eliminate factors of 5
                var fiveShift = new FastInteger(0);
                while (true)
                {
                    EInteger bigrem;
                    EInteger bigquo;
                    {
                        EInteger[] divrem = den.DivRem((EInteger)5);
                        bigquo = divrem[0];
                        bigrem = divrem[1];
                    }
                    if (!bigrem.IsZero)
                    {
                        break;
                    }
                    fiveShift.Increment();
                    den = bigquo;
                }
                if (den.CompareTo(EInteger.One) != 0)
                {
                    return null;
                }
                FastInteger fastlowbit = FastInteger.FromBig(elowbit);
                if (fiveShift.CompareTo(fastlowbit) > 0)
                {
                    return fiveShift;
                }
                else
                {
                    return fastlowbit;
                }
            }

            public FastIntegerFixed MultiplyByRadixPowerFastInt(
              FastIntegerFixed fbigint,
              FastIntegerFixed fpower)
            {
                // DebugUtility.Log("mbrp "+fbigint+"/"+fpower);
                if (fbigint.IsValueZero)
                {
                    return fbigint;
                }
                bool fitsInInt32 = fpower.CanFitInInt32();
                int powerInt = fitsInInt32 ? fpower.ToInt32() : 0;
                if (fitsInInt32 && powerInt == 0)
                {
                    return fbigint;
                }
                EInteger bigint = fbigint.ToEInteger();
                EInteger ret = null;
                if (bigint.CompareTo(1) != 0)
                {
                    if (fitsInInt32)
                    {
                        ret = NumberUtility.MultiplyByPowerOfTen(bigint, powerInt);
                    }
                    else
                    {
                        EInteger eipower = fpower.ToEInteger();
                        ret = NumberUtility.MultiplyByPowerOfTen(bigint, eipower);
                    }
                }
                else
                {
                    ret = fitsInInt32 ? NumberUtility.FindPowerOfTen(powerInt) :
                      NumberUtility.FindPowerOfTenFromBig(fpower.ToEInteger());
                }
                return FastIntegerFixed.FromBig(ret);
            }

            public EInteger MultiplyByRadixPower(
              EInteger bigint,
              FastInteger power)
            {
                if (bigint.IsZero)
                {
                    return bigint;
                }
                bool fitsInInt32 = power.CanFitInInt32();
                int powerInt = fitsInInt32 ? power.ToInt32() : 0;
                if (fitsInInt32 && powerInt == 0)
                {
                    return bigint;
                }
                if (bigint.CompareTo(1) != 0)
                {
                    if (fitsInInt32)
                    {
                        return NumberUtility.MultiplyByPowerOfTen(bigint, powerInt);
                    }
                    else
                    {
                        EInteger eipower = power.ToEInteger();
                        return NumberUtility.MultiplyByPowerOfTen(bigint, eipower);
                    }
                }
                return fitsInInt32 ? NumberUtility.FindPowerOfTen(powerInt) :
                  NumberUtility.FindPowerOfTenFromBig(power.ToEInteger());
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision decimal number.</param>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetFlags(EDecimal value)
            {
                return ((int)value.flags) & 0xff;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='mantissa'>The parameter <paramref name='mantissa'/> is
            /// a Numbers.EInteger object.</param>
            /// <param name='exponent'>The parameter <paramref name='exponent'/> is
            /// an internal parameter.</param>
            /// <param name='flags'>The parameter <paramref name='flags'/> is an
            /// internal parameter.</param>
            /// <returns>An arbitrary-precision decimal number.</returns>
            public EDecimal CreateNewWithFlags(
              EInteger mantissa,
              EInteger exponent,
              int flags)
            {
                return CreateWithFlags(
                    FastIntegerFixed.FromBig(mantissa),
                    FastIntegerFixed.FromBig(exponent),
                    flags);
            }

            public EDecimal CreateNewWithFlagsFastInt(
              FastIntegerFixed fmantissa,
              FastIntegerFixed fexponent,
              int flags)
            {
                return CreateWithFlags(fmantissa, fexponent, flags);
            }

            /// <summary>This is an internal method.</summary>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetArithmeticSupport()
            {
                return BigNumberFlags.FiniteAndNonFinite;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='val'>The parameter <paramref name='val'/> is a 32-bit
            /// signed integer.</param>
            /// <returns>An arbitrary-precision decimal number.</returns>
            public EDecimal ValueOf(int val)
            {
                return (val == 0) ? Zero : ((val == 1) ? One : FromInt64(val));
            }
        }

        /// <summary>Returns one added to this arbitrary-precision decimal
        /// number.</summary>
        /// <returns>The given arbitrary-precision decimal number plus
        /// one.</returns>
        public EDecimal Increment()
        {
            return this.Add(1);
        }

        /// <summary>Returns one subtracted from this arbitrary-precision
        /// decimal number.</summary>
        /// <returns>The given arbitrary-precision decimal number minus
        /// one.</returns>
        public EDecimal Decrement()
        {
            return this.Subtract(1);
        }

        // Begin integer conversions
        private void CheckTrivialOverflow(int maxDigits)
        {
            if (this.IsZero)
            {
                return;
            }
            if (this.exponent.Sign < 0)
            {
                EInteger bigexponent = this.Exponent;
                EInteger bigmantissa = this.UnsignedMantissa;
                bigexponent = bigexponent.Abs();
                bigmantissa = bigmantissa.Abs();
                EInteger lowerBound =
                  NumberUtility.DecimalDigitLengthBoundsAsEI(bigmantissa)[0];
                if (lowerBound.Subtract(bigexponent).CompareTo(maxDigits) > 0)
                {
                    throw new OverflowException("Value out of range");
                }
            }
            else
            {
                if (this.exponent.CompareToInt(maxDigits) >= 0)
                {
                    throw new OverflowException("Value out of range");
                }
            }
        }

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255) after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a byte (from 0 to
        /// 255).</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 255.</exception>
        public byte ToByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(3);
            if (this.IsIntegerPartZero())
            {
                return (byte)0;
            }
            else if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEInteger().ToByteChecked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a byte (from 0 to 255).</summary>
        /// <returns>This number, converted to a byte (from 0 to 255). Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public byte ToByteUnchecked()
        {
            if (this.IsFinite)
            {
                if (this.IsIntegerPartZero())
                {
                    return (byte)0;
                }
                if (this.exponent.CompareToInt(8) >= 0)
                {
                    /* Whether positive or negative, 10^x mod 256 is always 0
                        for x >= 8 */
                    return (byte)0;
                }
                return this.ToEInteger().ToByteUnchecked();
            }
            return (byte)0;
        }

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255) without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a byte (from 0 to 255).</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 255.</exception>
        public byte ToByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsNegative && !this.IsZero)
            {
                throw new OverflowException("Value out of range");
            }
            this.CheckTrivialOverflow(3);
            return this.ToEIntegerIfExact().ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>This number's value as an arbitrary-precision decimal
        /// number.</returns>
        public static EDecimal FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 16-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -32768 or greater than
        /// 32767.</exception>
        public short ToInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(5);
            return this.IsIntegerPartZero() ? ((short)0) :
              this.ToEInteger().ToInt16Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 16-bit signed integer.</summary>
        /// <returns>This number, converted to a 16-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public short ToInt16Unchecked()
        {
            if (this.IsFinite)
            {
                if (this.IsIntegerPartZero())
                {
                    return (short)0;
                }
                if (this.exponent.CompareToInt(16) >= 0)
                {
                    /* Whether positive or negative, 10^x mod 65536 is always 0
                        for x >= 16 */
                    return (short)0;
                }
                return this.ToEInteger().ToInt16Unchecked();
            }
            return (short)0;
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 16-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -32768 or
        /// greater than 32767.</exception>
        public short ToInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(5);
            return this.ToEIntegerIfExact().ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision decimal
        /// number.</returns>
        public static EDecimal FromInt16(short inputInt16)
        {
            var val = (int)inputInt16;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -2147483648 or greater
        /// than 2147483647.</exception>
        public int ToInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(10);
            return this.IsIntegerPartZero() ? ((int)0) :
              this.ToEInteger().ToInt32Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 32-bit signed integer.</summary>
        /// <returns>This number, converted to a 32-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public int ToInt32Unchecked()
        {
            if (this.IsFinite)
            {
                if (this.IsIntegerPartZero())
                {
                    return 0;
                }
                if (this.exponent.CompareToInt(32) >= 0)
                {
                    /* Whether positive or negative, 10^x mod 2^32 is always 0
                        for x >= 32 */
                    return 0;
                }
                return this.ToEInteger().ToInt32Unchecked();
            }
            return 0;
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -2147483648
        /// or greater than 2147483647.</exception>
        public int ToInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (int)0;
            }
            this.CheckTrivialOverflow(10);
            return this.ToEIntegerIfExact().ToInt32Checked();
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 64-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -9223372036854775808
        /// or greater than 9223372036854775807.</exception>
        public long ToInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(19);
            return this.IsIntegerPartZero() ? 0L : this.ToEInteger().ToInt64Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 64-bit signed integer.</summary>
        /// <returns>This number, converted to a 64-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public long ToInt64Unchecked()
        {
            if (this.IsFinite)
            {
                if (this.IsIntegerPartZero())
                {
                    return 0L;
                }
                if (this.exponent.CompareToInt(64) >= 0)
                {
                    /* Whether positive or negative, 10^x mod 2^64 is always 0
                        for x >= 64 */
                    return 0L;
                }
                return this.ToEInteger().ToInt64Unchecked();
            }
            return 0L;
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 64-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than
        /// -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        public long ToInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return 0L;
            }
            this.CheckTrivialOverflow(19);
            return this.ToEIntegerIfExact().ToInt64Checked();
        }
        // End integer conversions
    }

    public sealed partial class EDecimal
    {
        /// <summary>Converts this value to a <c>decimal</c> under the Common
        /// Language Infrastructure (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
        /// using the half-even rounding mode.</summary>
        /// <returns>A <c>decimal</c> under the Common Language Infrastructure
        /// (usually a.NET Framework decimal).</returns>
        public decimal ToDecimal()
        {
            EDecimal extendedNumber = this;
            if (extendedNumber.IsInfinity() || extendedNumber.IsNaN())
            {
                throw new OverflowException("This object's value is out of range");
            }
            decimal ret;
            System.Globalization.NumberStyles
            ns = System.Globalization.NumberStyles.Number |
              System.Globalization.NumberStyles.AllowExponent;
            if (
              Decimal.TryParse(
                this.ToString(),
                ns,
                System.Globalization.CultureInfo.InvariantCulture,
                out ret))
            {
                return ret;
            }
            throw new OverflowException("This object's value is out of range");
        }

        /// <summary>Converts a <c>decimal</c> under the Common Language
        /// Infrastructure (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) to
        /// an arbitrary-precision decimal.</summary>
        /// <param name='dec'>A <c>decimal</c> under the Common Language
        /// Infrastructure (usually a.NET Framework decimal).</param>
        /// <returns>An arbitrary-precision decimal floating-point
        /// number.</returns>
        public static EDecimal FromDecimal(decimal dec)
        {
            return

              EDecimal.FromString(
                dec.ToString(System.Globalization.CultureInfo.InvariantCulture));
        }

        /// <summary>Converts a boolean value (true or false) to an arbitrary
        /// precision decimal.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>The number 1 if <paramref name='boolValue'/> is true;
        /// otherwise, 0.</returns>
        public static explicit operator EDecimal(bool boolValue)
        {
            return FromBoolean(boolValue);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a
        /// <c>decimal</c> under the Common Language Infrastructure (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
        /// using the half-even rounding mode.</summary>
        /// <param name='dec'>The number to convert as an arbitrary-precision
        /// decimal floating-point number.</param>
        /// <returns>A <c>decimal</c> under the Common Language Infrastructure
        /// (usually a.NET Framework decimal).</returns>
        public static implicit operator EDecimal(decimal dec)
        {
            return FromDecimal(dec);
        }

        /// <summary>Converts an arbitrary-precision decimal's value to a
        /// <c>decimal</c> under the Common Language Infrastructure (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
        /// using the half-even rounding mode.</summary>
        /// <param name='bigValue'>The parameter <paramref name='bigValue'/> is
        /// an arbitrary-precision decimal floating-point number.</param>
        /// <returns>A <c>decimal</c> under the Common Language Infrastructure
        /// (usually a.NET Framework decimal).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator decimal(EDecimal bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToDecimal();
        }

        /// <summary>Converts an arbitrary-precision integer to an arbitrary
        /// precision decimal.</summary>
        /// <param name='eint'>An arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision decimal number with the exponent
        /// set to 0.</returns>
        public static implicit operator EDecimal(EInteger eint)
        {
            return FromEInteger(eint);
        }

        /// <summary>Adds an arbitrary-precision decimal floating-point number
        /// and another arbitrary-precision decimal floating-point number and
        /// returns the result.</summary>
        /// <param name='bthis'>The first arbitrary-precision decimal
        /// floating-point number.</param>
        /// <param name='otherValue'>The second decimal binary floating-point
        /// number.</param>
        /// <returns>The sum of the two numbers, that is, an
        /// arbitrary-precision decimal floating-point number plus another
        /// arbitrary-precision decimal floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> or <paramref name='otherValue'/> is
        /// null.</exception>
        public static EDecimal operator +(EDecimal bthis, EDecimal otherValue)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(otherValue);
        }

        /// <summary>Subtracts one arbitrary-precision decimal number from
        /// another and returns the result.</summary>
        /// <param name='bthis'>The first operand.</param>
        /// <param name='subtrahend'>The second operand.</param>
        /// <returns>The difference of the two decimal numbers.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> or <paramref name='subtrahend'/> is
        /// null.</exception>
        public static EDecimal operator -(
          EDecimal bthis,
          EDecimal subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <summary>Adds one to an arbitrary-precision decimal
        /// number.</summary>
        /// <param name='bthis'>An arbitrary-precision decimal number.</param>
        /// <returns>The given arbitrary-precision decimal number plus
        /// one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EDecimal operator ++(EDecimal bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(1);
        }

        /// <summary>Subtracts one from an arbitrary-precision decimal
        /// number.</summary>
        /// <param name='bthis'>An arbitrary-precision decimal number.</param>
        /// <returns>The given arbitrary-precision decimal number minus
        /// one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EDecimal operator --(EDecimal bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(1);
        }

        /// <summary>Multiplies an arbitrary-precision decimal floating-point
        /// number by another arbitrary-precision decimal floating-point number
        /// and returns the result.</summary>
        /// <param name='operand1'>The first operand.</param>
        /// <param name='operand2'>The second operand.</param>
        /// <returns>The product of the two numbers, that is, an
        /// arbitrary-precision decimal floating-point number times another
        /// arbitrary-precision decimal floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='operand1'/> or <paramref name='operand2'/> is
        /// null.</exception>
        public static EDecimal operator *(
          EDecimal operand1,
          EDecimal operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <summary>Divides this object by another decimal number and returns
        /// the result. When possible, the result will be exact.</summary>
        /// <param name='dividend'>The number that will be divided by the
        /// divisor.</param>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The quotient of the two numbers. Returns infinity if the
        /// divisor is 0 and the dividend is nonzero. Returns not-a-number
        /// (NaN) if the divisor and the dividend are 0. Returns NaN if the
        /// result can't be exact because it would have a nonterminating
        /// decimal expansion; examples include 1 divided by any multiple of 3,
        /// such as 1/3 or 1/12. If this is not desired, use DivideToExponent
        /// instead, or use the Divide overload that takes an EContext
        /// instead.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> is null.</exception>
        public static EDecimal operator /(
          EDecimal dividend,
          EDecimal divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <summary>Returns the remainder that would result when an
        /// arbitrary-precision decimal floating-point number is divided by
        /// another arbitrary-precision decimal floating-point number. The
        /// remainder is the number that remains when the absolute value of an
        /// arbitrary-precision decimal floating-point number is divided (as
        /// though by DivideToIntegerZeroScale) by the absolute value of the
        /// other arbitrary-precision decimal floating-point number; the
        /// remainder has the same sign (positive or negative) as this
        /// arbitrary-precision decimal floating-point number.</summary>
        /// <param name='dividend'>The number that will be divided by the
        /// divisor.</param>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The remainder that would result when an
        /// arbitrary-precision decimal floating-point number is divided by
        /// another arbitrary-precision decimal floating-point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> is null.</exception>
        public static EDecimal operator %(
          EDecimal dividend,
          EDecimal divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor, null);
        }

        /// <summary>Gets an arbitrary-precision decimal number with the same
        /// value as the given one, but with the sign reversed.</summary>
        /// <param name='bigValue'>An arbitrary-precision decimal number to
        /// negate.</param>
        /// <returns>An arbitrary-precision decimal number. If this value is
        /// positive zero, returns negative zero. Returns signaling NaN if this
        /// value is signaling NaN.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static EDecimal operator -(EDecimal bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <summary>Converts an arbitrary-precision decimal floating-point
        /// number to an arbitrary-precision integer. Any fractional part in
        /// this value will be discarded when converting to an
        /// arbitrary-precision integer.</summary>
        /// <param name='bigValue'>The number to convert as an
        /// arbitrary-precision decimal.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator EInteger(EDecimal bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToEInteger();
        }

        /// <summary>Converts this value to its closest equivalent as a 64-bit
        /// floating-point number. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 64-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <param name='bigValue'>The value to convert to a 64-bit
        /// floating-point number.</param>
        /// <returns>The closest 64-bit floating-point number to this value.
        /// The return value can be positive infinity or negative infinity if
        /// this value exceeds the range of a 64-bit floating point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator double(EDecimal bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToDouble();
        }

        /// <summary>Converts this value to its closest equivalent as a 32-bit
        /// floating-point number. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <param name='bigValue'>The number to convert as an
        /// arbitrary-precision decimal number.</param>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value. The return value can be positive infinity or negative
        /// infinity if this value exceeds the range of a 32-bit floating point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator float(EDecimal bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToSingle();
        }

        // Begin integer conversions

        /// <summary>Converts an arbitrary-precision decimal number to a byte
        /// (from 0 to 255) if it can fit in a byte (from 0 to 255) after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// byte (from 0 to 255).</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 255.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToByteChecked.")]
        public static explicit operator byte(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>The value of <paramref name='inputByte'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(byte inputByte)
        {
            return EDecimal.FromByte(inputByte);
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to an 8-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -128 or greater than
        /// 127.</exception>
        public sbyte ToSByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (sbyte)0;
            }
            if (this.exponent.CompareToInt(3) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEInteger().ToSByteChecked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as an 8-bit signed integer.</summary>
        /// <returns>This number, converted to an 8-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public sbyte ToSByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToSByteUnchecked() : (sbyte)0;
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as an 8-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -128 or
        /// greater than 127.</exception>
        public sbyte ToSByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (sbyte)0;
            }
            if (this.exponent.CompareToInt(3) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision decimal
        /// number.</returns>
        public static EDecimal FromSByte(sbyte inputSByte)
        {
            var val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision decimal number to an 8-bit
        /// signed integer if it can fit in an 8-bit signed integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to an
        /// 8-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -128 or greater than 127.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToSByteChecked.")]
        public static explicit operator sbyte(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputSByte'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(sbyte inputSByte)
        {
            return EDecimal.FromSByte(inputSByte);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a 16-bit
        /// signed integer if it can fit in a 16-bit signed integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 16-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -32768 or greater than 32767.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt16Checked.")]
        public static explicit operator short(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt16'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(short inputInt16)
        {
            return EDecimal.FromInt16(inputInt16);
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer after converting it to
        /// an integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 65535.</exception>
        public ushort ToUInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return (ushort)0;
            }
            if (this.exponent.CompareToInt(5) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEInteger().ToUInt16Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 16-bit unsigned integer.</summary>
        /// <returns>This number, converted to a 16-bit unsigned integer.
        /// Returns 0 if this value is infinity or not-a-number.</returns>
        public ushort ToUInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt16Unchecked() : (ushort)0;
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 65535.</exception>
        public ushort ToUInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return (ushort)0;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(5) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision decimal number.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision decimal
        /// number.</returns>
        public static EDecimal FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a 16-bit
        /// unsigned integer if it can fit in a 16-bit unsigned integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 16-bit unsigned integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 65535.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt16Checked.")]
        public static explicit operator ushort(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision decimal number.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt16'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(ushort inputUInt16)
        {
            return EDecimal.FromUInt16(inputUInt16);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a 32-bit
        /// signed integer if it can fit in a 32-bit signed integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -2147483648 or greater than 2147483647.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt32Checked.")]
        public static explicit operator int(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt32'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(int inputInt32)
        {
            return EDecimal.FromInt32(inputInt32);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 4294967295.</exception>
        public uint ToUInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return 0U;
            }
            if (this.exponent.CompareToInt(10) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEInteger().ToUInt32Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 32-bit signed integer.</summary>
        /// <returns>This number, converted to a 32-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public uint ToUInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt32Unchecked() : 0U;
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 4294967295.</exception>
        public uint ToUInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return 0U;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(10) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision decimal
        /// number.</returns>
        public static EDecimal FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a 32-bit
        /// signed integer if it can fit in a 32-bit signed integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 4294967295.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt32Checked.")]
        public static explicit operator uint(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputUInt32'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(uint inputUInt32)
        {
            return EDecimal.FromUInt32(inputUInt32);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a 64-bit
        /// signed integer if it can fit in a 64-bit signed integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 64-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt64Checked.")]
        public static explicit operator long(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt64Checked();
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// decimal number.</summary>
        /// <param name='inputInt64'>The number to convert as a 64-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt64'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(long inputInt64)
        {
            return EDecimal.FromInt64(inputInt64);
        }

        /// <summary>Converts this number's value to a 64-bit unsigned integer
        /// if it can fit in a 64-bit unsigned integer after converting it to
        /// an integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 18446744073709551615.</exception>
        public ulong ToUInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsIntegerPartZero())
            {
                return 0UL;
            }
            if (this.exponent.CompareToInt(20) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEInteger().ToUInt64Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 64-bit unsigned integer.</summary>
        /// <returns>This number, converted to a 64-bit unsigned integer.
        /// Returns 0 if this value is infinity or not-a-number.</returns>
        public ulong ToUInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt64Unchecked() : 0UL;
        }

        /// <summary>Converts this number's value to a 64-bit unsigned integer
        /// if it can fit in a 64-bit unsigned integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 18446744073709551615.</exception>
        public ulong ToUInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return 0UL;
            }
            if (this.IsNegative)
            {
                throw new OverflowException("Value out of range");
            }
            if (this.exponent.CompareToInt(20) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            return this.ToEIntegerIfExact().ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision decimal number.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision decimal
        /// number.</returns>
        public static EDecimal FromUInt64(ulong inputUInt64)
        {
            return FromEInteger(EInteger.FromUInt64(inputUInt64));
        }

        /// <summary>Converts an arbitrary-precision decimal number to a 64-bit
        /// unsigned integer if it can fit in a 64-bit unsigned integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 64-bit unsigned integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 18446744073709551615.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt64Checked.")]
        public static explicit operator ulong(EDecimal input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision decimal number.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt64'/> as an
        /// arbitrary-precision decimal number.</returns>
        public static implicit operator EDecimal(ulong inputUInt64)
        {
            return EDecimal.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    public static class EDecimals
    {
        private const int DecimalRadix = 10;

        /// <summary>Returns the number 10, the decimal radix.</summary>
        /// <param name='ec'>Specifies an arithmetic context for rounding the
        /// number 10. Can be null.</param>
        /// <returns>The number 10, or the closest representable number to 10
        /// in the arithmetic context.</returns>
        public static EDecimal Radix(EContext ec)
        {
            return EDecimal.FromInt32(DecimalRadix).RoundToPrecision(ec);
        }

        /// <summary>Creates an arbitrary-precision decimal number from a
        /// 32-bit signed integer.</summary>
        /// <param name='i32'>The parameter <paramref name='i32'/> is a 32-bit
        /// signed integer.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>An arbitrary-precision decimal number with the closest
        /// representable value to the given integer.</returns>
        public static EDecimal Int32ToEDecimal(int i32, EContext ec)
        {
            // NOTE: Not a miscellaneous operation in the General Decimal
            // Arithmetic Specification 1.70, but required since some of the
            // miscellaneous operations here return integers
            return EDecimal.FromInt32(i32).RoundToPrecision(ec);
        }

        /// <summary>Converts a boolean value (either true or false) to an
        /// arbitrary-precision decimal number.</summary>
        /// <param name='b'>Either true or false.</param>
        /// <param name='ec'>A context used for rounding the result. Can be
        /// null.</param>
        /// <returns>Either 1 if <paramref name='b'/> is true, or 0 if
        /// <paramref name='b'/> is false.. The result will be rounded as
        /// specified by the given context, if any.</returns>
        public static EDecimal BooleanToEDecimal(bool b, EContext ec)
        {
            // NOTE: Not a miscellaneous operation in the General Decimal
            // Arithmetic Specification 1.70, but required since some of the
            // miscellaneous operations here return booleans
            return EDecimal.FromInt32(b ? 1 : 0).RoundToPrecision(ec);
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is in a canonical form. For the current version of EDecimal,
        /// all EDecimal objects are in a canonical form.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Always <c>true</c>.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA1801",
          Justification = "Parameter 'ed' is deliberately unused.")]
        public static bool IsCanonical(EDecimal ed)
        {
            // Deliberately unused because all objects are in a canonical
            // form regardless of their value. Removing the parameter
            // or renaming it to be a "discard" parameter would be a
            // breaking change, though.
            return true;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is neither null nor infinity nor not-a-number
        /// (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> if the given arbitrary-precision number
        /// object is neither null nor infinity nor not-a-number (NaN), or
        /// <c>false</c> otherwise.</returns>
        public static bool IsFinite(EDecimal ed)
        {
            return ed != null && ed.IsFinite;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is positive or negative infinity.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> if the given arbitrary-precision number
        /// object is positive or negative infinity, or <c>false</c>
        /// otherwise.</returns>
        public static bool IsInfinite(EDecimal ed)
        {
            return ed != null && ed.IsInfinity();
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is a not-a-number (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsNaN(EDecimal ed)
        {
            return ed != null && ed.IsNaN();
        }

        /// <summary>Returns whether the given number is a
        /// <i>normal</i> number. A
        /// <i>subnormal number</i> is a nonzero finite number whose Exponent
        /// property (or the number's exponent when that number is expressed in
        /// scientific notation with one digit before the radix point) is less
        /// than the minimum possible exponent for that number. A
        /// <i>normal number</i> is nonzero and finite, but not
        /// subnormal.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <param name='ec'>A context specifying the exponent range of
        /// arbitrary-precision numbers. Can be null. If AdjustExponent of the
        /// given context is <c>true</c>, a nonzero number is normal if the
        /// number's exponent (when that number is expressed in scientific
        /// notation with one nonzero digit before the radix point) is at least
        /// the given context's EMax property (e.g., if EMax is -100, 2.3456 *
        /// 10
        /// <sup>-99</sup> is normal, but 2.3456 * 10
        /// <sup>-102</sup> is not). If AdjustExponent of the given context is
        /// <c>false</c>, a nonzero number is subnormal if the number's
        /// Exponent property is at least given context's EMax property (e.g.,
        /// if EMax is -100, 23456 * 10
        /// <sup>-99</sup> is normal, but 23456 * 10
        /// <sup>-102</sup> is not).</param>
        /// <returns>Either <c>true</c> if the given number is subnormal, or
        /// <c>false</c> otherwise. Returns <c>true</c> if the given context is
        /// null or HasExponentRange of the given context is <c>false</c>.</returns>
        public static bool IsNormal(EDecimal ed, EContext ec)
        {
            return ed != null && ed.IsFinite && !ed.IsZero && !IsSubnormal(ed, ec);
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is a quiet not-a-number (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsQuietNaN(EDecimal ed)
        {
            return ed != null && ed.IsQuietNaN();
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is negative (including negative infinity, negative
        /// not-a-number [NaN], or negative zero).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsSigned(EDecimal ed)
        {
            return ed != null && ed.IsNegative;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is a signaling not-a-number (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsSignalingNaN(EDecimal ed)
        {
            return ed != null && ed.IsSignalingNaN();
        }

        private static readonly string[] NumberClasses = {
      "+Normal", "-Normal",
      "+Subnormal", "-Subnormal",
      "+Zero", "-Zero",
      "+Infinity", "-Infinity",
      "NaN", "sNaN",
    };

        /// <summary>Converts a number class identifier (ranging from 0 through
        /// 9) to a text string. An arbitrary-precision number object can
        /// belong in one of ten number classes.</summary>
        /// <param name='nc'>An integer identifying a number class.</param>
        /// <returns>A text string identifying the given number class as
        /// follows: 0 = "+Normal"; 1 = "-Normal", 2 = "+Subnormal", 3 =
        /// "-Subnormal", 4 = "+Zero", 5 = "-Zero", 6 = "+Infinity", 7 =
        /// "-Infinity", 8 = "NaN", 9 = "sNaN".</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='nc'/> is less than 0 or greater than 9.</exception>
        public static string NumberClassString(int nc)
        {
            if (nc < 0)
            {
                throw new ArgumentException("nc(" + nc +
                  ") is not greater or equal to 0");
            }
            if (nc > 9)
            {
                throw new ArgumentException("nc(" + nc +
                  ") is not less or equal to 9");
            }
            return NumberClasses[nc];
        }

        /// <summary>Finds the number class for an arbitrary-precision decimal
        /// number object.</summary>
        /// <param name='ed'>An arbitrary-precision decimal number
        /// object.</param>
        /// <param name='ec'>A context object that specifies the precision and
        /// exponent range of arbitrary-precision numbers. This is used only to
        /// distinguish between normal and subnormal numbers. Can be
        /// null.</param>
        /// <returns>A 32-bit signed integer identifying the given number
        /// object, number class as follows: 0 = positive normal; 1 = negative
        /// normal, 2 = positive subnormal, 3 = negative subnormal, 4 =
        /// positive zero, 5 = negative zero, 6 = positive infinity, 7 =
        /// negative infinity, 8 = quiet not-a-number (NaN), 9 = signaling
        /// NaN.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static int NumberClass(EDecimal ed, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsQuietNaN())
            {
                return 8;
            }
            if (ed.IsNaN())
            {
                return 9;
            }
            if (ed.IsInfinity())
            {
                return ed.IsNegative ? 7 : 6;
            }
            if (ed.IsZero)
            {
                return ed.IsNegative ? 5 : 4;
            }
            return IsSubnormal(ed, ec) ? (ed.IsNegative ? 3 : 2) :
              (ed.IsNegative ? 1 : 0);
        }

        /// <summary>Returns whether the given number is a
        /// <i>subnormal</i> number. A
        /// <i>subnormal number</i> is a nonzero finite number whose Exponent
        /// property (or the number's exponent when that number is expressed in
        /// scientific notation with one digit before the radix point) is less
        /// than the minimum possible exponent for that number.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <param name='ec'>A context specifying the exponent range of
        /// arbitrary-precision numbers. Can be null. If AdjustExponent of the
        /// given context is <c>true</c>, a nonzero number is subnormal if the
        /// number's exponent (when that number is expressed in scientific
        /// notation with one nonzero digit before the radix point) is less
        /// than the given context's EMax property (e.g., if EMax is -100,
        /// 2.3456 * 10
        /// <sup>-102</sup> is subnormal, but 2.3456 * 10
        /// <sup>-99</sup> is not). If AdjustExponent of the given context is
        /// <c>false</c>, a nonzero number is subnormal if the number's
        /// Exponent property is less than the given context's EMax property
        /// (e.g., if EMax is -100, 23456 * 10
        /// <sup>-102</sup> is subnormal, but 23456 * 10
        /// <sup>-99</sup> is not).</param>
        /// <returns>Either <c>true</c> if the given number is subnormal, or
        /// <c>false</c> otherwise. Returns <c>false</c> if the given context
        /// is null or HasExponentRange of the given context is <c>false</c>.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static bool IsSubnormal(EDecimal ed, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsFinite && ec != null && !ed.IsZero && ec.HasExponentRange)
            {
                if (ec.AdjustExponent)
                {
                    return ed.Exponent.Add(ed.Precision().Subtract(1)).CompareTo(
                        ec.EMin) < 0;
                }
                else
                {
                    return ed.Exponent.CompareTo(ec.EMin) < 0;
                }
            }
            return false;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is zero (positive zero or negative zero).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns><c>true</c> if the given number has a value of zero
        /// (positive zero or negative zero); otherwise, <c>false</c>.</returns>
        public static bool IsZero(EDecimal ed)
        {
            return ed != null && ed.IsZero;
        }

        /// <summary>Returns the base-10 exponent of an arbitrary-precision
        /// decimal number (when that number is expressed in scientific
        /// notation with one digit before the radix point). For example,
        /// returns 3 for the numbers <c>6.66E + 3</c> and <c>666E + 1</c>.</summary>
        /// <param name='ed'>An arbitrary-precision decimal number.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>The base-10 exponent of the given number (when that number
        /// is expressed in scientific notation with one nonzero digit before
        /// the radix point). Signals DivideByZero and returns negative
        /// infinity if <paramref name='ed'/> is zero. Returns positive
        /// infinity if <paramref name='ed'/> is positive infinity or negative
        /// infinity.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EDecimal LogB(EDecimal ed, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsNaN())
            {
                return ed.RoundToPrecision(ec);
            }
            if (ed.IsInfinity())
            {
                return EDecimal.PositiveInfinity;
            }
            if (ed.IsZero)
            {
                return EDecimal.FromInt32(-1).Divide(EDecimal.Zero, ec);
            }
            EInteger ei = ed.Exponent.Add(ed.Precision().Subtract(1));
            return EDecimal.FromEInteger(ei).RoundToPrecision(ec);
        }

        /// <summary>Finds an arbitrary-precision decimal number whose decimal
        /// point is moved a given number of places.</summary>
        /// <param name='ed'>An arbitrary-precision decimal number.</param>
        /// <param name='ed2'>The number of decimal places to move the decimal
        /// point of "ed". This must be an integer with an exponent of
        /// 0.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>The given arbitrary-precision decimal number whose decimal
        /// point is moved the given number of places. Signals an invalid
        /// operation and returns not-a-number (NaN) if <paramref name='ed2'/>
        /// is infinity or NaN, has an Exponent property other than 0. Signals
        /// an invalid operation and returns not-a-number (NaN) if <paramref
        /// name='ec'/> defines a limited precision and exponent range and if
        /// <paramref name='ed2'/> 's absolute value is greater than twice the
        /// sum of the context's EMax property and its Precision
        /// property.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> or <paramref name='ed2'/> is null.</exception>
        public static EDecimal ScaleB(EDecimal ed, EDecimal ed2, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed2 == null)
            {
                throw new ArgumentNullException(nameof(ed2));
            }
            if (ed.IsNaN() || ed2.IsNaN())
            {
                return ed.Add(ed2, ec);
            }
            if (!ed2.IsFinite || ed2.Exponent.Sign != 0)
            {
                return InvalidOperation(ec);
            }
            EInteger scale = ed2.Mantissa;
            if (ec != null && ec.HasMaxPrecision && ec.HasExponentRange)
            {
                EInteger exp = ec.EMax.Add(ec.Precision).Multiply(2);
                if (scale.Abs().CompareTo(exp.Abs()) > 0)
                {
                    return InvalidOperation(ec);
                }
            }
            if (ed.IsInfinity())
            {
                return ed;
            }
            if (scale.IsZero)
            {
                return ed.RoundToPrecision(ec);
            }
            EDecimal ret = EDecimal.Create(
                ed.UnsignedMantissa,
                ed.Exponent.Add(scale));
            if (ed.IsNegative)
            {
                ret = ret.Negate();
            }
            return ret.RoundToPrecision(ec);
        }

        /// <summary>Shifts the digits of an arbitrary-precision decimal
        /// number's significand.</summary>
        /// <param name='ed'>An arbitrary-precision number containing the
        /// significand to shift.</param>
        /// <param name='ed2'>An arbitrary-precision number indicating the
        /// number of digits to shift the first operand's significand. Must be
        /// an integer with an exponent of 0. If this parameter is positive,
        /// the significand is shifted to the left by the given number of
        /// digits. If this parameter is negative, the significand is shifted
        /// to the right by the given number of digits.</param>
        /// <param name='ec'>An arithmetic context to control the precision of
        /// arbitrary-precision numbers. Can be null.</param>
        /// <returns>An arbitrary-precision decimal number whose significand is
        /// shifted the given number of digits. Signals an invalid operation
        /// and returns NaN (not-a-number) if <paramref name='ed2'/> is a
        /// signaling NaN or if <paramref name='ed2'/> is not an integer, is
        /// negative, has an exponent other than 0, or has an absolute value
        /// that exceeds the maximum precision specified in the
        /// context.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> or <paramref name='ed2'/> is null.</exception>
        public static EDecimal Shift(EDecimal ed, EDecimal ed2, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed2 == null)
            {
                throw new ArgumentNullException(nameof(ed2));
            }
            if (ed.IsNaN() || ed2.IsNaN())
            {
                return ed.Add(ed2, ec);
            }
            if (!ed2.IsFinite || ed2.Exponent.Sign != 0)
            {
                return InvalidOperation(ec);
            }
            EInteger shift = ed2.Mantissa;
            if (ec != null)
            {
                if (shift.Abs().CompareTo(ec.Precision) > 0)
                {
                    return InvalidOperation(ec);
                }
            }
            if (ed.IsInfinity())
            {
                // NOTE: Must check for validity of second
                // parameter first, before checking if first
                // parameter is infinity here
                return ed;
            }
            EInteger mant = ed.UnsignedMantissa;
            if (mant.IsZero)
            {
                return ed.RoundToPrecision(ec);
            }
            EInteger mantprec = ed.Precision();
            EInteger radix = EInteger.FromInt32(DecimalRadix);
            if (shift.Sign < 0)
            {
                if (shift.Abs().CompareTo(mantprec) < 0)
                {
                    EInteger divisor = radix.Pow(shift.Abs());
                    mant = mant.Divide(divisor);
                }
                else
                {
                    mant = EInteger.Zero;
                }
                EDecimal ret = EDecimal.Create(mant, ed.Exponent);
                return ed.IsNegative ? ret.Negate() : ret;
            }
            else
            {
                EInteger mult = radix.Pow(shift);
                mant = mant.Multiply(mult);
                if (ec != null && ec.HasMaxPrecision)
                {
                    EInteger mod = radix.Pow(ec.Precision);
                    mant = mant.Remainder(mod);
                }
                EDecimal ret = EDecimal.Create(mant, ed.Exponent);
                return ed.IsNegative ? ret.Negate() : ret;
            }
        }

        /// <summary>Rotates the digits of an arbitrary-precision decimal
        /// number's significand.</summary>
        /// <param name='ed'>An arbitrary-precision number containing the
        /// significand to rotate. If this significand contains more digits
        /// than the precision, the most-significant digits are chopped off the
        /// significand before the rotation begins.</param>
        /// <param name='ed2'>An arbitrary-precision number indicating the
        /// number of digits to rotate the first operand's significand. Must be
        /// an integer with an exponent of 0. If this parameter is positive,
        /// the significand is shifted to the left by the given number of
        /// digits and the most-significant digits shifted out of the
        /// significand become the least-significant digits instead. If this
        /// parameter is negative, the significand is shifted to the right by
        /// the given number of digits and the least-significant digits shifted
        /// out of the significand become the most-significant digits
        /// instead.</param>
        /// <param name='ec'>An arithmetic context to control the precision of
        /// arbitrary-precision numbers. If this parameter is null or specifies
        /// an unlimited precision, this method has the same behavior as
        /// <c>Shift</c>.</param>
        /// <returns>An arbitrary-precision decimal number whose significand is
        /// rotated the given number of digits. Signals an invalid operation
        /// and returns NaN (not-a-number) if <paramref name='ed2'/> is a
        /// signaling NaN or if <paramref name='ed2'/> is not an integer, is
        /// negative, has an exponent other than 0, or has an absolute value
        /// that exceeds the maximum precision specified in the
        /// context.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed2'/> or <paramref name='ed'/> is null.</exception>
        public static EDecimal Rotate(EDecimal ed, EDecimal ed2, EContext ec)
        {
            if (ec == null || !ec.HasMaxPrecision)
            {
                return Shift(ed, ed2, ec);
            }
            if (ed2 == null)
            {
                throw new ArgumentNullException(nameof(ed2));
            }
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsNaN() || ed2.IsNaN())
            {
                return ed.Add(ed2, ec);
            }
            if (!ed2.IsFinite || ed2.Exponent.Sign != 0)
            {
                return InvalidOperation(ec);
            }
            EInteger shift = ed2.Mantissa;
            if (shift.Abs().CompareTo(ec.Precision) > 0)
            {
                return InvalidOperation(ec);
            }
            if (ed.IsInfinity())
            {
                // NOTE: Must check for validity of second
                // parameter first, before checking if first
                // parameter is infinity here
                return ed;
            }
            EInteger mant = ed.UnsignedMantissa;
            EInteger mantprec = ed.Precision();
            if (ec != null && ec.HasMaxPrecision &&
              mantprec.CompareTo(ec.Precision) > 0)
            {
                mant = mant.Remainder(
                    EInteger.FromInt32(DecimalRadix).Pow(ec.Precision));
                mantprec = ec.Precision;
            }
            if (mant.IsZero)
            {
                return ed.RoundToPrecision(ec);
            }
            EInteger rightShift = shift.Sign < 0 ? shift.Abs() :
              ec.Precision.Subtract(shift);
            EInteger leftShift = ec.Precision.Subtract(rightShift);
            EInteger mantRight = EInteger.Zero;
            EInteger mantLeft = EInteger.Zero;
            EInteger radix = EInteger.FromInt32(DecimalRadix);
            // Right shift
            if (rightShift.CompareTo(mantprec) < 0)
            {
                EInteger divisor = radix.Pow(rightShift);
                mantRight = mant.Divide(divisor);
            }
            else
            {
                mantRight = EInteger.Zero;
            }
            // Left shift
            if (leftShift.IsZero)
            {
                mantLeft = mant;
            }
            else if (leftShift.CompareTo(ec.Precision) == 0)
            {
                mantLeft = EInteger.Zero;
            }
            else
            {
                EInteger mult = radix.Pow(leftShift);
                mantLeft = mant.Multiply(mult);
                EInteger mod = radix.Pow(ec.Precision);
                mantLeft = mantLeft.Remainder(mod);
            }
            EDecimal ret = EDecimal.Create(mantRight.Add(mantLeft), ed.Exponent);
            return ed.IsNegative ? ret.Negate() : ret;
        }

        /// <summary>Compares the values of one arbitrary-precision number
        /// object and another object, imposing a total ordering on all
        /// possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='ed'>The first arbitrary-precision number to
        /// compare.</param>
        /// <param name='other'>The second arbitrary-precision number to
        /// compare.</param>
        /// <param name='ec'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects are null or equal, or -1 if
        /// the first object is null or less than the other object, or 1 if the
        /// first object is greater or the other object is null. Does not
        /// signal flags if either value is signaling NaN.</returns>
        public static int CompareTotal(EDecimal ed, EDecimal other, EContext ec)
        {
            return (ed == null) ? (other == null ? 0 : -1) : ((other == null) ? 1 :
                ed.CompareToTotal(other, ec));
        }

        /// <summary>Compares the absolute values of two arbitrary-precision
        /// number objects, imposing a total ordering on all possible values
        /// (ignoring their signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero and positive zero are considered equal.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item></list></summary>
        /// <param name='ed'>The first arbitrary-precision number to
        /// compare.</param>
        /// <param name='other'>The second arbitrary-precision number to
        /// compare.</param>
        /// <param name='ec'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects are null or equal (ignoring
        /// their signs), or -1 if the first object is null or less than the
        /// other value (ignoring their signs), or 1 if the first object is
        /// greater (ignoring their signs) or the other object is null. Does
        /// not signal flags if either value is signaling NaN.</returns>
        public static int CompareTotalMagnitude(
          EDecimal ed,
          EDecimal other,
          EContext ec)
        {
            return (ed == null) ? (other == null ? 0 : -1) : ((other == null) ? 1 :
                ed.CompareToTotalMagnitude(other, ec));
        }

        /// <summary>Creates a copy of the given arbitrary-precision number
        /// object.</summary>
        /// <param name='ed'>An arbitrary-precision number object to
        /// copy.</param>
        /// <returns>A copy of the given arbitrary-precision number
        /// object.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EDecimal Copy(EDecimal ed)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            return ed.Copy();
        }

        /// <summary>Returns a canonical version of the given
        /// arbitrary-precision number object. In this method, this method
        /// behaves like the Copy method.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>A copy of the parameter <paramref name='ed'/>.</returns>
        public static EDecimal Canonical(EDecimal ed)
        {
            return Copy(ed);
        }

        /// <summary>Returns an arbitrary-precision number object with the same
        /// value as the given number object but with a nonnegative sign (that
        /// is, the given number object's absolute value).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>An arbitrary-precision number object with the same value
        /// as the given number object but with a nonnegative sign.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EDecimal CopyAbs(EDecimal ed)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            return Copy(ed.Abs());
        }

        /// <summary>Returns an arbitrary-precision number object with the sign
        /// reversed from the given number object.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>An arbitrary-precision number object with the sign
        /// reversed from the given number object.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EDecimal CopyNegate(EDecimal ed)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            return Copy(ed.Negate());
        }

        /// <summary>Returns an arbitrary-precision number object with the same
        /// value as the first given number object but with a the same sign
        /// (positive or negative) as the second given number object.</summary>
        /// <param name='ed'>An arbitrary-precision number object with the
        /// value the result will have.</param>
        /// <param name='other'>The parameter <paramref name='other'/> is an
        /// arbitrary-precision decimal floating-point number.</param>
        /// <returns>An arbitrary-precision number object with the same value
        /// as the first given number object but with a the same sign (positive
        /// or negative) as the second given number object.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> or <paramref name='other'/> is null.</exception>
        public static EDecimal CopySign(EDecimal ed, EDecimal other)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            return ed.IsNegative == other.IsNegative ? Copy(ed) : CopyNegate(ed);
        }

        private static EDecimal InvalidOperation(EContext ec)
        {
            return EDecimal.SignalingNaN.Plus(ec);
        }

        /// <summary>Returns whether two arbitrary-precision numbers have the
        /// same exponent, they both are not-a-number (NaN), or they both are
        /// infinity (positive and/or negative).</summary>
        /// <param name='ed1'>The first arbitrary-precision number.</param>
        /// <param name='ed2'>The second arbitrary-precision number.</param>
        /// <returns>Either <c>true</c> if the given arbitrary-precision
        /// numbers have the same exponent, they both are not-a-number (NaN),
        /// or they both are infinity (positive and/or negative); otherwise,
        /// <c>false</c>.</returns>
        public static bool SameQuantum(EDecimal ed1, EDecimal ed2)
        {
            if (ed1 == null || ed2 == null)
            {
                return false;
            }
            if (ed1.IsFinite && ed2.IsFinite)
            {
                return ed1.Exponent.Equals(ed2.Exponent);
            }
            else
            {
                return (ed1.IsNaN() && ed2.IsNaN()) || (ed1.IsInfinity() &&
                    ed2.IsInfinity());
            }
        }

        /// <summary>Returns an arbitrary-precision number with the same value
        /// as this one but with certain trailing zeros removed from its
        /// significand. If the number's exponent is 0, it is returned
        /// unchanged (but may be rounded depending on the arithmetic context);
        /// if that exponent is greater 0, its trailing zeros are removed from
        /// the significand (then rounded if necessary); if that exponent is
        /// less than 0, its trailing zeros are removed from the significand
        /// until the exponent reaches 0 (then the number is rounded if
        /// necessary).</summary>
        /// <param name='ed1'>An arbitrary-precision number.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>An arbitrary-precision number with the same value as this
        /// one but with certain trailing zeros removed from its significand.
        /// If <paramref name='ed1'/> is not-a-number (NaN) or infinity, it is
        /// generally returned unchanged.</returns>
        public static EDecimal Trim(EDecimal ed1, EContext ec)
        {
            EDecimal ed = ed1;
            if (ed1 == null)
            {
                return InvalidOperation(ec);
            }
            if (ed.IsSignalingNaN())
            {
                return EDecimal.CreateNaN(
                  ed.UnsignedMantissa,
                  true,
                  ed.IsNegative,
                  ec);
            }
            if (ed.IsFinite)
            {
                if (ed.IsZero)
                {
                    return (ed.IsNegative ? EDecimal.NegativeZero :
                        EDecimal.Zero).RoundToPrecision(ec);
                }
                else if (ed.Exponent.Sign > 0)
                {
                    return ed.Reduce(ec);
                }
                else if (ed.Exponent.Sign == 0)
                {
                    return ed.RoundToPrecision(ec);
                }
                else
                {
                    EInteger exp = ed.Exponent;
                    EInteger mant = ed.UnsignedMantissa;
                    bool neg = ed.IsNegative;
                    var trimmed = false;
                    EInteger radixint = EInteger.FromInt32(DecimalRadix);
                    while (exp.Sign < 0 && mant.Sign > 0)
                    {
                        EInteger[] divrem = mant.DivRem(radixint);
                        int rem = divrem[1].ToInt32Checked();
                        if (rem != 0)
                        {
                            break;
                        }
                        mant = divrem[0];
                        exp = exp.Add(1);
                        trimmed = true;
                    }
                    if (!trimmed)
                    {
                        return ed.RoundToPrecision(ec);
                    }
                    EDecimal ret = EDecimal.Create(mant, exp);
                    if (neg)
                    {
                        ret = ret.Negate();
                    }
                    return ret.RoundToPrecision(ec);
                }
            }
            else
            {
                return ed1.Plus(ec);
            }
        }

        /// <summary>Returns an arbitrary-precision decimal number with the
        /// same value as this object but with the given exponent, expressed as
        /// an arbitrary-precision decimal number.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of decimal places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// decimal places is desired, it's better to use the RoundToExponent
        /// and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b> This method can be used to implement
        /// fixed-point decimal arithmetic, in which a fixed number of digits
        /// come after the decimal point. A fixed-point decimal arithmetic in
        /// which no digits come after the decimal point (a desired exponent of
        /// 0) is considered an "integer arithmetic" .</para></summary>
        /// <param name='ed'>An arbitrary-precision decimal number whose
        /// exponent is to be changed.</param>
        /// <param name='scale'>The desired exponent of the result, expressed
        /// as an arbitrary-precision decimal number. The exponent is the
        /// number of fractional digits in the result, expressed as a negative
        /// number. Can also be positive, which eliminates lower-order places
        /// from the number. For example, -3 means round to the thousandth
        /// (10^-3, 0.0001), and 3 means round to the thousands-place (10^3,
        /// 1000). A value of 0 rounds the number to an integer.</param>
        /// <param name='ec'>The parameter <paramref name='ec'/> is an EContext
        /// object.</param>
        /// <returns>An arbitrary-precision decimal number with the same value
        /// as this object but with the exponent changed. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding, or if the arithmetic context defines an
        /// exponent range and the given exponent is outside that
        /// range.</returns>
        public static EDecimal Rescale(EDecimal ed, EDecimal scale, EContext ec)
        {
            if (ed == null || scale == null)
            {
                return InvalidOperation(ec);
            }
            if (!scale.IsFinite)
            {
                return ed.Quantize(scale, ec);
            }
            if (scale.Exponent.IsZero)
            {
                return ed.Quantize(EDecimal.Create(EInteger.One, scale.Mantissa), ec);
            }
            else
            {
                EContext tec = ec == null ? null : ec.WithTraps(0).WithBlankFlags();
                EDecimal rv = scale.RoundToExponentExact(0, tec);
                if (!rv.IsFinite || (tec.Flags & EContext.FlagInexact) != 0)
                {
                    if (ec != null && ec.IsSimplified)
                    {
                        // In simplified arithmetic, round scale to trigger
                        // appropriate error conditions
                        scale = scale.RoundToPrecision(ec);
                    }
                    return InvalidOperation(ec);
                }
                EDecimal rounded = scale.Quantize(0, tec);
                return ed.Quantize(
                    EDecimal.Create(EInteger.One, rounded.Mantissa),
                    ec);
            }
        }

        // Logical Operations

        /// <summary>Performs a logical AND operation on two decimal numbers in
        /// the form of
        /// <i>logical operands</i>. A <c>logical operand</c> is a
        /// non-negative base-10 number with an Exponent property of 0 and no
        /// other base-10 digits than 0 or 1 (examples include <c>01001</c> and
        /// <c>111001</c>, but not <c>02001</c> or <c>99999</c> ). The logical
        /// AND operation sets each digit of the result to 1 if the
        /// corresponding digits of each logical operand are both 1, and to 0
        /// otherwise. For example, <c>01001 AND 111010=01000</c>.</summary>
        /// <param name='ed1'>The first logical operand to the logical AND
        /// operation.</param>
        /// <param name='ed2'>The second logical operand to the logical AND
        /// operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more digits than the maximum precision
        /// specified in this context, the operand's most significant digits
        /// that exceed that precision are discarded. This parameter can be
        /// null.</param>
        /// <returns>The result of the logical AND operation as a logical
        /// operand. Signals an invalid operation and returns not-a-number
        /// (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
        /// are not logical operands.</returns>
        public static EDecimal And(EDecimal ed1, EDecimal ed2, EContext ec)
        {
            byte[] logi1 = FromLogical(ed1, ec, 10);
            if (logi1 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] logi2 = FromLogical(ed2, ec, 10);
            if (logi2 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = logi1.Length < logi2.Length ? logi1 : logi2;
            byte[] bigger = logi1.Length < logi2.Length ? logi2 : logi1;
            for (var i = 0; i < smaller.Length; ++i)
            {
                smaller[i] &= bigger[i];
            }
            return EDecimal.FromEInteger(ToLogical(smaller,
                  10)).RoundToPrecision(ec);
        }

        /// <summary>Performs a logical NOT operation on an arbitrary-precision
        /// decimal number in the form of a
        /// <i>logical operand</i>. A <c>logical operand</c> is a non-negative
        /// base-10 number with an Exponent property of 0 and no other base-10
        /// digits than 0 or 1 (examples include <c>01001</c> and <c>111001</c>
        /// , but not <c>02001</c> or <c>99999</c> ). The logical NOT operation
        /// sets each digit of the result to 1 if the corresponding digit is 0,
        /// and to 0 otherwise; it can set no more digits than the maximum
        /// precision, however. For example, if the maximum precision is 8
        /// digits, then <c>NOT 111010=11000101</c>.</summary>
        /// <param name='ed1'>The logical operand to the logical NOT
        /// operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more digits than the maximum precision
        /// specified in this context, the operand's most significant digits
        /// that exceed that precision are discarded. This parameter cannot be
        /// null and must specify a maximum precision (unlimited precision
        /// contexts are not allowed).</param>
        /// <returns>The result of the logical NOT operation as a logical
        /// operand. Signals an invalid operation and returns not-a-number
        /// (NaN) if <paramref name='ed1'/> is not a logical operand.</returns>
        public static EDecimal Invert(EDecimal ed1, EContext ec)
        {
            if (ec == null || !ec.HasMaxPrecision)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = FromLogical(ed1, ec, 10);
            if (smaller == null)
            {
                return InvalidOperation(ec);
            }
            EInteger ei = EInteger.One.ShiftLeft(ec.Precision).Subtract(1);
            byte[] bigger = ei.ToBytes(true);
#if DEBUG
            if (smaller.Length > bigger.Length)
            {
                throw new ArgumentException("smaller.Length(" + smaller.Length +
                  ") is not less or equal to " + bigger.Length);
            }
#endif

            for (var i = 0; i < smaller.Length; ++i)
            {
                bigger[i] ^= smaller[i];
            }
            return EDecimal.FromEInteger(ToLogical(bigger, 10)).RoundToPrecision(
        ec);
        }

        /// <summary>Performs a logical exclusive-OR (XOR) operation on two
        /// decimal numbers in the form of
        /// <i>logical operands</i>. A <c>logical operand</c> is a
        /// non-negative base-10 number with an exponent of 0 and no other
        /// base-10 digits than 0 or 1 (examples include <c>01001</c> and
        /// <c>111001</c>, but not <c>02001</c> or <c>99999</c> ). The logical
        /// exclusive-OR operation sets each digit of the result to 1 if either
        /// corresponding digit of the logical operands, but not both, is 1,
        /// and to 0 otherwise. For example, <c>01001 XOR 111010=101010</c>.</summary>
        /// <param name='ed1'>The first logical operand to the logical
        /// exclusive-OR operation.</param>
        /// <param name='ed2'>The second logical operand to the logical
        /// exclusive-OR operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more digits than the maximum precision
        /// specified in this context, the operand's most significant digits
        /// that exceed that precision are discarded. This parameter can be
        /// null.</param>
        /// <returns>An arbitrary-precision decimal floating-point
        /// number.</returns>
        public static EDecimal Xor(EDecimal ed1, EDecimal ed2, EContext ec)
        {
            byte[] logi1 = FromLogical(ed1, ec, 10);
            if (logi1 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] logi2 = FromLogical(ed2, ec, 10);
            if (logi2 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = logi1.Length < logi2.Length ? logi1 : logi2;
            byte[] bigger = logi1.Length < logi2.Length ? logi2 : logi1;
            for (var i = 0; i < smaller.Length; ++i)
            {
                bigger[i] ^= smaller[i];
            }
            return EDecimal.FromEInteger(ToLogical(bigger, 10)).RoundToPrecision(
        ec);
        }

        /// <summary>Performs a logical OR operation on two decimal numbers in
        /// the form of
        /// <i>logical operands</i>. A <c>logical operand</c> is a
        /// non-negative base-10 number with an Exponent property of 0 and no
        /// other base-10 digits than 0 or 1 (examples include <c>01001</c> and
        /// <c>111001</c>, but not <c>02001</c> or <c>99999</c> ). The logical
        /// OR operation sets each digit of the result to 1 if either or both
        /// of the corresponding digits of the logical operands are 1, and to 0
        /// otherwise. For example, <c>01001 OR 111010=111011</c>.</summary>
        /// <param name='ed1'>The first logical operand to the logical OR
        /// operation.</param>
        /// <param name='ed2'>The second logical operand to the logical OR
        /// operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more digits than the maximum precision
        /// specified in this context, the operand's most significant digits
        /// that exceed that precision are discarded. This parameter can be
        /// null.</param>
        /// <returns>The result of the logical OR operation as a logical
        /// operand. Signals an invalid operation and returns not-a-number
        /// (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
        /// are not logical operands.</returns>
        public static EDecimal Or(EDecimal ed1, EDecimal ed2, EContext ec)
        {
            byte[] logi1 = FromLogical(ed1, ec, 10);
            if (logi1 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] logi2 = FromLogical(ed2, ec, 10);
            if (logi2 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = logi1.Length < logi2.Length ? logi1 : logi2;
            byte[] bigger = logi1.Length < logi2.Length ? logi2 : logi1;
            for (var i = 0; i < smaller.Length; ++i)
            {
                bigger[i] |= smaller[i];
            }
            return EDecimal.FromEInteger(ToLogical(bigger, 10)).RoundToPrecision(
        ec);
        }

        internal static EInteger ToLogical(byte[] bytes, int iradix)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            EInteger ret = EInteger.Zero;
            int i;
            for (i = bytes.Length - 1; i >= 0; --i)
            {
                int b = bytes[i];
                for (var j = 7; j >= 0; --j)
                {
                    ret = ((bytes[i] & (1 << j)) != 0) ? ret.Multiply(iradix).Add(1) :
                      ret.Multiply(iradix);
                }
            }
            return ret;
        }

        internal static byte[] FromLogical(EInteger um, EContext ec, int iradix)
        {
            if (um == null || um.Sign < 0)
            {
                return null;
            }
            if (um.Sign == 0)
            {
                return new byte[] { 0 };
            }
            EInteger ret = EInteger.Zero;
            EInteger prec = um.GetDigitCountAsEInteger();
            EInteger maxprec = (ec != null && ec.HasMaxPrecision) ? ec.Precision :
              null;
            EInteger bytecount = prec.ShiftRight(3).Add(1);
            if (bytecount.CompareTo(0x7fffffff) > 0)
            {
                return null; // Out of memory
            }
            var bitindex = 0;
            var bytes = new byte[bytecount.ToInt32Checked()];
            EInteger radixint = EInteger.FromInt32(iradix);
            while (um.Sign > 0)
            {
                EInteger[] divrem = um.DivRem(radixint);
                int rem = divrem[1].ToInt32Checked();
                um = divrem[0];
                if (rem == 1)
                {
                    // Don't collect bits beyond max precision
                    if (maxprec == null || maxprec.CompareTo(bitindex) > 0)
                    {
                        int byteindex = bitindex >> 3;
                        int mask = 1 << (bitindex & 7);
                        bytes[byteindex] |= (byte)mask;
                    }
                }
                else if (rem != 0)
                {
                    return null;
                }
                ++bitindex;
            }
            return bytes;
        }

        internal static byte[] FromLogical(EDecimal ed, EContext ec, int iradix)
        {
            if (ed == null)
            {
                return null;
            }
            if (ec != null && ec.IsPrecisionInBits && iradix != 2)
            {
                // Round to bit precision if necessary and if the radix isn't binary
                ed = ed.RoundToPrecision(ec);
            }
            return (!ed.IsFinite || ed.IsNegative || ed.Exponent.Sign != 0 ||
                ed.Mantissa.Sign < 0) ? null : FromLogical(
                  ed.UnsignedMantissa,
                  ec,
                  iradix);
        }

        internal static byte[] FromLogical(EFloat ed, EContext ec, int iradix)
        {
            if (ed == null)
            {
                return null;
            }
            // NOTE: Precision of EFloat is already in bits, so no need to check for
            // IsPrecisionInBits here
            return (!ed.IsFinite || ed.IsNegative || ed.Exponent.Sign != 0 ||
                ed.Mantissa.Sign < 0) ? null : FromLogical(
                  ed.UnsignedMantissa,
                  ec,
                  iradix);
        }
    }

    internal static class EDecimalByteArrayString
    {
        private const int MaxSafeInt = EDecimal.MaxSafeInt;

        internal static EDecimal FromString(
          byte[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset(" + tmpoffset + ") is less than " +
                  "0");
            }
            if (tmpoffset > chars.Length)
            {
                throw new FormatException("offset(" + tmpoffset + ") is more than " +
                  chars.Length);
            }
            if (length <= 0)
            {
                if (length == 0)
                {
                    throw new FormatException("length is 0");
                }
                throw new FormatException("length(" + length + ") is less than " +
                  "0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is more than " +
                  chars.Length);
            }
            if (chars.Length - tmpoffset < length)
            {
                throw new FormatException("chars's length minus " + tmpoffset + "(" +
                  (chars.Length - tmpoffset) + ") is less than " + length);
            }
            var negative = false;
            int endStr = tmpoffset + length;
            byte c = chars[tmpoffset];
            if (c == '-')
            {
                negative = true;
                ++tmpoffset;
                if (tmpoffset >= endStr)
                {
                    throw new FormatException();
                }
                c = chars[tmpoffset];
            }
            else if (chars[tmpoffset] == '+')
            {
                ++tmpoffset;
                if (tmpoffset >= endStr)
                {
                    throw new FormatException();
                }
                c = chars[tmpoffset];
            }
            int i = tmpoffset;
            if (c < '0' || c > '9')
            {
                EDecimal ed = ParseSpecialValue(chars, i, endStr, negative, ctx);
                if (ed != null)
                {
                    return ed;
                }
            }
            if (ctx != null && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              !ctx.IsSimplified)
            {
                return ParseOrdinaryNumberLimitedPrecision(
                    chars,
                    i,
                    endStr,
                    negative,
                    ctx);
            }
            else
            {
                return ParseOrdinaryNumber(chars, i, endStr, negative, ctx);
            }
        }

        private static EDecimal ParseSpecialValue(
          byte[] chars,
          int i,
          int endStr,
          bool negative,
          EContext ctx)
        {
            var mantInt = 0;
            EInteger mant = null;
            var haveDigits = false;
            var digitStart = 0;
            if (i + 8 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') &&
                  (chars[i + 2] == 'F' || chars[i + 2] == 'f') &&
                  (chars[i + 3] == 'I' || chars[i + 3] == 'i') && (chars[i + 4] ==
        'N' ||
                    chars[i + 4] == 'n') && (chars[i + 5] == 'I' || chars[i + 5] ==
        'i') &&
                  (chars[i + 6] == 'T' || chars[i + 6] == 't') && (chars[i + 7] ==
        'Y' ||
                    chars[i + 7] == 'y'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? EDecimal.NegativeInfinity :
          EDecimal.PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') && (chars[i + 2] ==
        'F' ||
                    chars[i + 2] == 'f'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? EDecimal.NegativeInfinity :
          EDecimal.PositiveInfinity;
                }
            }
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((chars[i] == 'N' || chars[i] == 'n') && (chars[i + 1] == 'A' ||
        chars[i +
                      1] == 'a') && (chars[i + 2] == 'N' || chars[i + 2] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? EDecimal.NaN : new EDecimal(
                            FastIntegerFixed.Zero,
                            FastIntegerFixed.Zero,
                            (byte)flags2);
                    }
                    i += 3;
                    var digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    digitStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt <= MaxSafeInt)
                            {
                                // multiply by 10
                                mantInt *= 10;
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mantInt > MaxSafeInt)
                    {
                        mant = EInteger.FromSubstring(chars, digitStart, endStr);
                    }
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant;
                    flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    return EDecimal.CreateWithFlags(
                        FastIntegerFixed.FromBig(bigmant),
                        FastIntegerFixed.Zero,
                        flags2);
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((chars[i] == 'S' || chars[i] == 's') && (chars[i + 1] == 'N' ||
        chars[i +
                      1] == 'n') && (chars[i + 2] == 'A' || chars[i + 2] == 'a') &&
                  (chars[i + 3] == 'N' || chars[i + 3] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    if (i + 4 == endStr)
                    {
                        int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                          BigNumberFlags.FlagSignalingNaN;
                        return (!negative) ? EDecimal.SignalingNaN :
                          new EDecimal(
                            FastIntegerFixed.Zero,
                            FastIntegerFixed.Zero,
                            (byte)flags2);
                    }
                    i += 4;
                    var digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    digitStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt <= MaxSafeInt)
                            {
                                // multiply by 10
                                mantInt *= 10;
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mantInt > MaxSafeInt)
                    {
                        mant = EInteger.FromSubstring(chars, digitStart, endStr);
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant;
                    return EDecimal.CreateWithFlags(
                        bigmant,
                        EInteger.Zero,
                        flags3);
                }
            }
            return null;
        }

        private static EDecimal ParseOrdinaryNumberLimitedPrecision(
          byte[] chars,
          int offset,
          int endStr,
          bool negative,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                throw new InvalidOperationException();
            }
            var haveDecimalPoint = false;
            var haveDigits = false;
            var haveExponent = false;
            var newScaleInt = 0;
            int i = tmpoffset;
            long mantissaLong = 0L;
            // Ordinary number
            int digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            var nonzeroBeyondMax = false;
            var beyondMax = false;
            var lastdigit = -1;
            EInteger precisionPlusTwo = ctx.Precision.Add(2);
            for (; i < endStr; ++i)
            {
                byte ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveDigits = true;
                    haveNonzeroDigit |= thisdigit != 0;
                    if (beyondMax || (precisionPlusTwo.CompareTo(decimalPrec) < 0 &&
                        mantissaLong == Int64.MaxValue))
                    {
                        // Well beyond maximum precision, significand is
                        // max or bigger
                        beyondMax = true;
                        if (thisdigit != 0)
                        {
                            nonzeroBeyondMax = true;
                        }
                        if (!haveDecimalPoint)
                        {
                            // NOTE: Absolute value will not be more than
                            // the sequence portion's length, so will fit comfortably
                            // in an 'int'.
                            newScaleInt = checked(newScaleInt + 1);
                        }
                        continue;
                    }
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantissaLong <= 922337203685477580L)
                    {
                        mantissaLong *= 10;
                        mantissaLong += thisdigit;
                    }
                    else
                    {
                        mantissaLong = Int64.MaxValue;
                    }
                    if (haveDecimalPoint)
                    {
                        // NOTE: Absolute value will not be more than
                        // the sequence portion's length, so will fit comfortably
                        // in an 'int'.
                        newScaleInt = checked(newScaleInt - 1);
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            bool zeroMantissa = !haveNonzeroDigit;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (chars[i] == '+' || chars[i] == '-')
                {
                    if (chars[i] == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    byte ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= 214748364)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                        else
                        {
                            expInt = Int32.MaxValue;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                expInt *= expoffset;
                if (expPrec > 12)
                {
                    // Exponent that can't be compensated by digit
                    // length without remaining higher than Int32.MaxValue
                    if (expoffset < 0)
                    {
                        return EDecimal.SignalUnderflow(ctx, negative, zeroMantissa);
                    }
                    else
                    {
                        return EDecimal.SignalOverflow(ctx, negative, zeroMantissa);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (expInt != Int32.MaxValue && expInt > -Int32.MaxValue &&
              mantissaLong != Int64.MaxValue)
            {
                // Low precision, low exponent
                var finalexp = (long)expInt + (long)newScaleInt;
                if (negative)
                {
                    mantissaLong = -mantissaLong;
                }
                EDecimal eret = EDecimal.Create(mantissaLong, finalexp);
                if (negative && zeroMantissa)
                {
                    eret = eret.Negate();
                }
                return eret.RoundToPrecision(ctx);
            }
            EInteger mant = null;
            EInteger exp = (!haveExponent) ? EInteger.Zero :
              EInteger.FromSubstring(chars, expDigitStart, endStr);
            if (expoffset < 0)
            {
                exp = exp.Negate();
            }
            exp = exp.Add(newScaleInt);
            if (nonzeroBeyondMax)
            {
                exp = exp.Subtract(1);
                ++decimalPrec;
            }
            if (ctx.HasExponentRange)
            {
                EInteger adjExpUpperBound = exp.Add(decimalPrec).Subtract(1);
                EInteger adjExpLowerBound = exp;
                EInteger eTiny = ctx.EMin.Subtract(ctx.Precision.Subtract(1));
                eTiny = eTiny.Subtract(1);
                // DebugUtility.Log("exp=" + adjExpLowerBound + "~" +
                // adjExpUpperBound + ", emin={0} emax={1}", ctx.EMin, ctx.EMax);
                if (adjExpUpperBound.CompareTo(eTiny) < 0)
                {
                    return EDecimal.SignalUnderflow(ctx, negative, zeroMantissa);
                }
                else if (adjExpLowerBound.CompareTo(ctx.EMax) > 0)
                {
                    return EDecimal.SignalOverflow(ctx, negative, zeroMantissa);
                }
            }
            if (zeroMantissa)
            {
                EDecimal ef = EDecimal.Create(
                    EInteger.Zero,
                    exp);
                if (negative)
                {
                    ef = ef.Negate();
                }
                return ef.RoundToPrecision(ctx);
            }
            else if (decimalDigitStart != decimalDigitEnd)
            {
                byte[] ctmpstr = Extras.CharsConcat(
                  chars,
                  digitStart,
                  digitEnd - digitStart,
                  chars,
                  decimalDigitStart,
                  decimalDigitEnd - decimalDigitStart);
                mant = EInteger.FromString(ctmpstr);
            }
            else
            {
                mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
            }
            if (nonzeroBeyondMax)
            {
                mant = mant.Multiply(10).Add(1);
            }
            if (negative)
            {
                mant = mant.Negate();
            }
            return EDecimal.Create(mant, exp)
              .RoundToPrecision(ctx);
        }

        private static EDecimal ParseOrdinaryNumberNoContext(
          byte[] chars,
          int i,
          int endStr,
          bool negative)
        {
            // NOTE: Negative sign at beginning was omitted
            // from the sequence portion
            var mantInt = 0;
            EInteger mant = null;
            var haveDecimalPoint = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var haveDigits = false;
            var digitStart = 0;
            EInteger newScale = null;
            // Ordinary number
            if (endStr - i == 1)
            {
                byte tch = chars[i];
                if (tch >= '0' && tch <= '9')
                {
                    // String portion is a single digit
                    var si = (int)(tch - '0');
                    return negative ? ((si == 0) ? EDecimal.NegativeZero :
                        EDecimal.FromCache(-si)) : EDecimal.FromCache(si);
                }
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            var firstdigit = -1;
            int decimalDigitEnd = i;
            var lastdigit = -1;
            var realDigitEnd = -1;
            var realDecimalEnd = -1;
            for (; i < endStr; ++i)
            {
                byte ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveNonzeroDigit |= thisdigit != 0;
                    if (firstdigit < 0)
                    {
                        firstdigit = thisdigit;
                    }
                    haveDigits = true;
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantInt <= MaxSafeInt)
                    {
                        // multiply by 10
                        mantInt *= 10;
                        mantInt += thisdigit;
                    }
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Subtract(1);
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    realDigitEnd = i;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    realDecimalEnd = i;
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (realDigitEnd < 0)
            {
                realDigitEnd = i;
            }
            if (realDecimalEnd < 0)
            {
                realDecimalEnd = i;
            }
            EDecimal ret = null;
            EInteger exp = null;
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                byte ch = chars[i];
                if (ch == '+' || ch == '-')
                {
                    if (ch == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= MaxSafeInt)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            // Calculate newScale if exponent is "small"
            if (haveExponent && expInt <= MaxSafeInt)
            {
                if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                {
                    newScaleInt = expInt;
                }
                else if (newScale == null)
                {
                    long tmplong = newScaleInt;
                    if (expoffset < 0)
                    {
                        tmplong -= expInt;
                    }
                    else if (expInt != 0)
                    {
                        tmplong += expInt;
                    }
                    if (tmplong >= Int32.MaxValue && tmplong <= Int32.MinValue)
                    {
                        newScaleInt = (int)tmplong;
                    }
                    else
                    {
                        newScale = EInteger.FromInt64(tmplong);
                    }
                }
                else
                {
                    if (expoffset < 0)
                    {
                        newScale = newScale.Subtract(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale = newScale.Add(expInt);
                    }
                }
            }
            int de = digitEnd;
            int dde = decimalDigitEnd;
            if (!haveExponent && haveDecimalPoint)
            {
                // No more than 18 digits
                long lv = 0L;
                int expo = -(dde - decimalDigitStart);
                var digitCount = 0;
                if (mantInt <= MaxSafeInt)
                {
                    lv = mantInt;
                }
                else
                {
                    var vi = 0;
                    for (vi = digitStart; vi < de; ++vi)
                    {
                        byte chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                    for (vi = decimalDigitStart; vi < dde; ++vi)
                    {
                        byte chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                }
                if (negative)
                {
                    lv = -lv;
                }
                if (digitCount >= 0 && (!negative || lv != 0))
                {
                    ret = EDecimal.Create(lv, (long)expo);
                    return ret;
                }
            }
            // Parse significand if it's "big"
            if (mantInt > MaxSafeInt)
            {
                if (haveDecimalPoint)
                {
                    if (digitEnd - digitStart == 1 && firstdigit == 0)
                    {
                        mant = EInteger.FromSubstring(
                            chars,
                            decimalDigitStart,
                            decimalDigitEnd);
                    }
                    else
                    {
                        byte[] cdecstr = Extras.CharsConcat(
                          chars,
                          digitStart,
                          digitEnd - digitStart,
                          chars,
                          decimalDigitStart,
                          decimalDigitEnd - decimalDigitStart);
                        mant = EInteger.FromString(cdecstr);
                    }
                }
                else
                {
                    mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
                }
            }
            if (haveExponent && expInt > MaxSafeInt)
            {
                // Parse exponent if it's "big"
                exp = EInteger.FromSubstring(chars, expDigitStart, endStr);
                newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                newScale = (expoffset < 0) ? newScale.Subtract(exp) :
                  newScale.Add(exp);
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? FastIntegerFixed.FromInt32(
                newScaleInt) : FastIntegerFixed.FromBig(newScale);
            if (mant == null)
            {
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.ToInt32Checked();
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromBig(mant);
            }
            ret = new EDecimal(
              fastIntMant,
              fastIntScale,
              (byte)(negative ? BigNumberFlags.FlagNegative : 0));
            return ret;
        }

        private static EDecimal ParseOrdinaryNumber(
          byte[] chars,
          int i,
          int endStr,
          bool negative,
          EContext ctx)
        {
            if (ctx == null)
            {
                return ParseOrdinaryNumberNoContext(chars, i, endStr, negative);
            }
            // NOTE: Negative sign at beginning was omitted
            // from the sequence portion
            var mantInt = 0;
            EInteger mant = null;
            var haveDecimalPoint = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var haveDigits = false;
            var digitStart = 0;
            EInteger newScale = null;
            // Ordinary number
            if (endStr - i == 1)
            {
                byte tch = chars[i];
                if (tch >= '0' && tch <= '9')
                {
                    // String portion is a single digit
                    EDecimal cret;
                    var si = (int)(tch - '0');
                    cret = negative ? ((si == 0) ? EDecimal.NegativeZero :
          EDecimal.FromCache(-si)) : EDecimal.FromCache(si);
                    if (ctx != null)
                    {
                        cret = EDecimal.GetMathValue(ctx).RoundAfterConversion(cret, ctx);
                    }
                    return cret;
                }
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            // NOTE: Also check HasFlagsOrTraps here because
            // it's burdensome to determine which flags have
            // to be set when applying the optimization here
            bool roundDown = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.Down ||
                (negative && ctx.Rounding == ERounding.Ceiling) ||
                (!negative && ctx.Rounding == ERounding.Floor)) &&
              !ctx.HasFlagsOrTraps;
            bool roundHalf = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.HalfUp ||
                (ctx.Rounding == ERounding.HalfDown) ||
                (ctx.Rounding == ERounding.HalfEven)) &&
              !ctx.HasFlagsOrTraps;
            bool roundUp = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.Up ||
                (!negative && ctx.Rounding == ERounding.Ceiling) ||
                (negative && ctx.Rounding == ERounding.Floor)) &&
              !ctx.HasFlagsOrTraps;
            var haveIgnoredDigit = false;
            var lastdigit = -1;
            var beyondPrecision = false;
            var ignoreNextDigit = false;
            var zerorun = 0;
            var realDigitEnd = -1;
            var realDecimalEnd = -1;
            // DebugUtility.Log("round half=" + (// roundHalf) +
            // " up=" + roundUp + " down=" + roundDown +
            // " maxprec=" + (ctx != null && ctx.HasMaxPrecision));
            for (; i < endStr; ++i)
            {
                byte ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveNonzeroDigit |= thisdigit != 0;
                    haveDigits = true;
                    beyondPrecision |= ctx != null && ctx.HasMaxPrecision &&
                      !ctx.IsPrecisionInBits && ctx.Precision.CompareTo(decimalPrec)
                      <= 0;
                    if (ctx != null)
                    {
                        if (ignoreNextDigit)
                        {
                            haveIgnoredDigit = true;
                            ignoreNextDigit = false;
                        }
                        if (roundDown && (haveIgnoredDigit || beyondPrecision))
                        {
                            // "Ignored" digit
                            haveIgnoredDigit = true;
                        }
                        else if (roundUp && beyondPrecision && !haveIgnoredDigit)
                        {
                            if (thisdigit > 0)
                            {
                                ignoreNextDigit = true;
                            }
                            else
                            {
                                roundUp = false;
                            }
                        }
                        else if (roundHalf && beyondPrecision && !haveIgnoredDigit)
                        {
                            if (thisdigit >= 1 && thisdigit < 5)
                            {
                                ignoreNextDigit = true;
                            }
                            else if (thisdigit > 5 || (thisdigit == 5 &&
                              ctx.Rounding == ERounding.HalfUp))
                            {
                                roundHalf = false;
                                roundUp = true;
                                ignoreNextDigit = true;
                            }
                            else
                            {
                                roundHalf = false;
                            }
                        }
                    }
                    if (haveIgnoredDigit)
                    {
                        zerorun = 0;
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Add(1);
                        }
                        else
                        {
                            ++newScaleInt;
                        }
                    }
                    else
                    {
                        lastdigit = thisdigit;
                        if (beyondPrecision && thisdigit == 0)
                        {
                            ++zerorun;
                        }
                        else
                        {
                            zerorun = 0;
                        }
                        if (haveNonzeroDigit)
                        {
                            ++decimalPrec;
                        }
                        if (haveDecimalPoint)
                        {
                            decimalDigitEnd = i + 1;
                        }
                        else
                        {
                            digitEnd = i + 1;
                        }
                        if (mantInt <= MaxSafeInt)
                        {
                            // multiply by 10
                            mantInt *= 10;
                            mantInt += thisdigit;
                        }
                    }
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Subtract(1);
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    realDigitEnd = i;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    realDecimalEnd = i;
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (realDigitEnd < 0)
            {
                realDigitEnd = i;
            }
            if (realDecimalEnd < 0)
            {
                realDecimalEnd = i;
            }
            if (zerorun > 0 && lastdigit == 0 && (ctx == null ||
                !ctx.HasFlagsOrTraps))
            {
                decimalPrec -= zerorun;
                var nondec = 0;
                // NOTE: This check is apparently needed for correctness
                if (ctx == null || (!ctx.HasMaxPrecision ||
                    decimalPrec - ctx.Precision.ToInt32Checked() > zerorun))
                {
                    if (haveDecimalPoint)
                    {
                        int decdigits = decimalDigitEnd - decimalDigitStart;
                        nondec = Math.Min(decdigits, zerorun);
                        decimalDigitEnd -= nondec;
                        int remain = zerorun - nondec;
                        digitEnd -= remain;
                        // DebugUtility.Log("remain={0} nondec={1}
                        // newScale={2}",remain,nondec,newScaleInt);
                        nondec = zerorun;
                    }
                    else
                    {
                        digitEnd -= zerorun;
                        nondec = zerorun;
                    }
                    if (newScaleInt > Int32.MinValue + nondec &&
                      newScaleInt < Int32.MaxValue - nondec)
                    {
                        newScaleInt += nondec;
                    }
                    else
                    {
                        newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                        newScale = newScale.Add(nondec);
                    }
                }
                // DebugUtility.Log("-->zerorun={0} prec={1} [whole={2}, dec={3}]
                // chars={4}",zerorun,decimalPrec,
                // digitEnd-digitStart, decimalDigitEnd-decimalDigitStart, chars);
            }
            // if (ctx != null) {
            // DebugUtility.Log("roundup [prec=" + decimalPrec + ", ctxprec=" +
            // (// ctx.Precision) + ", chars=" + (// chars.Substring(0, Math.Min(20,
            // chars.Length))) + "] " + (ctx.Rounding));
            // }
            // DebugUtility.Log("digitRange="+digitStart+"-"+digitEnd+
            // "decdigitRange="+decimalDigitStart+"-"+decimalDigitEnd);
            if (
              roundUp && ctx != null &&
              ctx.Precision.CompareTo(decimalPrec) < 0)
            {
                int precdiff = decimalPrec - ctx.Precision.ToInt32Checked();
                // DebugUtility.Log("precdiff = " + precdiff + " [prec=" + (// decimalPrec) +
                // ",
                // ctxprec=" + ctx.Precision + "]");
                if (precdiff > 1)
                {
                    int precchop = precdiff - 1;
                    decimalPrec -= precchop;
                    int nondec = precchop;
                    // DebugUtility.Log("precchop=" + (precchop));
                    if (haveDecimalPoint)
                    {
                        int decdigits = decimalDigitEnd - decimalDigitStart;
                        // DebugUtility.Log("decdigits=" + decdigits + " decprecchop=" + (decdigits));
                        decimalDigitEnd -= nondec;
                        int remain = precchop - nondec;
                        digitEnd -= remain;
                    }
                    else
                    {
                        digitEnd -= precchop;
                    }
                    if (newScaleInt < Int32.MaxValue - nondec)
                    {
                        newScaleInt += nondec;
                    }
                    else
                    {
                        newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                        newScale = newScale.Add(nondec);
                    }
                }
            }
            EDecimal ret = null;
            EInteger exp = null;
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (chars[i] == '+' || chars[i] == '-')
                {
                    if (chars[i] == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    byte ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= MaxSafeInt)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            // Calculate newScale if exponent is "small"
            if (haveExponent && expInt <= MaxSafeInt)
            {
                if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                {
                    newScaleInt = expInt;
                }
                else if (newScale == null)
                {
                    long tmplong = newScaleInt;
                    if (expoffset < 0)
                    {
                        tmplong -= expInt;
                    }
                    else if (expInt != 0)
                    {
                        tmplong += expInt;
                    }
                    if (tmplong >= Int32.MaxValue && tmplong <= Int32.MinValue)
                    {
                        newScaleInt = (int)tmplong;
                    }
                    else
                    {
                        newScale = EInteger.FromInt64(tmplong);
                    }
                }
                else
                {
                    if (expoffset < 0)
                    {
                        newScale = newScale.Subtract(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale = newScale.Add(expInt);
                    }
                }
            }
            if (ctx != null && (mantInt > MaxSafeInt || (haveExponent &&
                  expInt > MaxSafeInt)) && ctx.HasExponentRange)
            {
                EInteger ns;
                if (expInt <= MaxSafeInt && ctx != null)
                {
                    ns = newScale ?? EInteger.FromInt32(newScaleInt);
                }
                else
                {
                    EInteger trialExponent = EInteger.FromInt32(MaxSafeInt);
                    if (expPrec > 25)
                    {
                        // Exponent has many significant digits; use a bigger trial exponent
                        trialExponent = EInteger.FromInt64(Int64.MaxValue);
                    }
                    // Trial exponent; in case of overflow or
                    // underflow, the real exponent will also overflow or underflow
                    if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                    {
                        ns = trialExponent;
                    }
                    else
                    {
                        ns = newScale ?? EInteger.FromInt32(newScaleInt);
                        ns = (expoffset < 0) ? ns.Subtract(trialExponent) :
                          ns.Add(trialExponent);
                    }
                }
                int expwithin = EDecimal.CheckOverflowUnderflow(
                    ctx,
                    decimalPrec,
                    ns);
                if (mantInt == 0 && (expwithin == 1 || expwithin == 2 ||
                    expwithin == 3))
                {
                    // Significand is zero
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(0),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    return EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                }
                else if (expwithin == 1)
                {
                    // Exponent indicates overflow
                    return EDecimal.GetMathValue(ctx).SignalOverflow(ctx, negative);
                }
                else if (expwithin == 2 || (expwithin == 3 && mantInt < MaxSafeInt))
                {
                    // Exponent indicates underflow to zero
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(expwithin == 3 ? mantInt : 1),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    return EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                }
                else if (expwithin == 3 && (ctx == null || ctx.Traps == 0))
                {
                    // Exponent indicates underflow to zero, adjust exponent
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(1),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                    ns = ret.Exponent.Subtract(decimalPrec - 1);
                    ret = EDecimal.ChangeExponent(ret, ns);
                    return ret;
                }
            }
            // DebugUtility.Log("digitRange="+digitStart+"-"+digitEnd+
            // "decdigitRange="+decimalDigitStart+"-"+decimalDigitEnd);
            int de = digitEnd;
            int dde = decimalDigitEnd;
            if (!haveExponent && haveDecimalPoint && newScale == null)
            {
                // No more than 18 digits
                long lv = 0L;
                int expo = newScaleInt; // -(dde - decimalDigitStart);
                var digitCount = 0;
                if (mantInt <= MaxSafeInt)
                {
                    lv = mantInt;
                }
                else
                {
                    var vi = 0;
                    for (vi = digitStart; vi < de; ++vi)
                    {
                        byte chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                    for (vi = decimalDigitStart; vi < dde; ++vi)
                    {
                        byte chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                }
                if (negative)
                {
                    lv = -lv;
                }
                if (digitCount >= 0 && (!negative || lv != 0))
                {
                    // DebugUtility.Log("lv="+lv+" expo="+expo);
                    ret = EDecimal.Create(lv, (long)expo);
                    if (ctx != null)
                    {
                        ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                    }
                    return ret;
                }
            }
            // Parse significand if it's "big"
            if (mantInt > MaxSafeInt)
            {
                if (haveDecimalPoint)
                {
                    if (digitEnd - digitStart == 1 && chars[digitStart] == '0')
                    {
                        mant = EInteger.FromSubstring(
                            chars,
                            decimalDigitStart,
                            decimalDigitEnd);
                    }
                    else
                    {
                        byte[] cdecstr = Extras.CharsConcat(
                          chars,
                          digitStart,
                          digitEnd - digitStart,
                          chars,
                          decimalDigitStart,
                          decimalDigitEnd - decimalDigitStart);
                        mant = EInteger.FromString(cdecstr);
                    }
                }
                else
                {
                    mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
                }
            }
            if (haveExponent && expInt > MaxSafeInt)
            {
                // Parse exponent if it's "big"
                exp = EInteger.FromSubstring(chars, expDigitStart, endStr);
                newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                newScale = (expoffset < 0) ? newScale.Subtract(exp) :
                  newScale.Add(exp);
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? FastIntegerFixed.FromInt32(
                newScaleInt) : FastIntegerFixed.FromBig(newScale);
            // DebugUtility.Log("fim="+ Chop(mant) + ", exp=" + fastIntScale);
            if (mant == null)
            {
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.ToInt32Checked();
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromBig(mant);
            }
            ret = new EDecimal(
              fastIntMant,
              fastIntScale,
              (byte)(negative ? BigNumberFlags.FlagNegative : 0));
            if (ctx != null)
            {
                // DebugUtility.Log("rounding");
                ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
            }
            return ret;
        }
    }

    internal static class EDecimalCharArrayString
    {
        private const int MaxSafeInt = EDecimal.MaxSafeInt;

        internal static EDecimal FromString(
          char[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset(" + tmpoffset + ") is less than " +
                  "0");
            }
            if (tmpoffset > chars.Length)
            {
                throw new FormatException("offset(" + tmpoffset + ") is more than " +
                  chars.Length);
            }
            if (length <= 0)
            {
                if (length == 0)
                {
                    throw new FormatException("length is 0");
                }
                throw new FormatException("length(" + length + ") is less than " +
                  "0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is more than " +
                  chars.Length);
            }
            if (chars.Length - tmpoffset < length)
            {
                throw new FormatException("chars's length minus " + tmpoffset + "(" +
                  (chars.Length - tmpoffset) + ") is less than " + length);
            }
            var negative = false;
            int endStr = tmpoffset + length;
            char c = chars[tmpoffset];
            if (c == '-')
            {
                negative = true;
                ++tmpoffset;
                if (tmpoffset >= endStr)
                {
                    throw new FormatException();
                }
                c = chars[tmpoffset];
            }
            else if (chars[tmpoffset] == '+')
            {
                ++tmpoffset;
                if (tmpoffset >= endStr)
                {
                    throw new FormatException();
                }
                c = chars[tmpoffset];
            }
            int i = tmpoffset;
            if (c < '0' || c > '9')
            {
                EDecimal ed = ParseSpecialValue(chars, i, endStr, negative, ctx);
                if (ed != null)
                {
                    return ed;
                }
            }
            if (ctx != null && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              !ctx.IsSimplified)
            {
                return ParseOrdinaryNumberLimitedPrecision(
                    chars,
                    i,
                    endStr,
                    negative,
                    ctx);
            }
            else
            {
                return ParseOrdinaryNumber(chars, i, endStr, negative, ctx);
            }
        }

        private static EDecimal ParseSpecialValue(
          char[] chars,
          int i,
          int endStr,
          bool negative,
          EContext ctx)
        {
            var mantInt = 0;
            EInteger mant = null;
            var haveDigits = false;
            var digitStart = 0;
            if (i + 8 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') &&
                  (chars[i + 2] == 'F' || chars[i + 2] == 'f') &&
                  (chars[i + 3] == 'I' || chars[i + 3] == 'i') && (chars[i + 4] ==
        'N' ||
                    chars[i + 4] == 'n') && (chars[i + 5] == 'I' || chars[i + 5] ==
        'i') &&
                  (chars[i + 6] == 'T' || chars[i + 6] == 't') && (chars[i + 7] ==
        'Y' ||
                    chars[i + 7] == 'y'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? EDecimal.NegativeInfinity :
          EDecimal.PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') && (chars[i + 2] ==
        'F' ||
                    chars[i + 2] == 'f'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? EDecimal.NegativeInfinity :
          EDecimal.PositiveInfinity;
                }
            }
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((chars[i] == 'N' || chars[i] == 'n') && (chars[i + 1] == 'A' ||
        chars[i +
                      1] == 'a') && (chars[i + 2] == 'N' || chars[i + 2] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? EDecimal.NaN : new EDecimal(
                            FastIntegerFixed.Zero,
                            FastIntegerFixed.Zero,
                            (byte)flags2);
                    }
                    i += 3;
                    var digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    digitStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt <= MaxSafeInt)
                            {
                                // multiply by 10
                                mantInt *= 10;
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mantInt > MaxSafeInt)
                    {
                        mant = EInteger.FromSubstring(chars, digitStart, endStr);
                    }
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant;
                    flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    return EDecimal.CreateWithFlags(
                        FastIntegerFixed.FromBig(bigmant),
                        FastIntegerFixed.Zero,
                        flags2);
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((chars[i] == 'S' || chars[i] == 's') && (chars[i + 1] == 'N' ||
        chars[i +
                      1] == 'n') && (chars[i + 2] == 'A' || chars[i + 2] == 'a') &&
                  (chars[i + 3] == 'N' || chars[i + 3] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    if (i + 4 == endStr)
                    {
                        int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                          BigNumberFlags.FlagSignalingNaN;
                        return (!negative) ? EDecimal.SignalingNaN :
                          new EDecimal(
                            FastIntegerFixed.Zero,
                            FastIntegerFixed.Zero,
                            (byte)flags2);
                    }
                    i += 4;
                    var digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    digitStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt <= MaxSafeInt)
                            {
                                // multiply by 10
                                mantInt *= 10;
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mantInt > MaxSafeInt)
                    {
                        mant = EInteger.FromSubstring(chars, digitStart, endStr);
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant;
                    return EDecimal.CreateWithFlags(
                        bigmant,
                        EInteger.Zero,
                        flags3);
                }
            }
            return null;
        }

        private static EDecimal ParseOrdinaryNumberLimitedPrecision(
          char[] chars,
          int offset,
          int endStr,
          bool negative,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                throw new InvalidOperationException();
            }
            var haveDecimalPoint = false;
            var haveDigits = false;
            var haveExponent = false;
            var newScaleInt = 0;
            int i = tmpoffset;
            long mantissaLong = 0L;
            // Ordinary number
            int digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            var nonzeroBeyondMax = false;
            var beyondMax = false;
            var lastdigit = -1;
            EInteger precisionPlusTwo = ctx.Precision.Add(2);
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveDigits = true;
                    haveNonzeroDigit |= thisdigit != 0;
                    if (beyondMax || (precisionPlusTwo.CompareTo(decimalPrec) < 0 &&
                        mantissaLong == Int64.MaxValue))
                    {
                        // Well beyond maximum precision, significand is
                        // max or bigger
                        beyondMax = true;
                        if (thisdigit != 0)
                        {
                            nonzeroBeyondMax = true;
                        }
                        if (!haveDecimalPoint)
                        {
                            // NOTE: Absolute value will not be more than
                            // the sequence portion's length, so will fit comfortably
                            // in an 'int'.
                            newScaleInt = checked(newScaleInt + 1);
                        }
                        continue;
                    }
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantissaLong <= 922337203685477580L)
                    {
                        mantissaLong *= 10;
                        mantissaLong += thisdigit;
                    }
                    else
                    {
                        mantissaLong = Int64.MaxValue;
                    }
                    if (haveDecimalPoint)
                    {
                        // NOTE: Absolute value will not be more than
                        // the sequence portion's length, so will fit comfortably
                        // in an 'int'.
                        newScaleInt = checked(newScaleInt - 1);
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            bool zeroMantissa = !haveNonzeroDigit;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (chars[i] == '+' || chars[i] == '-')
                {
                    if (chars[i] == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    char ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= 214748364)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                        else
                        {
                            expInt = Int32.MaxValue;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                expInt *= expoffset;
                if (expPrec > 12)
                {
                    // Exponent that can't be compensated by digit
                    // length without remaining higher than Int32.MaxValue
                    if (expoffset < 0)
                    {
                        return EDecimal.SignalUnderflow(ctx, negative, zeroMantissa);
                    }
                    else
                    {
                        return EDecimal.SignalOverflow(ctx, negative, zeroMantissa);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (expInt != Int32.MaxValue && expInt > -Int32.MaxValue &&
              mantissaLong != Int64.MaxValue)
            {
                // Low precision, low exponent
                var finalexp = (long)expInt + (long)newScaleInt;
                if (negative)
                {
                    mantissaLong = -mantissaLong;
                }
                EDecimal eret = EDecimal.Create(mantissaLong, finalexp);
                if (negative && zeroMantissa)
                {
                    eret = eret.Negate();
                }
                return eret.RoundToPrecision(ctx);
            }
            EInteger mant = null;
            EInteger exp = (!haveExponent) ? EInteger.Zero :
              EInteger.FromSubstring(chars, expDigitStart, endStr);
            if (expoffset < 0)
            {
                exp = exp.Negate();
            }
            exp = exp.Add(newScaleInt);
            if (nonzeroBeyondMax)
            {
                exp = exp.Subtract(1);
                ++decimalPrec;
            }
            if (ctx.HasExponentRange)
            {
                EInteger adjExpUpperBound = exp.Add(decimalPrec).Subtract(1);
                EInteger adjExpLowerBound = exp;
                EInteger eTiny = ctx.EMin.Subtract(ctx.Precision.Subtract(1));
                eTiny = eTiny.Subtract(1);
                // DebugUtility.Log("exp=" + adjExpLowerBound + "~" +
                // adjExpUpperBound + ", emin={0} emax={1}", ctx.EMin, ctx.EMax);
                if (adjExpUpperBound.CompareTo(eTiny) < 0)
                {
                    return EDecimal.SignalUnderflow(ctx, negative, zeroMantissa);
                }
                else if (adjExpLowerBound.CompareTo(ctx.EMax) > 0)
                {
                    return EDecimal.SignalOverflow(ctx, negative, zeroMantissa);
                }
            }
            if (zeroMantissa)
            {
                EDecimal ef = EDecimal.Create(
                    EInteger.Zero,
                    exp);
                if (negative)
                {
                    ef = ef.Negate();
                }
                return ef.RoundToPrecision(ctx);
            }
            else if (decimalDigitStart != decimalDigitEnd)
            {
                char[] ctmpstr = Extras.CharsConcat(
                  chars,
                  digitStart,
                  digitEnd - digitStart,
                  chars,
                  decimalDigitStart,
                  decimalDigitEnd - decimalDigitStart);
                mant = EInteger.FromString(ctmpstr);
            }
            else
            {
                mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
            }
            if (nonzeroBeyondMax)
            {
                mant = mant.Multiply(10).Add(1);
            }
            if (negative)
            {
                mant = mant.Negate();
            }
            return EDecimal.Create(mant, exp)
              .RoundToPrecision(ctx);
        }

        private static EDecimal ParseOrdinaryNumberNoContext(
          char[] chars,
          int i,
          int endStr,
          bool negative)
        {
            // NOTE: Negative sign at beginning was omitted
            // from the sequence portion
            var mantInt = 0;
            EInteger mant = null;
            var haveDecimalPoint = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var haveDigits = false;
            var digitStart = 0;
            EInteger newScale = null;
            // Ordinary number
            if (endStr - i == 1)
            {
                char tch = chars[i];
                if (tch >= '0' && tch <= '9')
                {
                    // String portion is a single digit
                    var si = (int)(tch - '0');
                    return negative ? ((si == 0) ? EDecimal.NegativeZero :
                        EDecimal.FromCache(-si)) : EDecimal.FromCache(si);
                }
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            var firstdigit = -1;
            int decimalDigitEnd = i;
            var lastdigit = -1;
            var realDigitEnd = -1;
            var realDecimalEnd = -1;
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveNonzeroDigit |= thisdigit != 0;
                    if (firstdigit < 0)
                    {
                        firstdigit = thisdigit;
                    }
                    haveDigits = true;
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantInt <= MaxSafeInt)
                    {
                        // multiply by 10
                        mantInt *= 10;
                        mantInt += thisdigit;
                    }
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Subtract(1);
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    realDigitEnd = i;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    realDecimalEnd = i;
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (realDigitEnd < 0)
            {
                realDigitEnd = i;
            }
            if (realDecimalEnd < 0)
            {
                realDecimalEnd = i;
            }
            EDecimal ret = null;
            EInteger exp = null;
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                char ch = chars[i];
                if (ch == '+' || ch == '-')
                {
                    if (ch == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= MaxSafeInt)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            // Calculate newScale if exponent is "small"
            if (haveExponent && expInt <= MaxSafeInt)
            {
                if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                {
                    newScaleInt = expInt;
                }
                else if (newScale == null)
                {
                    long tmplong = newScaleInt;
                    if (expoffset < 0)
                    {
                        tmplong -= expInt;
                    }
                    else if (expInt != 0)
                    {
                        tmplong += expInt;
                    }
                    if (tmplong >= Int32.MaxValue && tmplong <= Int32.MinValue)
                    {
                        newScaleInt = (int)tmplong;
                    }
                    else
                    {
                        newScale = EInteger.FromInt64(tmplong);
                    }
                }
                else
                {
                    if (expoffset < 0)
                    {
                        newScale = newScale.Subtract(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale = newScale.Add(expInt);
                    }
                }
            }
            int de = digitEnd;
            int dde = decimalDigitEnd;
            if (!haveExponent && haveDecimalPoint)
            {
                // No more than 18 digits
                long lv = 0L;
                int expo = -(dde - decimalDigitStart);
                var digitCount = 0;
                if (mantInt <= MaxSafeInt)
                {
                    lv = mantInt;
                }
                else
                {
                    var vi = 0;
                    for (vi = digitStart; vi < de; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                    for (vi = decimalDigitStart; vi < dde; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                }
                if (negative)
                {
                    lv = -lv;
                }
                if (digitCount >= 0 && (!negative || lv != 0))
                {
                    ret = EDecimal.Create(lv, (long)expo);
                    return ret;
                }
            }
            // Parse significand if it's "big"
            if (mantInt > MaxSafeInt)
            {
                if (haveDecimalPoint)
                {
                    if (digitEnd - digitStart == 1 && firstdigit == 0)
                    {
                        mant = EInteger.FromSubstring(
                            chars,
                            decimalDigitStart,
                            decimalDigitEnd);
                    }
                    else
                    {
                        char[] cdecstr = Extras.CharsConcat(
                          chars,
                          digitStart,
                          digitEnd - digitStart,
                          chars,
                          decimalDigitStart,
                          decimalDigitEnd - decimalDigitStart);
                        mant = EInteger.FromString(cdecstr);
                    }
                }
                else
                {
                    mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
                }
            }
            if (haveExponent && expInt > MaxSafeInt)
            {
                // Parse exponent if it's "big"
                exp = EInteger.FromSubstring(chars, expDigitStart, endStr);
                newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                newScale = (expoffset < 0) ? newScale.Subtract(exp) :
                  newScale.Add(exp);
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? FastIntegerFixed.FromInt32(
                newScaleInt) : FastIntegerFixed.FromBig(newScale);
            if (mant == null)
            {
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.ToInt32Checked();
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromBig(mant);
            }
            ret = new EDecimal(
              fastIntMant,
              fastIntScale,
              (byte)(negative ? BigNumberFlags.FlagNegative : 0));
            return ret;
        }

        private static EDecimal ParseOrdinaryNumber(
          char[] chars,
          int i,
          int endStr,
          bool negative,
          EContext ctx)
        {
            if (ctx == null)
            {
                return ParseOrdinaryNumberNoContext(chars, i, endStr, negative);
            }
            // NOTE: Negative sign at beginning was omitted
            // from the sequence portion
            var mantInt = 0;
            EInteger mant = null;
            var haveDecimalPoint = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var haveDigits = false;
            var digitStart = 0;
            EInteger newScale = null;
            // Ordinary number
            if (endStr - i == 1)
            {
                char tch = chars[i];
                if (tch >= '0' && tch <= '9')
                {
                    // String portion is a single digit
                    EDecimal cret;
                    var si = (int)(tch - '0');
                    cret = negative ? ((si == 0) ? EDecimal.NegativeZero :
          EDecimal.FromCache(-si)) : EDecimal.FromCache(si);
                    if (ctx != null)
                    {
                        cret = EDecimal.GetMathValue(ctx).RoundAfterConversion(cret, ctx);
                    }
                    return cret;
                }
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            // NOTE: Also check HasFlagsOrTraps here because
            // it's burdensome to determine which flags have
            // to be set when applying the optimization here
            bool roundDown = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.Down ||
                (negative && ctx.Rounding == ERounding.Ceiling) ||
                (!negative && ctx.Rounding == ERounding.Floor)) &&
              !ctx.HasFlagsOrTraps;
            bool roundHalf = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.HalfUp ||
                (ctx.Rounding == ERounding.HalfDown) ||
                (ctx.Rounding == ERounding.HalfEven)) &&
              !ctx.HasFlagsOrTraps;
            bool roundUp = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.Up ||
                (!negative && ctx.Rounding == ERounding.Ceiling) ||
                (negative && ctx.Rounding == ERounding.Floor)) &&
              !ctx.HasFlagsOrTraps;
            var haveIgnoredDigit = false;
            var lastdigit = -1;
            var beyondPrecision = false;
            var ignoreNextDigit = false;
            var zerorun = 0;
            var realDigitEnd = -1;
            var realDecimalEnd = -1;
            // DebugUtility.Log("round half=" + (// roundHalf) +
            // " up=" + roundUp + " down=" + roundDown +
            // " maxprec=" + (ctx != null && ctx.HasMaxPrecision));
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveNonzeroDigit |= thisdigit != 0;
                    haveDigits = true;
                    beyondPrecision |= ctx != null && ctx.HasMaxPrecision &&
                      !ctx.IsPrecisionInBits && ctx.Precision.CompareTo(decimalPrec)
                      <= 0;
                    if (ctx != null)
                    {
                        if (ignoreNextDigit)
                        {
                            haveIgnoredDigit = true;
                            ignoreNextDigit = false;
                        }
                        if (roundDown && (haveIgnoredDigit || beyondPrecision))
                        {
                            // "Ignored" digit
                            haveIgnoredDigit = true;
                        }
                        else if (roundUp && beyondPrecision && !haveIgnoredDigit)
                        {
                            if (thisdigit > 0)
                            {
                                ignoreNextDigit = true;
                            }
                            else
                            {
                                roundUp = false;
                            }
                        }
                        else if (roundHalf && beyondPrecision && !haveIgnoredDigit)
                        {
                            if (thisdigit >= 1 && thisdigit < 5)
                            {
                                ignoreNextDigit = true;
                            }
                            else if (thisdigit > 5 || (thisdigit == 5 &&
                              ctx.Rounding == ERounding.HalfUp))
                            {
                                roundHalf = false;
                                roundUp = true;
                                ignoreNextDigit = true;
                            }
                            else
                            {
                                roundHalf = false;
                            }
                        }
                    }
                    if (haveIgnoredDigit)
                    {
                        zerorun = 0;
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Add(1);
                        }
                        else
                        {
                            ++newScaleInt;
                        }
                    }
                    else
                    {
                        lastdigit = thisdigit;
                        if (beyondPrecision && thisdigit == 0)
                        {
                            ++zerorun;
                        }
                        else
                        {
                            zerorun = 0;
                        }
                        if (haveNonzeroDigit)
                        {
                            ++decimalPrec;
                        }
                        if (haveDecimalPoint)
                        {
                            decimalDigitEnd = i + 1;
                        }
                        else
                        {
                            digitEnd = i + 1;
                        }
                        if (mantInt <= MaxSafeInt)
                        {
                            // multiply by 10
                            mantInt *= 10;
                            mantInt += thisdigit;
                        }
                    }
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Subtract(1);
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    realDigitEnd = i;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    realDecimalEnd = i;
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (realDigitEnd < 0)
            {
                realDigitEnd = i;
            }
            if (realDecimalEnd < 0)
            {
                realDecimalEnd = i;
            }
            if (zerorun > 0 && lastdigit == 0 && (ctx == null ||
                !ctx.HasFlagsOrTraps))
            {
                decimalPrec -= zerorun;
                var nondec = 0;
                // NOTE: This check is apparently needed for correctness
                if (ctx == null || (!ctx.HasMaxPrecision ||
                    decimalPrec - ctx.Precision.ToInt32Checked() > zerorun))
                {
                    if (haveDecimalPoint)
                    {
                        int decdigits = decimalDigitEnd - decimalDigitStart;
                        nondec = Math.Min(decdigits, zerorun);
                        decimalDigitEnd -= nondec;
                        int remain = zerorun - nondec;
                        digitEnd -= remain;
                        // DebugUtility.Log("remain={0} nondec={1}
                        // newScale={2}",remain,nondec,newScaleInt);
                        nondec = zerorun;
                    }
                    else
                    {
                        digitEnd -= zerorun;
                        nondec = zerorun;
                    }
                    if (newScaleInt > Int32.MinValue + nondec &&
                      newScaleInt < Int32.MaxValue - nondec)
                    {
                        newScaleInt += nondec;
                    }
                    else
                    {
                        newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                        newScale = newScale.Add(nondec);
                    }
                }
                // DebugUtility.Log("-->zerorun={0} prec={1} [whole={2}, dec={3}]
                // chars={4}",zerorun,decimalPrec,
                // digitEnd-digitStart, decimalDigitEnd-decimalDigitStart, chars);
            }
            // if (ctx != null) {
            // DebugUtility.Log("roundup [prec=" + decimalPrec + ", ctxprec=" +
            // (// ctx.Precision) + ", chars=" + (// chars.Substring(0, Math.Min(20,
            // chars.Length))) + "] " + (ctx.Rounding));
            // }
            // DebugUtility.Log("digitRange="+digitStart+"-"+digitEnd+
            // "decdigitRange="+decimalDigitStart+"-"+decimalDigitEnd);
            if (
              roundUp && ctx != null &&
              ctx.Precision.CompareTo(decimalPrec) < 0)
            {
                int precdiff = decimalPrec - ctx.Precision.ToInt32Checked();
                // DebugUtility.Log("precdiff = " + precdiff + " [prec=" + (// decimalPrec) +
                // ",
                // ctxprec=" + ctx.Precision + "]");
                if (precdiff > 1)
                {
                    int precchop = precdiff - 1;
                    decimalPrec -= precchop;
                    int nondec = precchop;
                    // DebugUtility.Log("precchop=" + (precchop));
                    if (haveDecimalPoint)
                    {
                        int decdigits = decimalDigitEnd - decimalDigitStart;
                        // DebugUtility.Log("decdigits=" + decdigits + " decprecchop=" + (decdigits));
                        decimalDigitEnd -= nondec;
                        int remain = precchop - nondec;
                        digitEnd -= remain;
                    }
                    else
                    {
                        digitEnd -= precchop;
                    }
                    if (newScaleInt < Int32.MaxValue - nondec)
                    {
                        newScaleInt += nondec;
                    }
                    else
                    {
                        newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                        newScale = newScale.Add(nondec);
                    }
                }
            }
            EDecimal ret = null;
            EInteger exp = null;
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (chars[i] == '+' || chars[i] == '-')
                {
                    if (chars[i] == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    char ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= MaxSafeInt)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            // Calculate newScale if exponent is "small"
            if (haveExponent && expInt <= MaxSafeInt)
            {
                if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                {
                    newScaleInt = expInt;
                }
                else if (newScale == null)
                {
                    long tmplong = newScaleInt;
                    if (expoffset < 0)
                    {
                        tmplong -= expInt;
                    }
                    else if (expInt != 0)
                    {
                        tmplong += expInt;
                    }
                    if (tmplong >= Int32.MaxValue && tmplong <= Int32.MinValue)
                    {
                        newScaleInt = (int)tmplong;
                    }
                    else
                    {
                        newScale = EInteger.FromInt64(tmplong);
                    }
                }
                else
                {
                    if (expoffset < 0)
                    {
                        newScale = newScale.Subtract(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale = newScale.Add(expInt);
                    }
                }
            }
            if (ctx != null && (mantInt > MaxSafeInt || (haveExponent &&
                  expInt > MaxSafeInt)) && ctx.HasExponentRange)
            {
                EInteger ns;
                if (expInt <= MaxSafeInt && ctx != null)
                {
                    ns = newScale ?? EInteger.FromInt32(newScaleInt);
                }
                else
                {
                    EInteger trialExponent = EInteger.FromInt32(MaxSafeInt);
                    if (expPrec > 25)
                    {
                        // Exponent has many significant digits; use a bigger trial exponent
                        trialExponent = EInteger.FromInt64(Int64.MaxValue);
                    }
                    // Trial exponent; in case of overflow or
                    // underflow, the real exponent will also overflow or underflow
                    if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                    {
                        ns = trialExponent;
                    }
                    else
                    {
                        ns = newScale ?? EInteger.FromInt32(newScaleInt);
                        ns = (expoffset < 0) ? ns.Subtract(trialExponent) :
                          ns.Add(trialExponent);
                    }
                }
                int expwithin = EDecimal.CheckOverflowUnderflow(
                    ctx,
                    decimalPrec,
                    ns);
                if (mantInt == 0 && (expwithin == 1 || expwithin == 2 ||
                    expwithin == 3))
                {
                    // Significand is zero
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(0),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    return EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                }
                else if (expwithin == 1)
                {
                    // Exponent indicates overflow
                    return EDecimal.GetMathValue(ctx).SignalOverflow(ctx, negative);
                }
                else if (expwithin == 2 || (expwithin == 3 && mantInt < MaxSafeInt))
                {
                    // Exponent indicates underflow to zero
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(expwithin == 3 ? mantInt : 1),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    return EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                }
                else if (expwithin == 3 && (ctx == null || ctx.Traps == 0))
                {
                    // Exponent indicates underflow to zero, adjust exponent
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(1),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                    ns = ret.Exponent.Subtract(decimalPrec - 1);
                    ret = EDecimal.ChangeExponent(ret, ns);
                    return ret;
                }
            }
            // DebugUtility.Log("digitRange="+digitStart+"-"+digitEnd+
            // "decdigitRange="+decimalDigitStart+"-"+decimalDigitEnd);
            int de = digitEnd;
            int dde = decimalDigitEnd;
            if (!haveExponent && haveDecimalPoint && newScale == null)
            {
                // No more than 18 digits
                long lv = 0L;
                int expo = newScaleInt; // -(dde - decimalDigitStart);
                var digitCount = 0;
                if (mantInt <= MaxSafeInt)
                {
                    lv = mantInt;
                }
                else
                {
                    var vi = 0;
                    for (vi = digitStart; vi < de; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                    for (vi = decimalDigitStart; vi < dde; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                }
                if (negative)
                {
                    lv = -lv;
                }
                if (digitCount >= 0 && (!negative || lv != 0))
                {
                    // DebugUtility.Log("lv="+lv+" expo="+expo);
                    ret = EDecimal.Create(lv, (long)expo);
                    if (ctx != null)
                    {
                        ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                    }
                    return ret;
                }
            }
            // Parse significand if it's "big"
            if (mantInt > MaxSafeInt)
            {
                if (haveDecimalPoint)
                {
                    if (digitEnd - digitStart == 1 && chars[digitStart] == '0')
                    {
                        mant = EInteger.FromSubstring(
                            chars,
                            decimalDigitStart,
                            decimalDigitEnd);
                    }
                    else
                    {
                        char[] cdecstr = Extras.CharsConcat(
                          chars,
                          digitStart,
                          digitEnd - digitStart,
                          chars,
                          decimalDigitStart,
                          decimalDigitEnd - decimalDigitStart);
                        mant = EInteger.FromString(cdecstr);
                    }
                }
                else
                {
                    mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
                }
            }
            if (haveExponent && expInt > MaxSafeInt)
            {
                // Parse exponent if it's "big"
                exp = EInteger.FromSubstring(chars, expDigitStart, endStr);
                newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                newScale = (expoffset < 0) ? newScale.Subtract(exp) :
                  newScale.Add(exp);
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? FastIntegerFixed.FromInt32(
                newScaleInt) : FastIntegerFixed.FromBig(newScale);
            // DebugUtility.Log("fim="+ Chop(mant) + ", exp=" + fastIntScale);
            if (mant == null)
            {
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.ToInt32Checked();
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromBig(mant);
            }
            ret = new EDecimal(
              fastIntMant,
              fastIntScale,
              (byte)(negative ? BigNumberFlags.FlagNegative : 0));
            if (ctx != null)
            {
                // DebugUtility.Log("rounding");
                ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
            }
            return ret;
        }
    }

    internal static class EDecimalTextString
    {
        private const int MaxSafeInt = EDecimal.MaxSafeInt;

        internal static EDecimal FromString(
          string chars,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset(" + tmpoffset + ") is less than " +
                  "0");
            }
            if (tmpoffset > chars.Length)
            {
                throw new FormatException("offset(" + tmpoffset + ") is more than " +
                  chars.Length);
            }
            if (length <= 0)
            {
                if (length == 0)
                {
                    throw new FormatException("length is 0");
                }
                throw new FormatException("length(" + length + ") is less than " +
                  "0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is more than " +
                  chars.Length);
            }
            if (chars.Length - tmpoffset < length)
            {
                throw new FormatException("chars's length minus " + tmpoffset + "(" +
                  (chars.Length - tmpoffset) + ") is less than " + length);
            }
            var negative = false;
            int endStr = tmpoffset + length;
            char c = chars[tmpoffset];
            if (c == '-')
            {
                negative = true;
                ++tmpoffset;
                if (tmpoffset >= endStr)
                {
                    throw new FormatException();
                }
                c = chars[tmpoffset];
            }
            else if (chars[tmpoffset] == '+')
            {
                ++tmpoffset;
                if (tmpoffset >= endStr)
                {
                    throw new FormatException();
                }
                c = chars[tmpoffset];
            }
            int i = tmpoffset;
            if (c < '0' || c > '9')
            {
                EDecimal ed = ParseSpecialValue(chars, i, endStr, negative, ctx);
                if (ed != null)
                {
                    return ed;
                }
            }
            if (ctx != null && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              !ctx.IsSimplified)
            {
                return ParseOrdinaryNumberLimitedPrecision(
                    chars,
                    i,
                    endStr,
                    negative,
                    ctx);
            }
            else
            {
                return ParseOrdinaryNumber(chars, i, endStr, negative, ctx);
            }
        }

        private static EDecimal ParseSpecialValue(
          string chars,
          int i,
          int endStr,
          bool negative,
          EContext ctx)
        {
            var mantInt = 0;
            EInteger mant = null;
            var haveDigits = false;
            var digitStart = 0;
            if (i + 8 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') &&
                  (chars[i + 2] == 'F' || chars[i + 2] == 'f') &&
                  (chars[i + 3] == 'I' || chars[i + 3] == 'i') && (chars[i + 4] ==
        'N' ||
                    chars[i + 4] == 'n') && (chars[i + 5] == 'I' || chars[i + 5] ==
        'i') &&
                  (chars[i + 6] == 'T' || chars[i + 6] == 't') && (chars[i + 7] ==
        'Y' ||
                    chars[i + 7] == 'y'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? EDecimal.NegativeInfinity :
          EDecimal.PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') && (chars[i + 2] ==
        'F' ||
                    chars[i + 2] == 'f'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("Infinity not allowed");
                    }
                    return negative ? EDecimal.NegativeInfinity :
          EDecimal.PositiveInfinity;
                }
            }
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((chars[i] == 'N' || chars[i] == 'n') && (chars[i + 1] == 'A' ||
        chars[i +
                      1] == 'a') && (chars[i + 2] == 'N' || chars[i + 2] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? EDecimal.NaN : new EDecimal(
                            FastIntegerFixed.Zero,
                            FastIntegerFixed.Zero,
                            (byte)flags2);
                    }
                    i += 3;
                    var digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    digitStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt <= MaxSafeInt)
                            {
                                // multiply by 10
                                mantInt *= 10;
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mantInt > MaxSafeInt)
                    {
                        mant = EInteger.FromSubstring(chars, digitStart, endStr);
                    }
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant;
                    flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagQuietNaN;
                    return EDecimal.CreateWithFlags(
                        FastIntegerFixed.FromBig(bigmant),
                        FastIntegerFixed.Zero,
                        flags2);
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((chars[i] == 'S' || chars[i] == 's') && (chars[i + 1] == 'N' ||
        chars[i +
                      1] == 'n') && (chars[i + 2] == 'A' || chars[i + 2] == 'a') &&
                  (chars[i + 3] == 'N' || chars[i + 3] == 'n'))
                {
                    if (ctx != null && ctx.IsSimplified && i < endStr)
                    {
                        throw new FormatException("NaN not allowed");
                    }
                    if (i + 4 == endStr)
                    {
                        int flags2 = (negative ? BigNumberFlags.FlagNegative : 0) |
                          BigNumberFlags.FlagSignalingNaN;
                        return (!negative) ? EDecimal.SignalingNaN :
                          new EDecimal(
                            FastIntegerFixed.Zero,
                            FastIntegerFixed.Zero,
                            (byte)flags2);
                    }
                    i += 4;
                    var digitCount = new FastInteger(0);
                    FastInteger maxDigits = null;
                    haveDigits = false;
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        maxDigits = FastInteger.FromBig(ctx.Precision);
                        if (ctx.ClampNormalExponents)
                        {
                            maxDigits.Decrement();
                        }
                    }
                    digitStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (mantInt <= MaxSafeInt)
                            {
                                // multiply by 10
                                mantInt *= 10;
                                mantInt += thisdigit;
                            }
                            if (haveDigits && maxDigits != null)
                            {
                                digitCount.Increment();
                                if (digitCount.CompareTo(maxDigits) > 0)
                                {
                                    // NaN contains too many digits
                                    throw new FormatException();
                                }
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (mantInt > MaxSafeInt)
                    {
                        mant = EInteger.FromSubstring(chars, digitStart, endStr);
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    EInteger bigmant = (mant == null) ? ((EInteger)mantInt) :
                      mant;
                    return EDecimal.CreateWithFlags(
                        bigmant,
                        EInteger.Zero,
                        flags3);
                }
            }
            return null;
        }

        private static EDecimal ParseOrdinaryNumberLimitedPrecision(
          string chars,
          int offset,
          int endStr,
          bool negative,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                throw new InvalidOperationException();
            }
            var haveDecimalPoint = false;
            var haveDigits = false;
            var haveExponent = false;
            var newScaleInt = 0;
            int i = tmpoffset;
            long mantissaLong = 0L;
            // Ordinary number
            int digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            var nonzeroBeyondMax = false;
            var beyondMax = false;
            var lastdigit = -1;
            EInteger precisionPlusTwo = ctx.Precision.Add(2);
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveDigits = true;
                    haveNonzeroDigit |= thisdigit != 0;
                    if (beyondMax || (precisionPlusTwo.CompareTo(decimalPrec) < 0 &&
                        mantissaLong == Int64.MaxValue))
                    {
                        // Well beyond maximum precision, significand is
                        // max or bigger
                        beyondMax = true;
                        if (thisdigit != 0)
                        {
                            nonzeroBeyondMax = true;
                        }
                        if (!haveDecimalPoint)
                        {
                            // NOTE: Absolute value will not be more than
                            // the sequence portion's length, so will fit comfortably
                            // in an 'int'.
                            newScaleInt = checked(newScaleInt + 1);
                        }
                        continue;
                    }
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantissaLong <= 922337203685477580L)
                    {
                        mantissaLong *= 10;
                        mantissaLong += thisdigit;
                    }
                    else
                    {
                        mantissaLong = Int64.MaxValue;
                    }
                    if (haveDecimalPoint)
                    {
                        // NOTE: Absolute value will not be more than
                        // the sequence portion's length, so will fit comfortably
                        // in an 'int'.
                        newScaleInt = checked(newScaleInt - 1);
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            bool zeroMantissa = !haveNonzeroDigit;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (chars[i] == '+' || chars[i] == '-')
                {
                    if (chars[i] == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    char ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= 214748364)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                        else
                        {
                            expInt = Int32.MaxValue;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                expInt *= expoffset;
                if (expPrec > 12)
                {
                    // Exponent that can't be compensated by digit
                    // length without remaining higher than Int32.MaxValue
                    if (expoffset < 0)
                    {
                        return EDecimal.SignalUnderflow(ctx, negative, zeroMantissa);
                    }
                    else
                    {
                        return EDecimal.SignalOverflow(ctx, negative, zeroMantissa);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (expInt != Int32.MaxValue && expInt > -Int32.MaxValue &&
              mantissaLong != Int64.MaxValue)
            {
                // Low precision, low exponent
                var finalexp = (long)expInt + (long)newScaleInt;
                if (negative)
                {
                    mantissaLong = -mantissaLong;
                }
                EDecimal eret = EDecimal.Create(mantissaLong, finalexp);
                if (negative && zeroMantissa)
                {
                    eret = eret.Negate();
                }
                return eret.RoundToPrecision(ctx);
            }
            EInteger mant = null;
            EInteger exp = (!haveExponent) ? EInteger.Zero :
              EInteger.FromSubstring(chars, expDigitStart, endStr);
            if (expoffset < 0)
            {
                exp = exp.Negate();
            }
            exp = exp.Add(newScaleInt);
            if (nonzeroBeyondMax)
            {
                exp = exp.Subtract(1);
                ++decimalPrec;
            }
            if (ctx.HasExponentRange)
            {
                EInteger adjExpUpperBound = exp.Add(decimalPrec).Subtract(1);
                EInteger adjExpLowerBound = exp;
                EInteger eTiny = ctx.EMin.Subtract(ctx.Precision.Subtract(1));
                eTiny = eTiny.Subtract(1);
                // DebugUtility.Log("exp=" + adjExpLowerBound + "~" +
                // adjExpUpperBound + ", emin={0} emax={1}", ctx.EMin, ctx.EMax);
                if (adjExpUpperBound.CompareTo(eTiny) < 0)
                {
                    return EDecimal.SignalUnderflow(ctx, negative, zeroMantissa);
                }
                else if (adjExpLowerBound.CompareTo(ctx.EMax) > 0)
                {
                    return EDecimal.SignalOverflow(ctx, negative, zeroMantissa);
                }
            }
            if (zeroMantissa)
            {
                EDecimal ef = EDecimal.Create(
                    EInteger.Zero,
                    exp);
                if (negative)
                {
                    ef = ef.Negate();
                }
                return ef.RoundToPrecision(ctx);
            }
            else if (decimalDigitStart != decimalDigitEnd)
            {
                string ctmpstr = Extras.CharsConcat(
                  chars,
                  digitStart,
                  digitEnd - digitStart,
                  chars,
                  decimalDigitStart,
                  decimalDigitEnd - decimalDigitStart);
                mant = EInteger.FromString(ctmpstr);
            }
            else
            {
                mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
            }
            if (nonzeroBeyondMax)
            {
                mant = mant.Multiply(10).Add(1);
            }
            if (negative)
            {
                mant = mant.Negate();
            }
            return EDecimal.Create(mant, exp)
              .RoundToPrecision(ctx);
        }

        private static EDecimal ParseOrdinaryNumberNoContext(
          string chars,
          int i,
          int endStr,
          bool negative)
        {
            // NOTE: Negative sign at beginning was omitted
            // from the sequence portion
            var mantInt = 0;
            EInteger mant = null;
            var haveDecimalPoint = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var haveDigits = false;
            var digitStart = 0;
            EInteger newScale = null;
            // Ordinary number
            if (endStr - i == 1)
            {
                char tch = chars[i];
                if (tch >= '0' && tch <= '9')
                {
                    // String portion is a single digit
                    var si = (int)(tch - '0');
                    return negative ? ((si == 0) ? EDecimal.NegativeZero :
                        EDecimal.FromCache(-si)) : EDecimal.FromCache(si);
                }
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            var firstdigit = -1;
            int decimalDigitEnd = i;
            var lastdigit = -1;
            var realDigitEnd = -1;
            var realDecimalEnd = -1;
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveNonzeroDigit |= thisdigit != 0;
                    if (firstdigit < 0)
                    {
                        firstdigit = thisdigit;
                    }
                    haveDigits = true;
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantInt <= MaxSafeInt)
                    {
                        // multiply by 10
                        mantInt *= 10;
                        mantInt += thisdigit;
                    }
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Subtract(1);
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    realDigitEnd = i;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    realDecimalEnd = i;
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (realDigitEnd < 0)
            {
                realDigitEnd = i;
            }
            if (realDecimalEnd < 0)
            {
                realDecimalEnd = i;
            }
            EDecimal ret = null;
            EInteger exp = null;
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                char ch = chars[i];
                if (ch == '+' || ch == '-')
                {
                    if (ch == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= MaxSafeInt)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            // Calculate newScale if exponent is "small"
            if (haveExponent && expInt <= MaxSafeInt)
            {
                if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                {
                    newScaleInt = expInt;
                }
                else if (newScale == null)
                {
                    long tmplong = newScaleInt;
                    if (expoffset < 0)
                    {
                        tmplong -= expInt;
                    }
                    else if (expInt != 0)
                    {
                        tmplong += expInt;
                    }
                    if (tmplong >= Int32.MaxValue && tmplong <= Int32.MinValue)
                    {
                        newScaleInt = (int)tmplong;
                    }
                    else
                    {
                        newScale = EInteger.FromInt64(tmplong);
                    }
                }
                else
                {
                    if (expoffset < 0)
                    {
                        newScale = newScale.Subtract(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale = newScale.Add(expInt);
                    }
                }
            }
            int de = digitEnd;
            int dde = decimalDigitEnd;
            if (!haveExponent && haveDecimalPoint)
            {
                // No more than 18 digits
                long lv = 0L;
                int expo = -(dde - decimalDigitStart);
                var digitCount = 0;
                if (mantInt <= MaxSafeInt)
                {
                    lv = mantInt;
                }
                else
                {
                    var vi = 0;
                    for (vi = digitStart; vi < de; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                    for (vi = decimalDigitStart; vi < dde; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                }
                if (negative)
                {
                    lv = -lv;
                }
                if (digitCount >= 0 && (!negative || lv != 0))
                {
                    ret = EDecimal.Create(lv, (long)expo);
                    return ret;
                }
            }
            // Parse significand if it's "big"
            if (mantInt > MaxSafeInt)
            {
                if (haveDecimalPoint)
                {
                    if (digitEnd - digitStart == 1 && firstdigit == 0)
                    {
                        mant = EInteger.FromSubstring(
                            chars,
                            decimalDigitStart,
                            decimalDigitEnd);
                    }
                    else
                    {
                        string cdecstr = Extras.CharsConcat(
                          chars,
                          digitStart,
                          digitEnd - digitStart,
                          chars,
                          decimalDigitStart,
                          decimalDigitEnd - decimalDigitStart);
                        mant = EInteger.FromString(cdecstr);
                    }
                }
                else
                {
                    mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
                }
            }
            if (haveExponent && expInt > MaxSafeInt)
            {
                // Parse exponent if it's "big"
                exp = EInteger.FromSubstring(chars, expDigitStart, endStr);
                newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                newScale = (expoffset < 0) ? newScale.Subtract(exp) :
                  newScale.Add(exp);
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? FastIntegerFixed.FromInt32(
                newScaleInt) : FastIntegerFixed.FromBig(newScale);
            if (mant == null)
            {
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.ToInt32Checked();
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromBig(mant);
            }
            ret = new EDecimal(
              fastIntMant,
              fastIntScale,
              (byte)(negative ? BigNumberFlags.FlagNegative : 0));
            return ret;
        }

        private static EDecimal ParseOrdinaryNumber(
          string chars,
          int i,
          int endStr,
          bool negative,
          EContext ctx)
        {
            if (ctx == null)
            {
                return ParseOrdinaryNumberNoContext(chars, i, endStr, negative);
            }
            // NOTE: Negative sign at beginning was omitted
            // from the sequence portion
            var mantInt = 0;
            EInteger mant = null;
            var haveDecimalPoint = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var haveDigits = false;
            var digitStart = 0;
            EInteger newScale = null;
            // Ordinary number
            if (endStr - i == 1)
            {
                char tch = chars[i];
                if (tch >= '0' && tch <= '9')
                {
                    // String portion is a single digit
                    EDecimal cret;
                    var si = (int)(tch - '0');
                    cret = negative ? ((si == 0) ? EDecimal.NegativeZero :
          EDecimal.FromCache(-si)) : EDecimal.FromCache(si);
                    if (ctx != null)
                    {
                        cret = EDecimal.GetMathValue(ctx).RoundAfterConversion(cret, ctx);
                    }
                    return cret;
                }
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            // NOTE: Also check HasFlagsOrTraps here because
            // it's burdensome to determine which flags have
            // to be set when applying the optimization here
            bool roundDown = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.Down ||
                (negative && ctx.Rounding == ERounding.Ceiling) ||
                (!negative && ctx.Rounding == ERounding.Floor)) &&
              !ctx.HasFlagsOrTraps;
            bool roundHalf = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.HalfUp ||
                (ctx.Rounding == ERounding.HalfDown) ||
                (ctx.Rounding == ERounding.HalfEven)) &&
              !ctx.HasFlagsOrTraps;
            bool roundUp = ctx != null && ctx.HasMaxPrecision &&
              !ctx.IsPrecisionInBits && (ctx.Rounding == ERounding.Up ||
                (!negative && ctx.Rounding == ERounding.Ceiling) ||
                (negative && ctx.Rounding == ERounding.Floor)) &&
              !ctx.HasFlagsOrTraps;
            var haveIgnoredDigit = false;
            var lastdigit = -1;
            var beyondPrecision = false;
            var ignoreNextDigit = false;
            var zerorun = 0;
            var realDigitEnd = -1;
            var realDecimalEnd = -1;
            // DebugUtility.Log("round half=" + (// roundHalf) +
            // " up=" + roundUp + " down=" + roundDown +
            // " maxprec=" + (ctx != null && ctx.HasMaxPrecision));
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveNonzeroDigit |= thisdigit != 0;
                    haveDigits = true;
                    beyondPrecision |= ctx != null && ctx.HasMaxPrecision &&
                      !ctx.IsPrecisionInBits && ctx.Precision.CompareTo(decimalPrec)
                      <= 0;
                    if (ctx != null)
                    {
                        if (ignoreNextDigit)
                        {
                            haveIgnoredDigit = true;
                            ignoreNextDigit = false;
                        }
                        if (roundDown && (haveIgnoredDigit || beyondPrecision))
                        {
                            // "Ignored" digit
                            haveIgnoredDigit = true;
                        }
                        else if (roundUp && beyondPrecision && !haveIgnoredDigit)
                        {
                            if (thisdigit > 0)
                            {
                                ignoreNextDigit = true;
                            }
                            else
                            {
                                roundUp = false;
                            }
                        }
                        else if (roundHalf && beyondPrecision && !haveIgnoredDigit)
                        {
                            if (thisdigit >= 1 && thisdigit < 5)
                            {
                                ignoreNextDigit = true;
                            }
                            else if (thisdigit > 5 || (thisdigit == 5 &&
                              ctx.Rounding == ERounding.HalfUp))
                            {
                                roundHalf = false;
                                roundUp = true;
                                ignoreNextDigit = true;
                            }
                            else
                            {
                                roundHalf = false;
                            }
                        }
                    }
                    if (haveIgnoredDigit)
                    {
                        zerorun = 0;
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Add(1);
                        }
                        else
                        {
                            ++newScaleInt;
                        }
                    }
                    else
                    {
                        lastdigit = thisdigit;
                        if (beyondPrecision && thisdigit == 0)
                        {
                            ++zerorun;
                        }
                        else
                        {
                            zerorun = 0;
                        }
                        if (haveNonzeroDigit)
                        {
                            ++decimalPrec;
                        }
                        if (haveDecimalPoint)
                        {
                            decimalDigitEnd = i + 1;
                        }
                        else
                        {
                            digitEnd = i + 1;
                        }
                        if (mantInt <= MaxSafeInt)
                        {
                            // multiply by 10
                            mantInt *= 10;
                            mantInt += thisdigit;
                        }
                    }
                    if (haveDecimalPoint)
                    {
                        if (newScaleInt == Int32.MinValue ||
                          newScaleInt == Int32.MaxValue)
                        {
                            newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                            newScale = newScale.Subtract(1);
                        }
                        else
                        {
                            --newScaleInt;
                        }
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    realDigitEnd = i;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    realDecimalEnd = i;
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (realDigitEnd < 0)
            {
                realDigitEnd = i;
            }
            if (realDecimalEnd < 0)
            {
                realDecimalEnd = i;
            }
            if (zerorun > 0 && lastdigit == 0 && (ctx == null ||
                !ctx.HasFlagsOrTraps))
            {
                decimalPrec -= zerorun;
                var nondec = 0;
                // NOTE: This check is apparently needed for correctness
                if (ctx == null || (!ctx.HasMaxPrecision ||
                    decimalPrec - ctx.Precision.ToInt32Checked() > zerorun))
                {
                    if (haveDecimalPoint)
                    {
                        int decdigits = decimalDigitEnd - decimalDigitStart;
                        nondec = Math.Min(decdigits, zerorun);
                        decimalDigitEnd -= nondec;
                        int remain = zerorun - nondec;
                        digitEnd -= remain;
                        // DebugUtility.Log("remain={0} nondec={1}
                        // newScale={2}",remain,nondec,newScaleInt);
                        nondec = zerorun;
                    }
                    else
                    {
                        digitEnd -= zerorun;
                        nondec = zerorun;
                    }
                    if (newScaleInt > Int32.MinValue + nondec &&
                      newScaleInt < Int32.MaxValue - nondec)
                    {
                        newScaleInt += nondec;
                    }
                    else
                    {
                        newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                        newScale = newScale.Add(nondec);
                    }
                }
                // DebugUtility.Log("-->zerorun={0} prec={1} [whole={2}, dec={3}]
                // chars={4}",zerorun,decimalPrec,
                // digitEnd-digitStart, decimalDigitEnd-decimalDigitStart, chars);
            }
            // if (ctx != null) {
            // DebugUtility.Log("roundup [prec=" + decimalPrec + ", ctxprec=" +
            // (// ctx.Precision) + ", chars=" + (// chars.Substring(0, Math.Min(20,
            // chars.Length))) + "] " + (ctx.Rounding));
            // }
            // DebugUtility.Log("digitRange="+digitStart+"-"+digitEnd+
            // "decdigitRange="+decimalDigitStart+"-"+decimalDigitEnd);
            if (
              roundUp && ctx != null &&
              ctx.Precision.CompareTo(decimalPrec) < 0)
            {
                int precdiff = decimalPrec - ctx.Precision.ToInt32Checked();
                // DebugUtility.Log("precdiff = " + precdiff + " [prec=" + (// decimalPrec) +
                // ",
                // ctxprec=" + ctx.Precision + "]");
                if (precdiff > 1)
                {
                    int precchop = precdiff - 1;
                    decimalPrec -= precchop;
                    int nondec = precchop;
                    // DebugUtility.Log("precchop=" + (precchop));
                    if (haveDecimalPoint)
                    {
                        int decdigits = decimalDigitEnd - decimalDigitStart;
                        // DebugUtility.Log("decdigits=" + decdigits + " decprecchop=" + (decdigits));
                        decimalDigitEnd -= nondec;
                        int remain = precchop - nondec;
                        digitEnd -= remain;
                    }
                    else
                    {
                        digitEnd -= precchop;
                    }
                    if (newScaleInt < Int32.MaxValue - nondec)
                    {
                        newScaleInt += nondec;
                    }
                    else
                    {
                        newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                        newScale = newScale.Add(nondec);
                    }
                }
            }
            EDecimal ret = null;
            EInteger exp = null;
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            haveNonzeroDigit = false;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                if (chars[i] == '+' || chars[i] == '-')
                {
                    if (chars[i] == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    char ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= MaxSafeInt)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            // Calculate newScale if exponent is "small"
            if (haveExponent && expInt <= MaxSafeInt)
            {
                if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                {
                    newScaleInt = expInt;
                }
                else if (newScale == null)
                {
                    long tmplong = newScaleInt;
                    if (expoffset < 0)
                    {
                        tmplong -= expInt;
                    }
                    else if (expInt != 0)
                    {
                        tmplong += expInt;
                    }
                    if (tmplong >= Int32.MaxValue && tmplong <= Int32.MinValue)
                    {
                        newScaleInt = (int)tmplong;
                    }
                    else
                    {
                        newScale = EInteger.FromInt64(tmplong);
                    }
                }
                else
                {
                    if (expoffset < 0)
                    {
                        newScale = newScale.Subtract(expInt);
                    }
                    else if (expInt != 0)
                    {
                        newScale = newScale.Add(expInt);
                    }
                }
            }
            if (ctx != null && (mantInt > MaxSafeInt || (haveExponent &&
                  expInt > MaxSafeInt)) && ctx.HasExponentRange)
            {
                EInteger ns;
                if (expInt <= MaxSafeInt && ctx != null)
                {
                    ns = newScale ?? EInteger.FromInt32(newScaleInt);
                }
                else
                {
                    EInteger trialExponent = EInteger.FromInt32(MaxSafeInt);
                    if (expPrec > 25)
                    {
                        // Exponent has many significant digits; use a bigger trial exponent
                        trialExponent = EInteger.FromInt64(Int64.MaxValue);
                    }
                    // Trial exponent; in case of overflow or
                    // underflow, the real exponent will also overflow or underflow
                    if (expoffset >= 0 && newScaleInt == 0 && newScale == null)
                    {
                        ns = trialExponent;
                    }
                    else
                    {
                        ns = newScale ?? EInteger.FromInt32(newScaleInt);
                        ns = (expoffset < 0) ? ns.Subtract(trialExponent) :
                          ns.Add(trialExponent);
                    }
                }
                int expwithin = EDecimal.CheckOverflowUnderflow(
                    ctx,
                    decimalPrec,
                    ns);
                if (mantInt == 0 && (expwithin == 1 || expwithin == 2 ||
                    expwithin == 3))
                {
                    // Significand is zero
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(0),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    return EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                }
                else if (expwithin == 1)
                {
                    // Exponent indicates overflow
                    return EDecimal.GetMathValue(ctx).SignalOverflow(ctx, negative);
                }
                else if (expwithin == 2 || (expwithin == 3 && mantInt < MaxSafeInt))
                {
                    // Exponent indicates underflow to zero
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(expwithin == 3 ? mantInt : 1),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    return EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                }
                else if (expwithin == 3 && (ctx == null || ctx.Traps == 0))
                {
                    // Exponent indicates underflow to zero, adjust exponent
                    ret = new EDecimal(
                      FastIntegerFixed.FromInt32(1),
                      FastIntegerFixed.FromBig(ns),
                      (byte)(negative ? BigNumberFlags.FlagNegative : 0));
                    ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                    ns = ret.Exponent.Subtract(decimalPrec - 1);
                    ret = EDecimal.ChangeExponent(ret, ns);
                    return ret;
                }
            }
            // DebugUtility.Log("digitRange="+digitStart+"-"+digitEnd+
            // "decdigitRange="+decimalDigitStart+"-"+decimalDigitEnd);
            int de = digitEnd;
            int dde = decimalDigitEnd;
            if (!haveExponent && haveDecimalPoint && newScale == null)
            {
                // No more than 18 digits
                long lv = 0L;
                int expo = newScaleInt; // -(dde - decimalDigitStart);
                var digitCount = 0;
                if (mantInt <= MaxSafeInt)
                {
                    lv = mantInt;
                }
                else
                {
                    var vi = 0;
                    for (vi = digitStart; vi < de; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                    for (vi = decimalDigitStart; vi < dde; ++vi)
                    {
                        char chvi = chars[vi];
#if DEBUG
                        if (!(chvi >= '0' && chvi <= '9'))
                        {
                            throw new ArgumentException("doesn't satisfy chvi>= '0' &&" +
                              "\u0020chvi<= '9'");
                        }
#endif
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || chvi != '0')
                        {
                            ++digitCount;
                        }
                        lv = checked((lv * 10) + (int)(chvi - '0'));
                    }
                }
                if (negative)
                {
                    lv = -lv;
                }
                if (digitCount >= 0 && (!negative || lv != 0))
                {
                    // DebugUtility.Log("lv="+lv+" expo="+expo);
                    ret = EDecimal.Create(lv, (long)expo);
                    if (ctx != null)
                    {
                        ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
                    }
                    return ret;
                }
            }
            // Parse significand if it's "big"
            if (mantInt > MaxSafeInt)
            {
                if (haveDecimalPoint)
                {
                    if (digitEnd - digitStart == 1 && chars[digitStart] == '0')
                    {
                        mant = EInteger.FromSubstring(
                            chars,
                            decimalDigitStart,
                            decimalDigitEnd);
                    }
                    else
                    {
                        string cdecstr = Extras.CharsConcat(
                          chars,
                          digitStart,
                          digitEnd - digitStart,
                          chars,
                          decimalDigitStart,
                          decimalDigitEnd - decimalDigitStart);
                        mant = EInteger.FromString(cdecstr);
                    }
                }
                else
                {
                    mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
                }
            }
            if (haveExponent && expInt > MaxSafeInt)
            {
                // Parse exponent if it's "big"
                exp = EInteger.FromSubstring(chars, expDigitStart, endStr);
                newScale = newScale ?? EInteger.FromInt32(newScaleInt);
                newScale = (expoffset < 0) ? newScale.Subtract(exp) :
                  newScale.Add(exp);
            }
            FastIntegerFixed fastIntScale;
            FastIntegerFixed fastIntMant;
            fastIntScale = (newScale == null) ? FastIntegerFixed.FromInt32(
                newScaleInt) : FastIntegerFixed.FromBig(newScale);
            // DebugUtility.Log("fim="+ Chop(mant) + ", exp=" + fastIntScale);
            if (mant == null)
            {
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else if (mant.CanFitInInt32())
            {
                mantInt = mant.ToInt32Checked();
                fastIntMant = FastIntegerFixed.FromInt32(mantInt);
            }
            else
            {
                fastIntMant = FastIntegerFixed.FromBig(mant);
            }
            ret = new EDecimal(
              fastIntMant,
              fastIntScale,
              (byte)(negative ? BigNumberFlags.FlagNegative : 0));
            if (ctx != null)
            {
                // DebugUtility.Log("rounding");
                ret = EDecimal.GetMathValue(ctx).RoundAfterConversion(ret, ctx);
            }
            return ret;
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EFloat"]/*'/>
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
     "Microsoft.Design",
     "CA1036",
     Justification = "Awaiting advice at dotnet/dotnet-api-docs#2937.")]
    public sealed partial class EFloat : IComparable<EFloat>,
   IEquatable<EFloat>
    {
        //-----------------------------------------------
        private const int CacheFirst = -24;
        private const int CacheLast = 128;

        /// <summary>A not-a-number value.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat NaN = new EFloat(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)BigNumberFlags.FlagQuietNaN);

        /// <summary>Negative infinity, less than any other number.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat NegativeInfinity = new EFloat(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)(BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative));

        /// <summary>Represents the number negative zero.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat NegativeZero = new EFloat(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)BigNumberFlags.FlagNegative);

        /// <summary>Represents the number 1.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat One = new EFloat(
          FastIntegerFixed.One,
          FastIntegerFixed.Zero,
          (byte)0);

        /// <summary>Positive infinity, greater than any other
        /// number.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat PositiveInfinity = new EFloat(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)BigNumberFlags.FlagInfinity);

        /// <summary>A not-a-number value that signals an invalid operation
        /// flag when it's passed as an argument to any arithmetic operation in
        /// arbitrary-precision binary floating-point number.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat SignalingNaN = new EFloat(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)BigNumberFlags.FlagSignalingNaN);

        /// <summary>Represents the number 10.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat Ten = new EFloat(
          FastIntegerFixed.FromInt32(10),
          FastIntegerFixed.Zero,
          (byte)0);

        /// <summary>Represents the number 0.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "EFloat is immutable")]
        public static readonly EFloat Zero = new EFloat(
          FastIntegerFixed.Zero,
          FastIntegerFixed.Zero,
          (byte)0);

        private static readonly EFloat[] Cache = EFloatCache(CacheFirst,
            CacheLast);

        private static EFloat[] EFloatCache(int first, int last)
        {
#if DEBUG
            if (first < -65535)
            {
                throw new ArgumentException("first (" + first + ") is not greater" +
                  "\u0020or equal" + "\u0020to " + (-65535));
            }
            if (first > 65535)
            {
                throw new ArgumentException("first (" + first + ") is not less or" +
                  "\u0020equal to" + "\u002065535");
            }
            if (last < -65535)
            {
                throw new ArgumentException("last (" + last + ") is not greater or" +
                  "\u0020equal" + "\u0020to " + (-65535));
            }
            if (last > 65535)
            {
                throw new ArgumentException("last (" + last + ") is not less or" +
                  "\u0020equal to" + "65535");
            }
#endif

            var cache = new EFloat[(last - first) + 1];
            int i;
            for (i = first; i <= last; ++i)
            {
                if (i == 0)
                {
                    cache[i - first] = Zero;
                }
                else if (i == 1)
                {
                    cache[i - first] = One;
                }
                else if (i == 10)
                {
                    cache[i - first] = Ten;
                }
                else
                {
                    cache[i - first] = new EFloat(
                      FastIntegerFixed.FromInt32(Math.Abs(i)),
                      FastIntegerFixed.Zero,
                      (byte)((i < 0) ? BigNumberFlags.FlagNegative : 0));
                }
            }
            return cache;
        }

        //----------------------------------------------------------------
        private static readonly IRadixMath<EFloat> MathValue = new
        TrappableRadixMath<EFloat>(
          new ExtendedOrSimpleRadixMath<EFloat>(new BinaryMathHelper()));

        internal static IRadixMath<EFloat> GetMathValue()
        {
            return MathValue;
        }

        private readonly FastIntegerFixed exponent;
        private readonly FastIntegerFixed unsignedMantissa;
        private readonly byte flags;

        private EFloat(
          FastIntegerFixed unsignedMantissa,
          FastIntegerFixed exponent,
          byte flags)
        {
#if DEBUG
            if (unsignedMantissa == null)
            {
                throw new ArgumentNullException(nameof(unsignedMantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (unsignedMantissa.Sign < 0)
            {
                throw new ArgumentException("unsignedMantissa is less than 0.");
            }
#endif
            this.unsignedMantissa = unsignedMantissa;
            this.exponent = exponent;
            this.flags = flags;
        }

        /// <summary>Gets this object's exponent. This object's value will be
        /// an integer if the exponent is positive or zero.</summary>
        /// <value>This object's exponent. This object's value will be an
        /// integer if the exponent is positive or zero.</value>
        public EInteger Exponent
        {
            get
            {
                return this.exponent.ToEInteger();
            }
        }

        /// <summary>Gets a value indicating whether this object is finite (not
        /// infinity or not-a-number, NaN).</summary>
        /// <value><c>true</c> if this object is finite (not infinity or
        /// not-a-number, NaN); otherwise, <c>false</c>.</value>
        public bool IsFinite
        {
            get
            {
                return (this.flags & (BigNumberFlags.FlagInfinity |
                      BigNumberFlags.FlagNaN)) == 0;
            }
        }

        /// <summary>Gets a value indicating whether this object is negative,
        /// including negative zero.</summary>
        /// <value><c>true</c> if this object is negative, including negative
        /// zero; otherwise, <c>false</c>.</value>
        public bool IsNegative
        {
            get
            {
                return (this.flags & BigNumberFlags.FlagNegative) != 0;
            }
        }

        /// <summary>Gets a value indicating whether this object's value equals
        /// 0.</summary>
        /// <value><c>true</c> if this object's value equals 0; otherwise,
        /// <c>false</c>. <c>true</c> if this object's value equals 0;
        /// otherwise, <c>false</c>.</value>
        public bool IsZero
        {
            get
            {
                return ((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                  this.unsignedMantissa.IsValueZero;
            }
        }

        /// <summary>Gets this object's unscaled value, or significand, and
        /// makes it negative if this object is negative. If this value is
        /// not-a-number (NaN), that value's absolute value is the NaN's
        /// "payload" (diagnostic information).</summary>
        /// <value>This object's unscaled value. Will be negative if this
        /// object's value is negative (including a negative NaN).</value>
        public EInteger Mantissa
        {
            get
            {
                return this.IsNegative ? this.unsignedMantissa.ToEInteger().Negate() :
                  this.unsignedMantissa.ToEInteger();
            }
        }

        /// <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
        /// if zero.</summary>
        /// <value>This value's sign: -1 if negative; 1 if positive; 0 if
        /// zero.</value>
        public int Sign
        {
            get
            {
                return (((this.flags & BigNumberFlags.FlagSpecial) == 0) &&
                    this.unsignedMantissa.IsValueZero) ? 0 :
                  (((this.flags & BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
            }
        }

        /// <summary>Gets the absolute value of this object's unscaled value,
        /// or significand. If this value is not-a-number (NaN), that value is
        /// the NaN's "payload" (diagnostic information).</summary>
        /// <value>The absolute value of this object's unscaled value.</value>
        public EInteger UnsignedMantissa
        {
            get
            {
                return this.unsignedMantissa.ToEInteger();
            }
        }

        /// <summary>Creates a copy of this arbitrary-precision binary
        /// number.</summary>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat Copy()
        {
            return new EFloat(this.unsignedMantissa, this.exponent, this.flags);
        }

        /// <summary>Returns an arbitrary-precision number with the value
        /// <c>exponent*2^significand</c>.</summary>
        /// <param name='mantissaSmall'>Desired value for the
        /// significand.</param>
        /// <param name='exponentSmall'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        public static EFloat Create(int mantissaSmall, int exponentSmall)
        {
            if (exponentSmall == 0 && mantissaSmall >= CacheFirst &&
              mantissaSmall <= CacheLast)
            {
                return Cache[mantissaSmall - CacheFirst];
            }
            if (mantissaSmall < 0)
            {
                if (mantissaSmall == Int32.MinValue)
                {
                    FastIntegerFixed fi = FastIntegerFixed.FromInt64(Int32.MinValue);
                    return new EFloat(
                        fi.Negate(),
                        FastIntegerFixed.FromInt32(exponentSmall),
                        (byte)BigNumberFlags.FlagNegative);
                }
                return new EFloat(
                    FastIntegerFixed.FromInt32(-mantissaSmall),
                    FastIntegerFixed.FromInt32(exponentSmall),
                    (byte)BigNumberFlags.FlagNegative);
            }
            else if (mantissaSmall == 0)
            {
                return new EFloat(
                    FastIntegerFixed.Zero,
                    FastIntegerFixed.FromInt32(exponentSmall),
                    (byte)0);
            }
            else
            {
                return new EFloat(
                    FastIntegerFixed.FromInt32(mantissaSmall),
                    FastIntegerFixed.FromInt32(exponentSmall),
                    (byte)0);
            }
        }

        /// <summary>Returns an arbitrary-precision number with the value
        /// <c>exponent*2^significand</c>.</summary>
        /// <param name='mantissa'>Desired value for the significand.</param>
        /// <param name='exponentSmall'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='mantissa'/> is null.</exception>
        public static EFloat Create(
          EInteger mantissa,
          int exponentSmall)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (mantissa.CanFitInInt32())
            {
                int mantissaSmall = mantissa.ToInt32Checked();
                return Create(mantissaSmall, exponentSmall);
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EFloat(
                sign < 0 ? fi.Negate() : fi,
                FastIntegerFixed.FromInt32(exponentSmall),
                (byte)((sign < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Returns an arbitrary-precision number with the value
        /// <c>exponent*2^significand</c>.</summary>
        /// <param name='mantissa'>Desired value for the significand.</param>
        /// <param name='exponentLong'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='mantissa'/> is null.</exception>
        public static EFloat Create(
          EInteger mantissa,
          long exponentLong)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (mantissa.CanFitInInt64())
            {
                long mantissaLong = mantissa.ToInt64Checked();
                return Create(mantissaLong, exponentLong);
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EFloat(
                sign < 0 ? fi.Negate() : fi,
                FastIntegerFixed.FromInt64(exponentLong),
                (byte)((sign < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Returns an arbitrary-precision number with the value
        /// <c>exponent*2^significand</c>.</summary>
        /// <param name='mantissa'>Desired value for the significand.</param>
        /// <param name='exponent'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='mantissa'/> or <paramref name='exponent'/> is
        /// null.</exception>
        public static EFloat Create(
          EInteger mantissa,
          EInteger exponent)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            if (mantissa.CanFitInInt32() && exponent.IsZero)
            {
                int mantissaSmall = mantissa.ToInt32Checked();
                return Create(mantissaSmall, 0);
            }
            FastIntegerFixed fi = FastIntegerFixed.FromBig(mantissa);
            int sign = fi.Sign;
            return new EFloat(
                sign < 0 ? fi.Negate() : fi,
                FastIntegerFixed.FromBig(exponent),
                (byte)((sign < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Returns an arbitrary-precision number with the value
        /// <c>exponent*2^significand</c>.</summary>
        /// <param name='mantissaLong'>Desired value for the
        /// significand.</param>
        /// <param name='exponentSmall'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        public static EFloat Create(
          long mantissaLong,
          int exponentSmall)
        {
            return Create(mantissaLong, (long)exponentSmall);
        }

        /// <summary>Returns an arbitrary-precision number with the value
        /// <c>exponent*2^significand</c>.</summary>
        /// <param name='mantissaLong'>Desired value for the
        /// significand.</param>
        /// <param name='exponentLong'>Desired value for the exponent.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        public static EFloat Create(
          long mantissaLong,
          long exponentLong)
        {
            if (mantissaLong >= Int32.MinValue && mantissaLong <= Int32.MaxValue &&
              exponentLong >= Int32.MinValue && exponentLong <= Int32.MaxValue)
            {
                return Create((int)mantissaLong, (int)exponentLong);
            }
            else if (mantissaLong == Int64.MinValue)
            {
                FastIntegerFixed fi = FastIntegerFixed.FromInt64(mantissaLong);
                return new EFloat(
                    fi.Negate(),
                    FastIntegerFixed.FromInt64(exponentLong),
                    (byte)((mantissaLong < 0) ? BigNumberFlags.FlagNegative : 0));
            }
            else
            {
                FastIntegerFixed fi = FastIntegerFixed.FromInt64(Math.Abs(
                      mantissaLong));
                return new EFloat(
                    fi,
                    FastIntegerFixed.FromInt64(exponentLong),
                    (byte)((mantissaLong < 0) ? BigNumberFlags.FlagNegative : 0));
            }
        }

        /// <summary>Creates a not-a-number arbitrary-precision binary
        /// number.</summary>
        /// <param name='diag'>An integer, 0 or greater, to use as diagnostic
        /// information associated with this object. If none is needed, should
        /// be zero. To get the diagnostic information from another
        /// arbitrary-precision binary floating-point number, use that object's
        /// <c>UnsignedMantissa</c> property.</param>
        /// <returns>A quiet not-a-number.</returns>
        public static EFloat CreateNaN(EInteger diag)
        {
            return CreateNaN(diag, false, false, null);
        }

        /// <summary>Creates a not-a-number arbitrary-precision binary
        /// number.</summary>
        /// <param name='diag'>An integer, 0 or greater, to use as diagnostic
        /// information associated with this object. If none is needed, should
        /// be zero. To get the diagnostic information from another
        /// arbitrary-precision binary floating-point number, use that object's
        /// <c>UnsignedMantissa</c> property.</param>
        /// <param name='signaling'>Whether the return value will be signaling
        /// (true) or quiet (false).</param>
        /// <param name='negative'>Whether the return value is
        /// negative.</param>
        /// <param name='ctx'>An arithmetic context to control the precision
        /// (in binary digits) of the diagnostic information. The rounding and
        /// exponent range of this context will be ignored. Can be null. The
        /// only flag that can be signaled in this context is FlagInvalid,
        /// which happens if diagnostic information needs to be truncated and
        /// too much memory is required to do so.</param>
        /// <returns>An arbitrary-precision binary number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='diag'/> is null or is less than 0.</exception>
        public static EFloat CreateNaN(
          EInteger diag,
          bool signaling,
          bool negative,
          EContext ctx)
        {
            if (diag == null)
            {
                throw new ArgumentNullException(nameof(diag));
            }
            if (diag.Sign < 0)
            {
                throw new ArgumentException("Diagnostic information must be 0 or" +
                  "\u0020greater," + "\u0020 was: " + diag);
            }
            if (diag.IsZero && !negative)
            {
                return signaling ? SignalingNaN : NaN;
            }
            var flags = 0;
            if (negative)
            {
                flags |= BigNumberFlags.FlagNegative;
            }
            if (ctx != null && ctx.HasMaxPrecision)
            {
                flags |= BigNumberFlags.FlagQuietNaN;
                var ef = new EFloat(
                  FastIntegerFixed.FromBig(diag),
                  FastIntegerFixed.Zero,
                  (byte)flags).RoundToPrecision(ctx);

                int newFlags = ef.flags;
                newFlags &= ~BigNumberFlags.FlagQuietNaN;
                newFlags |= signaling ? BigNumberFlags.FlagSignalingNaN :
                  BigNumberFlags.FlagQuietNaN;
                return new EFloat(
                    ef.unsignedMantissa,
                    ef.exponent,
                    (byte)newFlags);
            }
            flags |= signaling ? BigNumberFlags.FlagSignalingNaN :
              BigNumberFlags.FlagQuietNaN;
            return new EFloat(
                FastIntegerFixed.FromBig(diag),
                FastIntegerFixed.Zero,
                (byte)flags);
        }

        /// <summary>Creates a binary floating-point number from a 64-bit
        /// floating-point number encoded in the IEEE 754 binary64 format. This
        /// method computes the exact value of the floating point number, not
        /// an approximation, as is often the case by converting the floating
        /// point number to a string first.</summary>
        /// <param name='dblBits'>The parameter <paramref name='dblBits'/> is a
        /// 64-bit signed integer.</param>
        /// <returns>A binary floating-point number with the same value as the
        /// floating-point number encoded in <paramref
        /// name='dblBits'/>.</returns>
        public static EFloat FromDoubleBits(long dblBits)
        {
            var floatExponent = (int)((dblBits >> 52) & 0x7ff);
            bool neg = (dblBits >> 63) != 0;
            long lvalue;
            if (floatExponent == 2047)
            {
                if ((dblBits & ((1L << 52) - 1)) == 0)
                {
                    return neg ? EFloat.NegativeInfinity : EFloat.PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = ((dblBits >> 32) & 0x80000) != 0;
                lvalue = dblBits & ((1L << 51) - 1);
                if (lvalue == 0)
                {
                    return quiet ? NaN : SignalingNaN;
                }
                int flags = (neg ? BigNumberFlags.FlagNegative : 0) |
                  (quiet ? BigNumberFlags.FlagQuietNaN :
                    BigNumberFlags.FlagSignalingNaN);
                return CreateWithFlags(
                    EInteger.FromInt64(lvalue),
                    EInteger.Zero,
                    flags);
            }
            lvalue = dblBits & ((1L << 52) - 1); // Mask out the exponent and sign
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                lvalue |= 1L << 52;
            }
            if (lvalue != 0)
            {
                // Shift away trailing zeros
                while ((lvalue & 1L) == 0)
                {
                    lvalue >>= 1;
                    ++floatExponent;
                }
            }
            else
            {
                return neg ? EFloat.NegativeZero : EFloat.Zero;
            }
            return CreateWithFlags(
                EInteger.FromInt64(lvalue),
                (EInteger)(floatExponent - 1075),
                neg ? BigNumberFlags.FlagNegative : 0);
        }

        /// <summary>Creates a binary floating-point number from a 32-bit
        /// floating-point number. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the floating point number to a string
        /// first.</summary>
        /// <param name='flt'>The parameter <paramref name='flt'/> is a 64-bit
        /// floating-point number.</param>
        /// <returns>A binary floating-point number with the same value as
        /// <paramref name='flt'/>.</returns>
        public static EFloat FromSingle(float flt)
        {
            return FromSingleBits(
                BitConverter.ToInt32(BitConverter.GetBytes((float)flt), 0));
        }

        /// <summary>Creates a binary floating-point number from a 64-bit
        /// floating-point number. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the floating point number to a string
        /// first.</summary>
        /// <param name='dbl'>The parameter <paramref name='dbl'/> is a 64-bit
        /// floating-point number.</param>
        /// <returns>A binary floating-point number with the same value as
        /// <paramref name='dbl'/>.</returns>
        public static EFloat FromDouble(double dbl)
        {
            long lvalue = BitConverter.ToInt64(
                BitConverter.GetBytes((double)dbl),
                0);
            return FromDoubleBits(lvalue);
        }

        /// <summary>Converts an arbitrary-precision integer to the same value
        /// as a binary floating-point number.</summary>
        /// <param name='bigint'>An arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public static EFloat FromEInteger(EInteger bigint)
        {
            return EFloat.Create(bigint, (int)0);
        }

        /// <summary>Creates a binary floating-point number from a 32-bit
        /// floating-point number encoded in the IEEE 754 binary32 format. This
        /// method computes the exact value of the floating point number, not
        /// an approximation, as is often the case by converting the floating
        /// point number to a string first.</summary>
        /// <param name='value'>A 32-bit binary floating-point number encoded
        /// in the IEEE 754 binary32 format.</param>
        /// <returns>A binary floating-point number with the same
        /// floating-point value as <paramref name='value'/>.</returns>
        public static EFloat FromSingleBits(int value)
        {
            bool neg = (value >> 31) != 0;
            var floatExponent = (int)((value >> 23) & 0xff);
            int valueFpMantissa = value & 0x7fffff;
            EInteger bigmant;
            if (floatExponent == 255)
            {
                if (valueFpMantissa == 0)
                {
                    return neg ? NegativeInfinity : PositiveInfinity;
                }
                // Treat high bit of mantissa as quiet/signaling bit
                bool quiet = (valueFpMantissa & 0x400000) != 0;
                valueFpMantissa &= 0x3fffff;
                bigmant = (EInteger)valueFpMantissa;
                value = (neg ? BigNumberFlags.FlagNegative : 0) | (quiet ?
                    BigNumberFlags.FlagQuietNaN : BigNumberFlags.FlagSignalingNaN);
                if (bigmant.IsZero)
                {
                    return quiet ? NaN : SignalingNaN;
                }
                return CreateWithFlags(
                    bigmant,
                    EInteger.Zero,
                    value);
            }
            if (floatExponent == 0)
            {
                ++floatExponent;
            }
            else
            {
                valueFpMantissa |= 1 << 23;
            }
            if (valueFpMantissa == 0)
            {
                return neg ? EFloat.NegativeZero : EFloat.Zero;
            }
            while ((valueFpMantissa & 1) == 0)
            {
                ++floatExponent;
                valueFpMantissa >>= 1;
            }
            if (neg)
            {
                valueFpMantissa = -valueFpMantissa;
            }
            bigmant = (EInteger)valueFpMantissa;
            return EFloat.Create(
                bigmant,
                (EInteger)(floatExponent - 150));
        }

        internal static EFloat SignalUnderflow(EContext ec, bool negative, bool
          zeroSignificand)
        {
            EInteger eTiny = ec.EMin.Subtract(ec.Precision.Subtract(1));
            eTiny = eTiny.Subtract(2); // subtract 2 from proper eTiny to
                                       // trigger underflow (2, rather than 1, because of HalfUp mode)
            EFloat ret = EFloat.Create(
                zeroSignificand ? EInteger.Zero : EInteger.One,
                eTiny);
            if (negative)
            {
                ret = ret.Negate();
            }
            return ret.RoundToPrecision(ec);
        }

        internal static EFloat SignalOverflow(EContext ec, bool negative, bool
          zeroSignificand)
        {
            if (zeroSignificand)
            {
                EFloat ret = EFloat.Create(EInteger.Zero, ec.EMax);
                if (negative)
                {
                    ret = ret.Negate();
                }
                return ret.RoundToPrecision(ec);
            }
            else
            {
                return MathValue.SignalOverflow(ec, negative);
            }
        }

        /// <summary>Creates a binary floating-point number from a text string
        /// that represents a number. Note that if the string contains a
        /// negative exponent, the resulting value might not be exact, in which
        /// case the resulting binary floating-point number will be an
        /// approximation of this decimal number's value.
        /// <para>The format of the string generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if '-' , the value is negative.)</item>
        /// <item>One or more digits, with a single optional decimal point
        /// (".", U+002E) before or after those digits or between two of them.
        /// These digits may begin with any number of zeros.</item>
        /// <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
        /// (negative exponent) plus one or more digits specifying the exponent
        /// (these digits may begin with any number of zeros).</item></list>
        /// <para>The string can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN") followed by any number of digits (these
        /// digits may begin with any number of zeros), or signaling NaN
        /// ("sNaN") followed by any number of digits (these digits may begin
        /// with any number of zeros), all where the letters can be any
        /// combination of basic upper-case and/or basic lower-case
        /// letters.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='str'>The parameter <paramref name='str'/> is a text
        /// string.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='str'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='str'/> (but not more than <paramref
        /// name='str'/> 's length).</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If HasFlags of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Note that
        /// providing a context is often much faster than creating an EDecimal
        /// without a context then calling ToEFloat on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='FormatException'>The portion given of <paramref
        /// name='str'/> is not a correctly formatted number string; or either
        /// <paramref name='offset'/> or <paramref name='length'/> is less than
        /// 0 or greater than <paramref name='str'/> 's length, or <paramref
        /// name='str'/> 's length minus <paramref name='offset'/> is less than
        /// <paramref name='length'/>.</exception>
        public static EFloat FromString(
          string str,
          int offset,
          int length,
          EContext ctx)
        {
            return EFloatTextString.FromString(str, offset, length, ctx);
        }

        /// <summary>Creates a binary floating-point number from a text string
        /// that represents a number, using an unlimited precision context. For
        /// more information, see the <c>FromString(String, int, int,
        /// EContext)</c> method.</summary>
        /// <param name='str'>A text string to convert to a binary
        /// floating-point number.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='FormatException'>The portion given of <paramref
        /// name='str'/> is not a correctly formatted number
        /// string.</exception>
        public static EFloat FromString(string str)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, null);
        }

        /// <summary>Creates a binary floating-point number from a text string
        /// that represents a number. For more information, see the
        /// <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='str'>A text string to convert to a binary
        /// floating-point number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If HasFlags of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Note that
        /// providing a context is often much faster than creating an EDecimal
        /// without a context then calling ToEFloat on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        public static EFloat FromString(string str, EContext ctx)
        {
            return FromString(str, 0, str == null ? 0 : str.Length, ctx);
        }

        /// <summary>Creates a binary floating-point number from a text string
        /// that represents a number. For more information, see the
        /// <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='str'>The parameter <paramref name='str'/> is a text
        /// string.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='str'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='str'/> (but not more than <paramref
        /// name='str'/> 's length).</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        /// <exception cref=' T:System.ArgumentException'>Either <paramref
        /// name=' offset'/> or <paramref name=' length'/> is less than 0 or
        /// greater than <paramref name='str'/> 's length, or <paramref name='
        /// str'/> 's length minus <paramref name='offset'/> is less than
        /// <paramref name='length'/>.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='str'/> 's length, or <paramref
        /// name='str'/> 's length minus <paramref name='offset'/> is less than
        /// <paramref name='length'/>.</exception>
        public static EFloat FromString(string str, int offset, int length)
        {
            return FromString(str, offset, length, null);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// <c>char</c> s that represents a number. Note that if the sequence
        /// contains a negative exponent, the resulting value might not be
        /// exact, in which case the resulting binary floating-point number
        /// will be an approximation of this decimal number's value.
        /// <para>The format of the sequence generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if '-' , the value is negative.)</item>
        /// <item>One or more digits, with a single optional decimal point
        /// (".", U+002E) before or after those digits or between two of them.
        /// These digits may begin with any number of zeros.</item>
        /// <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
        /// (negative exponent) plus one or more digits specifying the exponent
        /// (these digits may begin with any number of zeros).</item></list>
        /// <para>The sequence can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN") followed by any number of digits (these
        /// digits may begin with any number of zeros), or signaling NaN
        /// ("sNaN") followed by any number of digits (these digits may begin
        /// with any number of zeros), all where the letters can be any
        /// combination of basic upper-case and/or basic lower-case
        /// letters.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='chars'>A sequence of <c>char</c> s to convert to a
        /// binary floating-point number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='chars'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='chars'/> (but not more than <paramref
        /// name='chars'/> 's length).</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If HasFlags of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Note that
        /// providing a context is often much faster than creating an EDecimal
        /// without a context then calling ToEFloat on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        /// <exception cref='FormatException'>The portion given of <paramref
        /// name='chars'/> is not a correctly formatted number sequence; or
        /// either <paramref name='offset'/> or <paramref name='length'/> is
        /// less than 0 or greater than <paramref name='chars'/> 's length, or
        /// <paramref name='chars'/> 's length minus <paramref name='offset'/>
        /// is less than <paramref name='length'/>.</exception>
        public static EFloat FromString(
          char[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            return EFloatCharArrayString.FromString(chars, offset, length, ctx);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// <c>char</c> s that represents a number, using an unlimited
        /// precision context. For more information, see the
        /// <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='chars'>A sequence of <c>char</c> s to convert to a
        /// binary floating-point number.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        /// <exception cref='FormatException'>The portion given of <paramref
        /// name='chars'/> is not a correctly formatted number
        /// sequence.</exception>
        public static EFloat FromString(char[] chars)
        {
            return FromString(chars, 0, chars == null ? 0 : chars.Length, null);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// <c>char</c> s that represents a number. For more information, see
        /// the <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='chars'>A sequence of <c>char</c> s to convert to a
        /// binary floating-point number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If HasFlags of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Note that
        /// providing a context is often much faster than creating an EDecimal
        /// without a context then calling ToEFloat on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        public static EFloat FromString(char[] chars, EContext ctx)
        {
            return FromString(chars, 0, chars == null ? 0 : chars.Length, ctx);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// <c>char</c> s that represents a number. For more information, see
        /// the <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='chars'>A sequence of <c>char</c> s to convert to a
        /// binary floating-point number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='chars'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='chars'/> (but not more than <paramref
        /// name='chars'/> 's length).</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='chars'/> 's length, or <paramref
        /// name='chars'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EFloat FromString(char[] chars, int offset, int length)
        {
            return FromString(chars, offset, length, null);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// bytes that represents a number. Note that if the sequence contains
        /// a negative exponent, the resulting value might not be exact, in
        /// which case the resulting binary floating-point number will be an
        /// approximation of this decimal number's value.
        /// <para>The format of the sequence generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if '-' , the value is negative.)</item>
        /// <item>One or more digits, with a single optional decimal point
        /// (".", U+002E) before or after those digits or between two of them.
        /// These digits may begin with any number of zeros.</item>
        /// <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
        /// (negative exponent) plus one or more digits specifying the exponent
        /// (these digits may begin with any number of zeros).</item></list>
        /// <para>The sequence can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN") followed by any number of digits (these
        /// digits may begin with any number of zeros), or signaling NaN
        /// ("sNaN") followed by any number of digits (these digits may begin
        /// with any number of zeros), all where the letters can be any
        /// combination of basic upper-case and/or basic lower-case
        /// letters.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The sequence is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='bytes'>A sequence of bytes to convert to a binary
        /// floating-point number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='bytes'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='bytes'/> (but not more than <paramref
        /// name='bytes'/> 's length).</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If HasFlags of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Note that
        /// providing a context is often much faster than creating an EDecimal
        /// without a context then calling ToEFloat on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='FormatException'>The portion given of <paramref
        /// name='bytes'/> is not a correctly formatted number sequence; or
        /// either <paramref name='offset'/> or <paramref name='length'/> is
        /// less than 0 or greater than <paramref name='bytes'/> 's length, or
        /// <paramref name='bytes'/> 's length minus <paramref name='offset'/>
        /// is less than <paramref name='length'/>.</exception>
        public static EFloat FromString(
          byte[] bytes,
          int offset,
          int length,
          EContext ctx)
        {
            return EFloatByteArrayString.FromString(bytes, offset, length, ctx);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// bytes that represents a number, using an unlimited precision
        /// context. For more information, see the <c>FromString(String, int,
        /// int, EContext)</c> method.</summary>
        /// <param name='bytes'>A sequence of bytes to convert to a binary
        /// floating-point number.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='FormatException'>The portion given of <paramref
        /// name='bytes'/> is not a correctly formatted number
        /// sequence.</exception>
        public static EFloat FromString(byte[] bytes)
        {
            return FromString(bytes, 0, bytes == null ? 0 : bytes.Length, null);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// bytes that represents a number. For more information, see the
        /// <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='bytes'>A sequence of bytes to convert to a binary
        /// floating-point number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If HasFlags of the
        /// context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Note that
        /// providing a context is often much faster than creating an EDecimal
        /// without a context then calling ToEFloat on that EDecimal,
        /// especially if the context specifies a precision limit and exponent
        /// range.</param>
        /// <returns>The parsed number, converted to arbitrary-precision binary
        /// floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        public static EFloat FromString(byte[] bytes, EContext ctx)
        {
            return FromString(bytes, 0, bytes == null ? 0 : bytes.Length, ctx);
        }

        /// <summary>Creates a binary floating-point number from a sequence of
        /// bytes that represents a number. For more information, see the
        /// <c>FromString(String, int, int, EContext)</c> method.</summary>
        /// <param name='bytes'>A sequence of bytes to convert to a binary
        /// floating-point number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='bytes'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='bytes'/> (but not more than <paramref
        /// name='bytes'/> 's length).</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='bytes'/> 's length, or <paramref
        /// name='bytes'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EFloat FromString(byte[] bytes, int offset, int length)
        {
            return FromString(bytes, offset, length, null);
        }

        /// <summary>Gets the greater value between two binary floating-point
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The larger value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the positive zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the larger exponent. If the two numbers are negative and
        /// have the same value, returns the one with the smaller
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat Max(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MathValue.Max(first, second, ctx);
        }

        /// <summary>Gets the greater value between two binary floating-point
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The larger value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the positive zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the larger exponent. If the two numbers are negative and
        /// have the same value, returns the one with the smaller
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat Max(
          EFloat first,
          EFloat second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return Max(first, second, null);
        }

        /// <summary>Gets the greater value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Max.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The larger value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat MaxMagnitude(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MathValue.MaxMagnitude(first, second, ctx);
        }

        /// <summary>Gets the greater value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Max.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The larger value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat MaxMagnitude(
          EFloat first,
          EFloat second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MaxMagnitude(first, second, null);
        }

        /// <summary>Gets the lesser value between two binary floating-point
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The smaller value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the negative zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the smaller exponent. If the two numbers are negative and
        /// have the same value, returns the one with the larger
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat Min(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MathValue.Min(first, second, ctx);
        }

        /// <summary>Gets the lesser value between two binary floating-point
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The smaller value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the negative zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the smaller exponent. If the two numbers are negative and
        /// have the same value, returns the one with the larger
        /// exponent.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat Min(
          EFloat first,
          EFloat second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return Min(first, second, null);
        }

        /// <summary>Gets the lesser value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Min.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The smaller value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat MinMagnitude(
          EFloat first,
          EFloat second,
          EContext ctx)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MathValue.MinMagnitude(first, second, ctx);
        }

        /// <summary>Gets the lesser value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Min.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The smaller value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EFloat MinMagnitude(
          EFloat first,
          EFloat second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return MinMagnitude(first, second, null);
        }

        /// <summary>Finds the constant π, the circumference of a circle
        /// divided by its diameter.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as π can never be represented
        /// exactly.</i>.</param>
        /// <returns>The constant π rounded to the given precision. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public static EFloat PI(EContext ctx)
        {
            return MathValue.Pi(ctx);
        }

        /// <summary>Finds the absolute value of this object (if it's negative,
        /// it becomes positive).</summary>
        /// <returns>An arbitrary-precision binary floating-point number.
        /// Returns signaling NaN if this value is signaling NaN. (In this
        /// sense, this method is similar to the "copy-abs" operation in the
        /// General Decimal Arithmetic Specification, except this method does
        /// not necessarily return a copy of this object.).</returns>
        public EFloat Abs()
        {
            if (this.IsNegative)
            {
                var er = new EFloat(
                  this.unsignedMantissa,
                  this.exponent,
                  (byte)(this.flags & ~BigNumberFlags.FlagNegative));
                return er;
            }
            return this;
        }

        /// <summary>Finds the absolute value of this object (if it's negative,
        /// it becomes positive).</summary>
        /// <param name='context'>An arithmetic context to control the
        /// precision, rounding, and exponent range of the result. If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the precision is
        /// unlimited and no rounding is needed.</param>
        /// <returns>The absolute value of this object. Signals FlagInvalid and
        /// returns quiet NaN if this value is signaling NaN.</returns>
        public EFloat Abs(EContext context)
        {
            return MathValue.Abs(this, context);
        }

        /// <summary>Adds this arbitrary-precision binary floating-point number
        /// and a 32-bit signed integer and returns the result. The exponent
        /// for the result is the lower of this arbitrary-precision binary
        /// floating-point number's exponent and the other 32-bit signed
        /// integer's exponent.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number plus a 32-bit
        /// signed integer. If this arbitrary-precision binary floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EFloat Add(int intValue)
        {
            return this.Add(EFloat.FromInt32(intValue));
        }

        /// <summary>Subtracts a 32-bit signed integer from this
        /// arbitrary-precision binary floating-point number and returns the
        /// result. The exponent for the result is the lower of this
        /// arbitrary-precision binary floating-point number's exponent and the
        /// other 32-bit signed integer's exponent.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision binary floating-point number minus a 32-bit
        /// signed integer. If this arbitrary-precision binary floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EFloat Subtract(int intValue)
        {
            return (intValue == Int32.MinValue) ?
              this.Subtract(EFloat.FromInt32(intValue)) : this.Add(-intValue);
        }

        /// <summary>Multiplies this arbitrary-precision binary floating-point
        /// number by a 32-bit signed integer and returns the result. The
        /// exponent for the result is this arbitrary-precision binary
        /// floating-point number's exponent plus the other 32-bit signed
        /// integer's exponent.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number times a 32-bit
        /// signed integer.</returns>
        /// <example>
        /// <code>EInteger result = EInteger.FromString("5").Multiply(200);</code>
        ///  .
        /// </example>
        public EFloat Multiply(int intValue)
        {
            return this.Multiply(EFloat.FromInt32(intValue));
        }

        /// <summary>Divides this arbitrary-precision binary floating-point
        /// number by a 32-bit signed integer and returns the result; returns
        /// NaN instead if the result would have a nonterminating binary
        /// expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
        /// not desired, use DivideToExponent, or use the Divide overload that
        /// takes an EContext.</summary>
        /// <param name='intValue'>The divisor.</param>
        /// <returns>The result of dividing this arbitrary-precision binary
        /// floating-point number by a 32-bit signed integer. Returns infinity
        /// if the divisor (this arbitrary-precision binary floating-point
        /// number) is 0 and the dividend (the other 32-bit signed integer) is
        /// nonzero. Returns not-a-number (NaN) if the divisor and the dividend
        /// are 0. Returns NaN if the result can't be exact because it would
        /// have a nonterminating binary expansion (examples include 1 divided
        /// by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
        /// use DivideToExponent instead, or use the Divide overload that takes
        /// an <c>EContext</c> (such as <c>EContext.Binary64</c> )
        /// instead.</returns>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        public EFloat Divide(int intValue)
        {
            return this.Divide(EFloat.FromInt32(intValue));
        }

        /// <summary>Adds this arbitrary-precision binary floating-point number
        /// and a 64-bit signed integer and returns the result. The exponent
        /// for the result is the lower of this arbitrary-precision binary
        /// floating-point number's exponent and the other 64-bit signed
        /// integer's exponent.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number plus a 64-bit
        /// signed integer. If this arbitrary-precision binary floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EFloat Add(long longValue)
        {
            return this.Add(EFloat.FromInt64(longValue));
        }

        /// <summary>Subtracts a 64-bit signed integer from this
        /// arbitrary-precision binary floating-point number and returns the
        /// result. The exponent for the result is the lower of this
        /// arbitrary-precision binary floating-point number's exponent and the
        /// other 64-bit signed integer's exponent.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision binary floating-point number minus a 64-bit
        /// signed integer. If this arbitrary-precision binary floating-point
        /// number is not-a-number (NaN), returns NaN.</returns>
        public EFloat Subtract(long longValue)
        {
            return this.Subtract(EFloat.FromInt64(longValue));
        }

        /// <summary>Multiplies this arbitrary-precision binary floating-point
        /// number by a 64-bit signed integer and returns the result. The
        /// exponent for the result is this arbitrary-precision binary
        /// floating-point number's exponent plus the other 64-bit signed
        /// integer's exponent.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number times a 64-bit
        /// signed integer.</returns>
        /// <example>
        /// <code>EInteger result = EInteger.FromString("5").Multiply(200L);</code>
        ///  .
        /// </example>
        public EFloat Multiply(long longValue)
        {
            return this.Multiply(EFloat.FromInt64(longValue));
        }

        /// <summary>Divides this arbitrary-precision binary floating-point
        /// number by a 64-bit signed integer and returns the result; returns
        /// NaN instead if the result would have a nonterminating binary
        /// expansion (including 1/3, 1/12, 1/7, 2/3, and so on); if this is
        /// not desired, use DivideToExponent, or use the Divide overload that
        /// takes an EContext.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The result of dividing this arbitrary-precision binary
        /// floating-point number by a 64-bit signed integer. Returns infinity
        /// if the divisor (this arbitrary-precision binary floating-point
        /// number) is 0 and the dividend (the other 64-bit signed integer) is
        /// nonzero. Returns not-a-number (NaN) if the divisor and the dividend
        /// are 0. Returns NaN if the result can't be exact because it would
        /// have a nonterminating binary expansion (examples include 1 divided
        /// by any multiple of 3, such as 1/3 or 1/12). If this is not desired,
        /// use DivideToExponent instead, or use the Divide overload that takes
        /// an <c>EContext</c> (such as <c>EContext.Binary64</c> )
        /// instead.</returns>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        public EFloat Divide(long longValue)
        {
            return this.Divide(EFloat.FromInt64(longValue));
        }

        /// <summary>Adds this arbitrary-precision binary floating-point number
        /// and another arbitrary-precision binary floating-point number and
        /// returns the result. The exponent for the result is the lower of
        /// this arbitrary-precision binary floating-point number's exponent
        /// and the other arbitrary-precision binary floating-point number's
        /// exponent.</summary>
        /// <param name='otherValue'>An arbitrary-precision binary
        /// floating-point number.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number plus another
        /// arbitrary-precision binary floating-point number. If this
        /// arbitrary-precision binary floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        public EFloat Add(EFloat otherValue)
        {
            return this.Add(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <summary>Adds this arbitrary-precision binary floating-point number
        /// and another arbitrary-precision binary floating-point number and
        /// returns the result.</summary>
        /// <param name='otherValue'>The number to add to.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number plus another
        /// arbitrary-precision binary floating-point number. If this
        /// arbitrary-precision binary floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        public EFloat Add(
          EFloat otherValue,
          EContext ctx)
        {
            return MathValue.Add(this, otherValue, ctx);
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value or if <paramref name='other'/> is null, or 0 if both
        /// values are equal.</returns>
        public int CompareTo(EFloat other)
        {
            return MathValue.CompareTo(this, other);
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object or the other object is a quiet NaN or
        /// signaling NaN, this method will not trigger an error. Instead, NaN
        /// will compare greater than any other number, including infinity. Two
        /// different NaN values will be considered equal.</para></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value or if <paramref name='other'/> is null, or 0 if both
        /// values are equal.</returns>
        public int CompareToValue(EFloat other)
        {
            return MathValue.CompareTo(this, other);
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareTo(int intOther)
        {
            return this.CompareToValue(EFloat.FromInt32(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object is a quiet NaN or signaling NaN, this method
        /// will not trigger an error. Instead, NaN will compare greater than
        /// any other number.</para></summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareToValue(int intOther)
        {
            return this.CompareToValue(EFloat.FromInt32(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object is a quiet NaN or signaling NaN, this method
        /// will not trigger an error. Instead, NaN will compare greater than
        /// any other number, including infinity.</para></summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 64-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareToValue(long intOther)
        {
            return this.CompareToValue(FromInt64(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 64-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareTo(long intOther)
        {
            return this.CompareToValue(FromInt64(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, treating quiet NaN as signaling.
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object or the other object is a quiet NaN or
        /// signaling NaN, this method will return a quiet NaN and will signal
        /// a FlagInvalid flag.</para></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <param name='ctx'>An arithmetic context. The precision, rounding,
        /// and exponent range are ignored. If <c>HasFlags</c> of the context
        /// is true, will store the flags resulting from the operation (the
        /// flags are in addition to the pre-existing flags). Can be
        /// null.</param>
        /// <returns>Quiet NaN if this object or the other object is NaN, or 0
        /// if both objects have the same value, or -1 if this object is less
        /// than the other value, or 1 if this object is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public EFloat CompareToSignal(
          EFloat other,
          EContext ctx)
        {
            return MathValue.CompareToWithContext(this, other, true, ctx);
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number to compare with this one.</param>
        /// <param name='ctx'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater. Does not signal flags if either value is signaling NaN.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotal(EFloat other, EContext ctx)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsSignalingNaN() || other.IsSignalingNaN())
            {
                return this.CompareToTotal(other);
            }
            if (ctx != null && ctx.IsSimplified)
            {
                return this.RoundToPrecision(ctx)
                  .CompareToTotal(other.RoundToPrecision(ctx));
            }
            else
            {
                return this.CompareToTotal(other);
            }
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values (ignoring their
        /// signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number to compare with this one.</param>
        /// <param name='ctx'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects have the same value (ignoring
        /// their signs), or -1 if this object is less than the other value
        /// (ignoring their signs), or 1 if this object is greater (ignoring
        /// their signs). Does not signal flags if either value is signaling
        /// NaN.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotalMagnitude(EFloat other, EContext ctx)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsSignalingNaN() || other.IsSignalingNaN())
            {
                return this.CompareToTotalMagnitude(other);
            }
            if (ctx != null && ctx.IsSimplified)
            {
                return this.RoundToPrecision(ctx)
                  .CompareToTotalMagnitude(other.RoundToPrecision(ctx));
            }
            else
            {
                return this.CompareToTotalMagnitude(other);
            }
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number to compare with this one.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotal(EFloat other)
        {
            if (other == null)
            {
                return 1;
            }
            bool neg1 = this.IsNegative;
            bool neg2 = other.IsNegative;
            if (neg1 != neg2)
            {
                return neg1 ? -1 : 1;
            }
            var valueIThis = 0;
            var valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return neg1 ? -1 : 1;
            }
            else if (valueIThis < valueIOther)
            {
                return neg1 ? 1 : -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                    other.unsignedMantissa);
                return neg1 ? -cmp : cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.CompareTo(other);
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                        other.exponent);
                    return neg1 ? -cmp : cmp;
                }
                return cmp;
            }
        }

        /// <summary>Compares the absolute values of this object and another
        /// object, imposing a total ordering on all possible values (ignoring
        /// their signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero and positive zero are considered equal.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item></list></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number to compare with this one.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotalMagnitude(EFloat other)
        {
            if (other == null)
            {
                return 1;
            }
            var valueIThis = 0;
            var valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return 1;
            }
            else if (valueIThis < valueIOther)
            {
                return -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedMantissa.CompareTo(
                    other.unsignedMantissa);
                return cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.Abs().CompareTo(other.Abs());
                if (cmp == 0)
                {
                    cmp = this.exponent.CompareTo(
                        other.exponent);
                    return cmp;
                }
                return cmp;
            }
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object.
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object or the other object is a quiet NaN or
        /// signaling NaN, this method returns a quiet NaN, and will signal a
        /// FlagInvalid flag if either is a signaling NaN.</para></summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <param name='ctx'>An arithmetic context. The precision, rounding,
        /// and exponent range are ignored. If <c>HasFlags</c> of the context
        /// is true, will store the flags resulting from the operation (the
        /// flags are in addition to the pre-existing flags). Can be
        /// null.</param>
        /// <returns>Quiet NaN if this object or the other object is NaN, or 0
        /// if both objects have the same value, or -1 if this object is less
        /// than the other value, or 1 if this object is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public EFloat CompareToWithContext(
          EFloat other,
          EContext ctx)
        {
            return MathValue.CompareToWithContext(this, other, false, ctx);
        }

        /// <summary>Returns a number with the same value as this one, but
        /// copying the sign (positive or negative) of another number. (This
        /// method is similar to the "copy-sign" operation in the General
        /// Decimal Arithmetic Specification, except this method does not
        /// necessarily return a copy of this object.).</summary>
        /// <param name='other'>A number whose sign will be copied.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='other'/> is null.</exception>
        public EFloat CopySign(EFloat other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.IsNegative)
            {
                return other.IsNegative ? this : this.Negate();
            }
            else
            {
                return other.IsNegative ? this.Negate() : this;
            }
        }

        /// <summary>Divides this arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns the result; returns NaN instead if the result would
        /// have a nonterminating binary expansion (including 1/3, 1/12, 1/7,
        /// 2/3, and so on); if this is not desired, use DivideToExponent, or
        /// use the Divide overload that takes an EContext.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The result of dividing this arbitrary-precision binary
        /// floating-point number by another arbitrary-precision binary
        /// floating-point number. Returns infinity if the divisor (this
        /// arbitrary-precision binary floating-point number) is 0 and the
        /// dividend (the other arbitrary-precision binary floating-point
        /// number) is nonzero. Returns not-a-number (NaN) if the divisor and
        /// the dividend are 0. Returns NaN if the result can't be exact
        /// because it would have a nonterminating binary expansion (examples
        /// include 1 divided by any multiple of 3, such as 1/3 or 1/12). If
        /// this is not desired, use DivideToExponent instead, or use the
        /// Divide overload that takes an <c>EContext</c> (such as
        /// <c>EContext.Binary64</c> ) instead.</returns>
        public EFloat Divide(EFloat divisor)
        {
            return this.Divide(
                divisor,
                EContext.ForRounding(ERounding.None));
        }

        /// <summary>Divides this arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The result of dividing this arbitrary-precision binary
        /// floating-point number by another arbitrary-precision binary
        /// floating-point number. Signals FlagDivideByZero and returns
        /// infinity if the divisor (this arbitrary-precision binary
        /// floating-point number) is 0 and the dividend (the other
        /// arbitrary-precision binary floating-point number) is nonzero.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the divisor
        /// and the dividend are 0; or, either <paramref name='ctx'/> is null
        /// or <paramref name='ctx'/> 's precision is 0, and the result would
        /// have a nonterminating decimal expansion (examples include 1 divided
        /// by any multiple of 3, such as 1/3 or 1/12); or, the rounding mode
        /// is ERounding.None and the result is not exact.</returns>
        public EFloat Divide(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.Divide(this, divisor, ctx);
        }

        /// <summary>Calculates the quotient and remainder using the
        /// DivideToIntegerNaturalScale and the formula in
        /// RemainderNaturalScale.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>A 2 element array consisting of the quotient and remainder
        /// in that order.</returns>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EFloat[] DivideAndRemainderNaturalScale(EFloat
          divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <summary>Calculates the quotient and remainder using the
        /// DivideToIntegerNaturalScale and the formula in
        /// RemainderNaturalScale.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only in the division portion of the remainder
        /// calculation; as a result, it's possible for the remainder to have a
        /// higher precision than given in this context. Flags will be set on
        /// the given context only if the context's <c>HasFlags</c> is true and
        /// the integer part of the division result doesn't fit the precision
        /// and exponent range without rounding. Can be null, in which the
        /// precision is unlimited and no additional rounding, other than the
        /// rounding down to an integer after division, is needed.</param>
        /// <returns>A 2 element array consisting of the quotient and remainder
        /// in that order.</returns>
        [Obsolete("Renamed to DivRemNaturalScale.")]
        public EFloat[] DivideAndRemainderNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            return this.DivRemNaturalScale(divisor, ctx);
        }

        /// <summary>Divides two arbitrary-precision binary floating-point
        /// numbers, and gives a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentSmall'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual radix
        /// point (so a negative number means the number of binary digit places
        /// to round to). A positive number places the cutoff point to the left
        /// of the usual radix point.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// rounding mode to use if the result must be scaled down to have the
        /// same exponent as this value. If the precision given in the context
        /// is other than 0, calls the Quantize method with both arguments
        /// equal to the result of the operation (and can signal FlagInvalid
        /// and return NaN if the result doesn't fit the given precision). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the context defines an exponent range and the
        /// desired exponent is outside that range. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the rounding mode is ERounding.None
        /// and the result is not exact.</returns>
        public EFloat DivideToExponent(
          EFloat divisor,
          long desiredExponentSmall,
          EContext ctx)
        {
            return this.DivideToExponent(
                divisor,
                EInteger.FromInt64(desiredExponentSmall),
                ctx);
        }

        /// <summary>Divides two arbitrary-precision binary floating-point
        /// numbers, and gives a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponentSmall'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual radix
        /// point (so a negative number means the number of binary digit places
        /// to round to). A positive number places the cutoff point to the left
        /// of the usual radix point.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EFloat DivideToExponent(
          EFloat divisor,
          long desiredExponentSmall,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                EInteger.FromInt64(desiredExponentSmall),
                EContext.ForRounding(rounding));
        }

        /// <summary>Divides two arbitrary-precision binary floating-point
        /// numbers, and gives a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='exponent'>The desired exponent. A negative number
        /// places the cutoff point to the right of the usual radix point (so a
        /// negative number means the number of binary digit places to round
        /// to). A positive number places the cutoff point to the left of the
        /// usual radix point.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// rounding mode to use if the result must be scaled down to have the
        /// same exponent as this value. If the precision given in the context
        /// is other than 0, calls the Quantize method with both arguments
        /// equal to the result of the operation (and can signal FlagInvalid
        /// and return NaN if the result doesn't fit the given precision). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the context defines an exponent range and the
        /// desired exponent is outside that range. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the rounding mode is ERounding.None
        /// and the result is not exact.</returns>
        public EFloat DivideToExponent(
          EFloat divisor,
          EInteger exponent,
          EContext ctx)
        {
            return MathValue.DivideToExponent(this, divisor, exponent, ctx);
        }

        /// <summary>Divides two arbitrary-precision binary floating-point
        /// numbers, and gives a particular exponent to the result.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='desiredExponent'>The desired exponent. A negative
        /// number places the cutoff point to the right of the usual radix
        /// point (so a negative number means the number of binary digit places
        /// to round to). A positive number places the cutoff point to the left
        /// of the usual radix point.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two objects. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Returns not-a-number (NaN) if the divisor and the dividend
        /// are 0. Returns NaN if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EFloat DivideToExponent(
          EFloat divisor,
          EInteger desiredExponent,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                desiredExponent,
                EContext.ForRounding(rounding));
        }

        /// <summary>Divides two arbitrary-precision binary floating-point
        /// numbers, and returns the integer part of the result, rounded down,
        /// with the preferred exponent set to this value's exponent minus the
        /// divisor's exponent.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The integer part of the quotient of the two objects.
        /// Signals FlagDivideByZero and returns infinity if the divisor is 0
        /// and the dividend is nonzero. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the divisor and the dividend are 0.</returns>
        public EFloat DivideToIntegerNaturalScale(
          EFloat divisor)
        {
            return this.DivideToIntegerNaturalScale(
                divisor,
                EContext.ForRounding(ERounding.Down));
        }

        /// <summary>Divides this object by another object, and returns the
        /// integer part of the result (which is initially rounded down), with
        /// the preferred exponent set to this value's exponent minus the
        /// divisor's exponent.</summary>
        /// <param name='divisor'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <param name='ctx'>The parameter <paramref name='ctx'/> is an
        /// EContext object.</param>
        /// <returns>The integer part of the quotient of the two objects.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the return
        /// value would overflow the exponent range. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EFloat DivideToIntegerNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.DivideToIntegerNaturalScale(this, divisor, ctx);
        }

        /// <summary>Divides this object by another object, and returns the
        /// integer part of the result, with the exponent set to 0.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision. The rounding and exponent range settings of this context
        /// are ignored. If <c>HasFlags</c> of the context is true, will also
        /// store the flags resulting from the operation (the flags are in
        /// addition to the pre-existing flags). Can be null, in which case the
        /// precision is unlimited.</param>
        /// <returns>The integer part of the quotient of the two objects. The
        /// exponent will be set to 0. Signals FlagDivideByZero and returns
        /// infinity if the divisor is 0 and the dividend is nonzero. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the divisor and the
        /// dividend are 0, or if the result doesn't fit the given
        /// precision.</returns>
        public EFloat DivideToIntegerZeroScale(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.DivideToIntegerZeroScale(this, divisor, ctx);
        }

        /// <summary>Divides this object by another binary floating-point
        /// number and returns a result with the same exponent as this object
        /// (the dividend).</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='rounding'>The rounding mode to use if the result must
        /// be scaled down to have the same exponent as this value.</param>
        /// <returns>The quotient of the two numbers. Signals FlagDivideByZero
        /// and returns infinity if the divisor is 0 and the dividend is
        /// nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// divisor and the dividend are 0. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the rounding mode is ERounding.None and the
        /// result is not exact.</returns>
        public EFloat DivideToSameExponent(
          EFloat divisor,
          ERounding rounding)
        {
            return this.DivideToExponent(
                divisor,
                this.exponent.ToEInteger(),
                EContext.ForRounding(rounding));
        }

        /// <summary>Divides this arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns a two-item array containing the result of the division
        /// and the remainder, in that order. The result of division is
        /// calculated as though by <c>DivideToIntegerNaturalScale</c>, and
        /// the remainder is calculated as though by
        /// <c>RemainderNaturalScale</c>.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision binary floating-point number,
        /// and the second is the remainder as an arbitrary-precision binary
        /// floating-point number. The result of division is the result of the
        /// method on the two operands, and the remainder is the result of the
        /// Remainder method on the two operands.</returns>
        public EFloat[] DivRemNaturalScale(EFloat divisor)
        {
            return this.DivRemNaturalScale(divisor, null);
        }

        /// <summary>Divides this arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns a two-item array containing the result of the division
        /// and the remainder, in that order. The result of division is
        /// calculated as though by <c>DivideToIntegerNaturalScale</c>, and
        /// the remainder is calculated as though by
        /// <c>RemainderNaturalScale</c>.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only in the division portion of the remainder
        /// calculation; as a result, it's possible for the remainder to have a
        /// higher precision than given in this context. Flags will be set on
        /// the given context only if the context's <c>HasFlags</c> is true and
        /// the integer part of the division result doesn't fit the precision
        /// and exponent range without rounding. Can be null, in which the
        /// precision is unlimited and no additional rounding, other than the
        /// rounding down to an integer after division, is needed.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision binary floating-point number,
        /// and the second is the remainder as an arbitrary-precision binary
        /// floating-point number. The result of division is the result of the
        /// method on the two operands, and the remainder is the result of the
        /// Remainder method on the two operands.</returns>
        public EFloat[] DivRemNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            var result = new EFloat[2];
            result[0] = this.DivideToIntegerNaturalScale(divisor, null);
            result[1] = this.Subtract(
                result[0].Multiply(divisor, null),
                ctx);
            result[0] = result[0].RoundToPrecision(ctx);
            return result;
        }

        /// <summary>Determines whether this object's significand, exponent,
        /// and properties are equal to those of another object. Not-a-number
        /// values are considered equal if the rest of their properties are
        /// equal.</summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns><c>true</c> if this object's significand and exponent are
        /// equal to those of another object; otherwise, <c>false</c>.</returns>
        public bool Equals(EFloat other)
        {
            return this.EqualsInternal(other);
        }

        /// <summary>Determines whether this object's significand, exponent,
        /// and properties are equal to those of another object and that other
        /// object is an arbitrary-precision binary floating-point number.
        /// Not-a-number values are considered equal if the rest of their
        /// properties are equal.</summary>
        /// <param name='obj'>The parameter <paramref name='obj'/> is an
        /// arbitrary object.</param>
        /// <returns><c>true</c> if the objects are equal; otherwise,
        /// <c>false</c>. In this method, two objects are not equal if they
        /// don't have the same type or if one is null and the other
        /// isn't.</returns>
        public override bool Equals(object obj)
        {
            return this.EqualsInternal(obj as EFloat);
        }

        /// <summary>Determines whether this object's significand and exponent
        /// are equal to those of another object.</summary>
        /// <param name='otherValue'>An arbitrary-precision binary
        /// floating-point number.</param>
        /// <returns><c>true</c> if this object's significand and exponent are
        /// equal to those of another object; otherwise, <c>false</c>.</returns>
        public bool EqualsInternal(EFloat otherValue)
        {
            if (otherValue == null)
            {
                return false;
            }
            return this.exponent.Equals(otherValue.exponent) &&
              this.unsignedMantissa.Equals(otherValue.unsignedMantissa) &&
              this.flags == otherValue.flags;
        }

        /// <summary>Finds e (the base of natural logarithms) raised to the
        /// power of this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the exponential function's
        /// results are generally not exact.</i> (Unlike in the General Binary
        /// Arithmetic Specification, any rounding mode is allowed.).</param>
        /// <returns>Exponential of this object. If this object's value is 1,
        /// returns an approximation to " e" within the given precision.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public EFloat Exp(EContext ctx)
        {
            return MathValue.Exp(this, ctx);
        }

        /// <summary>Finds e (the base of natural logarithms) raised to the
        /// power of this object's value, and subtracts the result by 1 and
        /// returns the final result, in a way that avoids loss of precision if
        /// the true result is very close to 0.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the exponential function's
        /// results are generally not exact.</i> (Unlike in the General Binary
        /// Arithmetic Specification, any rounding mode is allowed.).</param>
        /// <returns>Exponential of this object, minus 1. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the parameter <paramref
        /// name='ctx'/> is null or the precision is unlimited (the context's
        /// Precision property is 0).</returns>
        public EFloat ExpM1(EContext ctx)
        {
            EFloat value = this;
            if (value.IsNaN())
            {
                return value.Plus(ctx);
            }
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return EFloat.SignalingNaN.Plus(ctx);
            }
            if (ctx.Traps != 0)
            {
                EContext tctx = ctx.GetNontrapping();
                EFloat ret = value.ExpM1(tctx);
                return ctx.TriggerTraps(ret, tctx);
            }
            else if (ctx.IsSimplified)
            {
                EContext tmpctx = ctx.WithSimplified(false).WithBlankFlags();
                EFloat ret = value.PreRound(ctx).ExpM1(tmpctx);
                if (ctx.HasFlags)
                {
                    int flags = ctx.Flags;
                    ctx.Flags = flags | tmpctx.Flags;
                }
                // Console.WriteLine("{0} {1} [{4} {5}] -> {2}
                // [{3}]",value,baseValue,ret,ret.RoundToPrecision(ctx),
                // value.Quantize(value, ctx), baseValue.Quantize(baseValue, ctx));
                return ret.RoundToPrecision(ctx);
            }
            else
            {
                if (value.CompareTo(-1) == 0)
                {
                    return EFloat.NegativeInfinity;
                }
                else if (value.IsPositiveInfinity())
                {
                    return EFloat.PositiveInfinity;
                }
                else if (value.IsNegativeInfinity())
                {
                    return EFloat.FromInt32(-1).Plus(ctx);
                }
                else if (value.CompareTo(0) == 0)
                {
                    return EFloat.FromInt32(0).Plus(ctx);
                }
                int flags = ctx.Flags;
                EContext tmpctx = null;
                EFloat ret;
                {
                    EInteger prec = ctx.Precision.Add(3);
                    tmpctx = ctx.WithBigPrecision(prec).WithBlankFlags();
                    if (value.Abs().CompareTo(EFloat.Create(1, -1)) < 0)
                    {
                        ret = value.Exp(tmpctx).Add(EFloat.FromInt32(-1), ctx);
                        EFloat oldret = ret;
                        while (true)
                        {
                            prec = prec.Add(ctx.Precision).Add(3);
                            tmpctx = ctx.WithBigPrecision(prec).WithBlankFlags();
                            ret = value.Exp(tmpctx).Add(EFloat.FromInt32(-1), ctx);
                            if (ret.CompareTo(0) != 0 && ret.CompareTo(oldret) == 0)
                            {
                                break;
                            }
                            oldret = ret;
                        }
                    }
                    else
                    {
                        ret = value.Exp(tmpctx).Add(EFloat.FromInt32(-1), ctx);
                    }
                    flags |= tmpctx.Flags;
                }
                if (ctx.HasFlags)
                {
                    flags |= ctx.Flags;
                    ctx.Flags = flags;
                }
                return ret;
            }
        }

        /// <summary>Calculates this object's hash code. No application or
        /// process IDs are used in the hash code calculation.</summary>
        /// <returns>A 32-bit signed integer.</returns>
        public override int GetHashCode()
        {
            var hashCode = 403796923;
            unchecked
            {
                hashCode += 403797019 * this.exponent.GetHashCode();
                hashCode += 403797059 * this.unsignedMantissa.GetHashCode();
                hashCode += 403797127 * this.flags;
            }
            return hashCode;
        }

        /// <summary>Gets a value indicating whether this object is positive or
        /// negative infinity.</summary>
        /// <returns><c>true</c> if this object is positive or negative
        /// infinity; otherwise, <c>false</c>.</returns>
        public bool IsInfinity()
        {
            return (this.flags & BigNumberFlags.FlagInfinity) != 0;
        }

        /// <summary>Gets a value indicating whether this object is not a
        /// number (NaN).</summary>
        /// <returns><c>true</c> if this object is not a number (NaN);
        /// otherwise, <c>false</c>.</returns>
        public bool IsNaN()
        {
            return (this.flags & (BigNumberFlags.FlagQuietNaN |
                  BigNumberFlags.FlagSignalingNaN)) != 0;
        }

        /// <summary>Returns whether this object is negative
        /// infinity.</summary>
        /// <returns><c>true</c> if this object is negative infinity;
        /// otherwise, <c>false</c>.</returns>
        public bool IsNegativeInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNegative)) ==
              (BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);
        }

        /// <summary>Returns whether this object is positive
        /// infinity.</summary>
        /// <returns><c>true</c> if this object is positive infinity;
        /// otherwise, <c>false</c>.</returns>
        public bool IsPositiveInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNegative)) == BigNumberFlags.FlagInfinity;
        }

        /// <summary>Gets a value indicating whether this object is a quiet
        /// not-a-number value.</summary>
        /// <returns><c>true</c> if this object is a quiet not-a-number value;
        /// otherwise, <c>false</c>.</returns>
        public bool IsQuietNaN()
        {
            return (this.flags & BigNumberFlags.FlagQuietNaN) != 0;
        }

        /// <summary>Gets a value indicating whether this object is a signaling
        /// not-a-number value.</summary>
        /// <returns><c>true</c> if this object is a signaling not-a-number
        /// value; otherwise, <c>false</c>.</returns>
        public bool IsSignalingNaN()
        {
            return (this.flags & BigNumberFlags.FlagSignalingNaN) != 0;
        }

        /// <summary>Finds the natural logarithm of this object, that is, the
        /// power (exponent) that e (the base of natural logarithms) must be
        /// raised to in order to equal this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the ln function's results are
        /// generally not exact.</i> (Unlike in the General Binary Arithmetic
        /// Specification, any rounding mode is allowed.).</param>
        /// <returns>Ln(this object). Signals the flag FlagInvalid and returns
        /// NaN if this object is less than 0 (the result would be a complex
        /// number with a real part equal to Ln of this object's absolute value
        /// and an imaginary part equal to pi, but the return value is still
        /// NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null or the precision is
        /// unlimited (the context's Precision property is 0). Signals no flags
        /// and returns negative infinity if this object's value is
        /// 0.</returns>
        public EFloat Log(EContext ctx)
        {
            return MathValue.Ln(this, ctx);
        }

        /// <summary>Finds the base-10 logarithm of this object, that is, the
        /// power (exponent) that the number 10 must be raised to in order to
        /// equal this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the ln function's results are
        /// generally not exact.</i> (Unlike in the General Binary Arithmetic
        /// Specification, any rounding mode is allowed.).</param>
        /// <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
        /// returns not-a-number (NaN) if this object is less than 0. Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public EFloat Log10(EContext ctx)
        {
            return this.LogN(EFloat.FromInt32(10), ctx);
        }

        /// <summary>Adds 1 to this object's value and finds the natural
        /// logarithm of the result, in a way that avoids loss of precision
        /// when this object's value is between 0 and 1.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the ln function's results are
        /// generally not exact.</i> (Unlike in the General Binary Arithmetic
        /// Specification, any rounding mode is allowed.).</param>
        /// <returns>Ln(1+(this object)). Signals the flag FlagInvalid and
        /// returns NaN if this object is less than -1 (the result would be a
        /// complex number with a real part equal to Ln of 1 plus this object's
        /// absolute value and an imaginary part equal to pi, but the return
        /// value is still NaN.). Signals FlagInvalid and returns not-a-number
        /// (NaN) if the parameter <paramref name='ctx'/> is null or the
        /// precision is unlimited (the context's Precision property is 0).
        /// Signals no flags and returns negative infinity if this object's
        /// value is 0.</returns>
        public EFloat Log1P(EContext ctx)
        {
            EFloat value = this;
            if (value.IsNaN())
            {
                return value.Plus(ctx);
            }
            if (ctx == null || !ctx.HasMaxPrecision ||
              (value.CompareTo(-1) < 0))
            {
                return EFloat.SignalingNaN.Plus(ctx);
            }
            if (ctx.Traps != 0)
            {
                EContext tctx = ctx.GetNontrapping();
                EFloat ret = value.Log1P(tctx);
                return ctx.TriggerTraps(ret, tctx);
            }
            else if (ctx.IsSimplified)
            {
                EContext tmpctx = ctx.WithSimplified(false).WithBlankFlags();
                EFloat ret = value.PreRound(ctx).Log1P(tmpctx);
                if (ctx.HasFlags)
                {
                    int flags = ctx.Flags;
                    ctx.Flags = flags | tmpctx.Flags;
                }
                // Console.WriteLine("{0} {1} [{4} {5}] -> {2}
                // [{3}]",value,baseValue,ret,ret.RoundToPrecision(ctx),
                // value.Quantize(value, ctx), baseValue.Quantize(baseValue, ctx));
                return ret.RoundToPrecision(ctx);
            }
            else
            {
                if (value.CompareTo(-1) == 0)
                {
                    return EFloat.NegativeInfinity;
                }
                else if (value.IsPositiveInfinity())
                {
                    return EFloat.PositiveInfinity;
                }
                if (value.CompareTo(0) == 0)
                {
                    return EFloat.FromInt32(0).Plus(ctx);
                }
                int flags = ctx.Flags;
                EContext tmpctx = null;
                EFloat ret;
                // DebugUtility.Log("cmp=" +
                // value.CompareTo(EFloat.Create(1, -1)) +
                // " add=" + value.Add(EFloat.FromInt32(1)));
                if (value.CompareTo(EFloat.Create(1, -1)) < 0)
                {
                    ret = value.Add(EFloat.FromInt32(1)).Log(ctx);
                }
                else
                {
                    tmpctx = ctx.WithBigPrecision(ctx.Precision.Add(3)).WithBlankFlags();
                    // DebugUtility.Log("orig "+value);
                    // DebugUtility.Log("sub "+value.Add(EFloat.FromInt32(1),
                    // tmpctx).Subtract(value));
                    ret = value.Add(EFloat.FromInt32(1), tmpctx).Log(ctx);
                    // DebugUtility.Log("ret "+ret);
                    flags |= tmpctx.Flags;
                }
                if (ctx.HasFlags)
                {
                    flags |= ctx.Flags;
                    ctx.Flags = flags;
                }
                return ret;
            }
        }

        /// <summary>Finds the base-N logarithm of this object, that is, the
        /// power (exponent) that the number N must be raised to in order to
        /// equal this object's value.</summary>
        /// <param name='baseValue'>The parameter <paramref name='baseValue'/>
        /// is a Numbers.EFloat object.</param>
        /// <param name='ctx'>The parameter <paramref name='ctx'/> is a
        /// Numbers.EContext object.</param>
        /// <returns>Ln(this object)/Ln(baseValue). Signals the flag
        /// FlagInvalid and returns not-a-number (NaN) if this object is less
        /// than 0. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null or the precision is
        /// unlimited (the context's Precision property is 0).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='baseValue'/> is null.</exception>
        public EFloat LogN(EFloat baseValue, EContext ctx)
        {
            EFloat value = this;
            if (baseValue == null)
            {
                throw new ArgumentNullException(nameof(baseValue));
            }
            if (value.IsNaN())
            {
                return value.Plus(ctx);
            }
            if (baseValue.IsNaN())
            {
                return baseValue.Plus(ctx);
            }
            if (ctx == null || !ctx.HasMaxPrecision ||
              (value.IsNegative && !value.IsZero) ||
              (baseValue.IsNegative && !baseValue.IsZero))
            {
                return EFloat.SignalingNaN.Plus(ctx);
            }
            if (ctx.Traps != 0)
            {
                EContext tctx = ctx.GetNontrapping();
                EFloat ret = value.LogN(baseValue, tctx);
                return ctx.TriggerTraps(ret, tctx);
            }
            else if (ctx.IsSimplified)
            {
                EContext tmpctx = ctx.WithSimplified(false).WithBlankFlags();
                EFloat ret = value.PreRound(ctx).LogN(baseValue.PreRound(ctx),
                    tmpctx);
                if (ctx.HasFlags)
                {
                    int flags = ctx.Flags;
                    ctx.Flags = flags | tmpctx.Flags;
                }
                // Console.WriteLine("{0} {1} [{4} {5}] -> {2}
                // [{3}]",value,baseValue,ret,ret.RoundToPrecision(ctx),
                // value.Quantize(value, ctx), baseValue.Quantize(baseValue, ctx));
                return ret.RoundToPrecision(ctx);
            }
            else
            {
                if (value.IsZero)
                {
                    return baseValue.CompareTo(1) < 0 ? EFloat.PositiveInfinity :
                      EFloat.NegativeInfinity;
                }
                else if (value.IsPositiveInfinity())
                {
                    return baseValue.CompareTo(1) < 0 ? EFloat.NegativeInfinity :
                      EFloat.PositiveInfinity;
                }
                if (baseValue.CompareTo(2) == 0)
                {
                    EFloat ev = value.Reduce(null);
                    if (ev.UnsignedMantissa.CompareTo(1) == 0)
                    {
                        return EFloat.FromEInteger(ev.Exponent).Plus(ctx);
                    }
                }
                else if (value.CompareTo(1) == 0)
                {
                    return EFloat.FromInt32(0).Plus(ctx);
                }
                else if (value.CompareTo(baseValue) == 0)
                {
                    return EFloat.FromInt32(1).Plus(ctx);
                }
                int flags = ctx.Flags;
                EContext tmpctx =
                  ctx.WithBigPrecision(ctx.Precision.Add(3)).WithBlankFlags();
                EFloat ret = value.Log(tmpctx).Divide(baseValue.Log(tmpctx), ctx);
                if (ret.IsInteger() && !ret.IsZero)
                {
                    flags |= EContext.FlagRounded | EContext.FlagInexact;
                    if (baseValue.Pow(ret).CompareToValue(value) == 0)
                    {
                        EFloat rtmp = ret.Quantize(EFloat.FromInt32(1),
                            ctx.WithNoFlags());
                        if (!rtmp.IsNaN())
                        {
                            flags &= ~(EContext.FlagRounded | EContext.FlagInexact);
                            ret = rtmp;
                        }
                    }
                }
                else
                {
                    flags |= tmpctx.Flags;
                }
                if (ctx.HasFlags)
                {
                    flags |= ctx.Flags;
                    ctx.Flags = flags;
                }
                return ret;
            }
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the left.</summary>
        /// <param name='places'>The number of binary digit places to move the
        /// radix point to the left. If this number is negative, instead moves
        /// the radix point to the right by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EFloat MovePointLeft(int places)
        {
            return this.MovePointLeft((EInteger)places, null);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the left.</summary>
        /// <param name='places'>The number of binary digit places to move the
        /// radix point to the left. If this number is negative, instead moves
        /// the radix point to the right by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EFloat MovePointLeft(int places, EContext ctx)
        {
            return this.MovePointLeft((EInteger)places, ctx);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the left.</summary>
        /// <param name='bigPlaces'>The number of binary digit places to move
        /// the radix point to the left. If this number is negative, instead
        /// moves the radix point to the right by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EFloat MovePointLeft(EInteger bigPlaces)
        {
            return this.MovePointLeft(bigPlaces, null);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the left.</summary>
        /// <param name='bigPlaces'>The number of binary digit places to move
        /// the radix point to the left. If this number is negative, instead
        /// moves the radix point to the right by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is decreased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EFloat MovePointLeft(
          EInteger bigPlaces,
          EContext ctx)
        {
            return (!this.IsFinite) ? this.RoundToPrecision(ctx) :
              this.MovePointRight(-(EInteger)bigPlaces, ctx);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the right.</summary>
        /// <param name='places'>The number of binary digit places to move the
        /// radix point to the right. If this number is negative, instead moves
        /// the radix point to the left by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EFloat MovePointRight(int places)
        {
            return this.MovePointRight((EInteger)places, null);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the right.</summary>
        /// <param name='places'>The number of binary digit places to move the
        /// radix point to the right. If this number is negative, instead moves
        /// the radix point to the left by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='places'/>, but not to more than 0.</returns>
        public EFloat MovePointRight(int places, EContext ctx)
        {
            return this.MovePointRight((EInteger)places, ctx);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the right.</summary>
        /// <param name='bigPlaces'>The number of binary digit places to move
        /// the radix point to the right. If this number is negative, instead
        /// moves the radix point to the left by this number's absolute
        /// value.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EFloat MovePointRight(EInteger bigPlaces)
        {
            return this.MovePointRight(bigPlaces, null);
        }

        /// <summary>Returns a number similar to this number but with the radix
        /// point moved to the right.</summary>
        /// <param name='bigPlaces'>The number of binary digit places to move
        /// the radix point to the right. If this number is negative, instead
        /// moves the radix point to the left by this number's absolute
        /// value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='bigPlaces'/>, but not to more than 0.</returns>
        public EFloat MovePointRight(
          EInteger bigPlaces,
          EContext ctx)
        {
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            if (bigExp.Sign > 0)
            {
                EInteger mant = this.UnsignedMantissa.ShiftLeft(bigExp);
                return CreateWithFlags(
                    mant,
                    EInteger.Zero,
                    this.flags).RoundToPrecision(ctx);
            }
            return CreateWithFlags(
                this.UnsignedMantissa,
                bigExp,
                this.flags).RoundToPrecision(ctx);
        }

        /// <summary>Multiplies this arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns the result. The exponent for the result is this
        /// arbitrary-precision binary floating-point number's exponent plus
        /// the other arbitrary-precision binary floating-point number's
        /// exponent.</summary>
        /// <param name='otherValue'>Another binary floating-point
        /// number.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number times another
        /// arbitrary-precision binary floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public EFloat Multiply(EFloat otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsFinite && otherValue.IsFinite)
            {
                EInteger exp = this.Exponent.Add(otherValue.Exponent);
                int newflags = otherValue.flags ^ this.flags;
                if (this.unsignedMantissa.CanFitInInt32() &&
                  otherValue.unsignedMantissa.CanFitInInt32())
                {
                    int integerA = this.unsignedMantissa.ToInt32();
                    int integerB = otherValue.unsignedMantissa.ToInt32();
                    long longA = ((long)integerA) * ((long)integerB);
                    return CreateWithFlags(longA, exp, newflags);
                }
                else
                {
                    EInteger eintA = this.UnsignedMantissa.Multiply(
                        otherValue.UnsignedMantissa);
                    return CreateWithFlags(eintA, exp, newflags);
                }
            }
            return this.Multiply(otherValue, EContext.UnlimitedHalfEven);
        }

        /// <summary>Multiplies this arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns the result.</summary>
        /// <param name='op'>Another binary floating-point number.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision binary floating-point number times another
        /// arbitrary-precision binary floating-point number.</returns>
        public EFloat Multiply(
          EFloat op,
          EContext ctx)
        {
            return MathValue.Multiply(this, op, ctx);
        }

        /// <summary>Multiplies by one binary floating-point number, and then
        /// adds another binary floating-point number.</summary>
        /// <param name='multiplicand'>The value to multiply.</param>
        /// <param name='augend'>The value to add.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat MultiplyAndAdd(
          EFloat multiplicand,
          EFloat augend)
        {
            return this.MultiplyAndAdd(multiplicand, augend, null);
        }

        /// <summary>Multiplies by one value, and then adds another
        /// value.</summary>
        /// <param name='op'>The value to multiply.</param>
        /// <param name='augend'>The value to add.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. If the precision doesn't indicate a simplified
        /// arithmetic, rounding and precision/exponent adjustment is done only
        /// once, namely, after multiplying and adding.</param>
        /// <returns>The result thisValue * multiplicand + augend.</returns>
        public EFloat MultiplyAndAdd(
          EFloat op,
          EFloat augend,
          EContext ctx)
        {
            return MathValue.MultiplyAndAdd(this, op, augend, ctx);
        }

        /// <summary>Multiplies by one value, and then subtracts another
        /// value.</summary>
        /// <param name='op'>The value to multiply.</param>
        /// <param name='subtrahend'>The value to subtract.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed. If the precision doesn't indicate a simplified
        /// arithmetic, rounding and precision/exponent adjustment is done only
        /// once, namely, after multiplying and subtracting.</param>
        /// <returns>The result thisValue * multiplicand -
        /// subtrahend.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='op'/> or <paramref name='subtrahend'/> is null.</exception>
        public EFloat MultiplyAndSubtract(
          EFloat op,
          EFloat subtrahend,
          EContext ctx)
        {
            if (op == null)
            {
                throw new ArgumentNullException(nameof(op));
            }
            if (subtrahend == null)
            {
                throw new ArgumentNullException(nameof(subtrahend));
            }
            EFloat negated = subtrahend;
            if ((subtrahend.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = subtrahend.flags ^ BigNumberFlags.FlagNegative;
                negated = new EFloat(
                  subtrahend.unsignedMantissa,
                  subtrahend.exponent,
                  (byte)newflags);
            }
            return MathValue.MultiplyAndAdd(this, op, negated, ctx);
        }

        /// <summary>Gets an object with the same value as this one, but with
        /// the sign reversed.</summary>
        /// <returns>An arbitrary-precision binary floating-point number. If
        /// this value is positive zero, returns negative zero. Returns
        /// signaling NaN if this value is signaling NaN. (In this sense, this
        /// method is similar to the "copy-negate" operation in the General
        /// Decimal Arithmetic Specification, except this method does not
        /// necessarily return a copy of this object.).</returns>
        public EFloat Negate()
        {
            return new EFloat(
                this.unsignedMantissa,
                this.exponent,
                (byte)(this.flags ^ BigNumberFlags.FlagNegative));
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but with the sign reversed.</summary>
        /// <param name='context'>An arithmetic context to control the
        /// precision, rounding, and exponent range of the result. If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which case the precision is
        /// unlimited and rounding isn't needed.</param>
        /// <returns>An arbitrary-precision binary floating-point number. If
        /// this value is positive zero, returns positive zero. Signals
        /// FlagInvalid and returns quiet NaN if this value is signaling
        /// NaN.</returns>
        public EFloat Negate(EContext context)
        {
            return MathValue.Negate(this, context);
        }

        /// <summary>Finds the largest value that's smaller than the given
        /// value.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision and exponent range of the result. The rounding mode from
        /// this context is ignored. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags).</param>
        /// <returns>Returns the largest value that's less than the given
        /// value. Returns negative infinity if the result is negative
        /// infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null, the precision is 0, or
        /// <paramref name='ctx'/> has an unlimited exponent range.</returns>
        public EFloat NextMinus(EContext ctx)
        {
            return MathValue.NextMinus(this, ctx);
        }

        /// <summary>Finds the smallest value that's greater than the given
        /// value.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision and exponent range of the result. The rounding mode from
        /// this context is ignored. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags).</param>
        /// <returns>Returns the smallest value that's greater than the given
        /// value.Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null, the precision is 0, or
        /// <paramref name='ctx'/> has an unlimited exponent range.</returns>
        public EFloat NextPlus(EContext ctx)
        {
            return MathValue.NextPlus(this, ctx);
        }

        /// <summary>Finds the next value that is closer to the other object's
        /// value than this object's value. Returns a copy of this value with
        /// the same sign as the other value if both values are
        /// equal.</summary>
        /// <param name='otherValue'>An arbitrary-precision binary
        /// floating-point number that the return value will approach.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision and exponent range of the result. The rounding mode from
        /// this context is ignored. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags).</param>
        /// <returns>Returns the next value that is closer to the other object'
        /// s value than this object's value. Signals FlagInvalid and returns
        /// NaN if the parameter <paramref name='ctx'/> is null, the precision
        /// is 0, or <paramref name='ctx'/> has an unlimited exponent
        /// range.</returns>
        public EFloat NextToward(
          EFloat otherValue,
          EContext ctx)
        {
            return MathValue.NextToward(this, otherValue, ctx);
        }

        /// <summary>Rounds this object's value to a given precision, using the
        /// given rounding mode and range of exponent, and also converts
        /// negative zero to positive zero. The idiom
        /// <c>EDecimal.SignalingNaN.Plus(ctx)</c> is useful for triggering an
        /// invalid operation and returning not-a-number (NaN) for custom
        /// arithmetic operations.</summary>
        /// <param name='ctx'>A context for controlling the precision, rounding
        /// mode, and exponent range. Can be null, in which case the precision
        /// is unlimited and rounding isn't needed.</param>
        /// <returns>The closest value to this object's value, rounded to the
        /// specified precision. If <paramref name='ctx'/> is null or the
        /// precision and exponent range are unlimited, returns the same value
        /// as this object (or a quiet NaN if this object is a signaling
        /// NaN).</returns>
        public EFloat Plus(EContext ctx)
        {
            return MathValue.Plus(this, ctx);
        }

        /// <summary>Raises this object's value to the given exponent, using
        /// unlimited precision.</summary>
        /// <param name='exponent'>An arbitrary-precision binary floating-point
        /// number expressing the exponent to raise this object's value
        /// to.</param>
        /// <returns>This^exponent. Returns not-a-number (NaN) if the exponent
        /// has a fractional part.</returns>
        public EFloat Pow(EFloat exponent)
        {
            return this.Pow(exponent, null);
        }

        /// <summary>Raises this object's value to the given
        /// exponent.</summary>
        /// <param name='exponent'>An arbitrary-precision binary floating-point
        /// number expressing the exponent to raise this object's value
        /// to.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>This^exponent. Signals the flag FlagInvalid and returns
        /// NaN if this object and exponent are both 0; or if this value is
        /// less than 0 and the exponent either has a fractional part or is
        /// infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
        /// parameter <paramref name='ctx'/> is null or the precision is
        /// unlimited (the context's Precision property is 0), and the exponent
        /// has a fractional part.</returns>
        public EFloat Pow(EFloat exponent, EContext ctx)
        {
            return MathValue.Power(this, exponent, ctx);
        }

        /// <summary>Raises this object's value to the given
        /// exponent.</summary>
        /// <param name='exponentSmall'>The exponent to raise this object's
        /// value to.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>This^exponent. Signals the flag FlagInvalid and returns
        /// NaN if this object and exponent are both 0.</returns>
        public EFloat Pow(int exponentSmall, EContext ctx)
        {
            return this.Pow(EFloat.FromInt64(exponentSmall), ctx);
        }

        /// <summary>Raises this object's value to the given
        /// exponent.</summary>
        /// <param name='exponentSmall'>The exponent to raise this object's
        /// value to.</param>
        /// <returns>This^exponent. Returns not-a-number (NaN) if this object
        /// and exponent are both 0.</returns>
        public EFloat Pow(int exponentSmall)
        {
            return this.Pow(EFloat.FromInt64(exponentSmall), null);
        }

        /// <summary>Finds the number of digits in this number's significand.
        /// Returns 1 if this value is 0, and 0 if this value is infinity or
        /// not-a-number (NaN).</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        public EInteger Precision()
        {
            if (!this.IsFinite)
            {
                return EInteger.Zero;
            }
            return this.IsZero ? EInteger.One :
              this.UnsignedMantissa.GetSignedBitLengthAsEInteger();
        }

        /// <summary>Returns whether this object's value is an
        /// integer.</summary>
        /// <returns><c>true</c> if this object's value is an integer;
        /// otherwise, <c>false</c>.</returns>
        public bool IsInteger()
        {
            if (!this.IsFinite)
            {
                return false;
            }
            if (this.IsZero || this.Exponent.CompareTo(0) >= 0)
            {
                return true;
            }
            else
            {
                EInteger absexp = this.Exponent.Abs();
                EInteger mant = this.UnsignedMantissa;
                return mant.GetLowBitAsEInteger().CompareTo(absexp) >= 0;
            }
        }

        /// <summary>
        ///  Returns a binary floating-point number with the same
        /// value but a new exponent.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of binary digit places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// binary digit places is desired, it's better to use the
        /// RoundToExponent and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b>
        ///  This method can be used to implement
        /// fixed-point binary arithmetic, in which each binary floating-point
        /// number has a fixed number of digits after the radix point. The
        /// following code example returns a fixed-point number with up to 20
        /// digits before and exactly 5 digits after the radix point:</para>
        /// <code> &#x2f;&#x2a; After performing arithmetic operations, adjust
        /// &#x2f;&#x2a; the number to 5 &#x2f;&#x2a;
        /// &#x2a;&#x2f;&#x2a;&#x2f;&#x2a;&#x2f;
        /// digits after the radix point number = number.Quantize(
        /// EInteger.FromInt32(-5), &#x2f;&#x2a; five digits after the radix
        /// point&#x2a;&#x2f;
        /// EContext.ForPrecision(25) &#x2f;&#x2a; 25-digit
        /// precision);&#x2a;&#x2f;</code>
        /// <para>A fixed-point binary arithmetic in which no digits come after
        /// the radix point (a desired exponent of 0) is considered an "integer
        /// arithmetic".</para>
        /// </summary>
        /// <param name='desiredExponent'>The desired exponent for the result.
        /// The exponent is the number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c>
        ///  of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>A binary floating-point number with the same value as this
        /// object but with the exponent changed. Signals FlagInvalid and
        /// returns not-a-number (NaN) if this object is infinity, if the
        /// rounded result can't fit the given precision, or if the context
        /// defines an exponent range and the given exponent is outside that
        /// range.</returns>
        public EFloat Quantize(
          EInteger desiredExponent,
          EContext ctx)
        {
            return this.Quantize(
                EFloat.Create(EInteger.One, desiredExponent),
                ctx);
        }

        /// <summary>
        ///  Returns a binary floating-point number with the same
        /// value but a new exponent.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of binary digit places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// binary digit places is desired, it's better to use the
        /// RoundToExponent and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b>
        ///  This method can be used to implement
        /// fixed-point binary arithmetic, in which each binary floating-point
        /// number has a fixed number of digits after the radix point. The
        /// following code example returns a fixed-point number with up to 20
        /// digits before and exactly 5 digits after the radix point:</para>
        /// <code> &#x2f;&#x2a; After performing arithmetic operations, adjust
        /// &#x2f;&#x2a; the number to 5&#x2a;&#x2f;&#x2a;&#x2f;
        /// digits after the radix point number = number.Quantize(-5, &#x2f;&#x2a; five
        /// digits&#x2a;&#x2f;
        /// after the radix point EContext.ForPrecision(25) &#x2f;&#x2a; 25-digit
        /// precision);&#x2a;&#x2f;</code>
        /// <para>A fixed-point binary arithmetic in which no digits come after
        /// the radix point (a desired exponent of 0) is considered an "integer
        /// arithmetic".</para>
        /// </summary>
        /// <param name='desiredExponentInt'>The desired exponent for the
        /// result. The exponent is the number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c>
        ///  of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>A binary floating-point number with the same value as this
        /// object but with the exponent changed. Signals FlagInvalid and
        /// returns not-a-number (NaN) if this object is infinity, if the
        /// rounded result can't fit the given precision, or if the context
        /// defines an exponent range and the given exponent is outside that
        /// range.</returns>
        public EFloat Quantize(
          int desiredExponentInt,
          EContext ctx)
        {
            return this.Quantize(
                EFloat.Create(1, desiredExponentInt),
                ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but with the same exponent as another binary
        /// floating-point number.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of binary digit places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// binary digit places is desired, it's better to use the
        /// RoundToExponent and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b> This method can be used to implement
        /// fixed-point binary arithmetic, in which a fixed number of digits
        /// come after the radix point. A fixed-point binary arithmetic in
        /// which no digits come after the radix point (a desired exponent of
        /// 0) is considered an "integer arithmetic" .</para></summary>
        /// <param name='otherValue'>A binary floating-point number containing
        /// the desired exponent of the result. The significand is ignored. The
        /// exponent is the number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the sixteenth (10b^-3, 0.0001b), and 3 means round
        /// to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number
        /// to an integer.</param>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>A binary floating-point number with the same value as this
        /// object but with the exponent changed. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding, or if the arithmetic context defines an
        /// exponent range and the given exponent is outside that
        /// range.</returns>
        public EFloat Quantize(
          EFloat otherValue,
          EContext ctx)
        {
            return MathValue.Quantize(this, otherValue, ctx);
        }

        /// <summary>Returns an object with the same numerical value as this
        /// one but with trailing zeros removed from its significand. For
        /// example, 1.00 becomes 1.
        /// <para>If this object's value is 0, changes the exponent to
        /// 0.</para></summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and rounding
        /// isn't needed.</param>
        /// <returns>This value with trailing zeros removed. Note that if the
        /// result has a very high exponent and the context says to clamp high
        /// exponents, there may still be some trailing zeros in the
        /// significand.</returns>
        public EFloat Reduce(EContext ctx)
        {
            return MathValue.Reduce(this, ctx);
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision binary floating-point number is divided by
        /// another arbitrary-precision binary floating-point number. The
        /// remainder is the number that remains when the absolute value of
        /// this arbitrary-precision binary floating-point number is divided
        /// (as though by DivideToIntegerZeroScale) by the absolute value of
        /// the other arbitrary-precision binary floating-point number; the
        /// remainder has the same sign (positive or negative) as this
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='divisor'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <param name='ctx'>The parameter <paramref name='ctx'/> is an
        /// EContext object.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision binary floating-point number is divided by
        /// another arbitrary-precision binary floating-point number. Signals
        /// FlagDivideByZero and returns infinity if the divisor (this
        /// arbitrary-precision binary floating-point number) is 0 and the
        /// dividend (the other arbitrary-precision binary floating-point
        /// number) is nonzero. Signals FlagInvalid and returns not-a-number
        /// (NaN) if the divisor and the dividend are 0, or if the result of
        /// the division doesn't fit the given precision.</returns>
        public EFloat Remainder(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.Remainder(this, divisor, ctx, true);
        }

        /// <summary>Finds the remainder that results when dividing two
        /// arbitrary-precision binary floating-point numbers. The remainder is
        /// the value that remains when the absolute value of this object is
        /// divided by the absolute value of the other object; the remainder
        /// has the same sign (positive or negative) as this object's
        /// value.</summary>
        /// <param name='divisor'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <param name='ctx'>The parameter <paramref name='ctx'/> is an
        /// EContext object.</param>
        /// <returns>The remainder of the two numbers. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the divisor is 0, or if the result
        /// doesn't fit the given precision.</returns>
        public EFloat RemainderNoRoundAfterDivide(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.Remainder(this, divisor, ctx, false);
        }

        /// <summary>Calculates the remainder of a number by the formula
        /// <c>"this" - (("this" / "divisor") * "divisor")</c>.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat RemainderNaturalScale(
          EFloat divisor)
        {
            return this.RemainderNaturalScale(divisor, null);
        }

        /// <summary>Calculates the remainder of a number by the formula "this"
        /// - (("this" / "divisor") * "divisor").</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only in the division portion of the remainder
        /// calculation; as a result, it's possible for the return value to
        /// have a higher precision than given in this context. Flags will be
        /// set on the given context only if the context's <c>HasFlags</c> is
        /// true and the integer part of the division result doesn't fit the
        /// precision and exponent range without rounding. Can be null, in
        /// which the precision is unlimited and no additional rounding, other
        /// than the rounding down to an integer after division, is
        /// needed.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat RemainderNaturalScale(
          EFloat divisor,
          EContext ctx)
        {
            return this.Subtract(
              this.DivideToIntegerNaturalScale(divisor, null).Multiply(divisor, null),
              ctx);
        }

        /// <summary>Finds the distance to the closest multiple of the given
        /// divisor, based on the result of dividing this object's value by
        /// another object's value.
        /// <list type=''>
        /// <item>If this and the other object divide evenly, the result is
        /// 0.</item>
        /// <item>If the remainder's absolute value is less than half of the
        /// divisor's absolute value, the result has the same sign as this
        /// object and will be the distance to the closest multiple.</item>
        /// <item>If the remainder's absolute value is more than half of the
        /// divisor's absolute value, the result has the opposite sign of this
        /// object and will be the distance to the closest multiple.</item>
        /// <item>If the remainder's absolute value is exactly half of the
        /// divisor's absolute value, the result has the opposite sign of this
        /// object if the quotient, rounded down, is odd, and has the same sign
        /// as this object if the quotient, rounded down, is even, and the
        /// result's absolute value is half of the divisor's absolute
        /// value.</item></list> This function is also known as the "IEEE
        /// Remainder" function.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision. The rounding and exponent range settings of this context
        /// are ignored (the rounding mode is always treated as HalfEven). If
        /// <c>HasFlags</c> of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null, in which the precision is
        /// unlimited.</param>
        /// <returns>The distance of the closest multiple. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the divisor is 0, or either the
        /// result of integer division (the quotient) or the remainder wouldn't
        /// fit the given precision.</returns>
        public EFloat RemainderNear(
          EFloat divisor,
          EContext ctx)
        {
            return MathValue.RemainderNear(this, divisor, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to a new exponent if necessary. The
        /// resulting number's Exponent property will not necessarily be the
        /// given exponent; use the Quantize method instead to give the result
        /// a particular exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// value representable in the given precision. If the result can't fit
        /// the precision, additional digits are discarded to make it fit.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to the given exponent when rounding, and the given
        /// exponent is outside of the valid range of the arithmetic
        /// context.</returns>
        public EFloat RoundToExponent(
          EInteger exponent,
          EContext ctx)
        {
            return MathValue.RoundToExponentSimple(this, exponent, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to a new exponent if necessary. The
        /// resulting number's Exponent property will not necessarily be the
        /// given exponent; use the Quantize method instead to give the result
        /// a particular exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// value representable in the given precision. If the result can't fit
        /// the precision, additional digits are discarded to make it fit.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to the given exponent when rounding, and the given
        /// exponent is outside of the valid range of the arithmetic
        /// context.</returns>
        public EFloat RoundToExponent(
          int exponentSmall,
          EContext ctx)
        {
            return this.RoundToExponent((EInteger)exponentSmall, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to the given exponent, and signals an
        /// inexact flag if the result would be inexact. The resulting number's
        /// Exponent property will not necessarily be the given exponent; use
        /// the Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// value representable in the given precision. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the arithmetic context defines an exponent
        /// range, the new exponent must be changed to the given exponent when
        /// rounding, and the given exponent is outside of the valid range of
        /// the arithmetic context.</returns>
        public EFloat RoundToExponentExact(
          EInteger exponent,
          EContext ctx)
        {
            return MathValue.RoundToExponentExact(this, exponent, ctx);
        }

        /// <summary>Returns a binary number with the same value as this object
        /// but rounded to the given exponent. The resulting number's Exponent
        /// property will not necessarily be the given exponent; use the
        /// Quantize method instead to give the result a particular
        /// exponent.</summary>
        /// <param name='exponent'>The minimum exponent the result can have.
        /// This is the maximum number of fractional digits in the result,
        /// expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the eighth (10^-1, 1/8), and 3 means round to the
        /// eight (2^3, 8). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='rounding'>Desired mode for rounding this object's
        /// value.</param>
        /// <returns>A binary number rounded to the closest value representable
        /// in the given precision.</returns>
        public EFloat RoundToExponentExact(
          EInteger exponent,
          ERounding rounding)
        {
            return MathValue.RoundToExponentExact(
                this,
                exponent,
                EContext.Unlimited.WithRounding(rounding));
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to the given exponent represented as a
        /// 32-bit signed integer, and signals an inexact flag if the result
        /// would be inexact. The resulting number's Exponent property will not
        /// necessarily be the given exponent; use the Quantize method instead
        /// to give the result a particular exponent.</summary>
        /// <param name='exponentSmall'>The minimum exponent the result can
        /// have. This is the maximum number of fractional digits in the
        /// result, expressed as a negative number. Can also be positive, which
        /// eliminates lower-order places from the number. For example, -3
        /// means round to the thousandth (10^-3, 0.0001), and 3 means round to
        /// the thousand (10^3, 1000). A value of 0 rounds the number to an
        /// integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// value representable in the given precision. Signals FlagInvalid and
        /// returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the arithmetic context defines an exponent
        /// range, the new exponent must be changed to the given exponent when
        /// rounding, and the given exponent is outside of the valid range of
        /// the arithmetic context.</returns>
        public EFloat RoundToExponentExact(
          int exponentSmall,
          EContext ctx)
        {
            return this.RoundToExponentExact((EInteger)exponentSmall, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to an integer, and signals an inexact
        /// flag if the result would be inexact. The resulting number's
        /// Exponent property will not necessarily be 0; use the Quantize
        /// method instead to give the result an exponent of 0.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// integer representable in the given precision. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the arithmetic context defines an exponent
        /// range, the new exponent must be changed to 0 when rounding, and 0
        /// is outside of the valid range of the arithmetic context.</returns>
        public EFloat RoundToIntegerExact(EContext ctx)
        {
            return MathValue.RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to an integer, without adding the
        /// <c>FlagInexact</c> or <c>FlagRounded</c> flags. The resulting
        /// number's Exponent property will not necessarily be 0; use the
        /// Quantize method instead to give the result an exponent of
        /// 0.</summary>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags), except that this
        /// function will never add the <c>FlagRounded</c> and
        /// <c>FlagInexact</c> flags (the only difference between this and
        /// RoundToExponentExact). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// integer representable in the given precision. If the result can't
        /// fit the precision, additional digits are discarded to make it fit.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to 0 when rounding, and 0 is outside of the valid range
        /// of the arithmetic context.</returns>
        public EFloat RoundToIntegerNoRoundedFlag(EContext ctx)
        {
            return MathValue.RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to an integer, and signals an inexact
        /// flag if the result would be inexact.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the default rounding mode is
        /// HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// integer representable in the given precision. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding. Signals FlagInvalid and returns
        /// not-a-number (NaN) if the arithmetic context defines an exponent
        /// range, the new exponent must be changed to 0 when rounding, and 0
        /// is outside of the valid range of the arithmetic context.</returns>
        [Obsolete("Renamed to RoundToIntegerExact.")]
        public EFloat RoundToIntegralExact(EContext ctx)
        {
            return MathValue.RoundToExponentExact(this, EInteger.Zero, ctx);
        }

        /// <summary>Returns a binary floating-point number with the same value
        /// as this object but rounded to an integer, without adding the
        /// <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary>
        /// <param name='ctx'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags), except that this
        /// function will never add the <c>FlagRounded</c> and
        /// <c>FlagInexact</c> flags (the only difference between this and
        /// RoundToExponentExact). Can be null, in which case the default
        /// rounding mode is HalfEven.</param>
        /// <returns>A binary floating-point number rounded to the closest
        /// integer representable in the given precision. If the result can't
        /// fit the precision, additional digits are discarded to make it fit.
        /// Signals FlagInvalid and returns not-a-number (NaN) if the
        /// arithmetic context defines an exponent range, the new exponent must
        /// be changed to 0 when rounding, and 0 is outside of the valid range
        /// of the arithmetic context.</returns>
        [Obsolete("Renamed to RoundToIntegerNoRoundedFlag.")]
        public EFloat RoundToIntegralNoRoundedFlag(EContext ctx)
        {
            return MathValue.RoundToExponentNoRoundedFlag(this, EInteger.Zero, ctx);
        }

        /// <summary>Rounds this object's value to a given precision, using the
        /// given rounding mode and range of exponent.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The closest value to this object's value, rounded to the
        /// specified precision. Returns the same value as this object if
        /// <paramref name='ctx'/> is null or the precision and exponent range
        /// are unlimited.</returns>
        public EFloat RoundToPrecision(EContext ctx)
        {
            return MathValue.RoundToPrecision(this, ctx);
        }

        /// <summary>Returns a number in which the value of this object is
        /// rounded to fit the maximum precision allowed if it has more
        /// significant digits than the maximum precision. The maximum
        /// precision allowed is given in an arithmetic context. This method is
        /// designed for preparing operands to a custom arithmetic operation in
        /// accordance with the "simplified" arithmetic given in Appendix A of
        /// the General Decimal Arithmetic Specification.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited. Signals the
        /// flag LostDigits if the input number has greater precision than
        /// allowed and was rounded to a different numerical value in order to
        /// fit the precision.</param>
        /// <returns>This object rounded to the given precision. Returns this
        /// object and signals no flags if <paramref name='ctx'/> is null or
        /// specifies an unlimited precision, if this object is infinity or
        /// not-a-number (including signaling NaN), or if the number's value
        /// has no more significant digits than the maximum precision given in
        /// <paramref name='ctx'/>.</returns>
        public EFloat PreRound(EContext ctx)
        {
            return NumberUtility.PreRound(this, ctx, MathValue);
        }

        /// <summary>Returns a number similar to this number but with the scale
        /// adjusted.</summary>
        /// <param name='places'>The parameter <paramref name='places'/> is a
        /// 32-bit signed integer.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat ScaleByPowerOfTwo(int places)
        {
            return this.ScaleByPowerOfTwo((EInteger)places, null);
        }

        /// <summary>Returns a number similar to this number but with the scale
        /// adjusted.</summary>
        /// <param name='places'>The parameter <paramref name='places'/> is a
        /// 32-bit signed integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat ScaleByPowerOfTwo(int places, EContext ctx)
        {
            return this.ScaleByPowerOfTwo((EInteger)places, ctx);
        }

        /// <summary>Returns a number similar to this number but with the scale
        /// adjusted.</summary>
        /// <param name='bigPlaces'>An arbitrary-precision integer.</param>
        /// <returns>A number whose exponent is increased by <paramref
        /// name='bigPlaces'/>.</returns>
        public EFloat ScaleByPowerOfTwo(EInteger bigPlaces)
        {
            return this.ScaleByPowerOfTwo(bigPlaces, null);
        }

        /// <summary>Returns a number similar to this number but with its scale
        /// adjusted.</summary>
        /// <param name='bigPlaces'>An arbitrary-precision integer.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null.</param>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigPlaces'/> is null.</exception>
        public EFloat ScaleByPowerOfTwo(
          EInteger bigPlaces,
          EContext ctx)
        {
            if (bigPlaces == null)
            {
                throw new ArgumentNullException(nameof(bigPlaces));
            }
            if (bigPlaces.IsZero)
            {
                return this.RoundToPrecision(ctx);
            }
            if (!this.IsFinite)
            {
                return this.RoundToPrecision(ctx);
            }
            EInteger bigExp = this.Exponent;
            bigExp += bigPlaces;
            return new EFloat(
                this.unsignedMantissa,
                FastIntegerFixed.FromBig(bigExp),
                (byte)this.flags).RoundToPrecision(ctx);
        }

        /// <summary>Finds the square root of this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the square root function's
        /// results are generally not exact for many inputs.</i> (Unlike in the
        /// General Binary Arithmetic Specification, any rounding mode is
        /// allowed.).</param>
        /// <returns>The square root. Signals the flag FlagInvalid and returns
        /// NaN if this object is less than 0 (the square root would be a
        /// complex number, but the return value is still NaN). Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        public EFloat Sqrt(EContext ctx)
        {
            return MathValue.SquareRoot(this, ctx);
        }

        /// <summary>Finds the square root of this object's value.</summary>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// <i>This parameter can't be null, as the square root function's
        /// results are generally not exact for many inputs.</i> (Unlike in the
        /// General Binary Arithmetic Specification, any rounding mode is
        /// allowed.).</param>
        /// <returns>The square root. Signals the flag FlagInvalid and returns
        /// NaN if this object is less than 0 (the square root would be a
        /// complex number, but the return value is still NaN). Signals
        /// FlagInvalid and returns not-a-number (NaN) if the parameter
        /// <paramref name='ctx'/> is null or the precision is unlimited (the
        /// context's Precision property is 0).</returns>
        [Obsolete("Renamed to Sqrt.")]
        public EFloat SquareRoot(EContext ctx)
        {
            return MathValue.SquareRoot(this, ctx);
        }

        /// <summary>Subtracts an arbitrary-precision binary floating-point
        /// number from this arbitrary-precision binary floating-point number
        /// and returns the result. The exponent for the result is the lower of
        /// this arbitrary-precision binary floating-point number's exponent
        /// and the other arbitrary-precision binary floating-point number's
        /// exponent.</summary>
        /// <param name='otherValue'>The number to subtract from this
        /// instance's value.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision binary floating-point number minus another
        /// arbitrary-precision binary floating-point number. If this
        /// arbitrary-precision binary floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        public EFloat Subtract(EFloat otherValue)
        {
            return this.Subtract(otherValue, null);
        }

        /// <summary>Subtracts an arbitrary-precision binary floating-point
        /// number from this arbitrary-precision binary floating-point number
        /// and returns the result.</summary>
        /// <param name='otherValue'>The number to subtract from this
        /// instance's value.</param>
        /// <param name='ctx'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. If <c>HasFlags</c> of
        /// the context is true, will also store the flags resulting from the
        /// operation (the flags are in addition to the pre-existing flags).
        /// Can be null, in which case the precision is unlimited and no
        /// rounding is needed.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision binary floating-point number minus another
        /// arbitrary-precision binary floating-point number. If this
        /// arbitrary-precision binary floating-point number is not-a-number
        /// (NaN), returns NaN.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public EFloat Subtract(
          EFloat otherValue,
          EContext ctx)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            EFloat negated = otherValue;
            if ((otherValue.flags & BigNumberFlags.FlagNaN) == 0)
            {
                int newflags = otherValue.flags ^ BigNumberFlags.FlagNegative;
                negated = new EFloat(
                  otherValue.unsignedMantissa,
                  otherValue.exponent,
                  (byte)newflags);
            }
            return this.Add(negated, ctx);
        }

        /// <summary>Converts this value to a 64-bit floating-point number
        /// encoded in the IEEE 754 binary64 format.</summary>
        /// <returns>This number, converted to a 64-bit floating-point number
        /// encoded in the IEEE 754 binary64 format. The return value can be
        /// positive infinity or negative infinity if this value exceeds the
        /// range of a 64-bit floating point number.</returns>
        public double ToDouble()
        {
            long value = this.ToDoubleBits();
            return BitConverter.ToDouble(BitConverter.GetBytes((long)value), 0);
        }

        /// <summary>Converts this value to its closest equivalent as 32-bit
        /// floating-point number, expressed as an integer in the IEEE 754
        /// binary32 format. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN.</para></summary>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value, expressed as an integer in the IEEE 754 binary32 format. The
        /// return value can be positive infinity or negative infinity if this
        /// value exceeds the range of a 32-bit floating point
        /// number.</returns>
        public int ToSingleBits()
        {
            if (this.IsPositiveInfinity())
            {
                return 0x7f800000;
            }
            if (this.IsNegativeInfinity())
            {
                return unchecked((int)0xff800000);
            }
            if (this.IsNaN())
            {
                var nan = 0x7f800000;
                if (this.IsNegative)
                {
                    nan |= unchecked((int)(1 << 31));
                }
                // IsQuietNaN(): the quiet bit for X86 at least
                // If signaling NaN and mantissa is 0: set 0x200000
                // bit to keep the mantissa from being zero
                if (this.IsQuietNaN())
                {
                    nan |= 0x400000;
                }
                else if (this.UnsignedMantissa.IsZero)
                {
                    nan |= 0x200000;
                }
                if (!this.UnsignedMantissa.IsZero)
                {
                    // Transfer diagnostic information
                    EInteger bigdata = this.UnsignedMantissa % (EInteger)0x400000;
                    var intData = (int)bigdata;
                    nan |= intData;
                    if (intData == 0 && !this.IsQuietNaN())
                    {
                        nan |= 0x200000;
                    }
                }
                return nan;
            }
            EFloat thisValue = this;
            // DebugUtility.Log("beforeround=" +thisValue + " ["+
            // thisValue.Mantissa + " " + thisValue.Exponent);
            // Check whether rounding can be avoided for common cases
            // where the value already fits a single
            if (!thisValue.IsFinite ||
              thisValue.unsignedMantissa.CompareToInt(0x1000000) >= 0 ||
              thisValue.exponent.CompareToInt(-95) < 0 ||
              thisValue.exponent.CompareToInt(95) > 0)
            {
                thisValue = this.RoundToPrecision(EContext.Binary32);
            }
            // DebugUtility.Log("afterround=" +thisValue + " ["+
            // thisValue.Mantissa + " " + thisValue.Exponent);
            if (!thisValue.IsFinite)
            {
                return thisValue.ToSingleBits();
            }
            int intmant = thisValue.unsignedMantissa.ToInt32();
            if (thisValue.IsNegative && intmant == 0)
            {
                return (int)1 << 31;
            }
            else if (intmant == 0)
            {
                return 0;
            }
            int intBitLength = NumberUtility.BitLength(intmant);
            int expo = thisValue.exponent.ToInt32();
            var subnormal = false;
            if (intBitLength < 24)
            {
                int diff = 24 - intBitLength;
                expo -= diff;
                if (expo < -149)
                {
                    // DebugUtility.Log("Diff changed from " + diff + " to " + (diff -
                    // (-149 - expo)));
                    diff -= -149 - expo;
                    expo = -149;
                    subnormal = true;
                }
                intmant <<= diff;
            }
            // DebugUtility.Log("intmant=" + intmant + " " + intBitLength +
            // " expo=" + expo +
            // " subnormal=" + subnormal);
            int smallmantissa = intmant & 0x7fffff;
            if (!subnormal)
            {
                smallmantissa |= (expo + 150) << 23;
            }
            if (this.IsNegative)
            {
                smallmantissa |= 1 << 31;
            }
            return smallmantissa;
        }

        /// <summary>Converts this value to its closest equivalent as a 64-bit
        /// floating-point number, expressed as an integer in the IEEE 754
        /// binary64 format. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 64-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN.</para></summary>
        /// <returns>The closest 64-bit binary floating-point number to this
        /// value, expressed as an integer in the IEEE 754 binary64 format. The
        /// return value can be positive infinity or negative infinity if this
        /// value exceeds the range of a 64-bit floating point
        /// number.</returns>
        public long ToDoubleBits()
        {
            if (this.IsPositiveInfinity())
            {
                return unchecked((long)0x7ff0000000000000L);
            }
            if (this.IsNegativeInfinity())
            {
                return unchecked((long)0xfff0000000000000L);
            }
            if (this.IsNaN())
            {
                int[] nan = { 0, 0x7ff00000 };
                if (this.IsNegative)
                {
                    nan[1] |= unchecked((int)(1 << 31));
                }
                if (this.IsQuietNaN())
                {
                    // Quiet NaN is a NaN in which the highest bit of
                    // the mantissa area is set
                    nan[1] |= 0x80000;
                }
                else if (this.UnsignedMantissa.IsZero)
                {
                    // Set the 0x40000 bit to keep the mantissa from
                    // being zero if this is a signaling NaN
                    nan[1] |= 0x40000;
                }
                if (!this.UnsignedMantissa.IsZero)
                {
                    // Copy diagnostic information
                    int[] words = FastInteger.GetLastWords(this.UnsignedMantissa, 2);
                    nan[0] = words[0];
                    nan[1] |= words[1] & 0x7ffff;
                    if ((words[0] | (words[1] & 0x7ffff)) == 0 && !this.IsQuietNaN())
                    {
                        // Set the 0x40000 bit to keep the mantissa from
                        // being zero if this is a signaling NaN
                        nan[1] |= 0x40000;
                    }
                }
                long lret = unchecked(((long)nan[0]) & 0xffffffffL);
                lret |= unchecked(((long)nan[1]) << 32);
                /*
                 DebugUtility.Log("lret={0:X8} {1:X8} {2:X}", nan[0], nan[1], lret);
                */
                return lret;
            }
            EFloat thisValue = this;
            // Check whether rounding can be avoided for common cases
            // where the value already fits a double
            if (!thisValue.IsFinite ||
              thisValue.unsignedMantissa.CompareToInt64(1L << 52) >= 0 ||
              thisValue.exponent.CompareToInt(-900) < 0 ||
              thisValue.exponent.CompareToInt(900) > 0)
            {
                thisValue = this.RoundToPrecision(EContext.Binary64);
            }
            if (!thisValue.IsFinite)
            {
                return thisValue.ToDoubleBits();
            }
            long longmant = thisValue.unsignedMantissa.ToInt64();
            if (thisValue.IsNegative && longmant == 0)
            {
                return 1L << 63;
            }
            else if (longmant == 0)
            {
                return 0L;
            }
            // DebugUtility.Log("todouble -->" + this);
            long longBitLength = NumberUtility.BitLength(longmant);
            int expo = thisValue.exponent.ToInt32();
            var subnormal = false;
            if (longBitLength < 53)
            {
                int diff = 53 - (int)longBitLength;
                expo -= diff;
                if (expo < -1074)
                {
                    // DebugUtility.Log("Diff changed from " + diff + " to " + (diff -
                    // (-1074 - expo)));
                    diff -= -1074 - expo;
                    expo = -1074;
                    subnormal = true;
                }
                longmant <<= diff;
            }
            // Clear the high bits where the exponent and sign are
            longmant &= 0xfffffffffffffL;
            if (!subnormal)
            {
                longmant |= (long)(expo + 1075) << 52;
            }
            if (thisValue.IsNegative)
            {
                longmant |= unchecked((long)(1L << 63));
            }
            return longmant;
        }

        /// <summary>Converts this value to an arbitrary-precision decimal
        /// number.</summary>
        /// <returns>This number, converted to an arbitrary-precision decimal
        /// number.</returns>
        public EDecimal ToEDecimal()
        {
            return EDecimal.FromEFloat(this);
        }

        /// <summary>Converts this value to an arbitrary-precision integer. Any
        /// fractional part of this value will be discarded when converting to
        /// an arbitrary-precision integer. Note that depending on the value,
        /// especially the exponent, generating the arbitrary-precision integer
        /// may require a huge amount of memory. Use the ToSizedEInteger method
        /// to convert a number to an EInteger only if the integer fits in a
        /// bounded bit range; that method will throw an exception on
        /// overflow.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        public EInteger ToEInteger()
        {
            return this.ToEIntegerInternal(false);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// checking whether the value contains a fractional part. Note that
        /// depending on the value, especially the exponent, generating the
        /// arbitrary-precision integer may require a huge amount of memory.
        /// Use the ToSizedEIntegerIfExact method to convert a number to an
        /// EInteger only if the integer fits in a bounded bit range; that
        /// method will throw an exception on overflow.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        [Obsolete("Renamed to ToEIntegerIfExact.")]
        public EInteger ToEIntegerExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// checking whether the value contains a fractional part. Note that
        /// depending on the value, especially the exponent, generating the
        /// arbitrary-precision integer may require a huge amount of memory.
        /// Use the ToSizedEIntegerIfExact method to convert a number to an
        /// EInteger only if the integer fits in a bounded bit range; that
        /// method will throw an exception on overflow.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        public EInteger ToEIntegerIfExact()
        {
            return this.ToEIntegerInternal(true);
        }

        /// <summary>Converts this value to an arbitrary-precision decimal
        /// number, then returns the value of that decimal's
        /// ToEngineeringString method.</summary>
        /// <returns>A text string.</returns>
        public string ToEngineeringString()
        {
            return this.ToEDecimal().ToEngineeringString();
        }

        /// <summary>Converts this value to an arbitrary-precision decimal
        /// number.</summary>
        /// <returns>An arbitrary-precision decimal number.</returns>
        [Obsolete("Renamed to ToEDecimal.")]
        public EDecimal ToExtendedDecimal()
        {
            return EDecimal.FromEFloat(this);
        }

        /// <summary>Converts this value to a string, but without exponential
        /// notation.</summary>
        /// <returns>A text string.</returns>
        public string ToPlainString()
        {
            return this.ToEDecimal().ToPlainString();
        }

        private string ToDebugString()
        {
            return "[" + this.Mantissa.ToRadixString(2) +
              "," + this.Mantissa.GetUnsignedBitLengthAsEInteger() +
              "," + this.Exponent + "]";
        }

        /// <summary>Returns a string representation of this number's value
        /// after rounding that value to the given precision (using the given
        /// arithmetic context, such as <c>EContext.Binary64</c>
        ///  ). If the
        /// number after rounding is neither infinity nor not-a-number (NaN),
        /// returns the shortest decimal form of this number's value (in terms
        /// of decimal digits starting with the first nonzero digit and ending
        /// with the last nonzero digit) that results in the rounded number
        /// after the decimal form is converted to binary floating-point format
        /// (using the given arithmetic context).</summary>
        /// <param name='ctx'>An arithmetic context to control precision (in
        /// bits), rounding, and exponent range of the rounded number. If
        /// <c>HasFlags</c>
        ///  of the context is true, will also store the flags
        /// resulting from the operation (the flags are in addition to the
        /// pre-existing flags). Can be null. If this parameter is null or
        /// defines no maximum precision, returns the same value as the
        /// ToString() method.</param>
        /// <returns>Shortest decimal form of this number's value for the given
        /// arithmetic context. The text string will be in exponential notation
        /// (expressed as a number 1 or greater, but less than 10, times a
        /// power of 10) if the number's first nonzero decimal digit is more
        /// than five digits after the decimal point, or if the number's
        /// exponent is greater than 0 and its value is 10, 000, 000 or
        /// greater.</returns>
        /// <example>
        /// <para>The following example converts an EFloat number to its
        /// shortest round-tripping decimal form using the same precision as
        /// the <c>double</c>
        ///  type in Java and.NET:</para>
        /// <code> String str = efloat.ToShortestString(EContext.Binary64); </code>
        /// </example>
        public string ToShortestString(EContext ctx)
        {
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return this.ToString();
            }
            if (this.IsNaN())
            {
                return CreateNaN(
                    this.UnsignedMantissa,
                    this.IsSignalingNaN(),
                    this.IsNegative,
                    ctx).ToString();
            }
            if (this.IsInfinity())
            {
                return this.RoundToPrecision(ctx).ToString();
            }
            EContext ctx2 = ctx.WithNoFlags();
            EFloat valueEfRnd = this.RoundToPrecision(ctx);
            if (valueEfRnd.IsInfinity())
            {
                return valueEfRnd.ToString();
            }
            if (this.IsZero)
            {
                return this.RoundToPrecision(ctx).ToString();
            }
            // NOTE: The original EFloat is converted to decimal,
            // not the rounded version, to avoid double rounding issues
            EDecimal dec = this.ToEDecimal();
            if (ctx.Precision.CompareTo(10) >= 0)
            {
                // Preround the decimal so the significand has closer to the
                // number of decimal digits of the maximum possible
                // decimal significand, to speed up further rounding
                EInteger roundedPrec = ctx.Precision.ShiftRight(1).Add(
                    EInteger.FromInt32(3));
                EInteger dmant = dec.UnsignedMantissa;
                EInteger dexp = dec.Exponent;
                bool dneg = dec.IsNegative;
                var dsa = new DigitShiftAccumulator(dmant, 0, 0);
                dsa.ShiftToDigits(FastInteger.FromBig(roundedPrec), null, false);
                dmant = dsa.ShiftedInt;
                dexp = dexp.Add(dsa.DiscardedDigitCount.ToEInteger());
                if (dsa.LastDiscardedDigit != 0 || dsa.OlderDiscardedDigits != 0)
                {
                    if (dmant.Remainder(10).ToInt32Checked() != 9)
                    {
                        dmant = dmant.Add(1);
                    }
                }
                dec = EDecimal.Create(dmant, dexp);
                if (dneg)
                {
                    dec = dec.Negate();
                }
            }
            bool mantissaIsPowerOfTwo = this.UnsignedMantissa.IsPowerOfTwo;
            EInteger eprecision = EInteger.Zero;
            while (true)
            {
                EInteger nextPrecision = eprecision.Add(EInteger.One);
                EContext nextCtx = ctx2.WithBigPrecision(nextPrecision);
                EDecimal nextDec = dec.RoundToPrecision(nextCtx);
                EFloat newFloat = nextDec.ToEFloat(ctx2);
                // DebugUtility.Log("nextDec=" + nextDec);
                if (newFloat.CompareTo(valueEfRnd) == 0)
                {
                    if (mantissaIsPowerOfTwo && eprecision.Sign > 0)
                    {
                        nextPrecision = eprecision;
                        nextCtx = ctx2.WithBigPrecision(nextPrecision);
#if DEBUG
                        if (!nextCtx.HasMaxPrecision)
                        {
                            throw new InvalidOperationException("mant=" + this.Mantissa +
                              "," + "\u0020 exp=" + this.Exponent);
                        }
#endif
                        EDecimal nextDec2 = dec.RoundToPrecision(nextCtx);
                        nextDec2 = nextDec2.NextPlus(nextCtx);
                        newFloat = nextDec2.ToEFloat(ctx2);
                        if (newFloat.CompareTo(valueEfRnd) == 0)
                        {
                            nextDec = nextDec2;
                        }
                    }
                    return (nextDec.Exponent.Sign > 0 &&
                        nextDec.Abs().CompareTo(EDecimal.FromInt32(10000000)) < 0) ?
                      nextDec.ToPlainString() : nextDec.ToString();
                }
                eprecision = nextPrecision;
            }
        }

        /// <summary>Converts this value to its closest equivalent as a 32-bit
        /// floating-point number. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value. The return value can be positive infinity or negative
        /// infinity if this value exceeds the range of a 32-bit floating point
        /// number.</returns>
        public float ToSingle()
        {
            int sb = this.ToSingleBits();
            return BitConverter.ToSingle(BitConverter.GetBytes(sb), 0);
        }

        /// <summary>Converts this number's value to a text string.</summary>
        /// <returns>A string representation of this object. The value is
        /// converted to decimal and the decimal form of this number's value is
        /// returned. The text string will be in exponential notation
        /// (expressed as a number 1 or greater, but less than 10, times a
        /// power of 10) if the converted number's scale is positive or if the
        /// number's first nonzero decimal digit is more than five digits after
        /// the decimal point.</returns>
        public override string ToString()
        {
            return EDecimal.FromEFloat(this).ToString();
        }

        /// <summary>Returns the unit in the last place. The significand will
        /// be 1 and the exponent will be this number's exponent. Returns 1
        /// with an exponent of 0 if this number is infinity or not-a-number
        /// (NaN).</summary>
        /// <returns>An arbitrary-precision binary floating-point
        /// number.</returns>
        public EFloat Ulp()
        {
            return (!this.IsFinite) ? EFloat.One :
              EFloat.Create(EInteger.One, this.Exponent);
        }

        internal static EFloat CreateWithFlags(
          long mantissa,
          EInteger exponent,
          int flags)
        {
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            return new EFloat(
                FastIntegerFixed.FromInt64(mantissa).Abs(),
                FastIntegerFixed.FromBig(exponent),
                (byte)flags);
        }

        internal static EFloat CreateWithFlags(
          EInteger mantissa,
          EInteger exponent,
          int flags)
        {
            if (mantissa == null)
            {
                throw new ArgumentNullException(nameof(mantissa));
            }
            if (exponent == null)
            {
                throw new ArgumentNullException(nameof(exponent));
            }
            return new EFloat(
                FastIntegerFixed.FromBig(mantissa).Abs(),
                FastIntegerFixed.FromBig(exponent),
                (byte)flags);
        }

        private EInteger ToEIntegerInternal(bool exact)
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsZero)
            {
                return EInteger.Zero;
            }
            int expsign = this.Exponent.Sign;
            if (expsign == 0)
            {
                // Integer
                return this.Mantissa;
            }
            if (expsign > 0)
            {
                // Integer with trailing zeros
                EInteger curexp = this.Exponent;
                EInteger bigmantissa = this.Mantissa;
                if (bigmantissa.IsZero)
                {
                    return bigmantissa;
                }
                bool neg = bigmantissa.Sign < 0;
                if (neg)
                {
                    bigmantissa = -bigmantissa;
                }
                bigmantissa = bigmantissa.ShiftLeft(curexp);
                if (neg)
                {
                    bigmantissa = -bigmantissa;
                }
                return bigmantissa;
            }
            else
            {
                if (exact && !this.unsignedMantissa.IsEvenNumber)
                {
                    // Mantissa is odd and will have to shift a nonzero
                    // number of bits, so can't be an exact integer
                    throw new ArithmeticException("Not an exact integer");
                }
                FastInteger bigexponent = FastInteger.FromBig(this.Exponent).Negate();
                EInteger bigmantissa = this.UnsignedMantissa;
                var acc = new BitShiftAccumulator(bigmantissa, 0, 0);
                acc.ShiftRight(bigexponent);
                if (exact && (acc.LastDiscardedDigit != 0 || acc.OlderDiscardedDigits !=
                    0))
                {
                    // Some digits were discarded
                    throw new ArithmeticException("Not an exact integer");
                }
                bigmantissa = acc.ShiftedInt;
                if (this.IsNegative)
                {
                    bigmantissa = -bigmantissa;
                }
                return bigmantissa;
            }
        }

        private static EInteger PowerOfRadixBitsLowerBound(EInteger e)
        {
            return e.Abs();
        }
        private static EInteger PowerOfRadixBitsUpperBound(EInteger e)
        {
            return e.Abs().Add(1);
        }

        /// <summary>Converts this value to an arbitrary-precision integer by
        /// discarding its fractional part and checking whether the resulting
        /// integer overflows the given signed bit count.</summary>
        /// <param name='maxBitLength'>The maximum number of signed bits the
        /// integer can have. The integer's value may not be less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN), or this number's value, once converted to an
        /// integer by discarding its fractional part, is less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
        public EInteger ToSizedEInteger(int maxBitLength)
        {
            return this.ToSizedEInteger(maxBitLength, false);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// only if this number's value is an exact integer and that integer
        /// does not overflow the given signed bit count.</summary>
        /// <param name='maxBitLength'>The maximum number of signed bits the
        /// integer can have. The integer's value may not be less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN), or this number's value, once converted to an
        /// integer by discarding its fractional part, is less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        public EInteger ToSizedEIntegerIfExact(int maxBitLength)
        {
            return this.ToSizedEInteger(maxBitLength, true);
        }

        private EInteger ToSizedEInteger(int maxBitLength, bool exact)
        {
            if (maxBitLength < 0)
            {
                throw new ArgumentException("maxBitLength (" + maxBitLength +
                  ") is not greater or equal to 0");
            }
            if (!this.IsFinite || this.IsZero)
            {
                return exact ? this.ToEIntegerIfExact() : this.ToEInteger();
            }
            EInteger mant = this.Mantissa;
            EInteger exp = this.Exponent;
            if (exp.Sign > 0)
            {
                // x * 2^y
                long imantbits = mant.GetSignedBitLengthAsInt64();
                if (imantbits >= maxBitLength)
                {
                    throw new OverflowException("Value out of range");
                }
                if (exp.CompareTo(0x100000) < 0 && imantbits < 0x100000)
                {
                    // Lower bound of bit count in 2^exp based on ln(2^exp)/ln(2)
                    long expBitsLowerBound = exp.ToInt64Checked();
                    if ((imantbits - 1) + expBitsLowerBound > maxBitLength)
                    {
                        throw new OverflowException("Value out of range");
                    }
                }
                else if (exp.CompareTo(maxBitLength) > 0)
                {
                    // Digits in exp is more than max bit length, so out of range
                    throw new OverflowException("Value out of range");
                }
                else
                {
                    EInteger mantbits = mant.GetSignedBitLengthAsEInteger();
                    if (mantbits.Subtract(1).Add(PowerOfRadixBitsLowerBound(exp))
                      .CompareTo(maxBitLength) > 0)
                    {
                        throw new OverflowException("Value out of range");
                    }
                }
                mant = exact ? this.ToEIntegerIfExact() : this.ToEInteger();
            }
            else if (exp.Sign < 0)
            {
                // x * 2^-y. Check for trivial overflow cases before
                // running ToEInteger.
                exp = exp.Abs();
                long imantbits = mant.GetSignedBitLengthAsInt64();
                if (exp.CompareTo(0x100000) < 0 && imantbits < 0x100000)
                {
                    long expBitsUpperBound = exp.ToInt64Checked() + 1;
                    long expBitsLowerBound = exp.ToInt64Checked();
                    if (imantbits - 1 - expBitsUpperBound > maxBitLength)
                    {
                        throw new OverflowException("Value out of range");
                    }
                    if (imantbits + 1 < expBitsLowerBound)
                    {
                        // Less than one, so not exact
                        if (exact)
                        {
                            throw new ArithmeticException("Not an exact integer");
                        }
                        else
                        {
                            return EInteger.FromInt32(0);
                        }
                    }
                }
                else if (imantbits < 0x100000 && exp.CompareTo(0x200000) >= 0)
                {
                    // (mant / 2^exp) would be less than one, so not exact
                    if (exact)
                    {
                        throw new ArithmeticException("Not an exact integer");
                    }
                    else
                    {
                        return EInteger.FromInt32(0);
                    }
                }
                else
                {
                    EInteger mantbits = mant.GetSignedBitLengthAsEInteger();
                    if (mantbits.Subtract(1).Subtract(PowerOfRadixBitsUpperBound(exp))
                      .CompareTo(maxBitLength) > 0)
                    {
                        throw new OverflowException("Value out of range");
                    }
                }
                mant = exact ? this.ToEIntegerIfExact() : this.ToEInteger();
            }
            if (mant.GetSignedBitLengthAsEInteger().CompareTo(maxBitLength) > 0)
            {
                throw new OverflowException("Value out of range");
            }
            return mant;
        }

        private sealed class BinaryMathHelper : IRadixMathHelper<EFloat>
        {
            /// <summary>This is an internal method.</summary>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetRadix()
            {
                return 2;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision binary floating-point
            /// number.</param>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetSign(EFloat value)
            {
                return value.Sign;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision binary floating-point
            /// number.</param>
            /// <returns>An arbitrary-precision integer.</returns>
            public EInteger GetMantissa(EFloat value)
            {
                return value.unsignedMantissa.ToEInteger();
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision binary floating-point
            /// number.</param>
            /// <returns>An arbitrary-precision integer.</returns>
            public EInteger GetExponent(EFloat value)
            {
                return value.exponent.ToEInteger();
            }

            public FastInteger GetDigitLength(EInteger ei)
            {
                return FastInteger.FromBig(ei.GetUnsignedBitLengthAsEInteger());
            }

            public FastIntegerFixed GetMantissaFastInt(EFloat value)
            {
                return value.unsignedMantissa;
            }

            public FastIntegerFixed GetExponentFastInt(EFloat value)
            {
                return value.exponent;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='bigint'>An arbitrary-precision integer.</param>
            /// <param name='lastDigit'>The parameter <paramref name='lastDigit'/>
            /// is a 32-bit signed integer.</param>
            /// <param name='olderDigits'>The parameter <paramref
            /// name='olderDigits'/> is a 32-bit signed integer.</param>
            /// <returns>An IShiftAccumulator object.</returns>
            public IShiftAccumulator CreateShiftAccumulatorWithDigits(
              EInteger bigint,
              int lastDigit,
              int olderDigits)
            {
                return new BitShiftAccumulator(bigint, lastDigit, olderDigits);
            }

            public IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(
              FastIntegerFixed fastInt,
              int lastDigit,
              int olderDigits)
            {
                if (fastInt.CanFitInInt32())
                {
                    return new BitShiftAccumulator(
                        fastInt.ToInt32(),
                        lastDigit,
                        olderDigits);
                }
                else
                {
                    return new BitShiftAccumulator(
                        fastInt.ToEInteger(),
                        lastDigit,
                        olderDigits);
                }
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='num'>An arbitrary-precision integer.</param>
            /// <param name='den'>Another arbitrary-precision integer.</param>
            /// <returns>A FastInteger object.</returns>
            public FastInteger DivisionShift(EInteger num, EInteger den)
            {
                if (den.IsZero)
                {
                    return null;
                }
                if (den.GetUnsignedBit(0) && den.CompareTo(EInteger.One) != 0)
                {
                    return null;
                }
                EInteger valueELowBit = den.GetLowBitAsEInteger();
                return
                  den.GetUnsignedBitLengthAsEInteger().Equals(valueELowBit.Add(1)) ?
                  FastInteger.FromBig(valueELowBit) : null;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='bigint'>Another arbitrary-precision integer.</param>
            /// <param name='power'>A fast integer.</param>
            /// <returns>An arbitrary-precision integer.</returns>
            public EInteger MultiplyByRadixPower(
              EInteger bigint,
              FastInteger power)
            {
                EInteger tmpbigint = bigint;
                if (power.Sign <= 0)
                {
                    return tmpbigint;
                }
                if (tmpbigint.Sign < 0)
                {
                    tmpbigint = -tmpbigint;
                    tmpbigint = power.ShiftEIntegerLeftByThis(tmpbigint);
                    tmpbigint = -tmpbigint;
                    return tmpbigint;
                }
                return power.ShiftEIntegerLeftByThis(tmpbigint);
            }

            public FastIntegerFixed MultiplyByRadixPowerFastInt(
              FastIntegerFixed fbigint,
              FastIntegerFixed fpower)
            {
                if (fpower.Sign <= 0)
                {
                    return fbigint;
                }
                EInteger ei = this.MultiplyByRadixPower(
                    fbigint.ToEInteger(),
                    FastInteger.FromBig(fpower.ToEInteger()));
                return FastIntegerFixed.FromBig(ei);
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='value'>An arbitrary-precision binary floating-point
            /// number.</param>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetFlags(EFloat value)
            {
                return value.flags;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='mantissa'>The parameter <paramref name='mantissa'/> is
            /// a Numbers.EInteger object.</param>
            /// <param name='exponent'>The parameter <paramref name='exponent'/> is
            /// an internal parameter.</param>
            /// <param name='flags'>The parameter <paramref name='flags'/> is an
            /// internal parameter.</param>
            /// <returns>An arbitrary-precision binary floating-point
            /// number.</returns>
            public EFloat CreateNewWithFlags(
              EInteger mantissa,
              EInteger exponent,
              int flags)
            {
                return new EFloat(FastIntegerFixed.FromBig(mantissa),
                    FastIntegerFixed.FromBig(exponent),
                    (byte)flags);
            }

            public EFloat CreateNewWithFlagsFastInt(
              FastIntegerFixed fmantissa,
              FastIntegerFixed fexponent,
              int flags)
            {
                return new EFloat(
                    fmantissa,
                    fexponent,
                    (byte)flags);
            }

            /// <summary>This is an internal method.</summary>
            /// <returns>A 32-bit signed integer.</returns>
            public int GetArithmeticSupport()
            {
                return BigNumberFlags.FiniteAndNonFinite;
            }

            /// <summary>This is an internal method.</summary>
            /// <param name='val'>The parameter <paramref name='val'/> is a 32-bit
            /// signed integer.</param>
            /// <returns>An arbitrary-precision binary floating-point
            /// number.</returns>
            public EFloat ValueOf(int val)
            {
                return FromInt32(val);
            }
        }

        /// <summary>Returns one added to this arbitrary-precision binary
        /// floating-point number.</summary>
        /// <returns>The given arbitrary-precision binary floating-point number
        /// plus one.</returns>
        public EFloat Increment()
        {
            return this.Add(1);
        }

        /// <summary>Returns one subtracted from this arbitrary-precision
        /// binary floating-point number.</summary>
        /// <returns>The given arbitrary-precision binary floating-point number
        /// minus one.</returns>
        public EFloat Decrement()
        {
            return this.Subtract(1);
        }

        // Begin integer conversions

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255) after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a byte (from 0 to
        /// 255).</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 255.</exception>
        public byte ToByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((byte)0) :
              this.ToEInteger().ToByteChecked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a byte (from 0 to 255).</summary>
        /// <returns>This number, converted to a byte (from 0 to 255). Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public byte ToByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToByteUnchecked() : (byte)0;
        }

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255) without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a byte (from 0 to 255).</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 255.</exception>
        public byte ToByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((byte)0) : this.ToEIntegerIfExact().ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 16-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -32768 or greater than
        /// 32767.</exception>
        public short ToInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((short)0) :
              this.ToEInteger().ToInt16Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 16-bit signed integer.</summary>
        /// <returns>This number, converted to a 16-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public short ToInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt16Unchecked() : (short)0;
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 16-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -32768 or
        /// greater than 32767.</exception>
        public short ToInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((short)0) :
              this.ToEIntegerIfExact().ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromInt16(short inputInt16)
        {
            var val = (int)inputInt16;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -2147483648 or greater
        /// than 2147483647.</exception>
        public int ToInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((int)0) :
              this.ToEInteger().ToInt32Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 32-bit signed integer.</summary>
        /// <returns>This number, converted to a 32-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public int ToInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt32Unchecked() : (int)0;
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -2147483648
        /// or greater than 2147483647.</exception>
        public int ToInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((int)0) : this.ToEIntegerIfExact().ToInt32Checked();
        }

        /// <summary>Converts a boolean value (either true or false) to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>The number 1 if <paramref name='boolValue'/> is true,
        /// otherwise, 0.</returns>
        public static EFloat FromBoolean(bool boolValue)
        {
            return boolValue ? EFloat.One : EFloat.Zero;
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromInt32(int inputInt32)
        {
            if (inputInt32 >= CacheFirst && inputInt32 <= CacheLast)
            {
                return Cache[inputInt32 - CacheFirst];
            }
            if (inputInt32 == Int32.MinValue)
            {
                return FromEInteger(EInteger.FromInt32(inputInt32));
            }
            return new EFloat(
                FastIntegerFixed.FromInt32(Math.Abs(inputInt32)),
                FastIntegerFixed.Zero,
                (byte)((inputInt32 < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 64-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -9223372036854775808
        /// or greater than 9223372036854775807.</exception>
        public long ToInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0L :
              this.ToEInteger().ToInt64Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 64-bit signed integer.</summary>
        /// <returns>This number, converted to a 64-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public long ToInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt64Unchecked() : 0L;
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 64-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than
        /// -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        public long ToInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0L : this.ToEIntegerIfExact().ToInt64Checked();
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputInt64'>The number to convert as a 64-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromInt64(long inputInt64)
        {
            if (inputInt64 >= CacheFirst && inputInt64 <= CacheLast)
            {
                return Cache[(int)inputInt64 - CacheFirst];
            }
            if (inputInt64 == Int64.MinValue)
            {
                return FromEInteger(EInteger.FromInt64(inputInt64));
            }
            return new EFloat(
                FastIntegerFixed.FromInt64(Math.Abs(inputInt64)),
                FastIntegerFixed.Zero,
                (byte)((inputInt64 < 0) ? BigNumberFlags.FlagNegative : 0));
        }

        // End integer conversions
    }

    public sealed partial class EFloat
    {
        /// <summary>Converts a boolean value (true or false) to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>The number 1 if <paramref name='boolValue'/> is true;
        /// otherwise, 0.</returns>
        public static explicit operator EFloat(bool boolValue)
        {
            return FromBoolean(boolValue);
        }

        /// <summary>Creates a binary floating-point number from a 32-bit
        /// floating-point number. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the floating point number to a string
        /// first.</summary>
        /// <param name='flt'>The parameter <paramref name='flt'/> is a 32-bit
        /// binary floating-point number.</param>
        /// <returns>A binary floating-point number with the same value as
        /// <paramref name='flt'/>.</returns>
        public static implicit operator EFloat(float flt)
        {
            return FromSingle(flt);
        }

        /// <summary>Creates a binary floating-point number from a 64-bit
        /// floating-point number. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the floating point number to a string
        /// first.</summary>
        /// <param name='dbl'>The parameter <paramref name='dbl'/> is a 64-bit
        /// floating-point number.</param>
        /// <returns>A binary floating-point number with the same value as
        /// <paramref name='dbl'/>.</returns>
        public static implicit operator EFloat(double dbl)
        {
            return FromDouble(dbl);
        }

        /// <summary>Converts an arbitrary-precision integer to an arbitrary
        /// precision binary.</summary>
        /// <param name='eint'>An arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision binary floating-point number with
        /// the exponent set to 0.</returns>
        public static implicit operator EFloat(EInteger eint)
        {
            return FromEInteger(eint);
        }

        /// <summary>Adds an arbitrary-precision binary floating-point number
        /// and another arbitrary-precision binary floating-point number and
        /// returns the result.</summary>
        /// <param name='bthis'>The first arbitrary-precision binary
        /// floating-point number.</param>
        /// <param name='otherValue'>The second arbitrary-precision binary
        /// floating-point number.</param>
        /// <returns>The sum of the two numbers, that is, an
        /// arbitrary-precision binary floating-point number plus another
        /// arbitrary-precision binary floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> or <paramref name='otherValue'/> is
        /// null.</exception>
        public static EFloat operator +(EFloat bthis, EFloat otherValue)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(otherValue);
        }

        /// <summary>Subtracts one arbitrary-precision binary floating-point
        /// number from another.</summary>
        /// <param name='bthis'>The first operand.</param>
        /// <param name='subtrahend'>The second operand.</param>
        /// <returns>The difference of the two objects.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EFloat operator -(
          EFloat bthis,
          EFloat subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <summary>Adds one to an arbitrary-precision binary floating-point
        /// number.</summary>
        /// <param name='bthis'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>The number given in <paramref name='bthis'/> plus
        /// one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EFloat operator ++(EFloat bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(1);
        }

        /// <summary>Subtracts one from an arbitrary-precision binary
        /// floating-point number.</summary>
        /// <param name='bthis'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>The number given in <paramref name='bthis'/> minus
        /// one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EFloat operator --(EFloat bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(1);
        }

        /// <summary>Multiplies an arbitrary-precision binary floating-point
        /// number by another arbitrary-precision binary floating-point number
        /// and returns the result.</summary>
        /// <param name='operand1'>The first operand.</param>
        /// <param name='operand2'>The second operand.</param>
        /// <returns>The product of the two numbers, that is, an
        /// arbitrary-precision binary floating-point number times another
        /// arbitrary-precision binary floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='operand1'/> is null.</exception>
        public static EFloat operator *(
          EFloat operand1,
          EFloat operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <summary>Divides one binary floating-point number by another and
        /// returns the result. When possible, the result will be
        /// exact.</summary>
        /// <param name='dividend'>The number that will be divided by the
        /// divisor.</param>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The quotient of the two numbers. Returns infinity if the
        /// divisor is 0 and the dividend is nonzero. Returns not-a-number
        /// (NaN) if the divisor and the dividend are 0. Returns NaN if the
        /// result can't be exact because it would have a nonterminating binary
        /// expansion. If this is not desired, use DivideToExponent instead, or
        /// use the Divide overload that takes an EContext instead.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> is null.</exception>
        public static EFloat operator /(
          EFloat dividend,
          EFloat divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <summary>Returns the remainder that would result when an
        /// arbitrary-precision binary floating-point number is divided by
        /// another arbitrary-precision binary floating-point number. The
        /// remainder is the number that remains when the absolute value of an
        /// arbitrary-precision binary floating-point number is divided (as
        /// though by DivideToIntegerZeroScale) by the absolute value of the
        /// other arbitrary-precision binary floating-point number; the
        /// remainder has the same sign (positive or negative) as this
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='dividend'>The number that will be divided by the
        /// divisor.</param>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The remainder that would result when an
        /// arbitrary-precision binary floating-point number is divided by
        /// another arbitrary-precision binary floating-point number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> is null.</exception>
        public static EFloat operator %(
          EFloat dividend,
          EFloat divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor, null);
        }

        /// <summary>Gets an object with the same value as this one, but with
        /// the sign reversed.</summary>
        /// <param name='bigValue'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>The negated form of the given number. If the given number
        /// is positive zero, returns negative zero. Returns signaling NaN if
        /// this value is signaling NaN.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static EFloat operator -(EFloat bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a value to an arbitrary-precision integer. Any fractional
        /// part in this value will be discarded when converting to an
        /// arbitrary-precision integer.</summary>
        /// <param name='bigValue'>The number to convert as an
        /// arbitrary-precision binary floating-point number.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator EInteger(EFloat bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToEInteger();
        }

        /// <summary>Converts this value to its closest equivalent as a 64-bit
        /// floating-point number. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 64-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <param name='bigValue'>The value to convert to a 64-bit
        /// floating-point number.</param>
        /// <returns>The closest 64-bit floating-point number to this value.
        /// The return value can be positive infinity or negative infinity if
        /// this value exceeds the range of a 64-bit floating point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator double(EFloat bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToDouble();
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to its closest equivalent as a 32-bit floating-point number.
        /// The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN. Unfortunately, in the.NET implementation, the return value of
        /// this method may be a quiet NaN even if a signaling NaN would
        /// otherwise be generated.</para></summary>
        /// <param name='bigValue'>The number to convert as an
        /// arbitrary-precision binary floating-point number.</param>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value. The return value can be positive infinity or negative
        /// infinity if this value exceeds the range of a 32-bit floating point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator float(EFloat bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToSingle();
        }
        // Begin integer conversions

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a byte (from 0 to 255) if it can fit in a byte (from 0 to
        /// 255) after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// byte (from 0 to 255).</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 255.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToByteChecked.")]
        public static explicit operator byte(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>The value of <paramref name='inputByte'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(byte inputByte)
        {
            return EFloat.FromByte(inputByte);
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to an 8-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -128 or greater than
        /// 127.</exception>
        public sbyte ToSByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) : this.ToEInteger().ToSByteChecked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as an 8-bit signed integer.</summary>
        /// <returns>This number, converted to an 8-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public sbyte ToSByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToSByteUnchecked() : (sbyte)0;
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as an 8-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -128 or
        /// greater than 127.</exception>
        public sbyte ToSByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) :
              this.ToEIntegerIfExact().ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromSByte(sbyte inputSByte)
        {
            var val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to an 8-bit signed integer if it can fit in an 8-bit signed
        /// integer after converting it to an integer by discarding its
        /// fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to an
        /// 8-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -128 or greater than 127.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToSByteChecked.")]
        public static explicit operator sbyte(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputSByte'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(sbyte inputSByte)
        {
            return EFloat.FromSByte(inputSByte);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a 16-bit signed integer if it can fit in a 16-bit signed
        /// integer after converting it to an integer by discarding its
        /// fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 16-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -32768 or greater than 32767.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt16Checked.")]
        public static explicit operator short(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt16'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(short inputInt16)
        {
            return EFloat.FromInt16(inputInt16);
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer after converting it to
        /// an integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 65535.</exception>
        public ushort ToUInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) : this.ToEInteger().ToUInt16Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 16-bit unsigned integer.</summary>
        /// <returns>This number, converted to a 16-bit unsigned integer.
        /// Returns 0 if this value is infinity or not-a-number.</returns>
        public ushort ToUInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt16Unchecked() : (ushort)0;
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 65535.</exception>
        public ushort ToUInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) :
              this.ToEIntegerIfExact().ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a 16-bit unsigned integer if it can fit in a 16-bit
        /// unsigned integer after converting it to an integer by discarding
        /// its fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 16-bit unsigned integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 65535.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt16Checked.")]
        public static explicit operator ushort(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt16'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(ushort inputUInt16)
        {
            return EFloat.FromUInt16(inputUInt16);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a 32-bit signed integer if it can fit in a 32-bit signed
        /// integer after converting it to an integer by discarding its
        /// fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -2147483648 or greater than 2147483647.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt32Checked.")]
        public static explicit operator int(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt32'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(int inputInt32)
        {
            return EFloat.FromInt32(inputInt32);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 4294967295.</exception>
        public uint ToUInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0U : this.ToEInteger().ToUInt32Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 32-bit signed integer.</summary>
        /// <returns>This number, converted to a 32-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public uint ToUInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt32Unchecked() : 0U;
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 4294967295.</exception>
        public uint ToUInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0U :
              this.ToEIntegerIfExact().ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a 32-bit signed integer if it can fit in a 32-bit signed
        /// integer after converting it to an integer by discarding its
        /// fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 4294967295.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt32Checked.")]
        public static explicit operator uint(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputUInt32'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(uint inputUInt32)
        {
            return EFloat.FromUInt32(inputUInt32);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a 64-bit signed integer if it can fit in a 64-bit signed
        /// integer after converting it to an integer by discarding its
        /// fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 64-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt64Checked.")]
        public static explicit operator long(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt64Checked();
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// binary floating-point number.</summary>
        /// <param name='inputInt64'>The number to convert as a 64-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt64'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(long inputInt64)
        {
            return EFloat.FromInt64(inputInt64);
        }

        /// <summary>Converts this number's value to a 64-bit unsigned integer
        /// if it can fit in a 64-bit unsigned integer after converting it to
        /// an integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 18446744073709551615.</exception>
        public ulong ToUInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0UL : this.ToEInteger().ToUInt64Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 64-bit unsigned integer.</summary>
        /// <returns>This number, converted to a 64-bit unsigned integer.
        /// Returns 0 if this value is infinity or not-a-number.</returns>
        public ulong ToUInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt64Unchecked() : 0UL;
        }

        /// <summary>Converts this number's value to a 64-bit unsigned integer
        /// if it can fit in a 64-bit unsigned integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 18446744073709551615.</exception>
        public ulong ToUInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0UL :
              this.ToEIntegerIfExact().ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision binary
        /// floating-point number.</returns>
        public static EFloat FromUInt64(ulong inputUInt64)
        {
            return FromEInteger(EInteger.FromUInt64(inputUInt64));
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a 64-bit unsigned integer if it can fit in a 64-bit
        /// unsigned integer after converting it to an integer by discarding
        /// its fractional part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 64-bit unsigned integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 18446744073709551615.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt64Checked.")]
        public static explicit operator ulong(EFloat input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt64'/> as an
        /// arbitrary-precision binary floating-point number.</returns>
        public static implicit operator EFloat(ulong inputUInt64)
        {
            return EFloat.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    public static class EFloats
    {
        private const int BinaryRadix = 2;

        /// <summary>Returns the number 2, the binary radix.</summary>
        /// <param name='ec'>Specifies an arithmetic context for rounding the
        /// number 2. Can be null.</param>
        /// <returns>The number 2, or the closest representable number to 2 in
        /// the arithmetic context.</returns>
        public static EFloat Radix(EContext ec)
        {
            return EFloat.FromInt32(BinaryRadix).RoundToPrecision(ec);
        }

        /// <summary>Creates a binary floating-point number from a 32-bit
        /// signed integer.</summary>
        /// <param name='i32'>The parameter <paramref name='i32'/> is a 32-bit
        /// signed integer.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>An arbitrary-precision binary floating-point number with
        /// the closest representable value to the given integer.</returns>
        public static EFloat Int32ToEFloat(int i32, EContext ec)
        {
            // NOTE: Not a miscellaneous operation in the General Decimal
            // Arithmetic Specification 1.70, but required since some of the
            // miscellaneous operations here return integers
            return EFloat.FromInt32(i32).RoundToPrecision(ec);
        }

        /// <summary>Converts a boolean value (either true or false) to an
        /// arbitrary-precision binary floating-point number.</summary>
        /// <param name='b'>Either true or false.</param>
        /// <param name='ec'>A context used for rounding the result. Can be
        /// null.</param>
        /// <returns>Either 1 if <paramref name='b'/> is true, or 0 if
        /// <paramref name='b'/> is false.. The result will be rounded as
        /// specified by the given context, if any.</returns>
        public static EFloat BooleanToEFloat(bool b, EContext ec)
        {
            // NOTE: Not a miscellaneous operation in the General Decimal
            // Arithmetic Specification 1.70, but required since some of the
            // miscellaneous operations here return booleans
            return EFloat.FromInt32(b ? 1 : 0).RoundToPrecision(ec);
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is in a canonical form. For the current version of EFloat,
        /// all EFloat objects are in a canonical form.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Always <c>true</c>.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA1801",
          Justification = "Parameter 'ed' is deliberately unused.")]
        public static bool IsCanonical(EFloat ed)
        {
            // Deliberately unused because all objects are in a canonical
            // form regardless of their value. Removing the parameter
            // or renaming it to be a "discard" parameter would be a
            // breaking change, though.
            return true;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is neither null nor infinity nor not-a-number
        /// (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> if the given arbitrary-precision number
        /// object is neither null nor infinity nor not-a-number (NaN), or
        /// <c>false</c> otherwise.</returns>
        public static bool IsFinite(EFloat ed)
        {
            return ed != null && ed.IsFinite;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is positive or negative infinity.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> if the given arbitrary-precision number
        /// object is positive or negative infinity, or <c>false</c>
        /// otherwise.</returns>
        public static bool IsInfinite(EFloat ed)
        {
            return ed != null && ed.IsInfinity();
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is a not-a-number (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsNaN(EFloat ed)
        {
            return ed != null && ed.IsNaN();
        }

        /// <summary>Returns whether the given number is a
        /// <i>normal</i> number. A
        /// <i>subnormal number</i> is a nonzero finite number whose Exponent
        /// property (or the number's exponent when that number is expressed in
        /// scientific notation with one digit before the radix point) is less
        /// than the minimum possible exponent for that number. A
        /// <i>normal number</i> is nonzero and finite, but not
        /// subnormal.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <param name='ec'>A context specifying the exponent range of
        /// arbitrary-precision numbers. Can be null. If AdjustExponent of the
        /// given context is <c>true</c>, a nonzero number is normal if the
        /// number's exponent (when that number is expressed in scientific
        /// notation with one nonzero digit before the radix point) is at least
        /// the given context's EMax property (e.g., if EMax is -100, 2.3456 *
        /// 10
        /// <sup>-99</sup> is normal, but 2.3456 * 10
        /// <sup>-102</sup> is not). If AdjustExponent of the given context is
        /// <c>false</c>, a nonzero number is subnormal if the number's
        /// Exponent property is at least given context's EMax property (e.g.,
        /// if EMax is -100, 23456 * 10
        /// <sup>-99</sup> is normal, but 23456 * 10
        /// <sup>-102</sup> is not).</param>
        /// <returns>Either <c>true</c> if the given number is subnormal, or
        /// <c>false</c> otherwise. Returns <c>true</c> if the given context is
        /// null or HasExponentRange of the given context is <c>false</c>.</returns>
        public static bool IsNormal(EFloat ed, EContext ec)
        {
            return ed != null && ed.IsFinite && !ed.IsZero && !IsSubnormal(ed, ec);
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is a quiet not-a-number (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsQuietNaN(EFloat ed)
        {
            return ed != null && ed.IsQuietNaN();
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is negative (including negative infinity, negative
        /// not-a-number [NaN], or negative zero).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsSigned(EFloat ed)
        {
            return ed != null && ed.IsNegative;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is a signaling not-a-number (NaN).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public static bool IsSignalingNaN(EFloat ed)
        {
            return ed != null && ed.IsSignalingNaN();
        }

        /// <summary>Converts a number class identifier (ranging from 0 through
        /// 9) to a text string. An arbitrary-precision number object can
        /// belong in one of ten number classes.</summary>
        /// <param name='nc'>An integer identifying a number class.</param>
        /// <returns>A text string identifying the given number class as
        /// follows: 0 = "+Normal"; 1 = "-Normal", 2 = "+Subnormal", 3 =
        /// "-Subnormal", 4 = "+Zero", 5 = "-Zero", 6 = "+Infinity", 7 =
        /// "-Infinity", 8 = "NaN", 9 = "sNaN".</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='nc'/> is less than 0 or greater than 9.</exception>
        public static string NumberClassString(int nc)
        {
            return EDecimals.NumberClassString(nc);
        }

        /// <summary>Finds the number class for an arbitrary-precision binary
        /// number object.</summary>
        /// <param name='ed'>An arbitrary-precision binary number
        /// object.</param>
        /// <param name='ec'>A context object that specifies the precision and
        /// exponent range of arbitrary-precision numbers. This is used only to
        /// distinguish between normal and subnormal numbers. Can be
        /// null.</param>
        /// <returns>A 32-bit signed integer identifying the given number
        /// object, number class as follows: 0 = positive normal; 1 = negative
        /// normal, 2 = positive subnormal, 3 = negative subnormal, 4 =
        /// positive zero, 5 = negative zero, 6 = positive infinity, 7 =
        /// negative infinity, 8 = quiet not-a-number (NaN), 9 = signaling
        /// NaN.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static int NumberClass(EFloat ed, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsQuietNaN())
            {
                return 8;
            }
            if (ed.IsNaN())
            {
                return 9;
            }
            if (ed.IsInfinity())
            {
                return ed.IsNegative ? 7 : 6;
            }
            if (ed.IsZero)
            {
                return ed.IsNegative ? 5 : 4;
            }
            return IsSubnormal(ed, ec) ? (ed.IsNegative ? 3 : 2) :
              (ed.IsNegative ? 1 : 0);
        }

        /// <summary>Returns whether the given number is a
        /// <i>subnormal</i> number. A
        /// <i>subnormal number</i> is a nonzero finite number whose Exponent
        /// property (or the number's exponent when that number is expressed in
        /// scientific notation with one digit before the radix point) is less
        /// than the minimum possible exponent for that number.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <param name='ec'>A context specifying the exponent range of
        /// arbitrary-precision numbers. Can be null. If AdjustExponent of the
        /// given context is <c>true</c>, a nonzero number is subnormal if the
        /// number's exponent (when that number is expressed in scientific
        /// notation with one nonzero digit before the radix point) is less
        /// than the given context's EMax property (e.g., if EMax is -100,
        /// 2.3456 * 10
        /// <sup>-102</sup> is subnormal, but 2.3456 * 10
        /// <sup>-99</sup> is not). If AdjustExponent of the given context is
        /// <c>false</c>, a nonzero number is subnormal if the number's
        /// Exponent property is less than the given context's EMax property
        /// (e.g., if EMax is -100, 23456 * 10
        /// <sup>-102</sup> is subnormal, but 23456 * 10
        /// <sup>-99</sup> is not).</param>
        /// <returns>Either <c>true</c> if the given number is subnormal, or
        /// <c>false</c> otherwise. Returns <c>false</c> if the given context
        /// is null or HasExponentRange of the given context is <c>false</c>.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static bool IsSubnormal(EFloat ed, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsFinite && ec != null && !ed.IsZero && ec.HasExponentRange)
            {
                if (ec.AdjustExponent)
                {
                    return ed.Exponent.Add(ed.Precision().Subtract(1)).CompareTo(
                        ec.EMin) < 0;
                }
                else
                {
                    return ed.Exponent.CompareTo(ec.EMin) < 0;
                }
            }
            return false;
        }

        /// <summary>Returns whether the given arbitrary-precision number
        /// object is zero (positive zero or negative zero).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns><c>true</c> if the given number has a value of zero
        /// (positive zero or negative zero); otherwise, <c>false</c>.</returns>
        public static bool IsZero(EFloat ed)
        {
            return ed != null && ed.IsZero;
        }

        /// <summary>Returns the base-2 exponent of an arbitrary-precision
        /// binary number (when that number is expressed in scientific notation
        /// with one nonzero digit before the radix point). For example,
        /// returns 3 for the numbers <c>1.11b * 2^3</c> and <c>111 * 2^1</c>.</summary>
        /// <param name='ed'>An arbitrary-precision binary number.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>The base-2 exponent of the given number (when that number
        /// is expressed in scientific notation with one nonzero digit before
        /// the radix point). Signals DivideByZero and returns negative
        /// infinity if <paramref name='ed'/> is zero. Returns positive
        /// infinity if <paramref name='ed'/> is positive infinity or negative
        /// infinity.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EFloat LogB(EFloat ed, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsNaN())
            {
                return ed.RoundToPrecision(ec);
            }
            if (ed.IsInfinity())
            {
                return EFloat.PositiveInfinity;
            }
            if (ed.IsZero)
            {
                return EFloat.FromInt32(-1).Divide(EFloat.Zero, ec);
            }
            EInteger ei = ed.Exponent.Add(ed.Precision().Subtract(1));
            return EFloat.FromEInteger(ei).RoundToPrecision(ec);
        }

        /// <summary>Finds an arbitrary-precision binary number whose binary
        /// point is moved a given number of places.</summary>
        /// <param name='ed'>An arbitrary-precision binary number.</param>
        /// <param name='ed2'>The number of binary places to move the binary
        /// point of "ed". This must be an integer with an exponent of
        /// 0.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>The given arbitrary-precision binary number whose binary
        /// point is moved the given number of places. Signals an invalid
        /// operation and returns not-a-number (NaN) if <paramref name='ed2'/>
        /// is infinity or NaN, has an Exponent property other than 0. Signals
        /// an invalid operation and returns not-a-number (NaN) if <paramref
        /// name='ec'/> defines a limited precision and exponent range and if
        /// <paramref name='ed2'/> 's absolute value is greater than twice the
        /// sum of the context's EMax property and its Precision
        /// property.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> or <paramref name='ed2'/> is null.</exception>
        public static EFloat ScaleB(EFloat ed, EFloat ed2, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed2 == null)
            {
                throw new ArgumentNullException(nameof(ed2));
            }
            if (ed.IsNaN() || ed2.IsNaN())
            {
                return ed.Add(ed2, ec);
            }
            if (!ed2.IsFinite || ed2.Exponent.Sign != 0)
            {
                return InvalidOperation(ec);
            }
            EInteger scale = ed2.Mantissa;
            if (ec != null && ec.HasMaxPrecision && ec.HasExponentRange)
            {
                EInteger exp = ec.EMax.Add(ec.Precision).Multiply(2);
                if (scale.Abs().CompareTo(exp.Abs()) > 0)
                {
                    return InvalidOperation(ec);
                }
            }
            if (ed.IsInfinity())
            {
                return ed;
            }
            if (scale.IsZero)
            {
                return ed.RoundToPrecision(ec);
            }
            EFloat ret = EFloat.Create(
                ed.UnsignedMantissa,
                ed.Exponent.Add(scale));
            if (ed.IsNegative)
            {
                ret = ret.Negate();
            }
            return ret.RoundToPrecision(ec);
        }

        /// <summary>Shifts the bits of an arbitrary-precision binary floating
        /// point number's significand.</summary>
        /// <param name='ed'>An arbitrary-precision binary floating point
        /// number containing the significand to shift.</param>
        /// <param name='ed2'>An arbitrary-precision number indicating the
        /// number of bits to shift the first operand's significand. Must be an
        /// integer with an exponent of 0. If this parameter is positive, the
        /// significand is shifted to the left by the given number of bits. If
        /// this parameter is negative, the significand is shifted to the right
        /// by the given number of bits.</param>
        /// <param name='ec'>An arithmetic context to control the precision of
        /// arbitrary-precision numbers. Can be null.</param>
        /// <returns>An arbitrary-precision binary number whose significand is
        /// shifted the given number of bits. Signals an invalid operation and
        /// returns NaN (not-a-number) if <paramref name='ed2'/> is a signaling
        /// NaN or if <paramref name='ed2'/> is not an integer, is negative,
        /// has an exponent other than 0, or has an absolute value that exceeds
        /// the maximum precision specified in the context.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> or <paramref name='ed2'/> is null.</exception>
        public static EFloat Shift(EFloat ed, EFloat ed2, EContext ec)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed2 == null)
            {
                throw new ArgumentNullException(nameof(ed2));
            }
            if (ed.IsNaN() || ed2.IsNaN())
            {
                return ed.Add(ed2, ec);
            }
            if (!ed2.IsFinite || ed2.Exponent.Sign != 0)
            {
                return InvalidOperation(ec);
            }
            EInteger shift = ed2.Mantissa;
            if (ec != null)
            {
                if (shift.Abs().CompareTo(ec.Precision) > 0)
                {
                    return InvalidOperation(ec);
                }
            }
            if (ed.IsInfinity())
            {
                // NOTE: Must check for validity of second
                // parameter first, before checking if first
                // parameter is infinity here
                return ed;
            }
            EInteger mant = ed.UnsignedMantissa;
            if (mant.IsZero)
            {
                return ed.RoundToPrecision(ec);
            }
            EInteger mantprec = ed.Precision();
            if (shift.Sign < 0)
            {
                if (shift.Abs().CompareTo(mantprec) < 0)
                {
                    EInteger divisor = EInteger.One.ShiftLeft(shift.Abs());
                    mant = mant.Divide(divisor);
                }
                else
                {
                    mant = EInteger.Zero;
                }
                EFloat ret = EFloat.Create(mant, ed.Exponent);
                return ed.IsNegative ? ret.Negate() : ret;
            }
            else
            {
                EInteger mult = EInteger.One.ShiftLeft(shift);
                mant = mant.Multiply(mult);
                if (ec != null && ec.HasMaxPrecision)
                {
                    EInteger mod = EInteger.One.ShiftLeft(ec.Precision);
                    mant = mant.Remainder(mod);
                }
                EFloat ret = EFloat.Create(mant, ed.Exponent);
                return ed.IsNegative ? ret.Negate() : ret;
            }
        }

        /// <summary>Rotates the bits of an arbitrary-precision binary number's
        /// significand.</summary>
        /// <param name='ed'>An arbitrary-precision number containing the
        /// significand to rotate. If this significand contains more bits than
        /// the precision, the most-significant bits are chopped off the
        /// significand.</param>
        /// <param name='ed2'>An arbitrary-precision number indicating the
        /// number of bits to rotate the first operand's significand. Must be
        /// an integer with an exponent of 0. If this parameter is positive,
        /// the significand is shifted to the left by the given number of bits
        /// and the most-significant bits shifted out of the significand become
        /// the least-significant bits instead. If this parameter is negative,
        /// the number is shifted by the given number of bits and the
        /// least-significant bits shifted out of the significand become the
        /// most-significant bits instead.</param>
        /// <param name='ec'>An arithmetic context to control the precision of
        /// arbitrary-precision numbers. If this parameter is null or specifies
        /// an unlimited precision, this method has the same behavior as
        /// <c>Shift</c>.</param>
        /// <returns>An arbitrary-precision binary number whose significand is
        /// rotated the given number of bits. Signals an invalid operation and
        /// returns NaN (not-a-number) if <paramref name='ed2'/> is a signaling
        /// NaN or if <paramref name='ed2'/> is not an integer, is negative,
        /// has an exponent other than 0, or has an absolute value that exceeds
        /// the maximum precision specified in the context.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed2'/> or <paramref name='ed'/> is null.</exception>
        public static EFloat Rotate(EFloat ed, EFloat ed2, EContext ec)
        {
            if (ec == null || !ec.HasMaxPrecision)
            {
                return Shift(ed, ed2, ec);
            }
            if (ed2 == null)
            {
                throw new ArgumentNullException(nameof(ed2));
            }
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (ed.IsNaN() || ed2.IsNaN())
            {
                return ed.Add(ed2, ec);
            }
            if (!ed2.IsFinite || ed2.Exponent.Sign != 0)
            {
                return InvalidOperation(ec);
            }
            EInteger shift = ed2.Mantissa;
            if (shift.Abs().CompareTo(ec.Precision) > 0)
            {
                return InvalidOperation(ec);
            }
            if (ed.IsInfinity())
            {
                // NOTE: Must check for validity of second
                // parameter first, before checking if first
                // parameter is infinity here
                return ed;
            }
            EInteger mant = ed.UnsignedMantissa;
            EInteger mantprec = ed.Precision();
            if (ec != null && ec.HasMaxPrecision && mantprec.CompareTo(
        ec.Precision) > 0)
            {
                mant = mant.Remainder(EInteger.One.ShiftLeft(ec.Precision));
                mantprec = ec.Precision;
            }
            if (mant.IsZero)
            {
                return ed.RoundToPrecision(ec);
            }
            EInteger rightShift = shift.Sign < 0 ? shift.Abs() :
              ec.Precision.Subtract(shift);
            EInteger leftShift = ec.Precision.Subtract(rightShift);
            EInteger mantRight = EInteger.Zero;
            EInteger mantLeft = EInteger.Zero;
            // Right shift
            if (rightShift.CompareTo(mantprec) < 0)
            {
                EInteger divisor = EInteger.One.ShiftLeft(rightShift);
                mantRight = mant.Divide(divisor);
            }
            else
            {
                mantRight = EInteger.Zero;
            }
            // Left shift
            if (leftShift.IsZero)
            {
                mantLeft = mant;
            }
            else if (leftShift.CompareTo(ec.Precision) == 0)
            {
                mantLeft = EInteger.Zero;
            }
            else
            {
                EInteger mult = EInteger.One.ShiftLeft(leftShift);
                mantLeft = mant.Multiply(mult);
                EInteger mod = EInteger.One.ShiftLeft(ec.Precision);
                mantLeft = mantLeft.Remainder(mod);
            }
            EFloat ret = EFloat.Create(mantRight.Add(mantLeft), ed.Exponent);
            return ed.IsNegative ? ret.Negate() : ret;
        }

        /// <summary>Compares the values of one arbitrary-precision number
        /// object and another object, imposing a total ordering on all
        /// possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='ed'>The first arbitrary-precision number to
        /// compare.</param>
        /// <param name='other'>The second arbitrary-precision number to
        /// compare.</param>
        /// <param name='ec'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects are null or equal, or -1 if
        /// the first object is null or less than the other object, or 1 if the
        /// first object is greater or the other object is null. Does not
        /// signal flags if either value is signaling NaN.</returns>
        public static int CompareTotal(EFloat ed, EFloat other, EContext ec)
        {
            return (ed == null) ? (other == null ? 0 : -1) : ((other == null) ? 1 :
                ed.CompareToTotal(other, ec));
        }

        /// <summary>Compares the absolute values of two arbitrary-precision
        /// number objects, imposing a total ordering on all possible values
        /// (ignoring their signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// exponent has a greater "absolute value".</item>
        /// <item>Negative zero and positive zero are considered equal.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item></list></summary>
        /// <param name='ed'>The first arbitrary-precision number to
        /// compare.</param>
        /// <param name='other'>The second arbitrary-precision number to
        /// compare.</param>
        /// <param name='ec'>An arithmetic context. Flags will be set in this
        /// context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
        /// context are true and only if an operand needed to be rounded before
        /// carrying out the operation. Can be null.</param>
        /// <returns>The number 0 if both objects are null or equal (ignoring
        /// their signs), or -1 if the first object is null or less than the
        /// other object (ignoring their signs), or 1 if the first object is
        /// greater (ignoring their signs) or the other object is null. Does
        /// not signal flags if either value is signaling NaN.</returns>
        public static int CompareTotalMagnitude(
          EFloat ed,
          EFloat other,
          EContext ec)
        {
            return (ed == null) ? (other == null ? 0 : -1) : ((other == null) ? 1 :
                ed.CompareToTotalMagnitude(other, ec));
        }

        /// <summary>Creates a copy of the given arbitrary-precision number
        /// object.</summary>
        /// <param name='ed'>An arbitrary-precision number object to
        /// copy.</param>
        /// <returns>A copy of the given arbitrary-precision number
        /// object.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EFloat Copy(EFloat ed)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            return ed.Copy();
        }

        /// <summary>Returns a canonical version of the given
        /// arbitrary-precision number object. In this method, this method
        /// behaves like the Copy method.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>A copy of the parameter <paramref name='ed'/>.</returns>
        public static EFloat Canonical(EFloat ed)
        {
            return Copy(ed);
        }

        /// <summary>Returns an arbitrary-precision number object with the same
        /// value as the given number object but with a nonnegative sign (that
        /// is, the given number object's absolute value).</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>An arbitrary-precision number object with the same value
        /// as the given number object but with a nonnegative sign.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EFloat CopyAbs(EFloat ed)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            return Copy(ed.Abs());
        }

        /// <summary>Returns an arbitrary-precision number object with the sign
        /// reversed from the given number object.</summary>
        /// <param name='ed'>An arbitrary-precision number object.</param>
        /// <returns>An arbitrary-precision number object with the sign
        /// reversed from the given number object.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> is null.</exception>
        public static EFloat CopyNegate(EFloat ed)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            return Copy(ed.Negate());
        }

        /// <summary>Returns an arbitrary-precision number object with the same
        /// value as the first given number object but with a the same sign
        /// (positive or negative) as the second given number object.</summary>
        /// <param name='ed'>An arbitrary-precision number object with the
        /// value the result will have.</param>
        /// <param name='other'>The parameter <paramref name='other'/> is an
        /// arbitrary-precision binary floating-point number.</param>
        /// <returns>An arbitrary-precision number object with the same value
        /// as the first given number object but with a the same sign (positive
        /// or negative) as the second given number object.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ed'/> or <paramref name='other'/> is null.</exception>
        public static EFloat CopySign(EFloat ed, EFloat other)
        {
            if (ed == null)
            {
                throw new ArgumentNullException(nameof(ed));
            }
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            return ed.IsNegative == other.IsNegative ? Copy(ed) : CopyNegate(ed);
        }

        private static EFloat InvalidOperation(EContext ec)
        {
            return EFloat.SignalingNaN.Plus(ec);
        }

        /// <summary>Returns whether two arbitrary-precision numbers have the
        /// same exponent, they both are not-a-number (NaN), or they both are
        /// infinity (positive and/or negative).</summary>
        /// <param name='ed1'>The first arbitrary-precision number.</param>
        /// <param name='ed2'>The second arbitrary-precision number.</param>
        /// <returns>Either <c>true</c> if the given arbitrary-precision
        /// numbers have the same exponent, they both are not-a-number (NaN),
        /// or they both are infinity (positive and/or negative); otherwise,
        /// <c>false</c>.</returns>
        public static bool SameQuantum(EFloat ed1, EFloat ed2)
        {
            if (ed1 == null || ed2 == null)
            {
                return false;
            }
            if (ed1.IsFinite && ed2.IsFinite)
            {
                return ed1.Exponent.Equals(ed2.Exponent);
            }
            else
            {
                return (ed1.IsNaN() && ed2.IsNaN()) || (ed1.IsInfinity() &&
                    ed2.IsInfinity());
            }
        }

        /// <summary>Returns an arbitrary-precision number with the same value
        /// as this one but with certain trailing zeros removed from its
        /// significand. If the number's exponent is 0, it is returned
        /// unchanged (but may be rounded depending on the arithmetic context);
        /// if that exponent is greater 0, its trailing zeros are removed from
        /// the significand (then rounded if necessary); if that exponent is
        /// less than 0, its trailing zeros are removed from the significand
        /// until the exponent reaches 0 (then the number is rounded if
        /// necessary).</summary>
        /// <param name='ed1'>An arbitrary-precision number.</param>
        /// <param name='ec'>An arithmetic context to control the precision,
        /// rounding, and exponent range of the result. Can be null.</param>
        /// <returns>An arbitrary-precision number with the same value as this
        /// one but with certain trailing zeros removed from its significand.
        /// If <paramref name='ed1'/> is not-a-number (NaN) or infinity, it is
        /// generally returned unchanged.</returns>
        public static EFloat Trim(EFloat ed1, EContext ec)
        {
            EFloat ed = ed1;
            if (ed1 == null)
            {
                return InvalidOperation(ec);
            }
            if (ed.IsSignalingNaN())
            {
                return EFloat.CreateNaN(
                  ed.UnsignedMantissa,
                  true,
                  ed.IsNegative,
                  ec);
            }
            if (ed.IsFinite)
            {
                if (ed.IsZero)
                {
                    return (ed.IsNegative ? EFloat.NegativeZero :
                        EFloat.Zero).RoundToPrecision(ec);
                }
                else if (ed.Exponent.Sign > 0)
                {
                    return ed.Reduce(ec);
                }
                else if (ed.Exponent.Sign == 0)
                {
                    return ed.RoundToPrecision(ec);
                }
                else
                {
                    EInteger exp = ed.Exponent;
                    EInteger mant = ed.UnsignedMantissa;
                    bool neg = ed.IsNegative;
                    var trimmed = false;
                    EInteger radixint = EInteger.FromInt32(BinaryRadix);
                    while (exp.Sign < 0 && mant.Sign > 0)
                    {
                        EInteger[] divrem = mant.DivRem(radixint);
                        int rem = divrem[1].ToInt32Checked();
                        if (rem != 0)
                        {
                            break;
                        }
                        mant = divrem[0];
                        exp = exp.Add(1);
                        trimmed = true;
                    }
                    if (!trimmed)
                    {
                        return ed.RoundToPrecision(ec);
                    }
                    EFloat ret = EFloat.Create(mant, exp);
                    if (neg)
                    {
                        ret = ret.Negate();
                    }
                    return ret.RoundToPrecision(ec);
                }
            }
            else
            {
                return ed1.Plus(ec);
            }
        }

        /// <summary>Returns an arbitrary-precision binary number with the same
        /// value as this object but with the given exponent, expressed as an
        /// arbitrary-precision binary number.
        /// <para>Note that this is not always the same as rounding to a given
        /// number of binary places, since it can fail if the difference
        /// between this value's exponent and the desired exponent is too big,
        /// depending on the maximum precision. If rounding to a number of
        /// binary places is desired, it's better to use the RoundToExponent
        /// and RoundToIntegral methods instead.</para>
        /// <para><b>Remark:</b> This method can be used to implement
        /// fixed-point binary arithmetic, in which a fixed number of digits
        /// come after the binary point. A fixed-point binary arithmetic in
        /// which no digits come after the binary point (a desired exponent of
        /// 0) is considered an "integer arithmetic" .</para></summary>
        /// <param name='ed'>An arbitrary-precision binary number whose
        /// exponent is to be changed.</param>
        /// <param name='scale'>The desired exponent of the result, expressed
        /// as an arbitrary-precision binary number. The exponent is the number
        /// of fractional digits in the result, expressed as a negative number.
        /// Can also be positive, which eliminates lower-order places from the
        /// number. For example, -3 means round to the sixteenth (10b^-3,
        /// 0.0001b), and 3 means round to the sixteens-place (10b^3, 1000b). A
        /// value of 0 rounds the number to an integer.</param>
        /// <param name='ec'>An arithmetic context to control precision and
        /// rounding of the result. If <c>HasFlags</c> of the context is true,
        /// will also store the flags resulting from the operation (the flags
        /// are in addition to the pre-existing flags). Can be null, in which
        /// case the default rounding mode is HalfEven.</param>
        /// <returns>An arbitrary-precision binary number with the same value
        /// as this object but with the exponent changed. Signals FlagInvalid
        /// and returns not-a-number (NaN) if the result can't fit the given
        /// precision without rounding, or if the arithmetic context defines an
        /// exponent range and the given exponent is outside that
        /// range.</returns>
        public static EFloat Rescale(EFloat ed, EFloat scale, EContext ec)
        {
            if (ed == null || scale == null)
            {
                return InvalidOperation(ec);
            }
            if (!scale.IsFinite)
            {
                return ed.Quantize(scale, ec);
            }
            if (scale.Exponent.IsZero)
            {
                return ed.Quantize(EFloat.Create(EInteger.One, scale.Mantissa), ec);
            }
            else
            {
                EContext tec = ec == null ? null : ec.WithTraps(0).WithBlankFlags();
                EFloat rv = scale.RoundToExponentExact(0, tec);
                if (!rv.IsFinite || (tec.Flags & EContext.FlagInexact) != 0)
                {
                    if (ec != null && ec.IsSimplified)
                    {
                        // In simplified arithmetic, round scale to trigger
                        // appropriate error conditions
                        scale = scale.RoundToPrecision(ec);
                    }
                    return InvalidOperation(ec);
                }
                EFloat rounded = scale.Quantize(0, tec);
                return ed.Quantize(
                    EFloat.Create(EInteger.One, rounded.Mantissa),
                    ec);
            }
        }

        // Logical Operations

        /// <summary>Performs a logical AND operation on two binary numbers in
        /// the form of
        /// <i>logical operands</i>. A <c>logical operand</c> is a
        /// non-negative base-2 number with an Exponent property of 0 (examples
        /// include the base-2 numbers <c>01001</c> and <c>111001</c> ). The
        /// logical AND operation sets each bit of the result to 1 if the
        /// corresponding bits of each logical operand are both 1, and to 0
        /// otherwise. For example, <c>01001 AND 111010=01000</c>.</summary>
        /// <param name='ed1'>The first logical operand to the logical AND
        /// operation.</param>
        /// <param name='ed2'>The second logical operand to the logical AND
        /// operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more bits than the maximum precision
        /// specified in this context, the operand's most significant bits that
        /// exceed that precision are discarded. This parameter can be
        /// null.</param>
        /// <returns>The result of the logical AND operation as a logical
        /// operand. Signals an invalid operation and returns not-a-number
        /// (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
        /// are not logical operands.</returns>
        public static EFloat And(EFloat ed1, EFloat ed2, EContext ec)
        {
            byte[] logi1 = EDecimals.FromLogical(ed1, ec, 2);
            if (logi1 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] logi2 = EDecimals.FromLogical(ed2, ec, 2);
            if (logi2 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = logi1.Length < logi2.Length ? logi1 : logi2;
            byte[] bigger = logi1.Length < logi2.Length ? logi2 : logi1;
            for (var i = 0; i < smaller.Length; ++i)
            {
                smaller[i] &= bigger[i];
            }
            return EFloat.FromEInteger(
                EDecimals.ToLogical(
                  smaller,
                  2)).RoundToPrecision(ec);
        }

        /// <summary>Performs a logical NOT operation on a binary number in the
        /// form of a
        /// <i>logical operand</i>. A <c>logical operand</c> is a non-negative
        /// base-2 number with an Exponent property of 0 (examples include
        /// <c>01001</c> and <c>111001</c> ). The logical NOT operation sets
        /// each bit of the result to 1 if the corresponding bit is 0, and to 0
        /// otherwise; it can set no more bits than the maximum precision,
        /// however. For example, if the maximum precision is 8 bits, then
        /// <c>NOT 111010=11000101</c>.</summary>
        /// <param name='ed1'>The operand to the logical NOT operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more bits than the maximum precision
        /// specified in this context, the operand's most significant bits that
        /// exceed that precision are discarded. This parameter cannot be null
        /// and must specify a maximum precision (unlimited precision contexts
        /// are not allowed).</param>
        /// <returns>The result of the logical NOT operation as a logical
        /// operand. Signals an invalid operation and returns not-a-number
        /// (NaN) if <paramref name='ed1'/> is not a logical operand.</returns>
        public static EFloat Invert(EFloat ed1, EContext ec)
        {
            if (ec == null || !ec.HasMaxPrecision)
            {
                return InvalidOperation(ec);
            }
            EInteger ei = EInteger.One.ShiftLeft(ec.Precision).Subtract(1);
            byte[] smaller = EDecimals.FromLogical(ed1, ec, 2);
            if (smaller == null)
            {
                return InvalidOperation(ec);
            }
            byte[] bigger = ei.ToBytes(true);
#if DEBUG
            if (smaller.Length > bigger.Length)
            {
                throw new ArgumentException("smaller.Length(" + smaller.Length +
                  ") is not less or equal to " + bigger.Length);
            }
#endif

            for (var i = 0; i < smaller.Length; ++i)
            {
                bigger[i] ^= smaller[i];
            }
            return EFloat.FromEInteger(
                EDecimals.ToLogical(
                  bigger,
                  2)).RoundToPrecision(ec);
        }

        /// <summary>Performs a logical exclusive-OR (XOR) operation on two
        /// binary numbers in the form of
        /// <i>logical operands</i>. A <c>logical operand</c> is a
        /// non-negative base-2 number with an Exponent property of 0 (examples
        /// include the base-2 numbers <c>01001</c> and <c>111001</c> ). The
        /// logical exclusive-OR operation sets each digit of the result to 1
        /// if either corresponding digit of the logical operands, but not
        /// both, is 1, and to 0 otherwise. For example, <c>01001 XOR 111010 =
        /// 101010</c>.</summary>
        /// <param name='ed1'>The first logical operand to the logical
        /// exclusive-OR operation.</param>
        /// <param name='ed2'>The second logical operand to the logical
        /// exclusive-OR operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more bits than the maximum precision
        /// specified in this context, the operand's most significant bits that
        /// exceed that precision are discarded. This parameter can be
        /// null.</param>
        /// <returns>The result of the logical exclusive-OR operation as a
        /// logical operand. Signals an invalid operation and returns
        /// not-a-number (NaN) if <paramref name='ed1'/>, <paramref
        /// name='ed2'/>, or both are not logical operands.</returns>
        public static EFloat Xor(EFloat ed1, EFloat ed2, EContext ec)
        {
            byte[] logi1 = EDecimals.FromLogical(ed1, ec, 2);
            if (logi1 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] logi2 = EDecimals.FromLogical(ed2, ec, 2);
            if (logi2 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = logi1.Length < logi2.Length ? logi1 : logi2;
            byte[] bigger = logi1.Length < logi2.Length ? logi2 : logi1;
            for (var i = 0; i < smaller.Length; ++i)
            {
                bigger[i] ^= smaller[i];
            }
            return EFloat.FromEInteger(
                EDecimals.ToLogical(
                  bigger,
                  2)).RoundToPrecision(ec);
        }

        /// <summary>Performs a logical OR operation on two binary numbers in
        /// the form of
        /// <i>logical operands</i>. A <c>logical operand</c> is a
        /// non-negative base-2 number with an Exponent property of 0 (examples
        /// include the base-2 numbers <c>01001</c> and <c>111001</c> ). The
        /// logical OR operation sets each bit of the result to 1 if either or
        /// both of the corresponding bits of each logical operand are 1, and
        /// to 0 otherwise. For example, <c>01001 OR 111010=111011</c>.</summary>
        /// <param name='ed1'>The first logical operand to the logical OR
        /// operation.</param>
        /// <param name='ed2'>The second logical operand to the logical OR
        /// operation.</param>
        /// <param name='ec'>An arithmetic context to control the maximum
        /// precision of arbitrary-precision numbers. If a logical operand
        /// passed to this method has more bits than the maximum precision
        /// specified in this context, the operand's most significant bits that
        /// exceed that precision are discarded. This parameter can be
        /// null.</param>
        /// <returns>The result of the logical OR operation as a logical
        /// operand. Signals an invalid operation and returns not-a-number
        /// (NaN) if <paramref name='ed1'/>, <paramref name='ed2'/>, or both
        /// are not logical operands.</returns>
        public static EFloat Or(EFloat ed1, EFloat ed2, EContext ec)
        {
            byte[] logi1 = EDecimals.FromLogical(ed1, ec, 2);
            if (logi1 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] logi2 = EDecimals.FromLogical(ed2, ec, 2);
            if (logi2 == null)
            {
                return InvalidOperation(ec);
            }
            byte[] smaller = logi1.Length < logi2.Length ? logi1 : logi2;
            byte[] bigger = logi1.Length < logi2.Length ? logi2 : logi1;
            for (var i = 0; i < smaller.Length; ++i)
            {
                bigger[i] |= smaller[i];
            }
            return EFloat.FromEInteger(
                EDecimals.ToLogical(
                  bigger,
                  2)).RoundToPrecision(ec);
        }
    }

    internal static class EFloatByteArrayString
    {
        internal static EFloat FromString(
          byte[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (offset < 0)
            {
                throw new FormatException("offset(" + offset + ") is not greater" +
                  "\u0020or equal to 0");
            }
            if (offset > chars.Length)
            {
                throw new FormatException("offset(" + offset + ") is not less or" +
                  "\u0020equal to " + chars.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length(" + length + ") is not greater or" +
                  "\u0020equal to 0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is not less or" +
                  "\u0020equal to " + chars.Length);
            }
            if (chars.Length - offset < length)
            {
                throw new FormatException("str's length minus " + offset + "(" +
                  (chars.Length - offset) + ") is not greater or equal to " + length);
            }
            EContext b64 = EContext.Binary64;
            if (ctx != null && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              !ctx.IsSimplified && ctx.EMax.CompareTo(b64.EMax) <= 0 &&
              ctx.EMin.CompareTo(b64.EMin) >= 0 &&
              ctx.Precision.CompareTo(b64.Precision) <= 0)
            {
                int tmpoffset = offset;
                int endpos = offset + length;
                if (length == 0)
                {
                    throw new FormatException();
                }
                if (chars[tmpoffset] == '-' || chars[tmpoffset] == '+')
                {
                    ++tmpoffset;
                }
                if (tmpoffset < endpos && ((chars[tmpoffset] >= '0' &&
                      chars[tmpoffset] <= '9') || chars[tmpoffset] == '.'))
                {
                    EFloat ef = DoubleEFloatFromString(chars, offset, length, ctx);
                    if (ef != null)
                    {
                        return ef;
                    }
                }
            }
            return EDecimal.FromString(
                chars,
                offset,
                length,
                EContext.Unlimited.WithSimplified(ctx != null && ctx.IsSimplified))
              .ToEFloat(ctx);
        }

        internal static EFloat DoubleEFloatFromString(
          byte[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            int endStr = tmpoffset + length;
            var negative = false;
            var haveDecimalPoint = false;
            var haveDigits = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var digitStart = 0;
            int i = tmpoffset;
            long mantissaLong = 0L;
            // Ordinary number
            if (chars[i] == '+' || chars[i] == '-')
            {
                if (chars[i] == '-')
                {
                    negative = true;
                }
                ++i;
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            var nonzeroBeyondMax = false;
            var lastdigit = -1;
            // 768 is maximum precision of a decimal
            // half-ULP in double format
            var maxDecimalPrec = 768;
            if (length > 21)
            {
                int eminInt = ctx.EMin.ToInt32Checked();
                int emaxInt = ctx.EMax.ToInt32Checked();
                int precInt = ctx.Precision.ToInt32Checked();
                if (eminInt >= -14 && emaxInt <= 15)
                {
                    maxDecimalPrec = (precInt <= 11) ? 21 : 63;
                }
                else if (eminInt >= -126 && emaxInt <= 127)
                {
                    maxDecimalPrec = (precInt <= 24) ? 113 : 142;
                }
            }
            for (; i < endStr; ++i)
            {
                byte ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveDigits = true;
                    haveNonzeroDigit |= thisdigit != 0;
                    if (decimalPrec > maxDecimalPrec)
                    {
                        if (thisdigit != 0)
                        {
                            nonzeroBeyondMax = true;
                        }
                        if (!haveDecimalPoint)
                        {
                            // NOTE: Absolute value will not be more than
                            // the byte[] portion's length, so will fit comfortably
                            // in an 'int'.
                            newScaleInt = checked(newScaleInt + 1);
                        }
                        continue;
                    }
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantissaLong <= 922337203685477580L)
                    {
                        mantissaLong *= 10;
                        mantissaLong += thisdigit;
                    }
                    else
                    {
                        mantissaLong = Int64.MaxValue;
                    }
                    if (haveDecimalPoint)
                    {
                        // NOTE: Absolute value will not be more than
                        // the portion's length, so will fit comfortably
                        // in an 'int'.
                        newScaleInt = checked(newScaleInt - 1);
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            bool zeroMantissa = !haveNonzeroDigit;
            haveNonzeroDigit = false;
            EFloat ef1, ef2;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                byte ch = chars[i];
                if (ch == '+' || ch == '-')
                {
                    if (ch == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= 214748364)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                        else
                        {
                            expInt = Int32.MaxValue;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                expInt *= expoffset;
                if (expPrec > 12)
                {
                    // Exponent that can't be compensated by digit
                    // length without remaining beyond Int32 range
                    if (expoffset < 0)
                    {
                        return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
                    }
                    else
                    {
                        return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (expInt != Int32.MaxValue && expInt > -Int32.MaxValue &&
              mantissaLong != Int64.MaxValue && (ctx == null ||
                !ctx.HasFlagsOrTraps))
            {
                if (mantissaLong == 0)
                {
                    EFloat ef = EFloat.Create(
                        EInteger.Zero,
                        EInteger.FromInt32(expInt));
                    if (negative)
                    {
                        ef = ef.Negate();
                    }
                    return ef.RoundToPrecision(ctx);
                }
                var finalexp = (long)expInt + (long)newScaleInt;
                long ml = mantissaLong;
                if (finalexp >= -22 && finalexp <= 44)
                {
                    var iexp = (int)finalexp;
                    while (ml <= 900719925474099L && iexp > 22)
                    {
                        ml *= 10;
                        --iexp;
                    }
                    int iabsexp = Math.Abs(iexp);
                    if (ml < 9007199254740992L && iabsexp == 0)
                    {
                        return EFloat.FromInt64(negative ?
                            -mantissaLong : mantissaLong).RoundToPrecision(ctx);
                    }
                    else if (ml < 9007199254740992L && iabsexp <= 22)
                    {
                        EFloat efn =
                          EFloat.FromEInteger(NumberUtility.FindPowerOfTen(iabsexp));
                        if (negative)
                        {
                            ml = -ml;
                        }
                        EFloat efml = EFloat.FromInt64(ml);
                        if (iexp < 0)
                        {
                            return efml.Divide(efn, ctx);
                        }
                        else
                        {
                            return efml.Multiply(efn, ctx);
                        }
                    }
                }
                long adjexpUpperBound = finalexp + (decimalPrec - 1);
                long adjexpLowerBound = finalexp;
                if (adjexpUpperBound < -326)
                {
                    return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
                }
                else if (adjexpLowerBound > 309)
                {
                    return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
                }
                if (negative)
                {
                    mantissaLong = -mantissaLong;
                }
                long absfinalexp = Math.Abs(finalexp);
                ef1 = EFloat.Create(mantissaLong, (int)0);
                ef2 = EFloat.FromEInteger(NumberUtility.FindPowerOfTen(absfinalexp));
                if (finalexp < 0)
                {
                    EFloat efret = ef1.Divide(ef2, ctx);
                    /* Console.WriteLine("div " + ef1 + "/" + ef2 + " -> " + (efret));
                    */
                    return efret;
                }
                else
                {
                    return ef1.Multiply(ef2, ctx);
                }
            }
            EInteger mant = null;
            EInteger exp = (!haveExponent) ? EInteger.Zero :
              EInteger.FromSubstring(chars, expDigitStart, endStr);
            if (expoffset < 0)
            {
                exp = exp.Negate();
            }
            exp = exp.Add(newScaleInt);
            if (nonzeroBeyondMax)
            {
                exp = exp.Subtract(1);
                ++decimalPrec;
            }
            EInteger adjExpUpperBound = exp.Add(decimalPrec).Subtract(1);
            EInteger adjExpLowerBound = exp;
            // DebugUtility.Log("exp=" + adjExpLowerBound + "~" + (adjExpUpperBound));
            if (adjExpUpperBound.CompareTo(-326) < 0)
            {
                return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
            }
            else if (adjExpLowerBound.CompareTo(309) > 0)
            {
                return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
            }
            if (zeroMantissa)
            {
                EFloat ef = EFloat.Create(
                    EInteger.Zero,
                    exp);
                if (negative)
                {
                    ef = ef.Negate();
                }
                return ef.RoundToPrecision(ctx);
            }
            else if (decimalDigitStart != decimalDigitEnd)
            {
                if (digitEnd - digitStart == 1 && chars[digitStart] == '0')
                {
                    mant = EInteger.FromSubstring(
                        chars,
                        decimalDigitStart,
                        decimalDigitEnd);
                }
                else
                {
                    byte[] ctmpstr = Extras.CharsConcat(
                      chars,
                      digitStart,
                      digitEnd - digitStart,
                      chars,
                      decimalDigitStart,
                      decimalDigitEnd - decimalDigitStart);
                    mant = EInteger.FromString(ctmpstr);
                }
            }
            else
            {
                mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
            }
            if (nonzeroBeyondMax)
            {
                mant = mant.Multiply(10).Add(1);
            }
            if (negative)
            {
                mant = mant.Negate();
            }
            return EDecimal.Create(mant, exp).ToEFloat(ctx);
        }
    }

    internal static class EFloatCharArrayString
    {
        internal static EFloat FromString(
          char[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (offset < 0)
            {
                throw new FormatException("offset(" + offset + ") is not greater" +
                  "\u0020or equal to 0");
            }
            if (offset > chars.Length)
            {
                throw new FormatException("offset(" + offset + ") is not less or" +
                  "\u0020equal to " + chars.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length(" + length + ") is not greater or" +
                  "\u0020equal to 0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is not less or" +
                  "\u0020equal to " + chars.Length);
            }
            if (chars.Length - offset < length)
            {
                throw new FormatException("str's length minus " + offset + "(" +
                  (chars.Length - offset) + ") is not greater or equal to " + length);
            }
            EContext b64 = EContext.Binary64;
            if (ctx != null && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              !ctx.IsSimplified && ctx.EMax.CompareTo(b64.EMax) <= 0 &&
              ctx.EMin.CompareTo(b64.EMin) >= 0 &&
              ctx.Precision.CompareTo(b64.Precision) <= 0)
            {
                int tmpoffset = offset;
                int endpos = offset + length;
                if (length == 0)
                {
                    throw new FormatException();
                }
                if (chars[tmpoffset] == '-' || chars[tmpoffset] == '+')
                {
                    ++tmpoffset;
                }
                if (tmpoffset < endpos && ((chars[tmpoffset] >= '0' &&
                      chars[tmpoffset] <= '9') || chars[tmpoffset] == '.'))
                {
                    EFloat ef = DoubleEFloatFromString(chars, offset, length, ctx);
                    if (ef != null)
                    {
                        return ef;
                    }
                }
            }
            return EDecimal.FromString(
                chars,
                offset,
                length,
                EContext.Unlimited.WithSimplified(ctx != null && ctx.IsSimplified))
              .ToEFloat(ctx);
        }

        internal static EFloat DoubleEFloatFromString(
          char[] chars,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            int endStr = tmpoffset + length;
            var negative = false;
            var haveDecimalPoint = false;
            var haveDigits = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var digitStart = 0;
            int i = tmpoffset;
            long mantissaLong = 0L;
            // Ordinary number
            if (chars[i] == '+' || chars[i] == '-')
            {
                if (chars[i] == '-')
                {
                    negative = true;
                }
                ++i;
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            var nonzeroBeyondMax = false;
            var lastdigit = -1;
            // 768 is maximum precision of a decimal
            // half-ULP in double format
            var maxDecimalPrec = 768;
            if (length > 21)
            {
                int eminInt = ctx.EMin.ToInt32Checked();
                int emaxInt = ctx.EMax.ToInt32Checked();
                int precInt = ctx.Precision.ToInt32Checked();
                if (eminInt >= -14 && emaxInt <= 15)
                {
                    maxDecimalPrec = (precInt <= 11) ? 21 : 63;
                }
                else if (eminInt >= -126 && emaxInt <= 127)
                {
                    maxDecimalPrec = (precInt <= 24) ? 113 : 142;
                }
            }
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveDigits = true;
                    haveNonzeroDigit |= thisdigit != 0;
                    if (decimalPrec > maxDecimalPrec)
                    {
                        if (thisdigit != 0)
                        {
                            nonzeroBeyondMax = true;
                        }
                        if (!haveDecimalPoint)
                        {
                            // NOTE: Absolute value will not be more than
                            // the char[] portion's length, so will fit comfortably
                            // in an 'int'.
                            newScaleInt = checked(newScaleInt + 1);
                        }
                        continue;
                    }
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantissaLong <= 922337203685477580L)
                    {
                        mantissaLong *= 10;
                        mantissaLong += thisdigit;
                    }
                    else
                    {
                        mantissaLong = Int64.MaxValue;
                    }
                    if (haveDecimalPoint)
                    {
                        // NOTE: Absolute value will not be more than
                        // the portion's length, so will fit comfortably
                        // in an 'int'.
                        newScaleInt = checked(newScaleInt - 1);
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            bool zeroMantissa = !haveNonzeroDigit;
            haveNonzeroDigit = false;
            EFloat ef1, ef2;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                char ch = chars[i];
                if (ch == '+' || ch == '-')
                {
                    if (ch == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= 214748364)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                        else
                        {
                            expInt = Int32.MaxValue;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                expInt *= expoffset;
                if (expPrec > 12)
                {
                    // Exponent that can't be compensated by digit
                    // length without remaining beyond Int32 range
                    if (expoffset < 0)
                    {
                        return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
                    }
                    else
                    {
                        return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (expInt != Int32.MaxValue && expInt > -Int32.MaxValue &&
              mantissaLong != Int64.MaxValue && (ctx == null ||
                !ctx.HasFlagsOrTraps))
            {
                if (mantissaLong == 0)
                {
                    EFloat ef = EFloat.Create(
                        EInteger.Zero,
                        EInteger.FromInt32(expInt));
                    if (negative)
                    {
                        ef = ef.Negate();
                    }
                    return ef.RoundToPrecision(ctx);
                }
                var finalexp = (long)expInt + (long)newScaleInt;
                long ml = mantissaLong;
                if (finalexp >= -22 && finalexp <= 44)
                {
                    var iexp = (int)finalexp;
                    while (ml <= 900719925474099L && iexp > 22)
                    {
                        ml *= 10;
                        --iexp;
                    }
                    int iabsexp = Math.Abs(iexp);
                    if (ml < 9007199254740992L && iabsexp == 0)
                    {
                        return EFloat.FromInt64(negative ?
                            -mantissaLong : mantissaLong).RoundToPrecision(ctx);
                    }
                    else if (ml < 9007199254740992L && iabsexp <= 22)
                    {
                        EFloat efn =
                          EFloat.FromEInteger(NumberUtility.FindPowerOfTen(iabsexp));
                        if (negative)
                        {
                            ml = -ml;
                        }
                        EFloat efml = EFloat.FromInt64(ml);
                        if (iexp < 0)
                        {
                            return efml.Divide(efn, ctx);
                        }
                        else
                        {
                            return efml.Multiply(efn, ctx);
                        }
                    }
                }
                long adjexpUpperBound = finalexp + (decimalPrec - 1);
                long adjexpLowerBound = finalexp;
                if (adjexpUpperBound < -326)
                {
                    return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
                }
                else if (adjexpLowerBound > 309)
                {
                    return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
                }
                if (negative)
                {
                    mantissaLong = -mantissaLong;
                }
                long absfinalexp = Math.Abs(finalexp);
                ef1 = EFloat.Create(mantissaLong, (int)0);
                ef2 = EFloat.FromEInteger(NumberUtility.FindPowerOfTen(absfinalexp));
                if (finalexp < 0)
                {
                    EFloat efret = ef1.Divide(ef2, ctx);
                    /* Console.WriteLine("div " + ef1 + "/" + ef2 + " -> " + (efret));
                    */
                    return efret;
                }
                else
                {
                    return ef1.Multiply(ef2, ctx);
                }
            }
            EInteger mant = null;
            EInteger exp = (!haveExponent) ? EInteger.Zero :
              EInteger.FromSubstring(chars, expDigitStart, endStr);
            if (expoffset < 0)
            {
                exp = exp.Negate();
            }
            exp = exp.Add(newScaleInt);
            if (nonzeroBeyondMax)
            {
                exp = exp.Subtract(1);
                ++decimalPrec;
            }
            EInteger adjExpUpperBound = exp.Add(decimalPrec).Subtract(1);
            EInteger adjExpLowerBound = exp;
            // DebugUtility.Log("exp=" + adjExpLowerBound + "~" + (adjExpUpperBound));
            if (adjExpUpperBound.CompareTo(-326) < 0)
            {
                return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
            }
            else if (adjExpLowerBound.CompareTo(309) > 0)
            {
                return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
            }
            if (zeroMantissa)
            {
                EFloat ef = EFloat.Create(
                    EInteger.Zero,
                    exp);
                if (negative)
                {
                    ef = ef.Negate();
                }
                return ef.RoundToPrecision(ctx);
            }
            else if (decimalDigitStart != decimalDigitEnd)
            {
                if (digitEnd - digitStart == 1 && chars[digitStart] == '0')
                {
                    mant = EInteger.FromSubstring(
                        chars,
                        decimalDigitStart,
                        decimalDigitEnd);
                }
                else
                {
                    char[] ctmpstr = Extras.CharsConcat(
                      chars,
                      digitStart,
                      digitEnd - digitStart,
                      chars,
                      decimalDigitStart,
                      decimalDigitEnd - decimalDigitStart);
                    mant = EInteger.FromString(ctmpstr);
                }
            }
            else
            {
                mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
            }
            if (nonzeroBeyondMax)
            {
                mant = mant.Multiply(10).Add(1);
            }
            if (negative)
            {
                mant = mant.Negate();
            }
            return EDecimal.Create(mant, exp).ToEFloat(ctx);
        }
    }

    internal static class EFloatTextString
    {
        internal static EFloat FromString(
          string chars,
          int offset,
          int length,
          EContext ctx)
        {
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (offset < 0)
            {
                throw new FormatException("offset(" + offset + ") is not greater" +
                  "\u0020or equal to 0");
            }
            if (offset > chars.Length)
            {
                throw new FormatException("offset(" + offset + ") is not less or" +
                  "\u0020equal to " + chars.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length(" + length + ") is not greater or" +
                  "\u0020equal to 0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is not less or" +
                  "\u0020equal to " + chars.Length);
            }
            if (chars.Length - offset < length)
            {
                throw new FormatException("str's length minus " + offset + "(" +
                  (chars.Length - offset) + ") is not greater or equal to " + length);
            }
            EContext b64 = EContext.Binary64;
            if (ctx != null && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              !ctx.IsSimplified && ctx.EMax.CompareTo(b64.EMax) <= 0 &&
              ctx.EMin.CompareTo(b64.EMin) >= 0 &&
              ctx.Precision.CompareTo(b64.Precision) <= 0)
            {
                int tmpoffset = offset;
                int endpos = offset + length;
                if (length == 0)
                {
                    throw new FormatException();
                }
                if (chars[tmpoffset] == '-' || chars[tmpoffset] == '+')
                {
                    ++tmpoffset;
                }
                if (tmpoffset < endpos && ((chars[tmpoffset] >= '0' &&
                      chars[tmpoffset] <= '9') || chars[tmpoffset] == '.'))
                {
                    EFloat ef = DoubleEFloatFromString(chars, offset, length, ctx);
                    if (ef != null)
                    {
                        return ef;
                    }
                }
            }
            return EDecimal.FromString(
                chars,
                offset,
                length,
                EContext.Unlimited.WithSimplified(ctx != null && ctx.IsSimplified))
              .ToEFloat(ctx);
        }

        internal static EFloat DoubleEFloatFromString(
          string chars,
          int offset,
          int length,
          EContext ctx)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            int endStr = tmpoffset + length;
            var negative = false;
            var haveDecimalPoint = false;
            var haveDigits = false;
            var haveExponent = false;
            var newScaleInt = 0;
            var digitStart = 0;
            int i = tmpoffset;
            long mantissaLong = 0L;
            // Ordinary number
            if (chars[i] == '+' || chars[i] == '-')
            {
                if (chars[i] == '-')
                {
                    negative = true;
                }
                ++i;
            }
            digitStart = i;
            int digitEnd = i;
            int decimalDigitStart = i;
            var haveNonzeroDigit = false;
            var decimalPrec = 0;
            int decimalDigitEnd = i;
            var nonzeroBeyondMax = false;
            var lastdigit = -1;
            // 768 is maximum precision of a decimal
            // half-ULP in double format
            var maxDecimalPrec = 768;
            if (length > 21)
            {
                int eminInt = ctx.EMin.ToInt32Checked();
                int emaxInt = ctx.EMax.ToInt32Checked();
                int precInt = ctx.Precision.ToInt32Checked();
                if (eminInt >= -14 && emaxInt <= 15)
                {
                    maxDecimalPrec = (precInt <= 11) ? 21 : 63;
                }
                else if (eminInt >= -126 && emaxInt <= 127)
                {
                    maxDecimalPrec = (precInt <= 24) ? 113 : 142;
                }
            }
            for (; i < endStr; ++i)
            {
                char ch = chars[i];
                if (ch >= '0' && ch <= '9')
                {
                    var thisdigit = (int)(ch - '0');
                    haveDigits = true;
                    haveNonzeroDigit |= thisdigit != 0;
                    if (decimalPrec > maxDecimalPrec)
                    {
                        if (thisdigit != 0)
                        {
                            nonzeroBeyondMax = true;
                        }
                        if (!haveDecimalPoint)
                        {
                            // NOTE: Absolute value will not be more than
                            // the string portion's length, so will fit comfortably
                            // in an 'int'.
                            newScaleInt = checked(newScaleInt + 1);
                        }
                        continue;
                    }
                    lastdigit = thisdigit;
                    if (haveNonzeroDigit)
                    {
                        ++decimalPrec;
                    }
                    if (haveDecimalPoint)
                    {
                        decimalDigitEnd = i + 1;
                    }
                    else
                    {
                        digitEnd = i + 1;
                    }
                    if (mantissaLong <= 922337203685477580L)
                    {
                        mantissaLong *= 10;
                        mantissaLong += thisdigit;
                    }
                    else
                    {
                        mantissaLong = Int64.MaxValue;
                    }
                    if (haveDecimalPoint)
                    {
                        // NOTE: Absolute value will not be more than
                        // the portion's length, so will fit comfortably
                        // in an 'int'.
                        newScaleInt = checked(newScaleInt - 1);
                    }
                }
                else if (ch == '.')
                {
                    if (haveDecimalPoint)
                    {
                        throw new FormatException();
                    }
                    haveDecimalPoint = true;
                    decimalDigitStart = i + 1;
                    decimalDigitEnd = i + 1;
                }
                else if (ch == 'E' || ch == 'e')
                {
                    haveExponent = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            var expInt = 0;
            var expoffset = 1;
            var expDigitStart = -1;
            var expPrec = 0;
            bool zeroMantissa = !haveNonzeroDigit;
            haveNonzeroDigit = false;
            EFloat ef1, ef2;
            if (haveExponent)
            {
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                char ch = chars[i];
                if (ch == '+' || ch == '-')
                {
                    if (ch == '-')
                    {
                        expoffset = -1;
                    }
                    ++i;
                }
                expDigitStart = i;
                for (; i < endStr; ++i)
                {
                    ch = chars[i];
                    if (ch >= '0' && ch <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(ch - '0');
                        haveNonzeroDigit |= thisdigit != 0;
                        if (haveNonzeroDigit)
                        {
                            ++expPrec;
                        }
                        if (expInt <= 214748364)
                        {
                            expInt *= 10;
                            expInt += thisdigit;
                        }
                        else
                        {
                            expInt = Int32.MaxValue;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                expInt *= expoffset;
                if (expPrec > 12)
                {
                    // Exponent that can't be compensated by digit
                    // length without remaining beyond Int32 range
                    if (expoffset < 0)
                    {
                        return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
                    }
                    else
                    {
                        return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
                    }
                }
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (expInt != Int32.MaxValue && expInt > -Int32.MaxValue &&
              mantissaLong != Int64.MaxValue && (ctx == null ||
                !ctx.HasFlagsOrTraps))
            {
                if (mantissaLong == 0)
                {
                    EFloat ef = EFloat.Create(
                        EInteger.Zero,
                        EInteger.FromInt32(expInt));
                    if (negative)
                    {
                        ef = ef.Negate();
                    }
                    return ef.RoundToPrecision(ctx);
                }
                var finalexp = (long)expInt + (long)newScaleInt;
                long ml = mantissaLong;
                if (finalexp >= -22 && finalexp <= 44)
                {
                    var iexp = (int)finalexp;
                    while (ml <= 900719925474099L && iexp > 22)
                    {
                        ml *= 10;
                        --iexp;
                    }
                    int iabsexp = Math.Abs(iexp);
                    if (ml < 9007199254740992L && iabsexp == 0)
                    {
                        return EFloat.FromInt64(negative ?
                            -mantissaLong : mantissaLong).RoundToPrecision(ctx);
                    }
                    else if (ml < 9007199254740992L && iabsexp <= 22)
                    {
                        EFloat efn =
                          EFloat.FromEInteger(NumberUtility.FindPowerOfTen(iabsexp));
                        if (negative)
                        {
                            ml = -ml;
                        }
                        EFloat efml = EFloat.FromInt64(ml);
                        if (iexp < 0)
                        {
                            return efml.Divide(efn, ctx);
                        }
                        else
                        {
                            return efml.Multiply(efn, ctx);
                        }
                    }
                }
                long adjexpUpperBound = finalexp + (decimalPrec - 1);
                long adjexpLowerBound = finalexp;
                if (adjexpUpperBound < -326)
                {
                    return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
                }
                else if (adjexpLowerBound > 309)
                {
                    return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
                }
                if (negative)
                {
                    mantissaLong = -mantissaLong;
                }
                long absfinalexp = Math.Abs(finalexp);
                ef1 = EFloat.Create(mantissaLong, (int)0);
                ef2 = EFloat.FromEInteger(NumberUtility.FindPowerOfTen(absfinalexp));
                if (finalexp < 0)
                {
                    EFloat efret = ef1.Divide(ef2, ctx);
                    /* Console.WriteLine("div " + ef1 + "/" + ef2 + " -> " + (efret));
                    */
                    return efret;
                }
                else
                {
                    return ef1.Multiply(ef2, ctx);
                }
            }
            EInteger mant = null;
            EInteger exp = (!haveExponent) ? EInteger.Zero :
              EInteger.FromSubstring(chars, expDigitStart, endStr);
            if (expoffset < 0)
            {
                exp = exp.Negate();
            }
            exp = exp.Add(newScaleInt);
            if (nonzeroBeyondMax)
            {
                exp = exp.Subtract(1);
                ++decimalPrec;
            }
            EInteger adjExpUpperBound = exp.Add(decimalPrec).Subtract(1);
            EInteger adjExpLowerBound = exp;
            // DebugUtility.Log("exp=" + adjExpLowerBound + "~" + (adjExpUpperBound));
            if (adjExpUpperBound.CompareTo(-326) < 0)
            {
                return EFloat.SignalUnderflow(ctx, negative, zeroMantissa);
            }
            else if (adjExpLowerBound.CompareTo(309) > 0)
            {
                return EFloat.SignalOverflow(ctx, negative, zeroMantissa);
            }
            if (zeroMantissa)
            {
                EFloat ef = EFloat.Create(
                    EInteger.Zero,
                    exp);
                if (negative)
                {
                    ef = ef.Negate();
                }
                return ef.RoundToPrecision(ctx);
            }
            else if (decimalDigitStart != decimalDigitEnd)
            {
                if (digitEnd - digitStart == 1 && chars[digitStart] == '0')
                {
                    mant = EInteger.FromSubstring(
                        chars,
                        decimalDigitStart,
                        decimalDigitEnd);
                }
                else
                {
                    string ctmpstr = Extras.CharsConcat(
                      chars,
                      digitStart,
                      digitEnd - digitStart,
                      chars,
                      decimalDigitStart,
                      decimalDigitEnd - decimalDigitStart);
                    mant = EInteger.FromString(ctmpstr);
                }
            }
            else
            {
                mant = EInteger.FromSubstring(chars, digitStart, digitEnd);
            }
            if (nonzeroBeyondMax)
            {
                mant = mant.Multiply(10).Add(1);
            }
            if (negative)
            {
                mant = mant.Negate();
            }
            return EDecimal.Create(mant, exp).ToEFloat(ctx);
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.EInteger"]/*'/>
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
     "Microsoft.Design",
     "CA1036",
     Justification = "Awaiting advice at dotnet/dotnet-api-docs#2937.")]
    public sealed partial class EInteger : IComparable<EInteger>,
   IEquatable<EInteger>
    {
        private const string Digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        private const int Toom3Threshold = 100;
        private const int Toom4Threshold = 400;
        private const int MultRecursionThreshold = 10;
        private const int RecursiveDivisionLimit = (Toom3Threshold * 2) + 1;

        private const int CacheFirst = -24;
        private const int CacheLast = 128;

        private const int ShortMask = 0xffff;

        internal static readonly int[] CharToDigit = {
      36, 36, 36, 36, 36, 36,
      36,
      36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      36, 36, 36, 36, 36, 36, 36, 36,
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 36, 36, 36, 36, 36, 36,
      36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36,
      36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36,
    };

        internal static readonly int[] MaxSafeInts = {
      1073741823, 715827881,
      536870911, 429496728, 357913940, 306783377, 268435455, 238609293,
      214748363, 195225785, 178956969, 165191048, 153391688, 143165575,
      134217727, 126322566, 119304646, 113025454, 107374181, 102261125,
      97612892, 93368853, 89478484, 85899344, 82595523, 79536430, 76695843,
      74051159, 71582787, 69273665, 67108863, 65075261, 63161282, 61356674,
      59652322,
    };

        private static readonly EInteger ValueOne = new EInteger(
          1, new short[] { 1 }, false);

        private static readonly EInteger ValueTen = new EInteger(
          1, new short[] { 10 }, false);

        private static readonly EInteger ValueZero = new EInteger(
          0, new short[] { 0 }, false);

        private readonly bool negative;
        private readonly int wordCount;
        private readonly short[] words;

        private static readonly EInteger[] Cache = EIntegerCache(CacheFirst,
            CacheLast);

        private static EInteger[] EIntegerCache(int first, int last)
        {
#if DEBUG
            if (first < -65535)
            {
                throw new ArgumentException("first (" + first + ") is not greater" +
                  "\u0020or equal" + "\u0020to " + (-65535));
            }
            if (first > 65535)
            {
                throw new ArgumentException("first (" + first + ") is not less or" +
                  "\u0020equal to" + "\u002065535");
            }
            if (last < -65535)
            {
                throw new ArgumentException("last (" + last + ") is not greater or" +
                  "\u0020equal" + "\u0020to " + (-65535));
            }
            if (last > 65535)
            {
                throw new ArgumentException("last (" + last + ") is not less or" +
                  "\u0020equal to" + "65535");
            }
#endif
            var i = 0;
            var cache = new EInteger[(last - first) + 1];
            for (i = first; i <= last; ++i)
            {
                if (i == 0)
                {
                    cache[i - first] = ValueZero;
                }
                else if (i == 1)
                {
                    cache[i - first] = ValueOne;
                }
                else if (i == 10)
                {
                    cache[i - first] = ValueTen;
                }
                else
                {
                    int iabs = Math.Abs(i);
                    var words = new short[] {
            unchecked((short)iabs),
          };
                    cache[i - first] = new EInteger(1, words, i < 0);
                }
            }
            return cache;
        }

        internal EInteger(int wordCount, short[] reg, bool negative)
        {
#if DEBUG
            if (wordCount > 0)
            {
                if (reg == null)
                {
                    throw new InvalidOperationException();
                }
                if (wordCount > reg.Length)
                {
                    throw new InvalidOperationException();
                }
                if (reg[wordCount - 1] == 0)
                {
                    throw new InvalidOperationException();
                }
            }
#endif
            this.wordCount = wordCount;
            this.words = reg;
            this.negative = negative;
        }

        /// <summary>Gets the number 1 as an arbitrary-precision
        /// integer.</summary>
        /// <value>The number 1 as an arbitrary-precision integer.</value>
        public static EInteger One
        {
            get
            {
                return ValueOne;
            }
        }

        /// <summary>Gets the number 10 as an arbitrary-precision
        /// integer.</summary>
        /// <value>The number 10 as an arbitrary-precision integer.</value>
        public static EInteger Ten
        {
            get
            {
                return ValueTen;
            }
        }

        /// <summary>Gets the number zero as an arbitrary-precision
        /// integer.</summary>
        /// <value>The number zero as an arbitrary-precision integer.</value>
        public static EInteger Zero
        {
            get
            {
                return ValueZero;
            }
        }

        /// <summary>Gets a value indicating whether this value is
        /// even.</summary>
        /// <value><c>true</c> if this value is even; otherwise, <c>false</c>.</value>
        public bool IsEven
        {
            get
            {
                return !this.GetUnsignedBit(0);
            }
        }

        /// <summary>Gets a value indicating whether this object's value is a
        /// power of two, and greater than 0.</summary>
        /// <value><c>true</c> if this object's value is a power of two, and
        /// greater than 0; otherwise, <c>false</c>.</value>
        public bool IsPowerOfTwo
        {
            get
            {
                int wc = this.wordCount;
                if (this.negative || wc == 0 ||
                  (wc > 1 && this.words[0] != 0))
                {
                    return false;
                }
                for (var i = 0; i < wc - 1; ++i)
                {
                    if (this.words[i] != 0)
                    {
                        return false;
                    }
                }
                int lastw = ((int)this.words[wc - 1]) & 0xffff;
                if (lastw == 0)
                {
                    throw new InvalidOperationException();
                }
                while ((lastw & 1) == 0)
                {
                    lastw >>= 1;
                }
                return lastw == 1;
            }
        }

        /// <summary>Gets a value indicating whether this value is 0.</summary>
        /// <value><c>true</c> if this value is 0; otherwise, <c>false</c>.</value>
        public bool IsZero
        {
            get
            {
                return this.wordCount == 0;
            }
        }

        /// <summary>Gets the sign of this object's value.</summary>
        /// <value>The sign of this object's value.</value>
        public int Sign
        {
            get
            {
                return (this.wordCount == 0) ? 0 : (this.negative ? -1 : 1);
            }
        }

        internal static EInteger FromInts(int[] intWords, int count)
        {
            var words = new short[count << 1];
            var j = 0;
            for (var i = 0; i < count; ++i, j += 2)
            {
                int w = intWords[i];
                words[j] = unchecked((short)w);
                words[j + 1] = unchecked((short)(w >> 16));
            }
            int newwordCount = words.Length;
            while (newwordCount != 0 && words[newwordCount - 1] == 0)
            {
                --newwordCount;
            }
            return (newwordCount == 0) ? EInteger.Zero :
              new EInteger(newwordCount, words, false);
        }

        /// <summary>Initializes an arbitrary-precision integer from an array
        /// of bytes.</summary>
        /// <param name='bytes'>A byte array consisting of the two's-complement
        /// form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
        /// the arbitrary-precision integer to create. The byte array is
        /// encoded using the rules given in the FromBytes(bytes, offset,
        /// length, littleEndian) overload.</param>
        /// <param name='littleEndian'>If true, the byte order is
        /// little-endian, or least-significant-byte first. If false, the byte
        /// order is big-endian, or most-significant-byte first.</param>
        /// <returns>An arbitrary-precision integer. Returns 0 if the byte
        /// array's length is 0.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        public static EInteger FromBytes(byte[] bytes, bool littleEndian)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            return FromBytes(bytes, 0, bytes.Length, littleEndian);
        }

        /// <summary>Initializes an arbitrary-precision integer from a portion
        /// of an array of bytes. The portion of the byte array is encoded
        /// using the following rules:
        /// <list>
        /// <item>Positive numbers have the first byte's highest bit cleared,
        /// and negative numbers have the bit set.</item>
        /// <item>The last byte contains the lowest 8-bits, the next-to-last
        /// contains the next lowest 8 bits, and so on. For example, the number
        /// 300 can be encoded as <c>0x01, 0x2C</c> and 200 as <c>0x00,
        /// 0xC8</c>. (Note that the second example contains a set high bit in
        /// <c>0xC8</c>, so an additional 0 is added at the start to ensure
        /// it's interpreted as positive.)</item>
        /// <item>To encode negative numbers, take the absolute value of the
        /// number, subtract by 1, encode the number into bytes, and toggle
        /// each bit of each byte. Any further bits that appear beyond the most
        /// significant bit of the number will be all ones. For example, the
        /// number -450 can be encoded as <c>0xfe, 0x70</c> and -52869 as
        /// <c>0xff, 0x31, 0x7B</c>. (Note that the second example contains a
        /// cleared high bit in <c>0x31, 0x7B</c>, so an additional 0xff is
        /// added at the start to ensure it's interpreted as
        /// negative.)</item></list>
        /// <para>For little-endian, the byte order is reversed from the byte
        /// order just discussed.</para></summary>
        /// <param name='bytes'>A byte array consisting of the two's-complement
        /// form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
        /// the arbitrary-precision integer to create. The byte array is
        /// encoded using the rules given in the FromBytes(bytes, offset,
        /// length, littleEndian) overload.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='bytes'/> begins.</param>
        /// <param name='length'>The length, in bytes, of the desired portion
        /// of <paramref name='bytes'/> (but not more than <paramref
        /// name='bytes'/> 's length).</param>
        /// <param name='littleEndian'>If true, the byte order is
        /// little-endian, or least-significant-byte first. If false, the byte
        /// order is big-endian, or most-significant-byte first.</param>
        /// <returns>An arbitrary-precision integer. Returns 0 if the byte
        /// array's length is 0.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='bytes'/> 's length, or <paramref
        /// name='bytes'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static EInteger FromBytes(
          byte[] bytes,
          int offset,
          int length,
          bool littleEndian)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            if (offset < 0)
            {
                throw new ArgumentException("offset (" + offset + ") is not greater" +
                   "\u0020or equal to 0");
            }
            if (offset > bytes.Length)
            {
                throw new ArgumentException("offset (" + offset + ") is not less or" +
                   "\u0020equal to " + bytes.Length);
            }
            if (length < 0)
            {
                throw new ArgumentException("length (" + length + ") is not " +
                    "greater or equal to 0");
            }
            if (length > bytes.Length)
            {
                throw new ArgumentException("length (" + length + ") is not less or" +
        "\u0020equal to " + bytes.Length);
            }
            if (bytes.Length - offset < length)
            {
                throw new ArgumentException("bytes's length minus " + offset + " (" +
                   (bytes.Length - offset) + ") is not greater or equal to " + length);
            }
            if (length == 0)
            {
                return EInteger.Zero;
            }
            else if (length == 1)
            {
                return (((int)bytes[offset] & 0x80) == 0) ?
        FromInt32((int)bytes[offset]) :
                  FromInt32(-1 - ((~bytes[offset]) & 0x7f));
            }
            int len = length;
            int wordLength = (len >> 1) + (len & 1);
            var newreg = new short[wordLength];
            int valueJIndex = littleEndian ? len - 1 : 0;
            var numIsNegative = false;
            bool odd = (len & 1) != 0;
            int evenedLen = odd ? len - 1 : len;
            var j = 0;
            if (littleEndian)
            {
                for (var i = 0; i < evenedLen; i += 2, j++)
                {
                    int index2 = i + 1;
                    int nrj = ((int)bytes[offset + i]) & 0xff;
                    nrj |= ((int)bytes[offset + i + 1]) << 8;
                    newreg[j] = unchecked((short)nrj);
                }
                if (odd)
                {
                    newreg[evenedLen >> 1] =
                      unchecked((short)(((int)bytes[offset + evenedLen]) & 0xff));
                }
                numIsNegative = (bytes[offset + len - 1] & 0x80) != 0;
            }
            else
            {
                for (var i = 0; i < evenedLen; i += 2, j++)
                {
                    int index = len - 1 - i;
                    int index2 = len - 2 - i;
                    int nrj = ((int)bytes[offset + index]) & 0xff;
                    nrj |= ((int)bytes[offset + index2]) << 8;
                    newreg[j] = unchecked((short)nrj);
                }
                if (odd)
                {
                    newreg[evenedLen >> 1] = unchecked((short)(((int)bytes[offset]) &
          0xff));
                }
                numIsNegative = (bytes[offset] & 0x80) != 0;
            }
            if (numIsNegative)
            {
                // Sign extension and two's-complement
                if (odd)
                {
                    newreg[len >> 1] |= unchecked((short)0xff00);
                }
                j = (len >> 1) + 1;
                for (; j < newreg.Length; ++j)
                {
                    newreg[j] = unchecked((short)0xffff); // sign extend remaining words
                }
                TwosComplement(newreg, 0, (int)newreg.Length);
            }
            int newwordCount = newreg.Length;
            while (newwordCount != 0 && newreg[newwordCount - 1] == 0)
            {
                --newwordCount;
            }
            return (newwordCount == 0) ? EInteger.Zero :
              new EInteger(newwordCount, newreg, numIsNegative);
        }

        /// <summary>Converts a boolean value (true or false) to an
        /// arbitrary-precision integer.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>The number 1 if <paramref name='boolValue'/> is true;
        /// otherwise, 0.</returns>
        public static EInteger FromBoolean(bool boolValue)
        {
            return boolValue ? ValueOne : ValueZero;
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>An arbitrary-precision integer with the same value as the
        /// 64-bit number.</returns>
        public static EInteger FromInt32(int intValue)
        {
            if (intValue >= CacheFirst && intValue <= CacheLast)
            {
                return Cache[intValue - CacheFirst];
            }
            short[] retreg;
            bool retnegative;
            int retwordcount;
            retnegative = intValue < 0;
            if ((intValue >> 15) == 0)
            {
                retreg = new short[2];
                if (retnegative)
                {
                    intValue = -intValue;
                }
                retreg[0] = (short)(intValue & ShortMask);
                retwordcount = 1;
            }
            else if (intValue == Int32.MinValue)
            {
                retreg = new short[2];
                retreg[0] = 0;
                retreg[1] = unchecked((short)0x8000);
                retwordcount = 2;
            }
            else
            {
                unchecked
                {
                    retreg = new short[2];
                    if (retnegative)
                    {
                        intValue = -intValue;
                    }
                    retreg[0] = (short)(intValue & ShortMask);
                    intValue >>= 16;
                    retreg[1] = (short)(intValue & ShortMask);
                    retwordcount = (retreg[1] == 0) ? 1 : 2;
                }
            }
            return new EInteger(retwordcount, retreg, retnegative);
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='longerValue'>The parameter <paramref
        /// name='longerValue'/> is a 64-bit signed integer.</param>
        /// <returns>An arbitrary-precision integer with the same value as the
        /// 64-bit number.</returns>
        public static EInteger FromInt64(long longerValue)
        {
            if (longerValue >= CacheFirst && longerValue <= CacheLast)
            {
                return Cache[(int)(longerValue - CacheFirst)];
            }
            short[] retreg;
            bool retnegative;
            int retwordcount;
            unchecked
            {
                retnegative = longerValue < 0;
                if ((longerValue >> 16) == 0)
                {
                    retreg = new short[1];
                    var intValue = (int)longerValue;
                    if (retnegative)
                    {
                        intValue = -intValue;
                    }
                    retreg[0] = (short)(intValue & ShortMask);
                    retwordcount = 1;
                }
                else if ((longerValue >> 31) == 0)
                {
                    retreg = new short[2];
                    var intValue = (int)longerValue;
                    if (retnegative)
                    {
                        intValue = -intValue;
                    }
                    retreg[0] = (short)(intValue & ShortMask);
                    retreg[1] = (short)((intValue >> 16) & ShortMask);
                    retwordcount = 2;
                }
                else if (longerValue == Int64.MinValue)
                {
                    retreg = new short[4];
                    retreg[0] = 0;
                    retreg[1] = 0;
                    retreg[2] = 0;
                    retreg[3] = unchecked((short)0x8000);
                    retwordcount = 4;
                }
                else
                {
                    retreg = new short[4];
                    long ut = longerValue;
                    if (retnegative)
                    {
                        ut = -ut;
                    }
                    retreg[0] = (short)(ut & ShortMask);
                    ut >>= 16;
                    retreg[1] = (short)(ut & ShortMask);
                    ut >>= 16;
                    retreg[2] = (short)(ut & ShortMask);
                    ut >>= 16;
                    retreg[3] = (short)(ut & ShortMask);
                    // at this point, the word count can't
                    // be 0 (the check for 0 was already done above)
                    retwordcount = 4;
                    while (retwordcount != 0 &&
                      retreg[retwordcount - 1] == 0)
                    {
                        --retwordcount;
                    }
                }
            }
            return new EInteger(retwordcount, retreg, retnegative);
        }

        // Approximate number of digits, multiplied by 100, that fit in
        // each 16-bit word of an EInteger. This is used to calculate
        // an upper bound on the EInteger's word array size based on
        // the radix and the number of digits. Calculated from:
        // ceil(ln(65536)*100/ln(radix)).
        internal static readonly int[] DigitsInWord = {
      0, 0,
      1600, 1010, 800, 690, 619, 570, 534, 505, 482, 463, 447,
      433, 421, 410, 400, 392, 384, 377, 371, 365, 359, 354,
      349, 345, 341, 337, 333, 330, 327, 323, 320, 318, 315,
      312, 310, 308,
    };

        /// <summary>Converts a string to an arbitrary-precision integer in a
        /// given radix.</summary>
        /// <param name='str'>A string described by the FromRadixSubstring
        /// method.</param>
        /// <param name='radix'>A base from 2 to 36. Depending on the radix,
        /// the string can use the basic digits 0 to 9 (U+0030 to U+0039) and
        /// then the basic upper-case letters A to Z (U+0041 to U+005A). For
        /// example, 0-9 in radix 10, and 0-9, then A-F in radix 16. Where a
        /// basic upper-case letter A to Z is allowed in the string, the
        /// corresponding basic lower-case letter (U+0061 to U+007a) is allowed
        /// instead.</param>
        /// <returns>An arbitrary-precision integer with the same value as the
        /// given string.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='FormatException'>The string is empty or in an
        /// invalid format.</exception>
        public static EInteger FromRadixString(string str, int radix)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return FromRadixSubstring(str, radix, 0, str.Length);
        }

        /// <summary>Converts a portion of a string to an arbitrary-precision
        /// integer in a given radix.</summary>
        /// <param name='str'>A text string. The desired portion of the string
        /// must contain only characters allowed by the given radix, except
        /// that it may start with a minus sign ("-", U+002D) to indicate a
        /// negative number. The desired portion is not allowed to contain
        /// white space characters, including spaces. The desired portion may
        /// start with any number of zeros.</param>
        /// <param name='radix'>A base from 2 to 36. Depending on the radix,
        /// the string can use the basic digits 0 to 9 (U+0030 to U+0039) and
        /// then the basic upper-case letters A to Z (U+0041 to U+005A). For
        /// example, 0-9 in radix 10, and 0-9, then A-F in radix 16. Where a
        /// basic upper-case letter A to Z is allowed in the string, the
        /// corresponding basic lower-case letter (U+0061 to U+007a) is allowed
        /// instead.</param>
        /// <param name='index'>The index of the string that starts the string
        /// portion.</param>
        /// <param name='endIndex'>The index of the string that ends the string
        /// portion. The length will be index + endIndex - 1.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the string portion.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='FormatException'>The string portion is empty or in
        /// an invalid format.</exception>
        public static EInteger FromRadixSubstring(
          string str,
          int radix,
          int index,
          int endIndex)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return EIntegerTextString.FromRadixSubstringImpl(
                str,
                radix,
                index,
                endIndex);
        }

        /// <summary>Converts a portion of a sequence of <c>char</c> s to an
        /// arbitrary-precision integer.</summary>
        /// <param name='cs'>A sequence of <c>char</c> s, the desired portion
        /// of which describes an integer in base-10 (decimal) form. The
        /// desired portion of the sequence of <c>char</c> s must contain only
        /// basic digits 0 to 9 (U+0030 to U+0039), except that it may start
        /// with a minus sign ("-", U+002D) to indicate a negative number. The
        /// desired portion is not allowed to contain white space characters,
        /// including spaces. The desired portion may start with any number of
        /// zeros.</param>
        /// <param name='index'>The index of the sequence of <c>char</c> s that
        /// starts the desired portion.</param>
        /// <param name='endIndex'>The index of the sequence of <c>char</c> s
        /// that ends the desired portion. The length will be index + endIndex
        /// - 1.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the sequence of <c>char</c> s portion.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='index'/> is less than 0, <paramref name='endIndex'/> is less
        /// than 0, or either is greater than the sequence's length, or
        /// <paramref name='endIndex'/> is less than <paramref
        /// name='index'/>.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='cs'/> is null.</exception>
        public static EInteger FromSubstring(
          char[] cs,
          int index,
          int endIndex)
        {
            if (cs == null)
            {
                throw new ArgumentNullException(nameof(cs));
            }
            return FromRadixSubstring(cs, 10, index, endIndex);
        }

        /// <summary>Converts a sequence of <c>char</c> s to an
        /// arbitrary-precision integer.</summary>
        /// <param name='cs'>A sequence of <c>char</c> s describing an integer
        /// in base-10 (decimal) form. The sequence must contain only basic
        /// digits 0 to 9 (U+0030 to U+0039), except that it may start with a
        /// minus sign ("-", U+002D) to indicate a negative number. The
        /// sequence is not allowed to contain white space characters,
        /// including spaces. The sequence may start with any number of
        /// zeros.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the sequence of <c>char</c> s.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='cs'/> is in an invalid format.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='cs'/> is null.</exception>
        public static EInteger FromString(char[] cs)
        {
            if (cs == null)
            {
                throw new ArgumentNullException(nameof(cs));
            }
            int len = cs.Length;
            if (len == 1)
            {
                char c = cs[0];
                if (c >= '0' && c <= '9')
                {
                    return FromInt32((int)(c - '0'));
                }
                throw new FormatException();
            }
            return FromRadixSubstring(cs, 10, 0, len);
        }

        /// <summary>Converts a sequence of <c>char</c> s to an
        /// arbitrary-precision integer in a given radix.</summary>
        /// <param name='cs'>A sequence of <c>char</c> s described by the
        /// FromRadixSubstring method.</param>
        /// <param name='radix'>A base from 2 to 36. Depending on the radix,
        /// the sequence of <c>char</c> s can use the basic digits 0 to 9
        /// (U+0030 to U+0039) and then the basic upper-case letters A to Z
        /// (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F
        /// in radix 16. Where a basic upper-case letter A to Z is allowed in
        /// the sequence of <c>char</c> s, the corresponding basic lower-case
        /// letter (U+0061 to U+007a) is allowed instead.</param>
        /// <returns>An arbitrary-precision integer with the same value as the
        /// given sequence of <c>char</c> s.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='cs'/> is null.</exception>
        /// <exception cref='FormatException'>The sequence of <c>char</c> s is
        /// empty or in an invalid format.</exception>
        public static EInteger FromRadixString(char[] cs, int radix)
        {
            if (cs == null)
            {
                throw new ArgumentNullException(nameof(cs));
            }
            return FromRadixSubstring(cs, radix, 0, cs.Length);
        }

        /// <summary>Converts a portion of a sequence of <c>char</c> s to an
        /// arbitrary-precision integer in a given radix.</summary>
        /// <param name='cs'>A text sequence of <c>char</c> s. The desired
        /// portion of the sequence of <c>char</c> s must contain only
        /// characters allowed by the given radix, except that it may start
        /// with a minus sign ("-", U+002D) to indicate a negative number. The
        /// desired portion is not allowed to contain white space characters,
        /// including spaces. The desired portion may start with any number of
        /// zeros.</param>
        /// <param name='radix'>A base from 2 to 36. Depending on the radix,
        /// the sequence of <c>char</c> s can use the basic digits 0 to 9
        /// (U+0030 to U+0039) and then the basic upper-case letters A to Z
        /// (U+0041 to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F
        /// in radix 16. Where a basic upper-case letter A to Z is allowed in
        /// the sequence of <c>char</c> s, the corresponding basic lower-case
        /// letter (U+0061 to U+007a) is allowed instead.</param>
        /// <param name='index'>The index of the sequence of <c>char</c> s that
        /// starts the desired portion.</param>
        /// <param name='endIndex'>The index of the sequence of <c>char</c> s
        /// that ends the desired portion. The length will be index + endIndex
        /// - 1.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the sequence's portion.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='cs'/> is null.</exception>
        /// <exception cref='FormatException'>The portion is empty or in an
        /// invalid format.</exception>
        public static EInteger FromRadixSubstring(
          char[] cs,
          int radix,
          int index,
          int endIndex)
        {
            if (cs == null)
            {
                throw new ArgumentNullException(nameof(cs));
            }
            return EIntegerCharArrayString.FromRadixSubstringImpl(
                cs,
                radix,
                index,
                endIndex);
        }

        /// <summary>Converts a portion of a sequence of bytes (interpreted as
        /// text) to an arbitrary-precision integer. Each byte in the sequence
        /// has to be a character in the Basic Latin range (0x00 to 0x7f or
        /// U+0000 to U+007F) of the Unicode Standard.</summary>
        /// <param name='bytes'>A sequence of bytes (interpreted as text), the
        /// desired portion of which describes an integer in base-10 (decimal)
        /// form. The desired portion of the sequence of bytes (interpreted as
        /// text) must contain only basic digits 0 to 9 (U+0030 to U+0039),
        /// except that it may start with a minus sign ("-", U+002D) to
        /// indicate a negative number. The desired portion is not allowed to
        /// contain white space characters, including spaces. The desired
        /// portion may start with any number of zeros.</param>
        /// <param name='index'>The index of the sequence of bytes (interpreted
        /// as text) that starts the desired portion.</param>
        /// <param name='endIndex'>The index of the sequence of bytes
        /// (interpreted as text) that ends the desired portion. The length
        /// will be index + endIndex - 1.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the sequence of bytes (interpreted as text)
        /// portion.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='index'/> is less than 0, <paramref name='endIndex'/> is less
        /// than 0, or either is greater than the sequence's length, or
        /// <paramref name='endIndex'/> is less than <paramref
        /// name='index'/>.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        public static EInteger FromSubstring(
          byte[] bytes,
          int index,
          int endIndex)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            return FromRadixSubstring(bytes, 10, index, endIndex);
        }

        /// <summary>Converts a sequence of bytes (interpreted as text) to an
        /// arbitrary-precision integer. Each byte in the sequence has to be a
        /// code point in the Basic Latin range (0x00 to 0x7f or U+0000 to
        /// U+007F) of the Unicode Standard.</summary>
        /// <param name='bytes'>A sequence of bytes describing an integer in
        /// base-10 (decimal) form. The sequence must contain only basic digits
        /// 0 to 9 (U+0030 to U+0039), except that it may start with a minus
        /// sign ("-", U+002D) to indicate a negative number. The sequence is
        /// not allowed to contain white space characters, including spaces.
        /// The sequence may start with any number of zeros.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the sequence of bytes.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='bytes'/> is in an invalid format.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        public static EInteger FromString(byte[] bytes)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            int len = bytes.Length;
            if (len == 1)
            {
                byte c = bytes[0];
                if (c >= '0' && c <= '9')
                {
                    return FromInt32((int)(c - '0'));
                }
                throw new FormatException();
            }
            return FromRadixSubstring(bytes, 10, 0, len);
        }

        /// <summary>Converts a sequence of bytes (interpreted as text) to an
        /// arbitrary-precision integer in a given radix. Each byte in the
        /// sequence has to be a character in the Basic Latin range (0x00 to
        /// 0x7f or U+0000 to U+007F) of the Unicode Standard.</summary>
        /// <param name='bytes'>A sequence of bytes (interpreted as text)
        /// described by the FromRadixSubstring method.</param>
        /// <param name='radix'>A base from 2 to 36. Depending on the radix,
        /// the sequence of bytes can use the basic digits 0 to 9 (U+0030 to
        /// U+0039) and then the basic upper-case letters A to Z (U+0041 to
        /// U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix
        /// 16. Where a basic upper-case letter A to Z is allowed in the
        /// sequence of bytes, the corresponding basic lower-case letter
        /// (U+0061 to U+007a) is allowed instead.</param>
        /// <returns>An arbitrary-precision integer with the same value as the
        /// given sequence of bytes.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='FormatException'>The sequence of bytes
        /// (interpreted as text) is empty or in an invalid format.</exception>
        public static EInteger FromRadixString(byte[] bytes, int radix)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            return FromRadixSubstring(bytes, radix, 0, bytes.Length);
        }

        /// <summary>Converts a portion of a sequence of bytes (interpreted as
        /// text) to an arbitrary-precision integer in a given radix. Each byte
        /// in the sequence has to be a character in the Basic Latin range
        /// (0x00 to 0x7f or U+0000 to U+007F) of the Unicode
        /// Standard.</summary>
        /// <param name='bytes'>A sequence of bytes (interpreted as text). The
        /// desired portion of the sequence of bytes (interpreted as text) must
        /// contain only characters allowed by the given radix, except that it
        /// may start with a minus sign ("-", U+002D) to indicate a negative
        /// number. The desired portion is not allowed to contain white space
        /// characters, including spaces. The desired portion may start with
        /// any number of zeros.</param>
        /// <param name='radix'>A base from 2 to 36. Depending on the radix,
        /// the sequence of bytes (interpreted as text) can use the basic
        /// digits 0 to 9 (U+0030 to U+0039) and then the basic upper-case
        /// letters A to Z (U+0041 to U+005A). For example, 0-9 in radix 10,
        /// and 0-9, then A-F in radix 16. Where a basic upper-case letter A to
        /// Z is allowed in the sequence of bytes (interpreted as text), the
        /// corresponding basic lower-case letter (U+0061 to U+007a) is allowed
        /// instead.</param>
        /// <param name='index'>The index of the sequence of bytes (interpreted
        /// as text) that starts the desired portion.</param>
        /// <param name='endIndex'>The index of the sequence of bytes
        /// (interpreted as text) that ends the desired portion. The length
        /// will be index + endIndex - 1.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the sequence's portion.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='FormatException'>The portion is empty or in an
        /// invalid format.</exception>
        public static EInteger FromRadixSubstring(
          byte[] bytes,
          int radix,
          int index,
          int endIndex)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }
            return EIntegerByteArrayString.FromRadixSubstringImpl(
                bytes,
                radix,
                index,
                endIndex);
        }

        /// <summary>Converts a string to an arbitrary-precision
        /// integer.</summary>
        /// <param name='str'>A text string describing an integer in base-10
        /// (decimal) form. The string must contain only basic digits 0 to 9
        /// (U+0030 to U+0039), except that it may start with a minus sign
        /// ("-", U+002D) to indicate a negative number. The string is not
        /// allowed to contain white space characters, including spaces. The
        /// string may start with any number of zeros.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the string.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='str'/> is in an invalid format.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        public static EInteger FromString(string str)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            int len = str.Length;
            if (len == 1)
            {
                char c = str[0];
                if (c >= '0' && c <= '9')
                {
                    return FromInt32((int)(c - '0'));
                }
                throw new FormatException();
            }
            return FromRadixSubstring(str, 10, 0, len);
        }

        /// <summary>Converts a portion of a string to an arbitrary-precision
        /// integer.</summary>
        /// <param name='str'>A text string, the desired portion of which
        /// describes an integer in base-10 (decimal) form. The desired portion
        /// of the string must contain only basic digits 0 to 9 (U+0030 to
        /// U+0039), except that it may start with a minus sign ("-", U+002D)
        /// to indicate a negative number. The desired portion is not allowed
        /// to contain white space characters, including spaces. The desired
        /// portion may start with any number of zeros.</param>
        /// <param name='index'>The index of the string that starts the string
        /// portion.</param>
        /// <param name='endIndex'>The index of the string that ends the string
        /// portion. The length will be index + endIndex - 1.</param>
        /// <returns>An arbitrary-precision integer with the same value as
        /// given in the string portion.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='index'/> is less than 0, <paramref name='endIndex'/> is less
        /// than 0, or either is greater than the string's length, or <paramref
        /// name='endIndex'/> is less than <paramref
        /// name='index'/>.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        public static EInteger FromSubstring(
          string str,
          int index,
          int endIndex)
        {
            if (str == null)
            {
                throw new ArgumentNullException(nameof(str));
            }
            return FromRadixSubstring(str, 10, index, endIndex);
        }

        /// <summary>Returns the absolute value of this object's
        /// value.</summary>
        /// <returns>This object's value with the sign removed.</returns>
        public EInteger Abs()
        {
            return (this.wordCount == 0 || !this.negative) ? this : new
              EInteger(this.wordCount, this.words, false);
        }

        /// <summary>Adds this arbitrary-precision integer and another
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='bigintAugend'>Another arbitrary-precision
        /// integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision integer plus another arbitrary-precision
        /// integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigintAugend'/> is null.</exception>
        public EInteger Add(EInteger bigintAugend)
        {
            if (bigintAugend == null)
            {
                throw new ArgumentNullException(nameof(bigintAugend));
            }
            if (this.wordCount == 0)
            {
                return bigintAugend;
            }
            if (bigintAugend.wordCount == 0)
            {
                return this;
            }
            short[] sumreg;
            if (bigintAugend.wordCount == 1 && this.wordCount == 1)
            {
                if (this.negative == bigintAugend.negative)
                {
                    int intSum = (((int)this.words[0]) & ShortMask) +
                      (((int)bigintAugend.words[0]) & ShortMask);
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)intSum);
                    sumreg[1] = unchecked((short)(intSum >> 16));
                    return new EInteger(
                        ((intSum >> 16) == 0) ? 1 : 2,
                        sumreg,
                        this.negative);
                }
                else
                {
                    int a = ((int)this.words[0]) & ShortMask;
                    int b = ((int)bigintAugend.words[0]) & ShortMask;
                    if (a == b)
                    {
                        return EInteger.Zero;
                    }
                    if (a > b)
                    {
                        a -= b;
                        sumreg = new short[2];
                        sumreg[0] = unchecked((short)a);
                        return new EInteger(1, sumreg, this.negative);
                    }
                    b -= a;
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)b);
                    return new EInteger(1, sumreg, !this.negative);
                }
            }
            if ((!this.negative) == (!bigintAugend.negative))
            {
                // both nonnegative or both negative
                int addendCount = this.wordCount;
                int augendCount = bigintAugend.wordCount;
                if (augendCount <= 2 && addendCount <= 2 &&
                  (this.wordCount < 2 || (this.words[1] >> 15) == 0) &&
                  (bigintAugend.wordCount < 2 || (bigintAugend.words[1] >> 15) == 0))
                {
                    int a = ((int)this.words[0]) & ShortMask;
                    if (this.wordCount == 2)
                    {
                        a |= (((int)this.words[1]) & ShortMask) << 16;
                    }
                    int b = ((int)bigintAugend.words[0]) & ShortMask;
                    if (bigintAugend.wordCount == 2)
                    {
                        b |= (((int)bigintAugend.words[1]) & ShortMask) << 16;
                    }
                    a = unchecked((int)(a + b));
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)(a & ShortMask));
                    sumreg[1] = unchecked((short)((a >> 16) & ShortMask));
                    int wcount = (sumreg[1] == 0) ? 1 : 2;
                    return new EInteger(wcount, sumreg, this.negative);
                }
                if (augendCount <= 2 && addendCount <= 2)
                {
                    int a = ((int)this.words[0]) & ShortMask;
                    if (this.wordCount == 2)
                    {
                        a |= (((int)this.words[1]) & ShortMask) << 16;
                    }
                    int b = ((int)bigintAugend.words[0]) & ShortMask;
                    if (bigintAugend.wordCount == 2)
                    {
                        b |= (((int)bigintAugend.words[1]) & ShortMask) << 16;
                    }
                    long longResult = ((long)a) & 0xffffffffL;
                    longResult += ((long)b) & 0xffffffffL;
                    if ((longResult >> 32) == 0)
                    {
                        a = unchecked((int)longResult);
                        sumreg = new short[2];
                        sumreg[0] = unchecked((short)(a & ShortMask));
                        sumreg[1] = unchecked((short)((a >> 16) & ShortMask));
                        int wcount = (sumreg[1] == 0) ? 1 : 2;
                        return new EInteger(wcount, sumreg, this.negative);
                    }
                }
                // DebugUtility.Log("" + this + " + " + bigintAugend);
                var wordLength2 = (int)Math.Max(
                    this.words.Length,
                    bigintAugend.words.Length);
                sumreg = new short[wordLength2];
                int carry;
                int desiredLength = Math.Max(addendCount, augendCount);
                if (addendCount == augendCount)
                {
                    carry = AddInternal(
                        sumreg,
                        0,
                        this.words,
                        0,
                        bigintAugend.words,
                        0,
                        addendCount);
                }
                else if (addendCount > augendCount)
                {
                    // Addend is bigger
                    carry = AddInternal(
                        sumreg,
                        0,
                        this.words,
                        0,
                        bigintAugend.words,
                        0,
                        augendCount);
                    Array.Copy(
                      this.words,
                      augendCount,
                      sumreg,
                      augendCount,
                      addendCount - augendCount);
                    if (carry != 0)
                    {
                        carry = IncrementWords(
                            sumreg,
                            augendCount,
                            addendCount - augendCount,
                            (short)carry);
                    }
                }
                else
                {
                    // Augend is bigger
                    carry = AddInternal(
                        sumreg,
                        0,
                        this.words,
                        0,
                        bigintAugend.words,
                        0,
                        (int)addendCount);
                    Array.Copy(
                      bigintAugend.words,
                      addendCount,
                      sumreg,
                      addendCount,
                      augendCount - addendCount);
                    if (carry != 0)
                    {
                        carry = IncrementWords(
                            sumreg,
                            addendCount,
                            (int)(augendCount - addendCount),
                            (short)carry);
                    }
                }
                var needShorten = true;
                if (carry != 0)
                {
                    int nextIndex = desiredLength;
                    int len = nextIndex + 1;
                    sumreg = CleanGrow(sumreg, len);
                    sumreg[nextIndex] = (short)carry;
                    needShorten = false;
                }
                int sumwordCount = CountWords(sumreg);
                if (sumwordCount == 0)
                {
                    return EInteger.Zero;
                }
                if (needShorten)
                {
                    sumreg = ShortenArray(sumreg, sumwordCount);
                }
                return new EInteger(sumwordCount, sumreg, this.negative);
            }
            EInteger minuend = this;
            EInteger subtrahend = bigintAugend;
            if (this.negative)
            {
                // this is negative, b is nonnegative
                minuend = bigintAugend;
                subtrahend = this;
            }
            // Do a subtraction
            int words1Size = minuend.wordCount;
            int words2Size = subtrahend.wordCount;
            var diffNeg = false;
#if DEBUG
            if (words1Size > minuend.words.Length)
            {
                throw new InvalidOperationException();
            }
            if (words2Size > subtrahend.words.Length)
            {
                throw new InvalidOperationException();
            }
#endif
            short borrow;
            var wordLength = (int)Math.Max(
                minuend.words.Length,
                subtrahend.words.Length);
            var diffReg = new short[wordLength];
            if (words1Size == words2Size)
            {
                if (Compare(minuend.words, 0, subtrahend.words, 0, (int)words1Size) >=
                  0)
                {
                    // words1 is at least as high as words2
                    SubtractInternal(
                      diffReg,
                      0,
                      minuend.words,
                      0,
                      subtrahend.words,
                      0,
                      words1Size);
                }
                else
                {
                    // words1 is less than words2
                    SubtractInternal(
                      diffReg,
                      0,
                      subtrahend.words,
                      0,
                      minuend.words,
                      0,
                      words1Size);
                    diffNeg = true; // difference will be negative
                }
            }
            else if (words1Size > words2Size)
            {
                // words1 is greater than words2
                borrow = (short)SubtractInternal(
                    diffReg,
                    0,
                    minuend.words,
                    0,
                    subtrahend.words,
                    0,
                    words2Size);
                Array.Copy(
                  minuend.words,
                  words2Size,
                  diffReg,
                  words2Size,
                  words1Size - words2Size);
                DecrementWords(
                  diffReg,
                  words2Size,
                  words1Size - words2Size,
                  borrow);
            }
            else
            {
                // words1 is less than words2
                borrow = (short)SubtractInternal(
                    diffReg,
                    0,
                    subtrahend.words,
                    0,
                    minuend.words,
                    0,
                    words1Size);
                Array.Copy(
                  subtrahend.words,
                  words1Size,
                  diffReg,
                  words1Size,
                  words2Size - words1Size);
                DecrementWords(
                  diffReg,
                  words1Size,
                  words2Size - words1Size,
                  borrow);
                diffNeg = true;
            }
            int count = CountWords(diffReg);
            if (count == 0)
            {
                return EInteger.Zero;
            }
            diffReg = ShortenArray(diffReg, count);
            return new EInteger(count, diffReg, diffNeg);
        }

        /// <summary>Converts this object's value to a 32-bit signed integer,
        /// throwing an exception if it can't fit.</summary>
        /// <returns>A 32-bit signed integer.</returns>
        /// <exception cref=' T:System.OverflowException'>This object's value
        /// is too big to fit a 32-bit signed integer.</exception>
        [Obsolete("Renamed to ToInt32Checked.")]
        public int AsInt32Checked()
        {
            return this.ToInt32Checked();
        }

        /// <summary>Converts this object's value to a 32-bit signed integer.
        /// If the value can't fit in a 32-bit integer, returns the lower 32
        /// bits of this object's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
        /// which case the return value might have a different sign than this
        /// object's value).</summary>
        /// <returns>A 32-bit signed integer.</returns>
        [Obsolete("Renamed to ToInt32Unchecked.")]
        public int AsInt32Unchecked()
        {
            return this.ToInt32Unchecked();
        }

        /// <summary>Converts this object's value to a 64-bit signed integer,
        /// throwing an exception if it can't fit.</summary>
        /// <returns>A 64-bit signed integer.</returns>
        /// <exception cref=' T:System.OverflowException'>This object's value
        /// is too big to fit a 64-bit signed integer.</exception>
        [Obsolete("Renamed to ToInt64Checked.")]
        public long AsInt64Checked()
        {
            return this.ToInt64Checked();
        }

        /// <summary>Converts this object's value to a 64-bit signed integer.
        /// If the value can't fit in a 64-bit integer, returns the lower 64
        /// bits of this object's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
        /// which case the return value might have a different sign than this
        /// object's value).</summary>
        /// <returns>A 64-bit signed integer.</returns>
        [Obsolete("Renamed to ToInt64Unchecked.")]
        public long AsInt64Unchecked()
        {
            return this.ToInt64Unchecked();
        }

        /// <summary>Returns whether this object's value can fit in a 32-bit
        /// signed integer.</summary>
        /// <returns><c>true</c> if this object's value is from -2147483648
        /// through 2147483647; otherwise, <c>false</c>.</returns>
        public bool CanFitInInt32()
        {
            int c = this.wordCount;
            if (c > 2)
            {
                return false;
            }
            if (c == 2 && (this.words[1] & 0x8000) != 0)
            {
                return this.negative && this.words[1] == unchecked((short)0x8000) &&
                  this.words[0] == 0;
            }
            return true;
        }

        /// <summary>Returns whether this object's value can fit in a 64-bit
        /// signed integer.</summary>
        /// <returns><c>true</c> if this object's value is from
        /// -9223372036854775808 through 9223372036854775807; otherwise,
        /// <c>false</c>.</returns>
        public bool CanFitInInt64()
        {
            int c = this.wordCount;
            if (c > 4)
            {
                return false;
            }
            if (c == 4 && (this.words[3] & 0x8000) != 0)
            {
                return this.negative && this.words[3] == unchecked((short)0x8000) &&
                  this.words[2] == 0 && this.words[1] == 0 &&
                  this.words[0] == 0;
            }
            return true;
        }

        /// <summary>Compares an arbitrary-precision integer with this
        /// instance.</summary>
        /// <param name='other'>The integer to compare to this value.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.CompareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareTo(EInteger other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this == other)
            {
                return 0;
            }
            int size = this.wordCount, tempSize = other.wordCount;
            int sa = size == 0 ? 0 : (this.negative ? -1 : 1);
            int sb = tempSize == 0 ? 0 : (other.negative ? -1 : 1);
            if (sa != sb)
            {
                return (sa < sb) ? -1 : 1;
            }
            if (sa == 0)
            {
                return 0;
            }
            if (size == tempSize)
            {
                if (size == 1 && this.words[0] == other.words[0])
                {
                    return 0;
                }
                else
                {
                    short[] words1 = this.words;
                    short[] words2 = other.words;
                    while (unchecked(size--) != 0)
                    {
                        int an = ((int)words1[size]) & ShortMask;
                        int bn = ((int)words2[size]) & ShortMask;
                        if (an > bn)
                        {
                            return (sa > 0) ? 1 : -1;
                        }
                        if (an < bn)
                        {
                            return (sa > 0) ? -1 : 1;
                        }
                    }
                    return 0;
                }
            }
            return ((size > tempSize) ^ (sa <= 0)) ? 1 : -1;
        }

        /// <summary>Returns the greater of two arbitrary-precision
        /// integers.</summary>
        /// <param name='first'>The first integer to compare.</param>
        /// <param name='second'>The second integer to compare.</param>
        /// <returns>The greater of the two integers.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EInteger Max(EInteger first, EInteger second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return first.CompareTo(second) > 0 ? first : second;
        }

        /// <summary>Returns the smaller of two arbitrary-precision
        /// integers.</summary>
        /// <param name='first'>The first integer to compare.</param>
        /// <param name='second'>The second integer to compare.</param>
        /// <returns>The smaller of the two integers.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EInteger Min(EInteger first, EInteger second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return first.CompareTo(second) < 0 ? first : second;
        }

        /// <summary>Of two arbitrary-precision integers, returns the one with
        /// the greater absolute value. If both integers have the same absolute
        /// value, this method has the same effect as Max.</summary>
        /// <param name='first'>The first integer to compare.</param>
        /// <param name='second'>The second integer to compare.</param>
        /// <returns>The integer with the greater absolute value.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EInteger MaxMagnitude(EInteger first, EInteger second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            int cmp = first.Abs().CompareTo(second.Abs());
            return (cmp == 0) ? Max(first, second) : (cmp > 0 ? first : second);
        }

        /// <summary>Of two arbitrary-precision integers, returns the one with
        /// the smaller absolute value. If both integers have the same absolute
        /// value, this method has the same effect as Min.</summary>
        /// <param name='first'>The first integer to compare.</param>
        /// <param name='second'>The second integer to compare.</param>
        /// <returns>The integer with the smaller absolute value.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static EInteger MinMagnitude(EInteger first, EInteger second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            int cmp = first.Abs().CompareTo(second.Abs());
            return (cmp == 0) ? Min(first, second) : (cmp < 0 ? first : second);
        }

        /// <summary>Adds this arbitrary-precision integer and a 32-bit signed
        /// integer and returns the result.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision integer plus a 32-bit signed integer.</returns>
        public EInteger Add(int intValue)
        {
            if (intValue == 0)
            {
                return this;
            }
            if (this.wordCount == 0)
            {
                return EInteger.FromInt32(intValue);
            }
            if (this.wordCount == 1 && intValue >= -0x7ffe0000 && intValue <
              0x7ffe0000)
            {
                short[] sumreg;
                int intSum = this.negative ?
                  intValue - (((int)this.words[0]) & ShortMask) :
                  intValue + (((int)this.words[0]) & ShortMask);
                if (intSum >= CacheFirst && intSum <= CacheLast)
                {
                    return Cache[intSum - CacheFirst];
                }
                else if ((intSum >> 16) == 0)
                {
                    sumreg = new short[1];
                    sumreg[0] = unchecked((short)intSum);
                    return new EInteger(
                        1,
                        sumreg,
                        false);
                }
                else if (intSum > 0)
                {
                    sumreg = new short[2];
                    sumreg[0] = unchecked((short)intSum);
                    sumreg[1] = unchecked((short)(intSum >> 16));
                    return new EInteger(
                        2,
                        sumreg,
                        false);
                }
                else if (intSum > -65536)
                {
#if DEBUG
                    if (intSum >= 0)
                    {
                        throw new ArgumentException("intSum (" + intSum + ") is not less" +
                          "\u0020than 0");
                    }
#endif

                    sumreg = new short[1];
                    intSum = -intSum;
                    sumreg[0] = unchecked((short)intSum);
                    return new EInteger(
                        1,
                        sumreg,
                        true);
                }
                else
                {
#if DEBUG
                    if (intSum >= 0)
                    {
                        throw new ArgumentException("intSum (" + intSum + ") is not less" +
                          "\u0020than 0");
                    }
#endif

                    sumreg = new short[2];
                    intSum = -intSum;
                    sumreg[0] = unchecked((short)intSum);
                    sumreg[1] = unchecked((short)(intSum >> 16));
                    return new EInteger(
                        2,
                        sumreg,
                        true);
                }
            }
            return this.Add(EInteger.FromInt32(intValue));
        }

        /// <summary>Subtracts a 32-bit signed integer from this
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision integer minus a 32-bit signed
        /// integer.</returns>
        public EInteger Subtract(int intValue)
        {
            return (intValue == Int32.MinValue) ?
              this.Subtract(EInteger.FromInt32(intValue)) : ((intValue == 0) ?
                this : this.Add(-intValue));
        }

        /// <summary>Multiplies this arbitrary-precision integer by a 32-bit
        /// signed integer and returns the result.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision integer times a 32-bit signed
        /// integer.</returns>
        /// <example>
        /// <code>EInteger result = EInteger.FromString("5").Multiply(200);</code>
        ///  .
        /// </example>
        public EInteger Multiply(int intValue)
        {
            return this.Multiply(EInteger.FromInt32(intValue));
        }

        /// <summary>Divides this arbitrary-precision integer by a 32-bit
        /// signed integer and returns the result. The result of the division
        /// is rounded down (the fractional part is discarded). Except if the
        /// result of the division is 0, it will be negative if this
        /// arbitrary-precision integer is positive and the other 32-bit signed
        /// integer is negative, or vice versa, and will be positive if both
        /// are positive or both are negative.</summary>
        /// <param name='intValue'>The divisor.</param>
        /// <returns>The result of dividing this arbitrary-precision integer by
        /// a 32-bit signed integer. The result of the division is rounded down
        /// (the fractional part is discarded). Except if the result of the
        /// division is 0, it will be negative if this arbitrary-precision
        /// integer is positive and the other 32-bit signed integer is
        /// negative, or vice versa, and will be positive if both are positive
        /// or both are negative.</returns>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        public EInteger Divide(int intValue)
        {
            return this.Divide(EInteger.FromInt32(intValue));
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision integer is divided by a 32-bit signed integer.
        /// The remainder is the number that remains when the absolute value of
        /// this arbitrary-precision integer is divided by the absolute value
        /// of the other 32-bit signed integer; the remainder has the same sign
        /// (positive or negative) as this arbitrary-precision
        /// integer.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision integer is divided by a 32-bit signed
        /// integer.</returns>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='intValue'/> is null.</exception>
        public EInteger Remainder(int intValue)
        {
            return this.Remainder(EInteger.FromInt32(intValue));
        }

        /// <summary>Compares an arbitrary-precision integer with this
        /// instance.</summary>
        /// <param name='intValue'>The parameter <paramref name='intValue'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is
        /// greater.</returns>
        public int CompareTo(int intValue)
        {
            int c = this.wordCount;
            if (c > 2)
            {
                return this.negative ? -1 : 1;
            }
            if (c == 2 && (this.words[1] & 0x8000) != 0)
            {
                if (this.negative && this.words[1] == unchecked((short)0x8000) &&
                  this.words[0] == 0)
                {
                    // This value is Int32.MinValue
                    return intValue == Int32.MinValue ? 0 : -1;
                }
                else
                {
                    return this.negative ? -1 : 1;
                }
            }
            int thisInt = this.ToInt32Unchecked();
            return thisInt == intValue ? 0 : (thisInt < intValue ? -1 : 1);
        }

        /// <summary>Divides this arbitrary-precision integer by another
        /// arbitrary-precision integer and returns the result. The result of
        /// the division is rounded down (the fractional part is discarded).
        /// Except if the result of the division is 0, it will be negative if
        /// this arbitrary-precision integer is positive and the other
        /// arbitrary-precision integer is negative, or vice versa, and will be
        /// positive if both are positive or both are negative.</summary>
        /// <param name='bigintDivisor'>The divisor.</param>
        /// <returns>The result of dividing this arbitrary-precision integer by
        /// another arbitrary-precision integer. The result of the division is
        /// rounded down (the fractional part is discarded). Except if the
        /// result of the division is 0, it will be negative if this
        /// arbitrary-precision integer is positive and the other
        /// arbitrary-precision integer is negative, or vice versa, and will be
        /// positive if both are positive or both are negative.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigintDivisor'/> is null.</exception>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        public EInteger Divide(EInteger bigintDivisor)
        {
            if (bigintDivisor == null)
            {
                throw new ArgumentNullException(nameof(bigintDivisor));
            }
            int words1Size = this.wordCount;
            int words2Size = bigintDivisor.wordCount;
            // ---- Special cases
            if (words2Size == 0)
            {
                // Divisor is 0
                throw new DivideByZeroException();
            }
            if (words1Size < words2Size)
            {
                // Dividend is less than divisor (includes case
                // where dividend is 0)
                return EInteger.Zero;
            }
            // DebugUtility.Log("divide " + this + " " + bigintDivisor);
            if (words1Size <= 2 && words2Size <= 2 && this.CanFitInInt32() &&
              bigintDivisor.CanFitInInt32())
            {
                int valueASmall = this.ToInt32Checked();
                int valueBSmall = bigintDivisor.ToInt32Checked();
                if (valueASmall != Int32.MinValue || valueBSmall != -1)
                {
                    int result = valueASmall / valueBSmall;
                    return EInteger.FromInt32(result);
                }
            }
            if (words1Size <= 4 && words2Size <= 4 && this.CanFitInInt64() &&
              bigintDivisor.CanFitInInt64())
            {
                long valueALong = this.ToInt64Checked();
                long valueBLong = bigintDivisor.ToInt64Checked();
                if (valueALong != Int64.MinValue || valueBLong != -1)
                {
                    long resultLong = valueALong / valueBLong;
                    return EInteger.FromInt64(resultLong);
                }
            }
            short[] quotReg;
            int quotwordCount;
            if (words2Size == 1)
            {
                // divisor is small, use a fast path
                quotReg = new short[this.words.Length];
                quotwordCount = this.wordCount;
                FastDivide(quotReg, this.words, words1Size, bigintDivisor.words[0]);
                while (quotwordCount != 0 && quotReg[quotwordCount - 1] == 0)
                {
                    --quotwordCount;
                }
                return (quotwordCount != 0) ? new EInteger(
                    quotwordCount,
                    quotReg,
                    this.negative ^ bigintDivisor.negative) : EInteger.Zero;
            }
            // ---- General case
            quotReg = new short[(int)(words1Size - words2Size + 1)];
            GeneralDivide(
              this.words,
              0,
              this.wordCount,
              bigintDivisor.words,
              0,
              bigintDivisor.wordCount,
              quotReg,
              0,
              null,
              0);
            quotwordCount = CountWords(quotReg);
            quotReg = ShortenArray(quotReg, quotwordCount);
            return (quotwordCount != 0) ? new EInteger(quotwordCount,
                quotReg,
                this.negative ^ bigintDivisor.negative) :
              EInteger.Zero;
        }

        private static int LinearMultiplySubtractMinuend1Bigger(
          short[] resultArr,
          int resultStart,
          short[] minuendArr,
          int minuendArrStart,
          int factor1,
          short[] factor2,
          int factor2Start,
          int factor2Count)
        {
#if DEBUG
            if (factor2Count <= 0 || (factor1 >> 16) != 0)
            {
                throw new InvalidOperationException();
            }
#endif
            var a = 0;
            var b = 0;
            const int SMask = ShortMask;
            var cc = 0;
            if (factor1 == 0)
            {
                for (var i = 0; i < factor2Count; ++i)
                {
                    b = ((int)minuendArr[minuendArrStart + i] & SMask) - cc;
                    resultArr[resultStart + i] = unchecked((short)b);
                    cc = (b >> 31) & 1;
                }
            }
            else
            {
                for (var i = 0; i < factor2Count; ++i)
                {
                    a = unchecked((((int)factor2[factor2Start + i]) & SMask) * factor1);
                    a = unchecked(a + cc);
                    b = ((int)minuendArr[minuendArrStart + i] & SMask) - (a & SMask);
                    resultArr[resultStart + i] = unchecked((short)b);
                    cc = (a >> 16) + ((b >> 31) & 1);
                    cc &= SMask;
                }
            }
            a = cc;
            b = ((int)minuendArr[minuendArrStart + factor2Count] & SMask) - a;
            resultArr[resultStart + factor2Count] = unchecked((short)b);
            cc = (b >> 31) & 1;
            return cc;
        }

        private static void DivideThreeBlocksByTwo(
          short[] valueALow,
          int posALow,
          short[] valueAMidHigh,
          int posAMidHigh,
          short[] b,
          int posB,
          int blockCount,
          short[] quot,
          int posQuot,
          short[] rem,
          int posRem,
          short[] tmp)
        {
            // NOTE: size of 'quot' equals 'blockCount' * 2
            // NOTE: size of 'rem' equals 'blockCount' * 2
#if DEBUG
            if (quot != null)
            {
                if (posQuot < 0)
                {
                    throw new ArgumentException("posQuot(" + posQuot +
                      ") is less than 0");
                }
                if (posQuot > quot.Length)
                {
                    throw new ArgumentException("posQuot(" + posQuot +
                      ") is more than " + quot.Length);
                }
                if ((blockCount * 2) < 0)
                {
                    throw new ArgumentException("blockCount*2(" + (blockCount * 2) +
                      ") is less than 0");
                }
                if ((blockCount * 2) > quot.Length)
                {
                    throw new ArgumentException("blockCount*2(" + (blockCount * 2) +
                      ") is more than " + quot.Length);
                }
                if (quot.Length - posQuot < blockCount * 2)
                {
                    throw new ArgumentException("quot's length minus " + posQuot + "(" +
                      (quot.Length - posQuot) + ") is less than " + (blockCount * 2));
                }
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is more than " + rem.Length);
                }
                if ((blockCount * 2) < 0)
                {
                    throw new ArgumentException("blockCount*2(" + (blockCount * 2) +
                      ") is less than 0");
                }
                if ((blockCount * 2) > rem.Length)
                {
                    throw new ArgumentException("blockCount*2(" + (blockCount * 2) +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < blockCount * 2)
                {
                    throw new ArgumentException("rem's length minus " + posRem + "(" +
                      (rem.Length - posRem) + ") is less than " + (blockCount * 2));
                }
            }
            if (tmp.Length < blockCount * 6)
            {
                throw new ArgumentException("tmp.Length(" + tmp.Length +
                  ") is less than " + (blockCount * 6));
            }
#endif
            // Implements Algorithm 2 of Burnikel & Ziegler 1998
            int c;
            // If AHigh is less than BHigh
            if (
              WordsCompare(
                valueAMidHigh,
                posAMidHigh + blockCount,
                blockCount,
                b,
                posB + blockCount,
                blockCount) < 0)
            {
                // Divide AMidHigh by BHigh
                RecursiveDivideInner(
                  valueAMidHigh,
                  posAMidHigh,
                  b,
                  posB + blockCount,
                  quot,
                  posQuot,
                  rem,
                  posRem,
                  blockCount);
                // Copy remainder to temp at block position 4
                Array.Copy(rem, posRem, tmp, blockCount * 4, blockCount);
                Array.Clear(tmp, blockCount * 5, blockCount);
            }
            else
            {
                // BHigh is less than AHigh
                // set quotient to all ones
                short allones = unchecked((short)0xffff);
                for (var i = 0; i < blockCount; ++i)
                {
                    quot[posQuot + i] = allones;
                }
                Array.Clear(quot, posQuot + blockCount, blockCount);
                // copy AMidHigh to temp
                Array.Copy(
                  valueAMidHigh,
                  posAMidHigh,
                  tmp,
                  blockCount * 4,
                  blockCount * 2);
                // subtract BHigh from temp's high block
                SubtractInternal(
                  tmp,
                  blockCount * 5,
                  tmp,
                  blockCount * 5,
                  b,
                  posB + blockCount,
                  blockCount);
                // add BHigh to temp
                c = AddInternal(
                    tmp,
                    blockCount * 4,
                    tmp,
                    blockCount * 4,
                    b,
                    posB + blockCount,
                    blockCount);
                IncrementWords(tmp, blockCount * 5, blockCount, (short)c);
            }
            AsymmetricMultiply(
              tmp,
              0,
              tmp,
              blockCount * 2,
              quot,
              posQuot,
              blockCount,
              b,
              posB,
              blockCount);
            int bc3 = blockCount * 3;
            Array.Copy(valueALow, posALow, tmp, bc3, blockCount);
            Array.Clear(tmp, blockCount * 2, blockCount);
            c = SubtractInternal(tmp, bc3, tmp, bc3, tmp, 0, blockCount * 3);
            if (c != 0)
            {
                while (true)
                {
                    c = AddInternal(tmp, bc3, tmp, bc3, b, posB, blockCount * 2);
                    c = IncrementWords(tmp, blockCount * 5, blockCount, (short)c);
                    DecrementWords(quot, posQuot, blockCount * 2, (short)1);
                    if (c != 0)
                    {
                        break;
                    }
                }
            }
            Array.Copy(tmp, bc3, rem, posRem, blockCount * 2);
        }

        private static void RecursiveDivideInner(
          short[] a,
          int posA,
          short[] b,
          int posB,
          short[] quot,
          int posQuot,
          short[] rem,
          int posRem,
          int blockSize)
        {
            // NOTE: size of 'a', 'quot', and 'rem' is 'blockSize'*2
            // NOTE: size of 'b' is 'blockSize'
#if DEBUG
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (posA < 0)
            {
                throw new ArgumentException("posA(" + posA +
                  ") is less than 0");
            }
            if (posA > a.Length)
            {
                throw new ArgumentException("posA(" + posA + ") is more than " +
                  a.Length);
            }
            if ((blockSize * 2) < 0)
            {
                throw new ArgumentException("(blockSize*2)(" + (blockSize * 2) +
                  ") is less than 0");
            }
            if ((blockSize * 2) > a.Length)
            {
                throw new ArgumentException("(blockSize*2)(" + (blockSize * 2) +
                  ") is more than " + a.Length);
            }
            if ((a.Length - posA) < (blockSize * 2))
            {
                throw new ArgumentException("a's length minus " + posA + "(" +
                  (a.Length - posA) + ") is less than " + (blockSize * 2));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (posB < 0)
            {
                throw new ArgumentException("posB(" + posB +
                  ") is less than 0");
            }
            if (posB > b.Length)
            {
                throw new ArgumentException("posB(" + posB + ") is more than " +
                  b.Length);
            }
            if (blockSize < 0)
            {
                throw new ArgumentException("blockSize(" + blockSize +
                  ") is less than 0");
            }
            if (blockSize > b.Length)
            {
                throw new ArgumentException("blockSize(" + blockSize +
                  ") is more than " + b.Length);
            }
            if (b.Length - posB < blockSize)
            {
                throw new ArgumentException("b's length minus " + posB + "(" +
                  (b.Length - posB) + ") is less than " + blockSize);
            }
            if (quot != null)
            {
                if (posQuot < 0)
                {
                    throw new ArgumentException("posQuot(" + posQuot +
                      ") is less than 0");
                }
                if (posQuot > quot.Length)
                {
                    throw new ArgumentException("posQuot(" + posQuot +
                      ") is more than " + quot.Length);
                }
                if ((blockSize * 2) < 0)
                {
                    throw new ArgumentException("blockSize*2(" + (blockSize * 2) +
                      ") is less than 0");
                }
                if ((blockSize * 2) > quot.Length)
                {
                    throw new ArgumentException("blockSize*2(" + (blockSize * 2) +
                      ") is more than " + quot.Length);
                }
                if (quot.Length - posQuot < blockSize * 2)
                {
                    throw new ArgumentException("quot's length minus " + posQuot + "(" +
                      (quot.Length - posQuot) + ") is less than " + (blockSize * 2));
                }
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is more than " + rem.Length);
                }
                if ((blockSize * 2) < 0)
                {
                    throw new ArgumentException("blockSize*2(" + (blockSize * 2) +
                      ") is less than 0");
                }
                if ((blockSize * 2) > rem.Length)
                {
                    throw new ArgumentException("blockSize*2(" + (blockSize * 2) +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < (blockSize * 2))
                {
                    throw new ArgumentException("rem's length minus " + posRem + "(" +
                      (rem.Length - posRem) + ") is less than " + (blockSize * 2));
                }
            }
#endif
            // Implements Algorithm 1 of Burnikel & Ziegler 1998
            if (blockSize < RecursiveDivisionLimit || (blockSize & 1) == 1)
            {
                GeneralDivide(
                  a,
                  posA,
                  blockSize * 2,
                  b,
                  posB,
                  blockSize,
                  quot,
                  posQuot,
                  rem,
                  posRem);
            }
            else
            {
                int halfBlock = blockSize >> 1;
                var tmp = new short[halfBlock * 10];
                Array.Clear(quot, posQuot, blockSize * 2);
                Array.Clear(rem, posRem, blockSize);
                DivideThreeBlocksByTwo(
                  a,
                  posA + halfBlock,
                  a,
                  posA + blockSize,
                  b,
                  posB,
                  halfBlock,
                  tmp,
                  halfBlock * 6,
                  tmp,
                  halfBlock * 8,
                  tmp);
                DivideThreeBlocksByTwo(
                  a,
                  posA,
                  tmp,
                  halfBlock * 8,
                  b,
                  posB,
                  halfBlock,
                  quot,
                  posQuot,
                  rem,
                  posRem,
                  tmp);
                Array.Copy(tmp, halfBlock * 6, quot, posQuot + halfBlock, halfBlock);
            }
        }

        private static void RecursiveDivide(
          short[] a,
          int posA,
          int countA,
          short[] b,
          int posB,
          int countB,
          short[] quot,
          int posQuot,
          short[] rem,
          int posRem)
        {
#if DEBUG
            if (countB <= RecursiveDivisionLimit)
            {
                throw new ArgumentException("countB(" + countB +
                  ") is not greater than " + RecursiveDivisionLimit);
            }
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (posA < 0)
            {
                throw new ArgumentException("posA(" + posA +
                  ") is less than 0");
            }
            if (posA > a.Length)
            {
                throw new ArgumentException("posA(" + posA + ") is more than " +
                  a.Length);
            }
            if (countA < 0)
            {
                throw new ArgumentException("countA(" + countA +
                  ") is less than 0");
            }
            if (countA > a.Length)
            {
                throw new ArgumentException("countA(" + countA +
                  ") is more than " + a.Length);
            }
            if (a.Length - posA < countA)
            {
                throw new ArgumentException("a's length minus " + posA + "(" +
                  (a.Length - posA) + ") is less than " + countA);
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (posB < 0)
            {
                throw new ArgumentException("posB(" + posB +
                  ") is less than 0");
            }
            if (posB > b.Length)
            {
                throw new ArgumentException("posB(" + posB + ") is more than " +
                  b.Length);
            }
            if (countB < 0)
            {
                throw new ArgumentException("countB(" + countB +
                  ") is less than 0");
            }
            if (countB > b.Length)
            {
                throw new ArgumentException("countB(" + countB +
                  ") is more than " + b.Length);
            }
            if (b.Length - posB < countB)
            {
                throw new ArgumentException("b's length minus " + posB + "(" +
                  (b.Length - posB) + ") is less than " + countB);
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is more than " + rem.Length);
                }
                if (countB < 0)
                {
                    throw new ArgumentException("countB(" + countB +
                      ") is less than 0");
                }
                if (countB > rem.Length)
                {
                    throw new ArgumentException("countB(" + countB +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < countB)
                {
                    throw new ArgumentException("rem's length minus " + posRem + "(" +
                      (rem.Length - posRem) + ") is less than " + countB);
                }
            }
#endif
            int workPosA, workPosB, i;
            short[] workA = a;
            short[] workB = b;
            workPosA = posA;
            workPosB = posB;
            int blocksB = RecursiveDivisionLimit;
            var shiftB = 0;
            var m = 1;
            while (blocksB < countB)
            {
                blocksB <<= 1;
                m <<= 1;
            }
            workB = new short[blocksB];
            workPosB = 0;
            Array.Copy(b, posB, workB, blocksB - countB, countB);
            var shiftA = 0;
            var extraWord = 0;
            int wordsA = countA + (blocksB - countB);
            if ((b[countB - 1] & 0x8000) == 0)
            {
                int x = b[countB - 1];
                while ((x & 0x8000) == 0)
                {
                    ++shiftB;
                    x <<= 1;
                }
                x = a[countA - 1];
                while ((x & 0x8000) == 0)
                {
                    ++shiftA;
                    x <<= 1;
                }
                if (shiftA < shiftB)
                {
                    // Shifting A would require an extra word
                    ++extraWord;
                }
                ShiftWordsLeftByBits(
                  workB,
                  workPosB + blocksB - countB,
                  countB,
                  shiftB);
            }
            int blocksA = (wordsA + extraWord + (blocksB - 1)) / blocksB;
            int totalWordsA = blocksA * blocksB;
            workA = new short[totalWordsA];
            workPosA = 0;
            Array.Copy(
              a,
              posA,
              workA,
              workPosA + (blocksB - countB),
              countA);
            ShiftWordsLeftByBits(
              workA,
              workPosA + (blocksB - countB),
              countA + extraWord,
              shiftB);
            // Start division
            // "tmprem" holds temporary space for the following:
            // - blocksB: Remainder
            // - blocksB * 2: Dividend
            // - blocksB * 2: Quotient
            var tmprem = new short[blocksB * 5];
            var size = 0;
            for (i = blocksA - 1; i >= 0; --i)
            {
                int workAIndex = workPosA + (i * blocksB);
                // Set the low part of the sub-dividend with the working
                // block of the dividend
                Array.Copy(workA, workAIndex, tmprem, blocksB, blocksB);
                // Clear the quotient
                Array.Clear(tmprem, blocksB * 3, blocksB << 1);
                RecursiveDivideInner(
                  tmprem,
                  blocksB,
                  workB,
                  workPosB,
                  tmprem,
                  blocksB * 3,
                  tmprem,
                  0,
                  blocksB);
                if (quot != null)
                {
                    size = Math.Min(blocksB, quot.Length - (i * blocksB));
                    // DebugUtility.Log("quot len=" + quot.Length + ",bb=" + blocksB +
                    // ",size=" + size + " [" + countA + "," + countB + "]");
                    if (size > 0)
                    {
                        Array.Copy(
                          tmprem,
                          blocksB * 3,
                          quot,
                          posQuot + (i * blocksB),
                          size);
                    }
                }
                // Set the high part of the sub-dividend with the remainder
                Array.Copy(tmprem, 0, tmprem, blocksB << 1, blocksB);
            }
            if (rem != null)
            {
                Array.Copy(tmprem, blocksB - countB, rem, posRem, countB);
                ShiftWordsRightByBits(rem, posRem, countB, shiftB);
            }
        }

        private static string WordsToString(short[] a, int pos, int len)
        {
            while (len != 0 && a[pos + len - 1] == 0)
            {
                --len;
            }
            if (len == 0)
            {
                return "\"0\"";
            }
            var words = new short[len];
            Array.Copy(a, pos, words, 0, len);
            return "\"" + new EInteger(len, words, false).ToString() + "\"";
        }
        private static string WordsToStringHex(short[] a, int pos, int len)
        {
            while (len != 0 && a[pos + len - 1] == 0)
            {
                --len;
            }
            if (len == 0)
            {
                return "\"0\"";
            }
            var words = new short[len];
            Array.Copy(a, pos, words, 0, len);
            return "\"" + new EInteger(len, words, false).ToRadixString(16) +
              "\"";
        }
        private static string WordsToString2(
          short[] a,
          int pos,
          int len,
          short[] b,
          int pos2,
          int len2)
        {
            var words = new short[len + len2];
            Array.Copy(a, pos, words, 0, len);
            Array.Copy(b, pos2, words, len, len2);
            len += len2;
            while (len != 0 && words[len - 1] == 0)
            {
                --len;
            }
            return (len == 0) ? "\"0\"" : ("\"" + new EInteger(
                  len,
                  words,
                  false).ToString() + "\"");
        }

        private static void GeneralDivide(
          short[] a,
          int posA,
          int countA,
          short[] b,
          int posB,
          int countB,
          short[] quot,
          int posQuot,
          short[] rem,
          int posRem)
        {
#if DEBUG
            if (!(countA > 0 && countB > 0))
            {
                throw new ArgumentException("doesn't satisfy countA>0 && countB>0");
            }
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (posA < 0)
            {
                throw new ArgumentException("posA(" + posA +
                  ") is less than 0");
            }
            if (posA > a.Length)
            {
                throw new ArgumentException("posA(" + posA + ") is more than " +
                  a.Length);
            }
            if (countA < 0)
            {
                throw new ArgumentException("countA(" + countA +
                  ") is less than 0");
            }
            if (countA > a.Length)
            {
                throw new ArgumentException("countA(" + countA +
                  ") is more than " + a.Length);
            }
            if (a.Length - posA < countA)
            {
                throw new ArgumentException("a's length minus " + posA + "(" +
                  (a.Length - posA) + ") is less than " + countA);
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            if (posB < 0)
            {
                throw new ArgumentException("posB(" + posB +
                  ") is less than 0");
            }
            if (posB > b.Length)
            {
                throw new ArgumentException("posB(" + posB + ") is more than " +
                  b.Length);
            }
            if (countB < 0)
            {
                throw new ArgumentException("countB(" + countB +
                  ") is less than 0");
            }
            if (countB > b.Length)
            {
                throw new ArgumentException("countB(" + countB +
                  ") is more than " + b.Length);
            }
            if (b.Length - posB < countB)
            {
                throw new ArgumentException("b's length minus " + posB + "(" +
                  (b.Length - posB) + ") is less than " + countB);
            }
            if (quot != null)
            {
                if (posQuot < 0)
                {
                    throw new ArgumentException("posQuot(" + posQuot +
                      ") is less than 0");
                }
                if (posQuot > quot.Length)
                {
                    throw new ArgumentException("posQuot(" + posQuot +
                      ") is more than " + quot.Length);
                }
                if (countA - countB + 1 < 0)
                {
                    throw new ArgumentException("(countA-countB+1)(" + (countA -
                        countB + 1) + ") is less than 0");
                }
                if (countA - countB + 1 > quot.Length)
                {
                    throw new ArgumentException("(countA-countB+1)(" + (countA -
                        countB + 1) + ") is more than " + quot.Length);
                }
                if ((quot.Length - posQuot) < (countA - countB + 1))
                {
                    throw new ArgumentException("quot's length minus " + posQuot + "(" +
                      (quot.Length - posQuot) + ") is less than " +
                      (countA - countB + 1));
                }
            }
            if (rem != null)
            {
                if (posRem < 0)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is less than 0");
                }
                if (posRem > rem.Length)
                {
                    throw new ArgumentException("posRem(" + posRem +
                      ") is more than " + rem.Length);
                }
                if (countB < 0)
                {
                    throw new ArgumentException("countB(" + countB +
                      ") is less than 0");
                }
                if (countB > rem.Length)
                {
                    throw new ArgumentException("countB(" + countB +
                      ") is more than " + rem.Length);
                }
                if (rem.Length - posRem < countB)
                {
                    throw new ArgumentException("rem's length minus " + posRem + "(" +
                      (rem.Length - posRem) + ") is less than " + countB);
                }
            }
#endif
            int origQuotSize = countA - countB + 1;
            int origCountA = countA;
            int origCountB = countB;
            while (countB > 0 && b[posB + countB - 1] == 0)
            {
                --countB;
            }
            while (countA > 0 && a[posA + countA - 1] == 0)
            {
                --countA;
            }
            int newQuotSize = countA - countB + 1;
            if (quot != null)
            {
                if (newQuotSize < 0 || newQuotSize >= origQuotSize)
                {
                    Array.Clear(quot, posQuot, Math.Max(0, origQuotSize));
                }
                else
                {
                    Array.Clear(
                      quot,
                      posQuot + newQuotSize,
                      Math.Max(0, origQuotSize - newQuotSize));
                }
            }
            if (rem != null)
            {
                Array.Clear(rem, posRem + countB, origCountB - countB);
            }
#if DEBUG
            if (countA != 0 && !(a[posA + countA - 1] != 0))
            {
                throw new InvalidOperationException();
            }
            if (countB == 0 || !(b[posB + countB - 1] != 0))
            {
                throw new InvalidOperationException();
            }
#endif
            if (countA < countB)
            {
                // A is less than B, so quotient is 0, remainder is "a"
                if (quot != null)
                {
                    Array.Clear(quot, posQuot, Math.Max(0, origQuotSize));
                }
                if (rem != null)
                {
                    Array.Copy(a, posA, rem, posRem, origCountA);
                }
                return;
            }
            else if (countA == countB)
            {
                int cmp = Compare(a, posA, b, posB, countA);
                if (cmp == 0)
                {
                    // A equals B, so quotient is 1, remainder is 0
                    if (quot != null)
                    {
                        quot[posQuot] = 1;
                        Array.Clear(quot, posQuot + 1, Math.Max(0, origQuotSize - 1));
                    }
                    if (rem != null)
                    {
                        Array.Clear(rem, posRem, countA);
                    }
                    return;
                }
                else if (cmp < 0)
                {
                    // A is less than B, so quotient is 0, remainder is "a"
                    if (quot != null)
                    {
                        Array.Clear(quot, posQuot, Math.Max(0, origQuotSize));
                    }
                    if (rem != null)
                    {
                        Array.Copy(a, posA, rem, posRem, origCountA);
                    }
                    return;
                }
            }
            if (countB == 1)
            {
                // Divisor is a single word
                short shortRemainder = FastDivideAndRemainder(
                    quot,
                    posQuot,
                    a,
                    posA,
                    countA,
                    b[posB]);
                if (rem != null)
                {
                    rem[posRem] = shortRemainder;
                }
                return;
            }
            int workPosA, workPosB;
            short[] workAB = null;
            short[] workA = a;
            short[] workB = b;
            workPosA = posA;
            workPosB = posB;
            if (countB > RecursiveDivisionLimit)
            {
                RecursiveDivide(
                  a,
                  posA,
                  countA,
                  b,
                  posB,
                  countB,
                  quot,
                  posQuot,
                  rem,
                  posRem);
                return;
            }
            var sh = 0;
            var noShift = false;
            if ((b[posB + countB - 1] & 0x8000) == 0)
            {
                // Normalize a and b by shifting both until the high
                // bit of b is the highest bit of the last word
                int x = b[posB + countB - 1];
                if (x == 0)
                {
                    throw new InvalidOperationException();
                }
                while ((x & 0x8000) == 0)
                {
                    ++sh;
                    x <<= 1;
                }
                workAB = new short[countA + 1 + countB];
                workPosA = 0;
                workPosB = countA + 1;
                workA = workAB;
                workB = workAB;
                Array.Copy(a, posA, workA, workPosA, countA);
                Array.Copy(b, posB, workB, workPosB, countB);
                ShiftWordsLeftByBits(workA, workPosA, countA + 1, sh);
                ShiftWordsLeftByBits(workB, workPosB, countB, sh);
            }
            else
            {
                noShift = true;
                workA = new short[countA + 1];
                workPosA = 0;
                Array.Copy(a, posA, workA, workPosA, countA);
            }
            var c = 0;
            short pieceBHigh = workB[workPosB + countB - 1];
            int pieceBHighInt = ((int)pieceBHigh) & ShortMask;
            int endIndex = workPosA + countA;
#if DEBUG
            // Assert that pieceBHighInt is normalized
            if (!((pieceBHighInt & 0x8000) != 0))
            {
                throw new ArgumentException("doesn't satisfy(pieceBHighInt &" +
                  "\u00200x8000)!=0");
            }
#endif
            short pieceBNextHigh = workB[workPosB + countB - 2];
            int pieceBNextHighInt = ((int)pieceBNextHigh) & ShortMask;
            for (int offset = countA - countB; offset >= 0; --offset)
            {
                int wpoffset = workPosA + offset;
                int wpaNextHigh = ((int)workA[wpoffset + countB - 1]) & ShortMask;
                var wpaHigh = 0;
                if (!noShift || wpoffset + countB < endIndex)
                {
                    wpaHigh = ((int)workA[wpoffset + countB]) & ShortMask;
                }
                int dividend = unchecked(wpaNextHigh + (wpaHigh << 16));
                int divnext = ((int)workA[wpoffset + countB - 2]) & ShortMask;
                int quorem0 = (dividend >> 31) == 0 ? (dividend / pieceBHighInt) :
                  unchecked((int)(((long)dividend & 0xffffffffL) / pieceBHighInt));
                int quorem1 = unchecked(dividend - (quorem0 * pieceBHighInt));
                // DebugUtility.Log("{0:X8}/{1:X4} = {2:X8},{3:X4}",
                // dividend, pieceBHigh, quorem0, quorem1);
                long t = (((long)quorem1) << 16) | (divnext & 0xffffL);
                // NOTE: quorem0 won't be higher than (1<< 16)+1 as long as
                // pieceBHighInt is
                // normalized (see Burnikel & Ziegler 1998). Since the following
                // code block
                // corrects all cases where quorem0 is too high by 2, and all
                // remaining cases
                // will reduce quorem0 by 1 if it's at least (1<< 16), quorem0 will
                // be guaranteed to
                // have a bit length of 16 or less by the end of the code block.
                if ((quorem0 >> 16) != 0 ||
                  (unchecked(quorem0 * pieceBNextHighInt) & 0xffffffffL) > t)
                {
                    quorem1 += pieceBHighInt;
                    --quorem0;
                    if ((quorem1 >> 16) == 0)
                    {
                        t = (((long)quorem1) << 16) | (divnext & 0xffffL);
                        if ((quorem0 >> 16) != 0 ||
                          (unchecked(quorem0 * pieceBNextHighInt) & 0xffffffffL) > t)
                        {
                            --quorem0;
                            if (rem == null && offset == 0)
                            {
                                // We can stop now and break; all cases where quorem0
                                // is 2 too big will have been caught by now
                                if (quot != null)
                                {
                                    quot[posQuot + offset] = unchecked((short)quorem0);
                                }
                                break;
                            }
                        }
                    }
                }
                int q1 = quorem0 & ShortMask;
#if DEBUG
                int q2 = (quorem0 >> 16) & ShortMask;
                if (q2 != 0)
                {
                    // NOTE: The checks above should have ensured that quorem0 can't
                    // be longer than 16 bits.
                    throw new InvalidOperationException();
                }
#endif
                c = LinearMultiplySubtractMinuend1Bigger(
                    workA,
                    wpoffset,
                    workA,
                    wpoffset,
                    q1,
                    workB,
                    workPosB,
                    countB);
                if (c != 0)
                {
                    // T(workA,workPosA,countA+1,"workA X");
                    c = AddInternal(
                        workA,
                        wpoffset,
                        workA,
                        wpoffset,
                        workB,
                        workPosB,
                        countB);
                    c = IncrementWords(workA, wpoffset + countB, 1, (short)c);
                    // T(workA,workPosA,countA+1,"workA "+c);
                    --quorem0;
                }
                if (quot != null)
                {
                    quot[posQuot + offset] = unchecked((short)quorem0);
                }
            }
            if (rem != null)
            {
                if (sh != 0)
                {
                    ShiftWordsRightByBits(workA, workPosA, countB + 1, sh);
                }
                Array.Copy(workA, workPosA, rem, posRem, countB);
            }
        }

        /// <summary>Divides this arbitrary-precision integer by a 32-bit
        /// signed integer and returns a two-item array containing the result
        /// of the division and the remainder, in that order. The result of the
        /// division is rounded down (the fractional part is discarded). Except
        /// if the result of the division is 0, it will be negative if this
        /// arbitrary-precision integer is positive and the other 32-bit signed
        /// integer is negative, or vice versa, and will be positive if both
        /// are positive or both are negative. The remainder is the number that
        /// remains when the absolute value of this arbitrary-precision integer
        /// is divided by the absolute value of the other 32-bit signed
        /// integer; the remainder has the same sign (positive or negative) as
        /// this arbitrary-precision integer.</summary>
        /// <param name='intDivisor'>The number to divide by.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision integer, and the second is the
        /// remainder as an arbitrary-precision integer. The result of division
        /// is the result of the Divide method on the two operands, and the
        /// remainder is the result of the Remainder method on the two
        /// operands.</returns>
        /// <exception cref='DivideByZeroException'>The parameter <paramref
        /// name='intDivisor'/> is 0.</exception>
        public EInteger[] DivRem(int intDivisor)
        {
            return this.DivRem(EInteger.FromInt32(intDivisor));
        }

        /// <summary>Adds this arbitrary-precision integer and a 64-bit signed
        /// integer and returns the result.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision integer plus a 64-bit signed integer.</returns>
        public EInteger Add(long longValue)
        {
            return this.Add(EInteger.FromInt64(longValue));
        }

        /// <summary>Subtracts a 64-bit signed integer from this
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision integer minus a 64-bit signed
        /// integer.</returns>
        public EInteger Subtract(long longValue)
        {
            return this.Subtract(EInteger.FromInt64(longValue));
        }

        /// <summary>Multiplies this arbitrary-precision integer by a 64-bit
        /// signed integer and returns the result.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision integer times a 64-bit signed
        /// integer.</returns>
        public EInteger Multiply(long longValue)
        {
            return this.Multiply(EInteger.FromInt64(longValue));
        }

        /// <summary>Divides this arbitrary-precision integer by a 64-bit
        /// signed integer and returns the result. The result of the division
        /// is rounded down (the fractional part is discarded). Except if the
        /// result of the division is 0, it will be negative if this
        /// arbitrary-precision integer is positive and the other 64-bit signed
        /// integer is negative, or vice versa, and will be positive if both
        /// are positive or both are negative.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The result of dividing this arbitrary-precision integer by
        /// a 64-bit signed integer. The result of the division is rounded down
        /// (the fractional part is discarded). Except if the result of the
        /// division is 0, it will be negative if this arbitrary-precision
        /// integer is positive and the other 64-bit signed integer is
        /// negative, or vice versa, and will be positive if both are positive
        /// or both are negative.</returns>
        public EInteger Divide(long longValue)
        {
            return this.Divide(EInteger.FromInt64(longValue));
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision integer is divided by a 64-bit signed integer.
        /// The remainder is the number that remains when the absolute value of
        /// this arbitrary-precision integer is divided by the absolute value
        /// of the other 64-bit signed integer; the remainder has the same sign
        /// (positive or negative) as this arbitrary-precision
        /// integer.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision integer is divided by a 64-bit signed
        /// integer.</returns>
        public EInteger Remainder(long longValue)
        {
            return this.Remainder(EInteger.FromInt64(longValue));
        }

        /// <summary>Compares an arbitrary-precision integer with this
        /// instance.</summary>
        /// <param name='longValue'>The parameter <paramref name='longValue'/>
        /// is a 64-bit signed integer.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is
        /// greater.</returns>
        public int CompareTo(long longValue)
        {
            return this.CompareTo(EInteger.FromInt64(longValue));
        }

        /// <summary>Divides this arbitrary-precision integer by a 64-bit
        /// signed integer and returns a two-item array containing the result
        /// of the division and the remainder, in that order. The result of the
        /// division is rounded down (the fractional part is discarded). Except
        /// if the result of the division is 0, it will be negative if this
        /// arbitrary-precision integer is positive and the other 64-bit signed
        /// integer is negative, or vice versa, and will be positive if both
        /// are positive or both are negative. The remainder is the number that
        /// remains when the absolute value of this arbitrary-precision integer
        /// is divided by the absolute value of the other 64-bit signed
        /// integer; the remainder has the same sign (positive or negative) as
        /// this arbitrary-precision integer.</summary>
        /// <param name='intDivisor'>The parameter <paramref
        /// name='intDivisor'/> is a 64-bit signed integer.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision integer, and the second is the
        /// remainder as an arbitrary-precision integer. The result of division
        /// is the result of the Divide method on the two operands, and the
        /// remainder is the result of the Remainder method on the two
        /// operands.</returns>
        public EInteger[] DivRem(long intDivisor)
        {
            return this.DivRem(EInteger.FromInt64(intDivisor));
        }

        /// <summary>Divides this arbitrary-precision integer by another
        /// arbitrary-precision integer and returns a two-item array containing
        /// the result of the division and the remainder, in that order. The
        /// result of the division is rounded down (the fractional part is
        /// discarded). Except if the result of the division is 0, it will be
        /// negative if this arbitrary-precision integer is positive and the
        /// other arbitrary-precision integer is negative, or vice versa, and
        /// will be positive if both are positive or both are negative. The
        /// remainder is the number that remains when the absolute value of
        /// this arbitrary-precision integer is divided by the absolute value
        /// of the other arbitrary-precision integer; the remainder has the
        /// same sign (positive or negative) as this arbitrary-precision
        /// integer.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision integer, and the second is the
        /// remainder as an arbitrary-precision integer. The result of division
        /// is the result of the Divide method on the two operands, and the
        /// remainder is the result of the Remainder method on the two
        /// operands.</returns>
        /// <exception cref='DivideByZeroException'>The parameter <paramref
        /// name='divisor'/> is 0.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='divisor'/> is null.</exception>
        public EInteger[] DivRem(EInteger divisor)
        {
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            int words1Size = this.wordCount;
            int words2Size = divisor.wordCount;
            if (words2Size == 0)
            {
                // Divisor is 0
                throw new DivideByZeroException();
            }

            if (words1Size < words2Size)
            {
                // Dividend is less than divisor (includes case
                // where dividend is 0)
                return new[] { EInteger.Zero, this };
            }
            if (words2Size == 1)
            {
                // divisor is small, use a fast path
                var quotient = new short[this.wordCount];
                int smallRemainder;
                switch (divisor.words[0])
                {
                    case 2:
                        smallRemainder = (int)FastDivideAndRemainderTwo(
                            quotient,
                            0,
                            this.words,
                            0,
                            words1Size);
                        break;
                    case 10:
                        smallRemainder = (int)FastDivideAndRemainderTen(
                            quotient,
                            0,
                            this.words,
                            0,
                            words1Size);
                        break;
                    default:
                        // DebugUtility.Log("smalldiv=" + (divisor.words[0]));
                        smallRemainder = ((int)FastDivideAndRemainder(
                              quotient,
                              0,
                              this.words,
                              0,
                              words1Size,
                              divisor.words[0])) & ShortMask;
                        break;
                }
                int count = this.wordCount;
                while (count != 0 &&
                  quotient[count - 1] == 0)
                {
                    --count;
                }
                if (count == 0)
                {
                    return new[] { EInteger.Zero, this };
                }
                quotient = ShortenArray(quotient, count);
                var bigquo = new EInteger(
                  count,
                  quotient,
                  this.negative ^ divisor.negative);
                if (this.negative)
                {
                    smallRemainder = -smallRemainder;
                }
                return new[] { bigquo, EInteger.FromInt64(smallRemainder) };
            }
            if (this.CanFitInInt32() && divisor.CanFitInInt32())
            {
                long dividendSmall = this.ToInt32Checked();
                long divisorSmall = divisor.ToInt32Checked();
                if (dividendSmall != Int32.MinValue || divisorSmall != -1)
                {
                    long quotientSmall = dividendSmall / divisorSmall;
                    long remainderSmall = dividendSmall - (quotientSmall * divisorSmall);
                    return new[] {
            EInteger.FromInt64(quotientSmall),
            EInteger.FromInt64(remainderSmall),
          };
                }
            }
            else if (this.CanFitInInt64() && divisor.CanFitInInt64())
            {
                long dividendLong = this.ToInt64Checked();
                long divisorLong = divisor.ToInt64Checked();
                if (dividendLong != Int64.MinValue || divisorLong != -1)
                {
                    long quotientLong = dividendLong / divisorLong;
                    long remainderLong = dividendLong - (quotientLong * divisorLong);
                    return new[] {
            EInteger.FromInt64(quotientLong),
            EInteger.FromInt64(remainderLong),
          };
                }
                // DebugUtility.Log("int64divrem {0}/{1}"
                // , this.ToInt64Checked(), divisor.ToInt64Checked());
            }
            // --- General case
            var bigRemainderreg = new short[(int)words2Size];
            var quotientreg = new short[(int)(words1Size - words2Size + 1)];
            GeneralDivide(
              this.words,
              0,
              this.wordCount,
              divisor.words,
              0,
              divisor.wordCount,
              quotientreg,
              0,
              bigRemainderreg,
              0);
            int remCount = CountWords(bigRemainderreg);
            int quoCount = CountWords(quotientreg);
            bigRemainderreg = ShortenArray(bigRemainderreg, remCount);
            quotientreg = ShortenArray(quotientreg, quoCount);
            EInteger bigrem = (remCount == 0) ? EInteger.Zero : new
              EInteger(remCount, bigRemainderreg, this.negative);
            EInteger bigquo2 = (quoCount == 0) ? EInteger.Zero : new
              EInteger(quoCount, quotientreg, this.negative ^ divisor.negative);
            return new[] { bigquo2, bigrem };
        }

        /// <summary>Determines whether this object and another object are
        /// equal and have the same type.</summary>
        /// <param name='obj'>The parameter <paramref name='obj'/> is an
        /// arbitrary object.</param>
        /// <returns><c>true</c> if this object and another object are equal;
        /// otherwise, <c>false</c>.</returns>
        public override bool Equals(object obj)
        {
            var other = obj as EInteger;
            if (other == null)
            {
                return false;
            }
            if (this.wordCount == other.wordCount)
            {
                if (this.negative != other.negative)
                {
                    return false;
                }
                for (var i = 0; i < this.wordCount; ++i)
                {
                    if (this.words[i] != other.words[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        private static EInteger LeftShiftBigIntVar(EInteger ei,
          EInteger bigShift)
        {
            if (ei.IsZero)
            {
                return ei;
            }
            while (bigShift.Sign > 0)
            {
                var shift = 1000000;
                if (bigShift.CompareTo((EInteger)1000000) < 0)
                {
                    shift = bigShift.ToInt32Checked();
                }
                ei <<= shift;
                bigShift -= (EInteger)shift;
            }
            return ei;
        }

        private static long GcdLong(long u, long v)
        {
            // Adapted from Christian Stigen Larsen's
            // public domain GCD code
#if DEBUG
            if (!(u >= 0 && v >= 0))
            {
                throw new ArgumentException("doesn't satisfy u>= 0 && v>= 0");
            }
#endif

            var shl = 0;
            while (u != 0 && v != 0 && u != v)
            {
                bool eu = (u & 1L) == 0;
                bool ev = (v & 1L) == 0;
                if (eu && ev)
                {
                    ++shl;
                    u >>= 1;
                    v >>= 1;
                }
                else if (eu && !ev)
                {
                    u >>= 1;
                }
                else if (!eu && ev)
                {
                    v >>= 1;
                }
                else if (u >= v)
                {
                    u = (u - v) >> 1;
                }
                else
                {
                    long tmp = u;
                    u = (v - u) >> 1;
                    v = tmp;
                }
            }
            return (u == 0) ? (v << shl) : (u << shl);
        }

        /// <summary>Returns the greatest common divisor of this integer and
        /// the given integer. The greatest common divisor (GCD) is also known
        /// as the greatest common factor (GCF). This method works even if
        /// either or both integers are negative.</summary>
        /// <param name='bigintSecond'>Another arbitrary-precision integer. Can
        /// be negative.</param>
        /// <returns>The greatest common divisor of this integer and the given
        /// integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigintSecond'/> is null.</exception>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        public EInteger Gcd(EInteger bigintSecond)
        {
            if (bigintSecond == null)
            {
                throw new ArgumentNullException(nameof(bigintSecond));
            }
            if (this.IsZero)
            {
                return bigintSecond.Abs();
            }
            EInteger thisValue = this.Abs();
            if (bigintSecond.IsZero)
            {
                return thisValue;
            }
            bigintSecond = bigintSecond.Abs();
            if (bigintSecond.Equals(EInteger.One) ||
              thisValue.Equals(bigintSecond))
            {
                return bigintSecond;
            }
            if (thisValue.Equals(EInteger.One))
            {
                return thisValue;
            }
            if (Math.Max(thisValue.wordCount, bigintSecond.wordCount) > 12)
            {
                // if (Math.Max(thisValue.wordCount, bigintSecond.wordCount) > 250) {
                return SubquadraticGCD(thisValue, bigintSecond);
            }
            else
            {
                return BaseGcd(thisValue, bigintSecond);
            }
        }

        private static EInteger BaseGcd(EInteger thisValue, EInteger bigintSecond)
        {
            if (thisValue.CanFitInInt64() && bigintSecond.CanFitInInt64())
            {
                long u = thisValue.ToInt64Unchecked();
                long v = bigintSecond.ToInt64Unchecked();
                return EInteger.FromInt64(GcdLong(u, v));
            }
            else
            {
                bool bigger = thisValue.CompareTo(bigintSecond) >= 0;
                if (!bigger)
                {
                    EInteger ta = thisValue;
                    thisValue = bigintSecond;
                    bigintSecond = ta;
                }
                EInteger eia = thisValue;
                EInteger eib = bigintSecond;
                // DebugUtility.Log("wc="+eia.wordCount+"/"+eib.wordCount);
                while (eib.wordCount > 3)
                {
                    // Lehmer's algorithm
                    EInteger eiaa, eibb, eicc, eidd;
                    EInteger eish = eia.GetUnsignedBitLengthAsEInteger();
                    eish = eish.Subtract(48);
                    EInteger eiee = eia.ShiftRight(eish);
                    EInteger eiff = eib.ShiftRight(eish);
                    eiaa = eidd = EInteger.One;
                    eibb = eicc = EInteger.Zero;
                    while (true)
                    {
                        EInteger eifc = eiff.Add(eicc);
                        EInteger eifd = eiff.Add(eidd);
                        if (eifc.IsZero || eifd.IsZero)
                        {
                            EInteger ta = eibb.IsZero ? eib :
                              eia.Multiply(eiaa).Add(eib.Multiply(eibb));
                            EInteger tb = eibb.IsZero ? eia.Remainder(eib) :
                              eia.Multiply(eicc).Add(eib.Multiply(eidd));
                            eia = ta;
                            eib = tb;
                            // DebugUtility.Log("z tawc="+eia.wordCount+"/"+eib.wordCount);
                            break;
                        }
                        EInteger eiq = eiee.Add(eiaa).Divide(eifc);
                        EInteger eiq2 = eiee.Add(eibb).Divide(eifd);
                        if (!eiq.Equals(eiq2))
                        {
                            EInteger ta = eibb.IsZero ? eib :
                              eia.Multiply(eiaa).Add(eib.Multiply(eibb));
                            EInteger tb = eibb.IsZero ? eia.Remainder(eib) :
                              eia.Multiply(eicc).Add(eib.Multiply(eidd));
                            // DebugUtility.Log("eia/b="+eia.wordCount+"/"+eib.wordCount);
                            // DebugUtility.Log("eiaa/bb="+eiaa.wordCount+"/"+eibb.wordCount);
                            eia = ta;
                            eib = tb;
                            break;
                        }
                        else if (eiq.CanFitInInt32() &&
                        eidd.CanFitInInt32() && eicc.CanFitInInt32())
                        {
                            EInteger t = eiff;
                            // DebugUtility.Log("eiq eiffccdd="+eiff.wordCount+"/"+
                            // eicc.wordCount+"/"+eidd.wordCount);
                            int eiqi = eiq.ToInt32Checked();
                            eiff = eiee.Subtract(eiff.Multiply(eiqi));
                            eiee = t;
                            t = eicc;
                            eicc = eiaa.Subtract((long)eicc.ToInt32Checked() * eiqi);
                            eiaa = t;
                            t = eidd;
                            eidd = eibb.Subtract((long)eidd.ToInt32Checked() * eiqi);
                            // DebugUtility.Log("->eiffccdd="+eiff.wordCount+"/"+
                            // eicc.wordCount+"/"+eidd.wordCount);
                            eibb = t;
                        }
                        else
                        {
                            EInteger t = eiff;
                            // DebugUtility.Log("eiffccdd="+eiff.wordCount+"/"+
                            // eicc.wordCount+"/"+eidd.wordCount);
                            eiff = eiee.Subtract(eiff.Multiply(eiq));
                            eiee = t;
                            t = eicc;
                            eicc = eiaa.Subtract(eicc.Multiply(eiq));
                            eiaa = t;
                            t = eidd;
                            eidd = eibb.Subtract(eidd.Multiply(eiq));
                            // DebugUtility.Log("->eiffccdd="+eiff.wordCount+"/"+
                            // eicc.wordCount+"/"+eidd.wordCount);
                            eibb = t;
                        }
                    }
                }
                if (eib.IsZero)
                {
                    return eia;
                }
                while (!eib.IsZero)
                {
                    if (eia.wordCount <= 3 && eib.wordCount <= 3)
                    {
                        return EInteger.FromInt64(
                            GcdLong(eia.ToInt64Checked(), eib.ToInt64Checked()));
                    }
                    EInteger ta = eib;
                    eib = eia.Remainder(eib);
                    eia = ta;
                }
                return eia;
            }
        }

        private static EInteger MinBitLength(EInteger eia, EInteger eib)
        {
            return EInteger.Min(BL(eia), BL(eib));
        }

        private static EInteger MaxBitLength(EInteger eia, EInteger eib)
        {
            return EInteger.Max(BL(eia), BL(eib));
        }

        private static void SDivStep(EInteger[] eiam, EInteger eis)
        {
            // a, b, m[0] ... m[3]
            if (eiam[0].CompareTo(eiam[1]) > 0)
            {
                // a > b
                EInteger eia = eiam[0];
                EInteger eib = eiam[1];
                EInteger[] divrem = eia.DivRem(eib);
                if (BL(divrem[1]).CompareTo(eis) <= 0)
                {
                    divrem[0] = divrem[0].Subtract(1);
                    if (divrem[0].Sign < 0)
                    {
                        throw new InvalidOperationException();
                    }
                    divrem[1] = divrem[1].Add(eib);
                }
                eiam[3] = eiam[3].Add(eiam[2].Multiply(divrem[0]));
                eiam[5] = eiam[5].Add(eiam[4].Multiply(divrem[0]));
                eiam[0] = divrem[1];
            }
            else
            {
                // a <= b
                EInteger eia = eiam[1];
                EInteger eib = eiam[0];
                EInteger[] divrem = eia.DivRem(eib);
                if (BL(divrem[1]).CompareTo(eis) <= 0)
                {
                    divrem[0] = divrem[0].Subtract(1);
                    if (divrem[0].Sign < 0)
                    {
                        throw new InvalidOperationException();
                    }
                    divrem[1] = divrem[1].Add(eib);
                }
                eiam[2] = eiam[2].Add(eiam[3].Multiply(divrem[0]));
                eiam[4] = eiam[4].Add(eiam[5].Multiply(divrem[0]));
                eiam[1] = divrem[1];
            }
        }

        private static void LSDivStep(long[] longam, long ls)
        {
            if (longam[0] < 0)
            {
                throw new ArgumentException("longam[0] (" + longam[0] + ") is not" +
                  "\u0020greater or equal to 0");
            }
            if (longam[1] < 0)
            {
                throw new ArgumentException("longam[1] (" + longam[1] + ") is not" +
                  "\u0020greater or equal to 0");
            }
            checked
            {
                // a, b, m[0] ... m[3]
                if (longam[0] > longam[1])
                {
                    // a > b
                    long a = longam[0];
                    long b = longam[1];
                    long ddiv = a / b;
                    var ldivrem = new long[] {
            ddiv, a - (ddiv * b),
          };
                    if (LBL(ldivrem[1]) <= ls)
                    {
                        --ldivrem[0];
                        if (ldivrem[0] < 0)
                        {
                            throw new InvalidOperationException();
                        }
                        ldivrem[1] += b;
                    }
                    longam[3] += longam[2] * ldivrem[0];
                    longam[5] += longam[4] * ldivrem[0];
                    longam[0] = ldivrem[1];
                }
                else
                {
                    // a <= b
                    long a = longam[1];
                    long b = longam[0];
                    long ddiv = a / b;
                    var ldivrem = new long[] {
            ddiv, a - (ddiv * b),
          };
                    if (LBL(ldivrem[1]) <= ls)
                    {
                        --ldivrem[0];
                        if (ldivrem[0] < 0)
                        {
                            throw new InvalidOperationException();
                        }
                        ldivrem[1] += b;
                    }
                    longam[2] += longam[3] * ldivrem[0];
                    longam[4] += longam[5] * ldivrem[0];
                    longam[1] = ldivrem[1];
                }
            }
        }

        private static EInteger BL(EInteger eia)
        {
            if (eia.IsZero)
            {
                return EInteger.Zero;
            }
            EInteger ret = eia.GetUnsignedBitLengthAsEInteger();
            return ret;
        }

        private static int LBL(long mantlong)
        {
#if DEBUG
            if (mantlong < Int64.MinValue + 1)
            {
                throw new InvalidOperationException("\"mantlong\" (" + mantlong + ") is not" +
        "\u0020greater or equal to " + Int64.MinValue + 1);
            }
#endif

            return (mantlong == 0) ? 0 : NumberUtility.BitLength(Math.Abs(mantlong));
        }

        private static long[] LHalfGCD(long longa, long longb)
        {
#if DEBUG
            if (longa < 0)
            {
                throw new InvalidOperationException("\"longa\" (" + longa + ") is not" +
        "\u0020greater or equal to 0");
            }
            if (longb < 0)
            {
                throw new InvalidOperationException("\"longb\" (" + longb + ") is not" +
        "\u0020greater or equal to 0");
            }
#endif

            if (longa == 0 || longb == 0)
            {
                // DebugUtility.Log("LHalfGCD failed");
                return new long[] { longa, longb, 1, 0, 0, 1 };
            }
            long olonga = longa;
            long olongb = longb;
            var ret = new long[6];
            // DebugUtility.Log("LHalfGCD " + longa + " " + longb);
            checked
            {
                int ln = Math.Max(LBL(longa), LBL(longb));
                int lnmin = Math.Min(LBL(longa), LBL(longb));
                int ls = (ln >> 1) + 1;
                if (lnmin <= ls)
                {
                    // DebugUtility.Log("LHalfGCD failed: nmin<= s");
                    return new long[] { longa, longb, 1, 0, 0, 1 };
                }
                if (lnmin > ((ln * 3) >> 2) + 2)
                {
                    int p1 = ln >> 1;
                    long nhalfmask = (1L << p1) - 1;
                    long longah = longa >> p1;
                    long longal = longa & nhalfmask;
                    long longbh = longb >> p1;
                    long longbl = longb & nhalfmask;
                    long[] ret2 = LHalfGCD(longah, longbh);
                    if (ret2 == null)
                    {
                        return null;
                    }
                    Array.Copy(ret2, 0, ret, 0, 6);
                    longa = (longal * ret2[5]) - (longbl * ret2[3]);
                    longb = (longbl * ret2[2]) - (longal * ret2[4]);
                    longa += ret2[0] << p1;
                    longb += ret2[1] << p1;
                    if (longa < 0 || longb < 0)
                    {
                        throw new InvalidOperationException(
                          "Internal error: longa=" + olonga + " olongb=" +
                          olongb);
                    }
                }
                else
                {
                    // Set M to identity
                    ret[2] = 1;
                    ret[3] = 0;
                    ret[4] = 0;
                    ret[5] = 1;
                }
                ret[0] = longa;
                ret[1] = longb;
                while (Math.Max(LBL(ret[0]), LBL(ret[1])) > ((ln * 3) >> 2) + 1 &&
                  LBL(ret[0] - ret[1]) > ls)
                {
                    if (ret[0] < 0 || ret[1] < 0)
                    {
                        throw new InvalidOperationException(
                          "Internal error: longa=" + olonga + " olongb=" +
                          olongb);
                    }
                    LSDivStep(ret, ls);
                }
                longa = ret[0];
                longb = ret[1];
                if (Math.Min(LBL(longa), LBL(longb)) > ls + 2)
                {
                    ln = Math.Max(LBL(longa), LBL(longb));
                    int p1 = ((ls * 2) - ln) + 1;
                    long nhalfmask = (1L << p1) - 1;
                    long longah = longa >> p1;
                    long longal = longa & nhalfmask;
                    long longbh = longb >> p1;
                    long longbl = longb & nhalfmask;
                    long[] ret2 = LHalfGCD(longah, longbh);
                    if (ret2 == null)
                    {
                        return null;
                    }
                    longa = (longal * ret2[5]) - (longbl * ret2[3]);
                    longb = (longbl * ret2[2]) - (longal * ret2[4]);
                    longa += ret2[0] << p1;
                    longb += ret2[1] << p1;
                    if (longa < 0 || longb < 0)
                    {
                        throw new InvalidOperationException("Internal error");
                    }
                    long ma, mb, mc, md;
                    ma = (ret[2] * ret2[2]) + (ret[3] * ret2[4]);
                    mb = (ret[2] * ret2[3]) + (ret[3] * ret2[5]);
                    mc = (ret[4] * ret2[2]) + (ret[5] * ret2[4]);
                    md = (ret[4] * ret2[3]) + (ret[5] * ret2[5]);
                    ret[2] = ma;
                    ret[3] = mb;
                    ret[4] = mc;
                    ret[5] = md;
                }
                ret[0] = longa;
                ret[1] = longb;
                while (LBL(ret[0] - ret[1]) > ls)
                {
                    if (ret[0] < 0 || ret[1] < 0)
                    {
                        throw new InvalidOperationException("Internal error");
                    }
                    LSDivStep(ret, ls);
                }
                if (ret[0] < 0 || ret[1] < 0)
                {
                    throw new InvalidOperationException("Internal error");
                }
#if DEBUG
                /* long[] lret3 = SlowSgcd(olonga, olongb);
                if (ret[0] != lret3[0] || ret[1] != lret3[1] ||
                    ret[2] != lret3[2] || ret[3] != lret3[3] ||
                    ret[4] != lret3[4] || ret[5] != lret3[5]) {
                   var sb = new StringBuilder();
                   sb.Append("eia1=" + olonga + "\n");
                   sb.Append("eib1=" + olongb + "\n");
                   for (int k = 0; k < 6; ++k) {
                     sb.Append("expected_" + k + "=" + lret3[k] + "\n");
                     sb.Append("got______" + k + "=" + ret[k] + "\n");
                   }
                  throw new InvalidOperationException("" + sb);
                }
                */
                // Verify det(M) == 1
                if (ret[2] < 0 || ret[3] < 0 || ret[4] < 0 ||
                  ret[5] < 0)
                {
                    throw new InvalidOperationException("Internal error");
                }
                if ((ret[2] * ret[5]) - (ret[3] * ret[4]) != 1)
                {
                    throw new InvalidOperationException("Internal error");
                }
                if (LBL(ret[0] - ret[1]) > ls)
                {
                    throw new InvalidOperationException("Internal error");
                }
#endif
            }
            return ret;
        }

        private static long[] SlowSgcd(long longa, long longb)
        {
            var ret = new long[] { longa, longb, 1, 0, 0, 1 };
            int ls = Math.Max(LBL(longa), LBL(longb));
            ls = (ls >> 1) + 1;
            while (LBL(ret[0] - ret[1]) > ls)
            {
                LSDivStep(ret, ls);
            }
            return ret;
        }

        private static EInteger[] SlowSgcd(EInteger eia, EInteger eib)
        {
            var ret = new EInteger[] {
         eia, eib, EInteger.One, EInteger.Zero,
         EInteger.Zero, EInteger.One,
       };
            EInteger eis = EInteger.Max(BL(eia), BL(eib));
            eis = eis.ShiftRight(1).Add(1);
            while (BL(ret[0].Subtract(ret[1])).CompareTo(eis) > 0)
            {
                SDivStep(ret, eis);
            }
            return ret;
        }

        // Implements Niels Moeller's Half-GCD algorithm from 2008
        private static EInteger[] HalfGCD(EInteger eia, EInteger eib)
        {
            if (eia.Sign < 0)
            {
                throw new InvalidOperationException("doesn't satisfy !eia.IsNegative");
            }
            if (eib.Sign < 0)
            {
                throw new InvalidOperationException("doesn't satisfy !eib.IsNegative");
            }
            EInteger oeia = eia;
            EInteger oeib = eib;
            if (eia.IsZero || eib.IsZero)
            {
                // DebugUtility.Log("HalfGCD failed");
                return new EInteger[] {
          eia, eib, EInteger.One, EInteger.Zero,
          EInteger.Zero, EInteger.One,
        };
            }
            var ret = new EInteger[6];
            // DebugUtility.Log("HalfGCD " + eia + " " + eib);
            if (eia.CanFitInInt64() && eib.CanFitInInt64())
            {
                long[] lret = LHalfGCD(eia.ToInt64Checked(), eib.ToInt64Checked());
                if (lret == null)
                {
                    return null;
                }
                for (int i = 0; i < 6; ++i)
                {
                    ret[i] = EInteger.FromInt64(lret[i]);
                }
                return ret;
            }
            EInteger ein = MaxBitLength(eia, eib);
            EInteger einmin = MinBitLength(eia, eib);
            long ln = ein.CanFitInInt64() ? ein.ToInt64Checked() : -1;
            EInteger eis = ein.ShiftRight(1).Add(1);
            if (einmin.CompareTo(eis) <= 0)
            {
                // DebugUtility.Log("HalfGCD failed: nmin<= s");
                return new EInteger[] {
           eia, eib, EInteger.One, EInteger.Zero,
           EInteger.Zero, EInteger.One,
         };
            }
            EInteger eiah, eial, eibh, eibl;
            if (einmin.CompareTo(ein.Multiply(3).ShiftRight(2).Add(2)) > 0)
            {
                EInteger p1 = ein.ShiftRight(1);
                EInteger nhalfmask = EInteger.FromInt32(1).ShiftLeft(p1).Subtract(1);
                eiah = eia.ShiftRight(p1);
                eial = eia.And(nhalfmask);
                eibh = eib.ShiftRight(p1);
                eibl = eib.And(nhalfmask);
                EInteger[] ret2 = HalfGCD(eiah, eibh);
                if (ret2 == null)
                {
                    return null;
                }
                Array.Copy(ret2, 0, ret, 0, 6);
                eia = eial.Multiply(ret2[5]).Subtract(eibl.Multiply(ret2[3]));
                eib = eibl.Multiply(ret2[2]).Subtract(eial.Multiply(ret2[4]));
                eia = eia.Add(ret2[0].ShiftLeft(p1));
                eib = eib.Add(ret2[1].ShiftLeft(p1));
                if (eia.Sign < 0 || eib.Sign < 0)
                {
                    throw new InvalidOperationException(
                      "Internal error: oeia=" + oeia + " oeib=" +
                        oeib + " eiah=" + eiah + " eibh=" + eibh);
                }
            }
            else
            {
                // Set M to identity
                ret[2] = EInteger.FromInt32(1);
                ret[3] = EInteger.FromInt32(0);
                ret[4] = EInteger.FromInt32(0);
                ret[5] = EInteger.FromInt32(1);
            }
            ret[0] = eia;
            ret[1] = eib;
            /*
            for (int k = 0; k < 6; ++k) {
              DebugUtility.Log("ret_afterloop1_"+ k + "=" +
                 ret[k].ToRadixString(16));
            }
            */
            while (MaxBitLength(ret[0], ret[1]).CompareTo(
             ein.Multiply(3).ShiftRight(2).Add(1)) > 0 &&
           BL(ret[0].Subtract(ret[1])).CompareTo(eis) > 0)
            {
                if (ret[0].Sign < 0 || ret[1].Sign < 0)
                {
                    throw new InvalidOperationException(
                      "Internal error: eia=" + oeia + " oeib=" +
                        oeib);
                }
                SDivStep(ret, eis);
                // for (int k = 0; k < 6; ++k) {
                // DebugUtility.Log("ret_loop2_"+ k + "=" + ret[k].ToRadixString(16));
                // }
            }
            // for (int k = 0; k < 6; ++k) {
            // DebugUtility.Log("ret_afterloop2_"+ k + "=" +
            // ret[k].ToRadixString(16));
            // }
            eia = ret[0];
            eib = ret[1];
            if (MinBitLength(eia, eib).CompareTo(eis.Add(2)) > 0)
            {
                ein = MaxBitLength(eia, eib);
                EInteger p1 = eis.Add(eis).Subtract(ein).Add(1);
                EInteger nhalfmask = EInteger.FromInt32(1).ShiftLeft(p1).Subtract(1);
                eiah = eia.ShiftRight(p1);
                eial = eia.And(nhalfmask);
                eibh = eib.ShiftRight(p1);
                eibl = eib.And(nhalfmask);
                EInteger[] ret2 = HalfGCD(eiah, eibh);
                if (ret2 == null)
                {
                    return null;
                }
                eia = eial.Multiply(ret2[5]).Subtract(eibl.Multiply(ret2[3]));
                eib = eibl.Multiply(ret2[2]).Subtract(eial.Multiply(ret2[4]));
                eia = eia.Add(ret2[0].ShiftLeft(p1));
                eib = eib.Add(ret2[1].ShiftLeft(p1));
                if (eia.Sign < 0 || eib.Sign < 0)
                {
                    throw new InvalidOperationException("Internal error");
                }
                EInteger ma, mb, mc, md;
                // DebugUtility.Log("m "+Arrays.toString(new
                // EInteger[] { ret[2], ret[3], ret[4], ret[5]}));
                // DebugUtility.Log("m' "+Arrays.toString(new
                // EInteger[] { ret2[2], ret2[3], ret2[4], ret2[5]}));
                ma = ret[2].Multiply(ret2[2]).Add(ret[3].Multiply(ret2[4]));
                mb = ret[2].Multiply(ret2[3]).Add(ret[3].Multiply(ret2[5]));
                mc = ret[4].Multiply(ret2[2]).Add(ret[5].Multiply(ret2[4]));
                md = ret[4].Multiply(ret2[3]).Add(ret[5].Multiply(ret2[5]));
                ret[2] = ma;
                ret[3] = mb;
                ret[4] = mc;
                ret[5] = md;
                // DebugUtility.Log("newm "+Arrays.toString(ret));
            }
            ret[0] = eia;
            ret[1] = eib;
            // for (int k = 0; k < 6; ++k) {
            // DebugUtility.Log("ret_afterloop3["+k+"]=" +
            // ret[k].ToRadixString(16));
            // }
            while (BL(ret[0].Subtract(ret[1])).CompareTo(eis) > 0)
            {
                if (ret[0].Sign < 0 || ret[1].Sign < 0)
                {
                    throw new InvalidOperationException("Internal error");
                }
                SDivStep(ret, eis);
                // DebugUtility.Log("[sdiv2]ret="+Arrays.toString(ret));
            }
#if DEBUG
            /* EInteger[] ret3 = SlowSgcd(oeia, oeib);
            if (!ret[0].Equals(ret3[0]) ||
                   !ret[1].Equals(ret3[1]) ||
                   !ret[2].Equals(ret3[2]) ||
                   !ret[3].Equals(ret3[3]) ||
                   !ret[4].Equals(ret3[4]) ||
                   !ret[5].Equals(ret3[5])) {
               var sb = new StringBuilder();
               sb.Append("eia1=" + oeia + "\n");
               sb.Append("eib1=" + oeib + "\n");
               for (int k = 0; k < 6; ++k) {
                 sb.Append("expected_" + k + "=" + ret3[k] + "\n");
                 sb.Append("got______" + k + "=" + ret[k] + "\n");
               }
              throw new InvalidOperationException("" + sb);
            }
            */
            if (ret[0].Sign < 0 || ret[1].Sign < 0)
            {
                throw new InvalidOperationException("Internal error");
            }
            // Verify det(M) == 1
            if (ret[2].Sign < 0 || ret[3].Sign < 0 || ret[4].Sign < 0 ||
              ret[5].Sign < 0)
            {
                throw new InvalidOperationException("Internal error");
            }
            if
            (ret[2].Multiply(ret[5]).Subtract(ret[3].Multiply(ret[4])).CompareTo(1) !=
              0)
            {
                throw new InvalidOperationException("Internal error");
            }
            if (BL(ret[0].Subtract(ret[1])).CompareTo(eis) > 0)
            {
                throw new InvalidOperationException("Internal error");
            }
#endif
            return ret;
        }

        private static EInteger SubquadraticGCD(EInteger eia, EInteger eib)
        {
            EInteger ein = MaxBitLength(eia, eib);
            var ret = new EInteger[] { eia, eib };
            while (true)
            {
                if (ein.CompareTo(48) < 0)
                {
                    break;
                }
                // DebugUtility.Log("eia=" + ret[0].ToRadixString(16));
                // DebugUtility.Log("eib=" + ret[1].ToRadixString(16));
                EInteger nhalf = ein.ShiftRight(1);
                EInteger nhalfmask =
                  EInteger.FromInt32(1).ShiftLeft(nhalf).Subtract(1);
                EInteger eiah = ret[0].ShiftRight(nhalf);
                EInteger eial = ret[0].And(nhalfmask);
                EInteger eibh = ret[1].ShiftRight(nhalf);
                EInteger eibl = ret[1].And(nhalfmask);
                // DebugUtility.Log("eiah->" + eiah.ToRadixString(16));
                // DebugUtility.Log("eibh->" + eibh.ToRadixString(16));
                EInteger[] hgcd = HalfGCD(eiah, eibh);
                if (hgcd == null)
                {
                    // DebugUtility.Log("hgcd failed");
                    break;
                }
                eia = eial.Multiply(hgcd[5]).Subtract(eibl.Multiply(hgcd[3]));
                eib = eibl.Multiply(hgcd[2]).Subtract(eial.Multiply(hgcd[4]));
                eia = eia.Add(hgcd[0].ShiftLeft(nhalf));
                eib = eib.Add(hgcd[1].ShiftLeft(nhalf));
                // DebugUtility.Log("eia->" + eia.ToRadixString(16));
                // DebugUtility.Log("eib->" + eib.ToRadixString(16));
                if (eia.Sign < 0 || eib.Sign < 0)
                {
                    var sb = new StringBuilder();
                    sb.Append("eia=" + ret[0] + "\n");
                    sb.Append("eib=" + ret[1] + "\n");
                    for (int k = 0; k < 6; ++k)
                    {
                        sb.Append("hgcd_" + k + "=" + hgcd[k].ToRadixString(16));
                        sb.Append("\n");
                    }
                    throw new InvalidOperationException("Internal error\n" + sb);
                }
                if (ret[0].Equals(eia) && ret[1].Equals(eib))
                {
                    // Didn't change
                    break;
                }
                ein = MaxBitLength(eia, eib);
                ret[0] = eia;
                ret[1] = eib;
            }
            // DebugUtility.Log("eia final "+eia.ToRadixString(16));
            // DebugUtility.Log("eib final "+eib.ToRadixString(16));
            return BaseGcd(ret[0], ret[1]);
        }

        /// <summary>Returns the number of decimal digits used by this integer,
        /// in the form of an arbitrary-precision integer.</summary>
        /// <returns>The number of digits in the decimal form of this integer.
        /// Returns 1 if this number is 0.</returns>
        public EInteger GetDigitCountAsEInteger()
        {
            // NOTE: All digit counts can currently fit in Int64, so just
            // use GetDigitCountAsInt64 for the time being
            return EInteger.FromInt64(this.GetDigitCountAsInt64());
        }

        /// <summary>Returns the number of decimal digits used by this
        /// integer.</summary>
        /// <returns>The number of digits in the decimal form of this integer.
        /// Returns 1 if this number is 0.</returns>
        /// <exception cref='OverflowException'>The return value would exceed
        /// the range of a 32-bit signed integer.</exception>
        [Obsolete("This method may overflow. Use GetDigitCountAsEInteger instead.")]
        public int GetDigitCount()
        {
            long dc = this.GetDigitCountAsInt64();
            if (dc < Int32.MinValue || dc > Int32.MaxValue)
            {
                throw new OverflowException();
            }
            return checked((int)dc);
        }

        /// <summary>Returns the number of decimal digits used by this integer,
        /// in the form of a 64-bit signed integer.</summary>
        /// <returns>The number of digits in the decimal form of this integer.
        /// Returns 1 if this number is 0. Returns 2^63 - 1(
        /// <c>Int64.MaxValue</c> in.NET or <c>Long.MAX_VALUE</c> in Java) if
        /// the number of decimal digits is 2^63 - 1 or greater. (Use
        /// <c>GetDigitCountAsEInteger</c> instead if the application relies on
        /// the exact number of decimal digits.).</returns>
        public long GetDigitCountAsInt64()
        {
            // NOTE: Currently can't be 2^63-1 or greater, due to int32 word counts
            EInteger ei = this;
            long retval;
            if (ei.IsZero)
            {
                return 1;
            }
            retval = 0L;
            while (true)
            {
                if (ei.CanFitInInt64())
                {
                    long value = ei.ToInt64Checked();
                    if (value == 0)
                    {
                        // Treat zero after division as having no digits
                        break;
                    }
                    if (value == Int64.MinValue)
                    {
                        retval += 19;
                        break;
                    }
                    if (value < 0)
                    {
                        value = -value;
                    }
                    if (value >= 1000000000L)
                    {
                        retval += (value >= 1000000000000000000L) ? 19 : ((value >=
                              100000000000000000L) ? 18 : ((value >= 10000000000000000L) ?
                              17 : ((value >= 1000000000000000L) ? 16 :
                                ((value >= 100000000000000L) ? 15 : ((value
                                      >= 10000000000000L) ?
                                    14 : ((value >= 1000000000000L) ? 13 : ((value
                            >= 100000000000L) ? 12 : ((value >= 10000000000L) ?
                                          11 : ((value >= 1000000000L) ? 10 : 9)))))))));
                    }
                    else
                    {
                        var v2 = (int)value;
                        retval += (v2 >= 100000000) ? 9 : ((v2 >= 10000000) ? 8 : ((v2 >=
                                1000000) ? 7 : ((v2 >= 100000) ? 6 : ((v2
                                    >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ?
                                      3 : ((v2 >= 10) ? 2 : 1)))))));
                    }
                    break;
                }
                // NOTE: Bitlength accurate for wordCount<1000000 here, only as
                // an approximation
                int bitlen = (ei.wordCount < 1000000) ?
                  (int)ei.GetUnsignedBitLengthAsInt64() :
                  Int32.MaxValue;
                var maxDigits = 0;
                var minDigits = 0;
                if (bitlen <= 2135)
                {
                    // (x*631305) >> 21 is an approximation
                    // to trunc(x*log10(2)) that is correct up
                    // to x = 2135; the multiplication would require
                    // up to 31 bits in all cases up to 2135
                    // (cases up to 63 are already handled above)
                    minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                    maxDigits = 1 + ((bitlen * 631305) >> 21);
                    if (minDigits == maxDigits)
                    {
                        // Number of digits is the same for
                        // all numbers with this bit length
                        retval += minDigits;
                        break;
                    }
                }
                else if (bitlen <= 6432162)
                {
                    // Much more accurate approximation
                    // Approximation of ln(2)/ln(10)
                    minDigits = 1 + (int)(((long)(bitlen - 1) * 661971961083L) >> 41);
                    maxDigits = 1 + (int)(((long)bitlen * 661971961083L) >> 41);
                    if (minDigits == maxDigits)
                    {
                        // Number of digits is the same for
                        // all numbers with this bit length
                        retval += minDigits;
                        break;
                    }
                }
                if (ei.wordCount >= 100)
                {
                    long digits = ei.wordCount * 3;
                    EInteger pow = NumberUtility.FindPowerOfTen(digits);
                    EInteger div = ei.Divide(pow);
                    retval += digits;
                    ei = div;
                    continue;
                }
                if (bitlen <= 2135)
                {
                    retval += ei.Abs().CompareTo(NumberUtility.FindPowerOfTen(
                          minDigits)) >= 0 ? maxDigits : minDigits;
                    break;
                }
                else if (bitlen < 50000)
                {
                    retval += ei.Abs().CompareTo(NumberUtility.FindPowerOfTen(
                          minDigits + 1)) >= 0 ? maxDigits + 1 : minDigits + 1;
                    break;
                }
                short[] tempReg = null;
                int currentCount = ei.wordCount;
                var done = false;
                while (!done && currentCount != 0)
                {
                    if (currentCount == 1 || (currentCount == 2 && tempReg[1] == 0))
                    {
                        int rest = ((int)tempReg[0]) & ShortMask;
                        if (rest >= 10000)
                        {
                            retval += 5;
                        }
                        else if (rest >= 1000)
                        {
                            retval += 4;
                        }
                        else if (rest >= 100)
                        {
                            retval += 3;
                        }
                        else if (rest >= 10)
                        {
                            retval += 2;
                        }
                        else
                        {
                            ++retval;
                        }
                        break;
                    }
                    if (currentCount == 2 && tempReg[1] > 0 && tempReg[1] <= 0x7fff)
                    {
                        int rest = ((int)tempReg[0]) & ShortMask;
                        rest |= (((int)tempReg[1]) & ShortMask) << 16;
                        if (rest >= 1000000000)
                        {
                            retval += 10;
                        }
                        else if (rest >= 100000000)
                        {
                            retval += 9;
                        }
                        else if (rest >= 10000000)
                        {
                            retval += 8;
                        }
                        else if (rest >= 1000000)
                        {
                            retval += 7;
                        }
                        else if (rest >= 100000)
                        {
                            retval += 6;
                        }
                        else if (rest >= 10000)
                        {
                            retval += 5;
                        }
                        else if (rest >= 1000)
                        {
                            retval += 4;
                        }
                        else if (rest >= 100)
                        {
                            retval += 3;
                        }
                        else if (rest >= 10)
                        {
                            retval += 2;
                        }
                        else
                        {
                            ++retval;
                        }
                        break;
                    }
                    else
                    {
                        int wci = currentCount;
                        short remainderShort = 0;
                        int quo, rem;
                        var firstdigit = false;
                        short[] dividend = tempReg ?? ei.words;
                        // Divide by 10000
                        while (!done && (wci--) > 0)
                        {
                            int curValue = ((int)dividend[wci]) & ShortMask;
                            int currentDividend = unchecked((int)(curValue |
                                  ((int)remainderShort << 16)));
                            quo = currentDividend / 10000;
                            if (!firstdigit && quo != 0)
                            {
                                firstdigit = true;
                                // Since we are dividing from left to right, the first
                                // nonzero result is the first part of the
                                // new quotient
                                // NOTE: Bitlength accurate for wci<1000000 here, only as
                                // an approximation
                                bitlen = (wci < 1000000) ? GetUnsignedBitLengthEx(
                                    quo,
                                    wci + 1) :
                                  Int32.MaxValue;
                                if (bitlen <= 2135)
                                {
                                    // (x*631305) >> 21 is an approximation
                                    // to trunc(x*log10(2)) that is correct up
                                    // to x = 2135; the multiplication would require
                                    // up to 31 bits in all cases up to 2135
                                    // (cases up to 64 are already handled above)
                                    minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                                    maxDigits = 1 + ((bitlen * 631305) >> 21);
                                    if (minDigits == maxDigits)
                                    {
                                        // Number of digits is the same for
                                        // all numbers with this bit length
                                        // NOTE: The 4 is the number of digits just
                                        // taken out of the number, and "i" is the
                                        // number of previously known digits
                                        retval += minDigits + 4;
                                        done = true;
                                        break;
                                    }
                                    if (minDigits > 1)
                                    {
                                        int maxDigitEstimate = maxDigits + 4;
                                        int minDigitEstimate = minDigits + 4;
                                        retval += ei.Abs().CompareTo(NumberUtility.FindPowerOfTen(
                                    minDigitEstimate)) >= 0 ? retval + maxDigitEstimate : retval +
                                          minDigitEstimate;
                                        done = true;
                                        break;
                                    }
                                }
                                else if (bitlen <= 6432162)
                                {
                                    // Much more accurate approximation
                                    // Approximation of ln(2)/ln(10)
                                    minDigits = 1 + (int)(((long)(bitlen - 1) * 661971961083L) >>
                                        41);
                                    maxDigits = 1 + (int)(((long)bitlen * 661971961083L) >> 41);
                                    if (minDigits == maxDigits)
                                    {
                                        // Number of digits is the same for
                                        // all numbers with this bit length
                                        retval += minDigits + 4;
                                        done = true;
                                        break;
                                    }
                                }
                            }
                            if (tempReg == null)
                            {
                                if (quo != 0)
                                {
                                    tempReg = new short[ei.wordCount];
                                    Array.Copy(ei.words, tempReg, tempReg.Length);
                                    // Use the calculated word count during division;
                                    // zeros that may have occurred in division
                                    // are not incorporated in the tempReg
                                    currentCount = wci + 1;
                                    tempReg[wci] = unchecked((short)quo);
                                }
                            }
                            else
                            {
                                tempReg[wci] = unchecked((short)quo);
                            }
                            rem = currentDividend - (10000 * quo);
                            remainderShort = unchecked((short)rem);
                        }
                        // Recalculate word count
                        while (currentCount != 0 && tempReg[currentCount - 1] == 0)
                        {
                            --currentCount;
                        }
                        retval += 4;
                    }
                }
            }
            return retval;
        }

        /// <summary>Returns the hash code for this instance. No application or
        /// process IDs are used in the hash code calculation.</summary>
        /// <returns>A 32-bit signed integer.</returns>
        public override int GetHashCode()
        {
            var hashCodeValue = 0;
            unchecked
            {
                hashCodeValue += 1000000007 * this.Sign;
                if (this.words != null)
                {
                    for (var i = 0; i < this.wordCount; ++i)
                    {
                        hashCodeValue += 1000000013 * this.words[i];
                    }
                }
            }
            return hashCodeValue;
        }

        /// <summary>Gets the bit position of the lowest set bit in this
        /// number's absolute value. (This will also be the position of the
        /// lowest set bit in the number's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
        /// ).).</summary>
        /// <returns>The bit position of the lowest bit set in the number's
        /// absolute value, starting at 0. Returns -1 if this value is
        /// 0.</returns>
        [Obsolete("This method may overflow. Use GetLowBitAsEInteger instead.")]
        public int GetLowBit()
        {
            return this.GetLowBitAsEInteger().ToInt32Checked();
        }

        /// <summary>Gets the bit position of the lowest set bit in this
        /// number's absolute value, in the form of a 64-bit signed integer.
        /// (This will also be the position of the lowest set bit in the
        /// number's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
        /// ).).</summary>
        /// <returns>The bit position of the lowest bit set in the number's
        /// absolute value, starting at 0. Returns -1 if this value is 0 or
        /// odd. Returns 2^63 - 1 ( <c>Int64.MaxValue</c> in.NET or
        /// <c>Long.MAX_VALUE</c> in Java) if this number is other than zero
        /// but the lowest set bit is at 2^63 - 1 or greater. (Use
        /// <c>GetLowBitAsEInteger</c> instead if the application relies on the
        /// exact value of the lowest set bit position.).</returns>
        public long GetLowBitAsInt64()
        {
            // NOTE: Currently can't be 2^63-1 or greater, due to int32 word counts
            long retSetBitLong = 0;
            for (var i = 0; i < this.wordCount; ++i)
            {
                int c = ((int)this.words[i]) & ShortMask;
                if (c == 0)
                {
                    retSetBitLong += 16;
                }
                else
                {
                    int rsb = (((c << 15) & ShortMask) != 0) ? 0 : ((((c <<
                              14) & ShortMask) != 0) ? 1 : ((((c <<
                                13) & ShortMask) != 0) ? 2 : ((((c <<
                                  12) & ShortMask) != 0) ? 3 : ((((c << 11) &
                                  0xffff) != 0) ? 4 : ((((c << 10) & ShortMask) != 0) ?
                                5 : ((((c << 9) & ShortMask) != 0) ? 6 : ((((c <<
                                          8) & ShortMask) != 0) ? 7 : ((((c << 7) &
                                          ShortMask) != 0) ? 8 : ((((c << 6) &
          ShortMask) != 0) ? 9 :
                                        ((((c << 5) & ShortMask) != 0) ? 10 : ((((c <<
                                                  4) & ShortMask) != 0) ? 11 : ((((c <<
          3) &
                                                  0xffff) != 0) ? 12 : ((((c << 2) &
                                                    0xffff) != 0) ? 13 : ((((c << 1) &
                                                      ShortMask) != 0) ? 14 :
          15))))))))))))));
                    retSetBitLong += rsb;
                    return retSetBitLong;
                }
            }
            return -1;
        }

        /// <summary>Gets the bit position of the lowest set bit in this
        /// number's absolute value, in the form of an arbitrary-precision
        /// integer. (This will also be the position of the lowest set bit in
        /// the number's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
        /// ).).</summary>
        /// <returns>The bit position of the lowest bit set in the number's
        /// absolute value, starting at 0. Returns -1 if this value is 0 or
        /// odd.</returns>
        public EInteger GetLowBitAsEInteger()
        {
            return EInteger.FromInt64(this.GetLowBitAsInt64());
        }

        /// <summary>Returns whether a bit is set in the two's-complement form
        /// (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
        /// this object's value.</summary>
        /// <param name='bigIndex'>The index, starting at zero, of the bit to
        /// test, where 0 is the least significant bit, 1 is the next least
        /// significant bit, and so on.</param>
        /// <returns><c>true</c> if the given bit is set in the two'
        /// s-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
        /// this object's value; otherwise, <c>false</c>.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigIndex'/> is null.</exception>
        public bool GetSignedBit(EInteger bigIndex)
        {
            if (bigIndex == null)
            {
                throw new ArgumentNullException(nameof(bigIndex));
            }
            if (bigIndex.Sign < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(bigIndex));
            }
            if (this.negative)
            {
                if (bigIndex.CanFitInInt32())
                {
                    return this.GetSignedBit(bigIndex.ToInt32Checked());
                }
                EInteger valueEWordPos = bigIndex.Divide(16);
                if (valueEWordPos.CompareTo(this.words.Length) >= 0)
                {
                    return true;
                }
                long tcindex = 0;
                while (valueEWordPos.CompareTo(EInteger.FromInt64(tcindex)) > 0 &&
                  this.words[checked((int)tcindex)] == 0)
                {
                    ++tcindex;
                }
                short tc;
                // NOTE: array indices are currently limited to Int32
                int wordpos = valueEWordPos.ToInt32Checked();
                unchecked
                {
                    tc = this.words[wordpos];
                    if (tcindex == wordpos)
                    {
                        --tc;
                    }
                    tc = (short)~tc;
                }
                int mod15 = bigIndex.Remainder(16).ToInt32Checked();
                return (bool)(((tc >> mod15) & 1) != 0);
            }
            else
            {
                return this.GetUnsignedBit(bigIndex);
            }
        }

        /// <summary>Returns whether a bit is set in the two's-complement form
        /// (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
        /// this object's value.</summary>
        /// <param name='index'>The index, starting at 0, of the bit to test,
        /// where 0 is the least significant bit, 1 is the next least
        /// significant bit, and so on.</param>
        /// <returns><c>true</c> if the given bit is set in the two'
        /// s-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) of
        /// this object's value; otherwise, <c>false</c>.</returns>
        public bool GetSignedBit(int index)
        {
            if (index < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }
            if (this.wordCount == 0)
            {
                return false;
            }
            if (this.negative)
            {
                var tcindex = 0;
                int wordpos = index / 16;
                if (wordpos >= this.words.Length)
                {
                    return true;
                }
                while (tcindex < wordpos && this.words[tcindex] == 0)
                {
                    ++tcindex;
                }
                short tc;
                unchecked
                {
                    tc = this.words[wordpos];
                    if (tcindex == wordpos)
                    {
                        --tc;
                    }
                    tc = (short)~tc;
                }
                return (bool)(((tc >> (int)(index & 15)) & 1) != 0);
            }
            return this.GetUnsignedBit(index);
        }

        /// <summary>Finds the minimum number of bits needed to represent this
        /// object's value, except for its sign, in the form of an
        /// arbitrary-precision integer. If the value is negative, finds the
        /// number of bits in the value equal to this object's absolute value
        /// minus 1. For example, all integers in the interval [-(2^63), (2^63)
        /// - 1], which is the same as the range of integers in Java's
        /// and.NET's <c>long</c> type, have a signed bit length of 63 or less,
        /// and all other integers have a signed bit length of greater than
        /// 63.</summary>
        /// <returns>The number of bits in this object's value, except for its
        /// sign. Returns 0 if this object's value is 0 or negative
        /// 1.</returns>
        public EInteger GetSignedBitLengthAsEInteger()
        {
            // NOTE: Currently can't be 2^63-1 or greater, due to int32 word counts
            return EInteger.FromInt64(this.GetSignedBitLengthAsInt64());
        }

        /// <summary>Finds the minimum number of bits needed to represent this
        /// object's value, except for its sign, in the form of a 64-bit signed
        /// integer. If the value is negative, finds the number of bits in the
        /// value equal to this object's absolute value minus 1. For example,
        /// all integers in the interval [-(2^63), (2^63) - 1], which is the
        /// same as the range of integers in Java's and.NET's <c>long</c> type,
        /// have a signed bit length of 63 or less, and all other integers have
        /// a signed bit length of greater than 63.</summary>
        /// <returns>The number of bits in this object's value, except for its
        /// sign. Returns 0 if this object's value is 0 or negative 1. Returns
        /// 2^63 - 1 ( <c>Int64.MaxValue</c> in.NET or <c>Long.MAX_VALUE</c> in
        /// Java) if the number of bits is 2^63 - 1 or greater. (Use
        /// <c>GetUnsignedBitLengthAsEInteger</c> instead if the application
        /// relies on the exact number of bits.).</returns>
        public long GetSignedBitLengthAsInt64()
        {
            // NOTE: Currently can't be 2^63-1 or greater, due to int32 word counts
            int wc = this.wordCount;
            if (wc != 0)
            {
                if (this.negative)
                {
                    // Two's complement operation
                    EInteger eiabs = this.Abs();
                    long eiabsbl = eiabs.GetSignedBitLengthAsInt64();
                    if (eiabs.IsPowerOfTwo)
                    {
                        // Absolute value is a power of 2
                        --eiabsbl;
                    }
                    return eiabsbl;
                }
                int numberValue = ((int)this.words[wc - 1]) & ShortMask;
                var wcextra = 0;
                if (numberValue != 0)
                {
                    wcextra = 16;
                    unchecked
                    {
                        if ((numberValue >> 8) == 0)
                        {
                            numberValue <<= 8;
                            wcextra -= 8;
                        }
                        if ((numberValue >> 12) == 0)
                        {
                            numberValue <<= 4;
                            wcextra -= 4;
                        }
                        if ((numberValue >> 14) == 0)
                        {
                            numberValue <<= 2;
                            wcextra -= 2;
                        }
                        wcextra = ((numberValue >> 15) == 0) ? wcextra - 1 : wcextra;
                    }
                }
                return (((long)wc - 1) * 16) + wcextra;
            }
            return 0;
        }

        /// <summary>Finds the minimum number of bits needed to represent this
        /// object's value, except for its sign. If the value is negative,
        /// finds the number of bits in the value equal to this object's
        /// absolute value minus 1. For example, all integers in the interval
        /// [-(2^63), (2^63) - 1], which is the same as the range of integers
        /// in Java's and.NET's <c>long</c> type, have a signed bit length of
        /// 63 or less, and all other integers have a signed bit length of
        /// greater than 63.</summary>
        /// <returns>The number of bits in this object's value, except for its
        /// sign. Returns 0 if this object's value is 0 or negative
        /// 1.</returns>
        /// <exception cref='OverflowException'>The return value would exceed
        /// the range of a 32-bit signed integer.</exception>
        [Obsolete("This method may overflow. Use GetSignedBitLength" +
            "AsEInteger instead.")]
        public int GetSignedBitLength()
        {
            return this.GetSignedBitLengthAsEInteger().ToInt32Checked();
        }

        /// <summary>Returns whether a bit is set in this number's absolute
        /// value.</summary>
        /// <param name='bigIndex'>The index, starting at zero, of the bit to
        /// test, where 0 is the least significant bit, 1 is the next least
        /// significant bit, and so on.</param>
        /// <returns><c>true</c> if the given bit is set in this number's
        /// absolute value.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigIndex'/> is null.</exception>
        public bool GetUnsignedBit(EInteger bigIndex)
        {
            if (bigIndex == null)
            {
                throw new ArgumentNullException(nameof(bigIndex));
            }
            if (bigIndex.Sign < 0)
            {
                throw new ArgumentException("bigIndex(" + bigIndex +
                  ") is less than 0");
            }
            if (bigIndex.CanFitInInt32())
            {
                return this.GetUnsignedBit(bigIndex.ToInt32Checked());
            }
            if (bigIndex.Divide(16).CompareTo(this.words.Length) < 0)
            {
                return false;
            }
            int index = bigIndex.ShiftRight(4).ToInt32Checked();
            int indexmod = bigIndex.Remainder(16).ToInt32Checked();
            return (bool)(((this.words[index] >> (int)indexmod) & 1) != 0);
        }

        /// <summary>Returns whether a bit is set in this number's absolute
        /// value.</summary>
        /// <param name='index'>The index, starting at 0, of the bit to test,
        /// where 0 is the least significant bit, 1 is the next least
        /// significant bit, and so on.</param>
        /// <returns><c>true</c> if the given bit is set in this number's
        /// absolute value.</returns>
        public bool GetUnsignedBit(int index)
        {
            if (index < 0)
            {
                throw new ArgumentException("index(" + index + ") is less than 0");
            }
            return ((index >> 4) < this.words.Length) &&
              ((bool)(((this.words[index >> 4] >> (int)(index & 15)) & 1) != 0));
        }

        /// <summary>Finds the minimum number of bits needed to represent this
        /// number's absolute value, in the form of an arbitrary-precision
        /// integer. For example, all integers in the interval [-((2^63) - 1),
        /// (2^63) - 1] have an unsigned bit length of 63 or less, and all
        /// other integers have an unsigned bit length of greater than 63. This
        /// interval is not the same as the range of integers in Java's
        /// and.NET's <c>long</c> type.</summary>
        /// <returns>The number of bits in this object's absolute value.
        /// Returns 0 if this object's value is 0, and returns 1 if the value
        /// is negative 1.</returns>
        public EInteger GetUnsignedBitLengthAsEInteger()
        {
            // NOTE: Currently can't be 2^63-1 or greater, due to int32 word counts
            return EInteger.FromInt64(this.GetUnsignedBitLengthAsInt64());
        }

        /// <summary>Finds the minimum number of bits needed to represent this
        /// number's absolute value, in the form of a 64-bit signed integer.
        /// For example, all integers in the interval [-((2^63) - 1), (2^63) -
        /// 1] have an unsigned bit length of 63 or less, and all other
        /// integers have an unsigned bit length of greater than 63. This
        /// interval is not the same as the range of integers in Java's
        /// and.NET's <c>long</c> type.</summary>
        /// <returns>The number of bits in this object's absolute value.
        /// Returns 0 if this object's value is 0, and returns 1 if the value
        /// is negative 1. Returns 2^63 - 1 ( <c>Int64.MaxValue</c> in.NET or
        /// <c>Long.MAX_VALUE</c> in Java) if the number of bits is 2^63 - 1 or
        /// greater. (Use <c>GetUnsignedBitLengthAsEInteger</c> instead if the
        /// application relies on the exact number of bits.).</returns>
        public long GetUnsignedBitLengthAsInt64()
        {
            // NOTE: Currently can't be 2^63-1 or greater, due to int32 word counts
            int wc = this.wordCount;
            if (wc != 0)
            {
                int numberValue = ((int)this.words[wc - 1]) & ShortMask;
                long longBase = ((long)wc - 1) << 4;
                if (numberValue == 0)
                {
                    return longBase;
                }
                wc = 16;
                unchecked
                {
                    if ((numberValue >> 8) == 0)
                    {
                        numberValue <<= 8;
                        wc -= 8;
                    }
                    if ((numberValue >> 12) == 0)
                    {
                        numberValue <<= 4;
                        wc -= 4;
                    }
                    if ((numberValue >> 14) == 0)
                    {
                        numberValue <<= 2;
                        wc -= 2;
                    }
                    if ((numberValue >> 15) == 0)
                    {
                        --wc;
                    }
                }
                return longBase + wc;
            }
            return 0;
        }

        /// <summary>Finds the minimum number of bits needed to represent this
        /// number's absolute value. For example, all integers in the interval
        /// [-((2^63) - 1), (2^63) - 1] have an unsigned bit length of 63 or
        /// less, and all other integers have an unsigned bit length of greater
        /// than 63. This interval is not the same as the range of integers in
        /// Java's and.NET's <c>long</c> type.</summary>
        /// <returns>The number of bits in this object's absolute value.
        /// Returns 0 if this object's value is 0, and returns 1 if the value
        /// is negative 1.</returns>
        /// <exception cref='OverflowException'>The return value would exceed
        /// the range of a 32-bit signed integer.</exception>
        [Obsolete("This method may overflow. Use GetUnsignedBitLength" +
            "AsEInteger instead.")]
        public int GetUnsignedBitLength()
        {
            return this.GetUnsignedBitLengthAsEInteger().ToInt32Checked();
        }

        /// <summary>Finds the modulus remainder that results when this
        /// instance is divided by the value of an arbitrary-precision integer.
        /// The modulus remainder is the same as the normal remainder if the
        /// normal remainder is positive, and equals divisor plus normal
        /// remainder if the normal remainder is negative.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='divisor'/> is less than 0.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='divisor'/> is null.</exception>
        public EInteger Mod(EInteger divisor)
        {
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            if (divisor.Sign < 0)
            {
                throw new ArithmeticException("Divisor is negative");
            }
            EInteger remainderEInt = this.Remainder(divisor);
            if (remainderEInt.Sign < 0)
            {
                remainderEInt = divisor.Add(remainderEInt);
            }
            return remainderEInt;
        }

        /// <summary>Finds the modulus remainder that results when this
        /// instance is divided by the value of another integer. The modulus
        /// remainder is the same as the normal remainder if the normal
        /// remainder is positive, and equals divisor plus normal remainder if
        /// the normal remainder is negative.</summary>
        /// <param name='smallDivisor'>The divisor of the modulus.</param>
        /// <returns>The modulus remainder.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='smallDivisor'/> is less than 0.</exception>
        public EInteger Mod(int smallDivisor)
        {
            if (smallDivisor < 0)
            {
                throw new ArithmeticException("Divisor is negative");
            }
            EInteger remainderEInt = this.Remainder(smallDivisor);
            if (remainderEInt.Sign < 0)
            {
                remainderEInt = EInteger.FromInt32(smallDivisor).Add(remainderEInt);
            }
            return remainderEInt;
        }

        /// <summary>Calculates the remainder when this arbitrary-precision
        /// integer raised to a certain power is divided by another
        /// arbitrary-precision integer.</summary>
        /// <param name='pow'>The power to raise this integer by.</param>
        /// <param name='mod'>The integer to divide the raised number
        /// by.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='pow'/> or <paramref name='mod'/> is null.</exception>
        public EInteger ModPow(EInteger pow, EInteger mod)
        {
            if (pow == null)
            {
                throw new ArgumentNullException(nameof(pow));
            }
            if (mod == null)
            {
                throw new ArgumentNullException(nameof(mod));
            }
            if (pow.Sign < 0)
            {
                throw new ArgumentException("pow(" + pow + ") is less than 0");
            }
            if (mod.Sign <= 0)
            {
                throw new ArgumentException("mod(" + mod + ") is not greater than 0");
            }
            EInteger r = EInteger.One;
            EInteger eiv = this;
            while (!pow.IsZero)
            {
                if (!pow.IsEven)
                {
                    r = (r * (EInteger)eiv).Mod(mod);
                }
                pow >>= 1;
                if (!pow.IsZero)
                {
                    eiv = (eiv * (EInteger)eiv).Mod(mod);
                }
            }
            return r;
        }

        /// <summary>Multiplies this arbitrary-precision integer by another
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='bigintMult'>Another arbitrary-precision
        /// integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision integer times another arbitrary-precision
        /// integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigintMult'/> is null.</exception>
        public EInteger Multiply(EInteger bigintMult)
        {
            if (bigintMult == null)
            {
                throw new ArgumentNullException(nameof(bigintMult));
            }
            if (this.wordCount == 0 || bigintMult.wordCount == 0)
            {
                return EInteger.Zero;
            }
            if (this.wordCount == 1 && this.words[0] == 1)
            {
                return this.negative ? bigintMult.Negate() : bigintMult;
            }
            if (bigintMult.wordCount == 1 && bigintMult.words[0] == 1)
            {
                return bigintMult.negative ? this.Negate() : this;
            }
            // DebugUtility.Log("multiply " + this + " " + bigintMult);
            short[] productreg;
            int productwordCount;
            var needShorten = true;
            if (this.wordCount == 1)
            {
                int wc;
                if (bigintMult.wordCount == 1)
                {
                    // NOTE: Result can't be 0 here, since checks
                    // for 0 were already made earlier in this function
                    productreg = new short[2];
                    int ba = ((int)this.words[0]) & ShortMask;
                    int bb = ((int)bigintMult.words[0]) & ShortMask;
                    ba = unchecked(ba * bb);
                    productreg[0] = unchecked((short)(ba & ShortMask));
                    productreg[1] = unchecked((short)((ba >> 16) & ShortMask));
                    short preg = productreg[1];
                    wc = (preg == 0) ? 1 : 2;
                    return new EInteger(
                        wc,
                        productreg,
                        this.negative ^ bigintMult.negative);
                }
                wc = bigintMult.wordCount;
                int regLength = wc + 1;
                productreg = new short[regLength];
                productreg[wc] = LinearMultiply(
                    productreg,
                    0,
                    bigintMult.words,
                    0,
                    this.words[0],
                    wc);
                productwordCount = productreg.Length;
                needShorten = false;
            }
            else if (bigintMult.wordCount == 1)
            {
                int wc = this.wordCount;
                int regLength = wc + 1;
                productreg = new short[regLength];
                productreg[wc] = LinearMultiply(
                    productreg,
                    0,
                    this.words,
                    0,
                    bigintMult.words[0],
                    wc);
                productwordCount = productreg.Length;
                needShorten = false;
            }
            else if (this.Equals(bigintMult))
            {
                int words1Size = this.wordCount;
                productreg = new short[words1Size + words1Size];
                productwordCount = productreg.Length;
                var workspace = new short[words1Size + words1Size];
                RecursiveSquare(
                  productreg,
                  0,
                  workspace,
                  0,
                  this.words,
                  0,
                  words1Size);
            }
            else if (this.wordCount <= MultRecursionThreshold &&
            bigintMult.wordCount <= MultRecursionThreshold)
            {
                int wc = this.wordCount + bigintMult.wordCount;
                productreg = new short[wc];
                productwordCount = productreg.Length;
                SchoolbookMultiply(
                  productreg,
                  0,
                  this.words,
                  0,
                  this.wordCount,
                  bigintMult.words,
                  0,
                  bigintMult.wordCount);
                needShorten = false;
            }
            else
            {
                int words1Size = this.wordCount;
                int words2Size = bigintMult.wordCount;
                productreg = new short[words1Size + words2Size];
                var workspace = new short[words1Size + words2Size];
                productwordCount = productreg.Length;
                AsymmetricMultiply(
                  productreg,
                  0,
                  workspace,
                  0,
                  this.words,
                  0,
                  words1Size,
                  bigintMult.words,
                  0,
                  words2Size);
            }
            // Recalculate word count
            while (productwordCount != 0 && productreg[productwordCount - 1] == 0)
            {
                --productwordCount;
            }
            if (needShorten)
            {
                productreg = ShortenArray(productreg, productwordCount);
            }
            return new EInteger(
                productwordCount,
                productreg,
                this.negative ^ bigintMult.negative);
        }

        private static EInteger MakeEInteger(
          short[] words,
          int wordsEnd,
          int offset,
          int count)
        {
            if (offset >= wordsEnd)
            {
                return EInteger.Zero;
            }
            int ct = Math.Min(count, wordsEnd - offset);
            while (ct != 0 && words[offset + ct - 1] == 0)
            {
                --ct;
            }
            if (ct == 0)
            {
                return EInteger.Zero;
            }
            var newwords = new short[ct];
            Array.Copy(words, offset, newwords, 0, ct);
            return new EInteger(ct, newwords, false);
        }

        private static void Toom3(
          short[] resultArr,
          int resultStart,
          short[] wordsA,
          int wordsAStart,
          int countA,
          short[] wordsB,
          int wordsBStart,
          int countB)
        {
            int imal = Math.Max(countA, countB);
            int im3 = (imal / 3) + (((imal % 3) + 2) / 3);
            EInteger m3mul16 = EInteger.FromInt32(im3).ShiftLeft(4);
            EInteger x0 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart,
                im3);
            EInteger x1 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart + im3,
                im3);
            EInteger x2 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart + (im3 * 2),
                im3);
            EInteger w0, wt1, wt2, wt3, w4;
            if (wordsA == wordsB && wordsAStart == wordsBStart &&
              countA == countB)
            {
                // Same array, offset, and count, so we're squaring
                w0 = x0.Multiply(x0);
                w4 = x2.Multiply(x2);
                EInteger x2x0 = x2.Add(x0);
                wt1 = x2x0.Add(x1);
                wt2 = x2x0.Subtract(x1);
                wt3 = x2.ShiftLeft(2).Add(x1.ShiftLeft(1)).Add(x0);
                wt1 = wt1.Multiply(wt1);
                wt2 = wt2.Multiply(wt2);
                wt3 = wt3.Multiply(wt3);
            }
            else
            {
                EInteger y0 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart,
                    im3);
                EInteger y1 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart + im3,
                    im3);
                EInteger y2 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart + (im3 * 2),
                    im3);
                w0 = x0.Multiply(y0);
                w4 = x2.Multiply(y2);
                EInteger x2x0 = x2.Add(x0);
                EInteger y2y0 = y2.Add(y0);
                wt1 = x2x0.Add(x1).Multiply(y2y0.Add(y1));
                wt2 = x2x0.Subtract(x1).Multiply(y2y0.Subtract(y1));
                wt3 = x2.ShiftLeft(2).Add(x1.ShiftLeft(1)).Add(x0)
                  .Multiply(y2.ShiftLeft(2).Add(y1.ShiftLeft(1)).Add(y0));
            }
            EInteger w4mul2 = w4.ShiftLeft(1);
            EInteger w4mul12 = w4mul2.Multiply(6);
            EInteger w0mul3 = w0.Multiply(3);
            EInteger w3 = w0mul3.Subtract(w4mul12).Subtract(wt1.Multiply(3))
              .Subtract(wt2).Add(wt3).Divide(6);
            EInteger w2 = wt1.Add(wt2).Subtract(w0.ShiftLeft(1))
              .Subtract(w4mul2).ShiftRight(1);
            EInteger w1 = wt1.Multiply(6).Add(w4mul12)
              .Subtract(wt3).Subtract(wt2).Subtract(wt2)
              .Subtract(w0mul3).Divide(6);
            if (m3mul16.CompareTo(0x70000000) < 0)
            {
                im3 <<= 4; // multiply by 16
                w0 = w0.Add(w1.ShiftLeft(im3));
                w0 = w0.Add(w2.ShiftLeft(im3 * 2));
                w0 = w0.Add(w3.ShiftLeft(im3 * 3));
                w0 = w0.Add(w4.ShiftLeft(im3 * 4));
            }
            else
            {
                w0 = w0.Add(w1.ShiftLeft(m3mul16));
                w0 = w0.Add(w2.ShiftLeft(m3mul16.Multiply(2)));
                w0 = w0.Add(w3.ShiftLeft(m3mul16.Multiply(3)));
                w0 = w0.Add(w4.ShiftLeft(m3mul16.Multiply(4)));
            }
            Array.Clear(resultArr, resultStart, countA + countB);
            Array.Copy(
              w0.words,
              0,
              resultArr,
              resultStart,
              Math.Min(countA + countB, w0.wordCount));
        }

        private static EInteger Interpolate(
          EInteger[] wts,
          int[] values,
          int divisor)
        {
            EInteger ret = EInteger.Zero;
            for (int i = 0; i < wts.Length; ++i)
            {
                int v = values[i];
                if (v == 0)
                {
                    continue;
                }
                else
                {
                    ret = (v == 1) ? ret.Add(wts[i]) : ((v == -1) ? ret.Subtract(
                          wts[i]) : ret.Add(wts[i].Multiply(v)));
                }
            }
            return ret.Divide(divisor);
        }
        /*
        public EInteger Toom4Multiply(EInteger eib) {
          var r = new short[this.wordCount + eib.wordCount];
          Toom4(r, 0, this.words, 0, this.wordCount, eib.words, 0, eib.wordCount);
          EInteger ret = MakeEInteger(r, r.Length, 0, r.Length);
          return (this.negative^eib.negative) ? ret.Negate() : ret;
        }
        */
        private static void Toom4(
          short[] resultArr,
          int resultStart,
          short[] wordsA,
          int wordsAStart,
          int countA,
          short[] wordsB,
          int wordsBStart,
          int countB)
        {
            int imal = Math.Max(countA, countB);
            int im3 = (imal / 4) + (((imal % 4) + 3) / 4);
            EInteger m3mul16 = EInteger.FromInt32(im3).ShiftLeft(4);
            EInteger x0 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart,
                im3);
            EInteger x1 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart + im3,
                im3);
            EInteger x2 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart + (im3 * 2),
                im3);
            EInteger x3 = MakeEInteger(
                wordsA,
                wordsAStart + countA,
                wordsAStart + (im3 * 3),
                im3);
            EInteger w0, wt1, wt2, wt3, wt4, wt5, w6;
            if (wordsA == wordsB && wordsAStart == wordsBStart &&
              countA == countB)
            {
                // Same array, offset, and count, so we're squaring
                w0 = x0.Multiply(x0);
                w6 = x3.Multiply(x3);
                EInteger x2mul2 = x2.ShiftLeft(1);
                EInteger x1mul4 = x1.ShiftLeft(2);
                EInteger x0mul8 = x0.ShiftLeft(3);
                EInteger x1x3 = x1.Add(x3);
                EInteger x0x2 = x0.Add(x2);
                wt1 = x3.Add(x2mul2).Add(x1mul4).Add(x0mul8);
                wt2 = x3.Negate().Add(x2mul2).Subtract(x1mul4).Add(x0mul8);
                wt3 = x0x2.Add(x1x3);
                wt4 = x0x2.Subtract(x1x3);
                wt5 = x0.Add(
                    x3.ShiftLeft(3)).Add(x2.ShiftLeft(2)).Add(x1.ShiftLeft(1));
                wt1 = wt1.Multiply(wt1);
                wt2 = wt2.Multiply(wt2);
                wt3 = wt3.Multiply(wt3);
                wt4 = wt4.Multiply(wt4);
                wt5 = wt5.Multiply(wt5);
            }
            else
            {
                EInteger y0 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart,
                    im3);
                EInteger y1 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart + im3,
                    im3);
                EInteger y2 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart + (im3 * 2),
                    im3);
                EInteger y3 = MakeEInteger(
                    wordsB,
                    wordsBStart + countB,
                    wordsBStart + (im3 * 3),
                    im3);
                w0 = x0.Multiply(y0);
                w6 = x3.Multiply(y3);
                EInteger x2mul2 = x2.ShiftLeft(1);
                EInteger x1mul4 = x1.ShiftLeft(2);
                EInteger x0mul8 = x0.ShiftLeft(3);
                EInteger y2mul2 = y2.ShiftLeft(1);
                EInteger y1mul4 = y1.ShiftLeft(2);
                EInteger y0mul8 = y0.ShiftLeft(3);
                EInteger x1x3 = x1.Add(x3);
                EInteger x0x2 = x0.Add(x2);
                EInteger y1y3 = y1.Add(y3);
                EInteger y0y2 = y0.Add(y2);
                wt1 = x3.Add(x2mul2).Add(x1mul4).Add(x0mul8);
                wt1 = wt1.Multiply(y3.Add(y2mul2).Add(y1mul4).Add(y0mul8));
                wt2 = x3.Negate().Add(x2mul2).Subtract(x1mul4).Add(x0mul8);
                wt2 = wt2.Multiply(
                    y3.Negate().Add(y2mul2).Subtract(y1mul4).Add(y0mul8));
                wt3 = x0x2.Add(x1x3);
                wt3 = wt3.Multiply(y0y2.Add(y1y3));
                wt4 = x0x2.Subtract(x1x3);
                wt4 = wt4.Multiply(y0y2.Subtract(y1y3));
                wt5 = x0.Add(
                    x3.ShiftLeft(3)).Add(x2.ShiftLeft(2)).Add(x1.ShiftLeft(1));
                wt5 = wt5.Multiply(
                    y0.Add(
                      y3.ShiftLeft(3)).Add(y2.ShiftLeft(2)).Add(y1.ShiftLeft(1)));
            }
            EInteger[] wts = { w0, wt1, wt2, wt3, wt4, wt5, w6 };
            var wts2 = new int[] {
        -90, 5, -3, -60, 20, 2,
        -90,
      };
            EInteger w1 = Interpolate(wts, wts2, 180);
            wts2 = new int[] {
        -120,
        1,
        1,
        -4,
        -4,
        0,
        6,
      };
            EInteger w2 = Interpolate(wts, wts2, 24);
            wts2 = new int[] {
        45,
        -1,
        0,
        27,
        -7,
        -1,
        45,
      };
            EInteger w3 = Interpolate(wts,
                wts2,
                18);
            wts2 = new int[] {
        96,
        -1,
        -1,
        16,
        16,
        0,
        -30,
      };
            EInteger w4 = Interpolate(
                wts,
                wts2,
                24);
            wts2 = new int[] {
        -360, 5, 3, -120, -40, 8,
        -360,
      };
            EInteger w5 = Interpolate(wts,
                wts2,
                180);
            if (m3mul16.CompareTo(0x70000000) < 0)
            {
                im3 <<= 4; // multiply by 16
                w0 = w0.Add(w1.ShiftLeft(im3));
                w0 = w0.Add(w2.ShiftLeft(im3 * 2));
                w0 = w0.Add(w3.ShiftLeft(im3 * 3));
                w0 = w0.Add(w4.ShiftLeft(im3 * 4));
                w0 = w0.Add(w5.ShiftLeft(im3 * 5));
                w0 = w0.Add(w6.ShiftLeft(im3 * 6));
            }
            else
            {
                w0 = w0.Add(w1.ShiftLeft(m3mul16));
                w0 = w0.Add(w2.ShiftLeft(m3mul16.Multiply(2)));
                w0 = w0.Add(w3.ShiftLeft(m3mul16.Multiply(3)));
                w0 = w0.Add(w4.ShiftLeft(m3mul16.Multiply(4)));
                w0 = w0.Add(w5.ShiftLeft(m3mul16.Multiply(5)));
                w0 = w0.Add(w6.ShiftLeft(m3mul16.Multiply(6)));
            }
            Array.Clear(resultArr, resultStart, countA + countB);
            Array.Copy(
              w0.words,
              0,
              resultArr,
              resultStart,
              Math.Min(countA + countB, w0.wordCount));
        }

        /// <summary>Gets the value of this object with the sign
        /// reversed.</summary>
        /// <returns>This object's value with the sign reversed.</returns>
        public EInteger Negate()
        {
            return this.wordCount == 0 ? this : new EInteger(
                this.wordCount,
                this.words,
                !this.negative);
        }

        /// <summary>Raises an arbitrary-precision integer to a
        /// power.</summary>
        /// <param name='bigPower'>The exponent to raise this integer
        /// to.</param>
        /// <returns>The result. Returns 1 if <paramref name='bigPower'/> is
        /// 0.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigPower'/> is null.</exception>
        /// <exception cref='ArgumentException'>BigPower is
        /// negative.</exception>
        public EInteger Pow(EInteger bigPower)
        {
            if (bigPower == null)
            {
                throw new ArgumentNullException(nameof(bigPower));
            }
            if (bigPower.Sign < 0)
            {
                throw new ArgumentException("bigPower is negative");
            }
            if (bigPower.Sign == 0)
            {
                // however 0 to the power of 0 is undefined
                return EInteger.One;
            }
            if (bigPower.CompareTo(1) == 0)
            {
                return this;
            }
            if (this.IsZero || this.CompareTo(1) == 0)
            {
                return this;
            }
            if (this.CompareTo(-1) == 0)
            {
                return bigPower.IsEven ? EInteger.FromInt32(1) : this;
            }
            EInteger bitLength = this.GetUnsignedBitLengthAsEInteger();
            if (!this.IsPowerOfTwo)
            {
                bitLength = bitLength.Subtract(1);
            }
            // DebugUtility.Log("sizeNeeded=" + bitLength.Multiply(bigPower));
            // DebugUtility.Log("bigPower=" + bigPower);
            if (bigPower.CanFitInInt32())
            {
                return this.Pow(bigPower.ToInt32Checked());
            }
            EInteger bp = bigPower;
            EInteger ret = EInteger.One;
            EInteger rmax = this.Pow(Int32.MaxValue);
            while (!bp.CanFitInInt32())
            {
                ret = ret.Multiply(rmax);
                bp = bp.Subtract(Int32.MaxValue);
            }
            int lastp = bp.ToInt32Checked();
            ret = (lastp == Int32.MaxValue) ? ret.Multiply(rmax) :
              ret.Multiply(this.Pow(lastp));
            return ret;
        }

        /// <summary>Raises an arbitrary-precision integer to a
        /// power.</summary>
        /// <param name='powerSmall'>The exponent to raise this integer
        /// to.</param>
        /// <returns>The result. Returns 1 if <paramref name='powerSmall'/> is
        /// 0.</returns>
        public EInteger Pow(int powerSmall)
        {
            if (powerSmall < 0)
            {
                throw new ArgumentException("powerSmall(" + powerSmall +
                  ") is less than 0");
            }
            EInteger thisVar = this;
            if (powerSmall == 0)
            {
                // however 0 to the power of 0 is undefined
                return EInteger.One;
            }
            if (powerSmall == 1)
            {
                return this;
            }
            if (this.IsZero || this.CompareTo(1) == 0)
            {
                return this;
            }
            if (this.CompareTo(-1) == 0)
            {
                return (powerSmall & 1) == 0 ? EInteger.FromInt32(1) : this;
            }
            if (powerSmall == 2)
            {
                return thisVar.Multiply(thisVar);
            }
            if (powerSmall == 3)
            {
                return thisVar.Multiply(thisVar).Multiply(thisVar);
            }
            EInteger r = EInteger.One;
            // bool negatePower = (powerSmall & 1) != 0 && thisVar.Sign < 0;
            // thisVar = thisVar.Abs();
            while (powerSmall != 0)
            {
                if ((powerSmall & 1) != 0)
                {
                    r *= (EInteger)thisVar;
                }
                powerSmall >>= 1;
                if (powerSmall != 0)
                {
                    thisVar *= (EInteger)thisVar;
                }
            }
            return r; // negatePower ? r.Negate() : r;
        }

        /// <summary>Raises an arbitrary-precision integer to a power, which is
        /// given as another arbitrary-precision integer.</summary>
        /// <param name='power'>The exponent to raise to.</param>
        /// <returns>The result. Returns 1 if <paramref name='power'/> is
        /// 0.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='power'/> is less than 0.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='power'/> is null.</exception>
        public EInteger PowBigIntVar(EInteger power)
        {
            // TODO: Deprecate in favor of Pow(EInteger)
            if (power == null)
            {
                throw new ArgumentNullException(nameof(power));
            }
            int sign = power.Sign;
            if (sign < 0)
            {
                throw new ArgumentException(
                  "sign (" + sign + ") is less than 0");
            }
            EInteger thisVar = this;
            if (sign == 0)
            {
                return EInteger.One;
            }
            if (power.Equals(EInteger.One))
            {
                return this;
            }
            if (power.wordCount == 1 && power.words[0] == 2)
            {
                return thisVar.Multiply(thisVar);
            }
            if (power.wordCount == 1 && power.words[0] == 3)
            {
                return thisVar.Multiply(thisVar).Multiply(thisVar);
            }
            EInteger r = EInteger.One;
            // bool negatePower = !power.IsEven && thisVar.Sign < 0;
            // thisVar = thisVar.Abs();
            while (!power.IsZero)
            {
                if (!power.IsEven)
                {
                    r *= (EInteger)thisVar;
                }
                power >>= 1;
                if (!power.IsZero)
                {
                    thisVar *= (EInteger)thisVar;
                }
            }
            return r; // negatePower ? r.Negate() : r;
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision integer is divided by another
        /// arbitrary-precision integer. The remainder is the number that
        /// remains when the absolute value of this arbitrary-precision integer
        /// is divided by the absolute value of the other arbitrary-precision
        /// integer; the remainder has the same sign (positive or negative) as
        /// this arbitrary-precision integer.</summary>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision integer is divided by another
        /// arbitrary-precision integer.</returns>
        /// <exception cref='DivideByZeroException'>Attempted to divide by
        /// zero.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='divisor'/> is null.</exception>
        public EInteger Remainder(EInteger divisor)
        {
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            int words1Size = this.wordCount;
            int words2Size = divisor.wordCount;
            if (words2Size == 0)
            {
                throw new DivideByZeroException();
            }
            if (words1Size < words2Size)
            {
                // dividend is less than divisor
                return this;
            }
            if (words2Size == 1)
            {
                short shortRemainder = FastRemainder(
                    this.words,
                    this.wordCount,
                    divisor.words[0]);
                int smallRemainder = ((int)shortRemainder) & ShortMask;
                if (this.negative)
                {
                    smallRemainder = -smallRemainder;
                }
                return EInteger.FromInt64(smallRemainder);
            }
            if (this.PositiveCompare(divisor) < 0)
            {
                return this;
            }
            var remainderReg = new short[(int)words2Size];
            GeneralDivide(
              this.words,
              0,
              this.wordCount,
              divisor.words,
              0,
              divisor.wordCount,
              null,
              0,
              remainderReg,
              0);
            int count = CountWords(remainderReg);
            if (count == 0)
            {
                return EInteger.Zero;
            }
            remainderReg = ShortenArray(remainderReg, count);
            return new EInteger(count, remainderReg, this.negative);
        }

        /// <summary>Returns an arbitrary-precision integer with the bits
        /// shifted to the right. For this operation, the arbitrary-precision
        /// integer is treated as a two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ).
        /// Thus, for negative values, the arbitrary-precision integer is
        /// sign-extended.</summary>
        /// <param name='eshift'>The number of bits to shift. Can be negative,
        /// in which case this is the same as ShiftLeft with the absolute value
        /// of this parameter.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='eshift'/> is null.</exception>
        public EInteger ShiftRight(EInteger eshift)
        {
            if (eshift == null)
            {
                throw new ArgumentNullException(nameof(eshift));
            }
            EInteger valueETempShift = eshift;
            EInteger ret = this;
            if (valueETempShift.Sign < 0)
            {
                return ret.ShiftLeft(valueETempShift.Negate());
            }
            while (!valueETempShift.CanFitInInt32())
            {
                valueETempShift = valueETempShift.Subtract(0x7ffffff0);
                ret = ret.ShiftRight(0x7ffffff0);
            }
            return ret.ShiftRight(valueETempShift.ToInt32Checked());
        }

        /// <summary>Returns an arbitrary-precision integer with the bits
        /// shifted to the left by a number of bits given as an
        /// arbitrary-precision integer. A value of 1 doubles this value, a
        /// value of 2 multiplies it by 4, a value of 3 by 8, a value of 4 by
        /// 16, and so on.</summary>
        /// <param name='eshift'>The number of bits to shift. Can be negative,
        /// in which case this is the same as ShiftRight with the absolute
        /// value of this parameter.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='eshift'/> is null.</exception>
        public EInteger ShiftLeft(EInteger eshift)
        {
            if (eshift == null)
            {
                throw new ArgumentNullException(nameof(eshift));
            }
            EInteger valueETempShift = eshift;
            EInteger ret = this;
            if (valueETempShift.Sign < 0)
            {
                return ret.ShiftRight(valueETempShift.Negate());
            }
            while (!valueETempShift.CanFitInInt32())
            {
                valueETempShift = valueETempShift.Subtract(0x7ffffff0);
                ret = ret.ShiftLeft(0x7ffffff0);
            }
            return ret.ShiftLeft(valueETempShift.ToInt32Checked());
        }

        /// <summary>Returns an arbitrary-precision integer with the bits
        /// shifted to the left by a number of bits. A value of 1 doubles this
        /// value, a value of 2 multiplies it by 4, a value of 3 by 8, a value
        /// of 4 by 16, and so on.</summary>
        /// <param name='numberBits'>The number of bits to shift. Can be
        /// negative, in which case this is the same as shiftRight with the
        /// absolute value of this parameter.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        public EInteger ShiftLeft(int numberBits)
        {
            if (numberBits == 0 || this.wordCount == 0)
            {
                return this;
            }
            if (numberBits < 0)
            {
                return (numberBits == Int32.MinValue) ?
                  this.ShiftRight(1).ShiftRight(Int32.MaxValue) :
                  this.ShiftRight(-numberBits);
            }
            int numWords = this.wordCount;
            var shiftWords = (int)(numberBits >> 4);
            var shiftBits = (int)(numberBits & 15);
            if (!this.negative)
            {
                // Determine shifted integer's word count in advance;
                // it's more cache-friendly to do so because the
                // unshifted word has less memory
                int lastWord = ((int)this.words[this.wordCount - 1]) & 0xffff;
                int lastWordBL = NumberUtility.BitLength(lastWord) +
                  shiftBits;
                var newWordCount = 0;
                if (lastWordBL <= 16)
                {
                    // New bit count is such that an additional word
                    // is not needed
                    newWordCount = numWords + shiftWords;
                }
                else
                {
                    newWordCount = numWords + BitsToWords(numberBits);
                }
                var ret = new short[newWordCount];
                Array.Copy(this.words, 0, ret, shiftWords, numWords);
                ShiftWordsLeftByBits(
                  ret,
                  shiftWords,
                  newWordCount - shiftWords,
                  shiftBits);
#if DEBUG
                if (newWordCount <= 0 || ret[newWordCount - 1] == 0)
                {
                    throw new InvalidOperationException();
                }
#endif
                return new EInteger(newWordCount, ret, false);
            }
            else
            {
                var ret = new short[numWords + BitsToWords((int)numberBits)];
                Array.Copy(this.words, ret, numWords);
                TwosComplement(ret, 0, (int)ret.Length);
                ShiftWordsLeftByWords(ret, 0, numWords + shiftWords, shiftWords);
                ShiftWordsLeftByBits(
                  ret,
                  (int)shiftWords,
                  numWords + BitsToWords(shiftBits),
                  shiftBits);
                TwosComplement(ret, 0, (int)ret.Length);
                return new EInteger(CountWords(ret), ret, true);
            }
        }

        private static void OrWords(short[] r, short[] a, short[] b, int n)
        {
            for (var i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(a[i] | b[i]));
            }
        }

        private static void XorWords(short[] r, short[] a, short[] b, int n)
        {
            for (var i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(a[i] ^ b[i]));
            }
        }

        private static void NotWords(short[] r, int n)
        {
            for (var i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(~r[i]));
            }
        }

        private static void AndWords(short[] r, short[] a, short[] b, int n)
        {
            for (var i = 0; i < n; ++i)
            {
                r[i] = unchecked((short)(a[i] & b[i]));
            }
        }

        /// <summary>Returns an arbitrary-precision integer with every bit
        /// flipped from this one (also called an inversion or NOT
        /// operation).</summary>
        /// <returns>An arbitrary-precision integer in which each bit in its
        /// two's complement representation is set if the corresponding bit of
        /// this integer is clear, and vice versa. Returns -1 if this integer
        /// is 0. If this integer is positive, the return value is negative,
        /// and vice versa. This method uses the two's complement form of
        /// negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, NOT 10100 = ...11101011 (or in decimal, NOT 20
        /// = -21). In binary, NOT ...11100110 = 11001 (or in decimal, NOT -26
        /// = 25).</returns>
        public EInteger Not()
        {
            if (this.wordCount == 0)
            {
                return EInteger.FromInt32(-1);
            }
            var valueXaNegative = false;
            var valueXaWordCount = 0;
            var valueXaReg = new short[this.wordCount];
            Array.Copy(this.words, valueXaReg, valueXaReg.Length);
            valueXaWordCount = this.wordCount;
            if (this.negative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            NotWords(
              valueXaReg,
              (int)valueXaReg.Length);
            if (this.negative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaNegative = !this.negative;
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative);
        }

        /// <summary>Does an AND operation between this arbitrary-precision
        /// integer and another one.</summary>
        /// <param name='other'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bits of this integer and the other integer (in
        /// their two's-complement representation) are both set. For example,
        /// in binary, 10110 AND 01100 = 00100 (or in decimal, 22 AND 12 = 4).
        /// This method uses the two's complement form of negative integers
        /// (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11100111 AND 01100 = 00100 (or in decimal,
        /// -25 AND 12 = 4).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='other'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger And(EInteger other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (other.IsZero || this.IsZero)
            {
                return EInteger.Zero;
            }
            if (!this.negative && !other.negative)
            {
                int smallerCount = Math.Min(this.wordCount, other.wordCount);
                short[] smaller = (this.wordCount == smallerCount) ?
                  this.words : other.words;
                short[] bigger = (this.wordCount == smallerCount) ?
                  other.words : this.words;
                var result = new short[smallerCount];
                for (var i = 0; i < smallerCount; ++i)
                {
                    result[i] = unchecked((short)(smaller[i] & bigger[i]));
                }
                smallerCount = CountWords(result);
                return (smallerCount == 0) ? EInteger.Zero : new
                  EInteger(smallerCount, result, false);
            }
            var valueXaNegative = false;
            var valueXaWordCount = 0;
            var valueXaReg = new short[this.wordCount];
            Array.Copy(this.words, valueXaReg, valueXaReg.Length);
            var valueXbNegative = false;
            var valueXbReg = new short[other.wordCount];
            Array.Copy(other.words, valueXbReg, valueXbReg.Length);
            valueXaNegative = this.negative;
            valueXaWordCount = this.wordCount;
            valueXbNegative = other.negative;
            valueXaReg = CleanGrow(
                valueXaReg,
                Math.Max(valueXaReg.Length, valueXbReg.Length));
            valueXbReg = CleanGrow(
                valueXbReg,
                Math.Max(valueXaReg.Length, valueXbReg.Length));
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            if (valueXbNegative)
            {
                TwosComplement(valueXbReg, 0, (int)valueXbReg.Length);
            }
            valueXaNegative &= valueXbNegative;
            AndWords(valueXaReg, valueXaReg, valueXbReg, (int)valueXaReg.Length);
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative);
        }

        /// <summary>Does an OR operation between this arbitrary-precision
        /// integer and another one.</summary>
        /// <param name='second'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit of this integer is set, the other integer's
        /// corresponding bit is set, or both. For example, in binary, 10110 OR
        /// 11010 = 11110 (or in decimal, 22 OR 26 = 30). This method uses the
        /// two's complement form of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101110 OR 01011 = ...11101111 (or in
        /// decimal, -18 OR 11 = -17).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger Or(EInteger second)
        {
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            if (this.wordCount == 0)
            {
                return second;
            }
            if (second.wordCount == 0)
            {
                return this;
            }
            if (!this.negative && !second.negative)
            {
                int smallerCount = Math.Min(this.wordCount, second.wordCount);
                int biggerCount = Math.Max(this.wordCount, second.wordCount);
                short[] smaller = (this.wordCount == smallerCount) ?
                  this.words : second.words;
                short[] bigger = (this.wordCount == smallerCount) ?
                  second.words : this.words;
                var result = new short[biggerCount];
                for (var i = 0; i < smallerCount; ++i)
                {
                    result[i] = unchecked((short)(smaller[i] | bigger[i]));
                }
                Array.Copy(
                  bigger,
                  smallerCount,
                  result,
                  smallerCount,
                  biggerCount - smallerCount);
#if DEBUG
                if (!(biggerCount > 0))
                {
                    throw new InvalidOperationException(
                      "doesn't satisfy biggerCount>0");
                }
                if (!(biggerCount == CountWords(result)))
                {
                    throw new InvalidOperationException("doesn't satisfy" +
                      "\u0020biggerCount==CountWords(result)");
                }
#endif

                return new EInteger(biggerCount, result, false);
            }
            var valueXaNegative = false;
            var valueXaWordCount = 0;
            var valueXaReg = new short[this.wordCount];
            Array.Copy(this.words, valueXaReg, valueXaReg.Length);
            var valueXbNegative = false;
            var valueXbReg = new short[second.wordCount];
            Array.Copy(second.words, valueXbReg, valueXbReg.Length);
            valueXaNegative = this.negative;
            valueXaWordCount = this.wordCount;
            valueXbNegative = second.negative;
            valueXaReg = CleanGrow(
                valueXaReg,
                Math.Max(valueXaReg.Length, valueXbReg.Length));
            valueXbReg = CleanGrow(
                valueXbReg,
                Math.Max(valueXaReg.Length, valueXbReg.Length));
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            if (valueXbNegative)
            {
                TwosComplement(valueXbReg, 0, (int)valueXbReg.Length);
            }
            valueXaNegative |= valueXbNegative;
            OrWords(valueXaReg, valueXaReg, valueXbReg, (int)valueXaReg.Length);
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative);
        }

        /// <summary>Does an AND NOT operation between this arbitrary-precision
        /// integer and another one.</summary>
        /// <param name='second'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit of this integer is set, and the other
        /// integer's corresponding bit is
        /// <i>not</i> set. For example, in binary, 10110 AND NOT 11010 = 00100
        /// (or in decimal, 22 AND NOT 26 = 4). This method uses the two's
        /// complement form of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101110 AND NOT 01011 = 00100 (or in
        /// decimal, -18 OR 11 = 4).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger AndNot(EInteger second)
        {
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return this.And(second.Not());
        }

        /// <summary>Does an OR NOT operation (or implication or IMP operation)
        /// between this arbitrary-precision integer and another one.</summary>
        /// <param name='second'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit of this integer is set, the other integer's
        /// corresponding bit is
        /// <i>not</i> set, or both. For example, in binary, 10110 OR NOT 11010
        /// = 00100 (or in decimal, 22 OR NOT 26 = 23). This method uses the
        /// two's complement form of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101110 OR NOT 01011 = ...11111110 (or in
        /// decimal, -18 OR 11 = -2).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger OrNot(EInteger second)
        {
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return this.Or(second.Not());
        }

        /// <summary>Does an OR NOT operation (or implication or IMP operation)
        /// between this arbitrary-precision integer and another one.</summary>
        /// <param name='second'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit of this integer is set, the other integer's
        /// corresponding bit is
        /// <i>not</i> set, or both. For example, in binary, 10110 OR NOT 11010
        /// = 00100 (or in decimal, 22 OR NOT 26 = 23). This method uses the
        /// two's complement form of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101110 OR NOT 01011 = ...11111110 (or in
        /// decimal, -18 OR 11 = -2).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger Imp(EInteger second)
        {
            return this.OrNot(second);
        }

        /// <summary>Does an XOR NOT operation (or equivalence operation, EQV
        /// operation, or exclusive-OR NOT operation) between this
        /// arbitrary-precision integer and another one.</summary>
        /// <param name='second'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit of this integer is set or the other integer's
        /// corresponding bit is
        /// <i>not</i> set, but not both. For example, in binary, 10110 XOR NOT
        /// 11010 = 10011 (or in decimal, 22 XOR NOT 26 = 19). This method uses
        /// the two's complement form of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101110 XOR NOT 01011 = ...11111010 (or in
        /// decimal, -18 OR 11 = -6).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger XorNot(EInteger second)
        {
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return this.Xor(second.Not());
        }

        /// <summary>Does an XOR NOT operation (or equivalence operation, EQV
        /// operation, or exclusive-OR NOT operation) between this
        /// arbitrary-precision integer and another one.</summary>
        /// <param name='second'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit of this integer is set or the other integer's
        /// corresponding bit is
        /// <i>not</i> set, but not both. For example, in binary, 10110 XOR NOT
        /// 11010 = 10011 (or in decimal, 22 XOR NOT 26 = 19). This method uses
        /// the two's complement form of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101110 XOR NOT 01011 = ...11111010 (or in
        /// decimal, -18 OR 11 = -6).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public EInteger Eqv(EInteger second)
        {
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return this.XorNot(second);
        }

        /// <summary>Does an exclusive OR (XOR) operation between this
        /// arbitrary-precision integer and another one.</summary>
        /// <param name='other'>Another arbitrary-precision integer that
        /// participates in the operation.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit is set in one input integer but not in the
        /// other. For example, in binary, 11010 XOR 01001 = 10011 (or in
        /// decimal, 26 XOR 9 = 19). This method uses the two's complement form
        /// of negative integers (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ). For
        /// example, in binary, ...11101101 XOR 00011 = ...11101110 (or in
        /// decimal, -19 XOR 3 = -18).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='other'/> is null.</exception>
        public EInteger Xor(EInteger other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.Equals(other))
            {
                return EInteger.Zero;
            }
            if (this.wordCount == 0)
            {
                return other;
            }
            if (other.wordCount == 0)
            {
                return this;
            }
            if (!this.negative && !other.negative)
            {
                int smallerCount = Math.Min(this.wordCount, other.wordCount);
                int biggerCount = Math.Max(this.wordCount, other.wordCount);
                short[] smaller = (this.wordCount == smallerCount) ?
                  this.words : other.words;
                short[] bigger = (this.wordCount == smallerCount) ?
                  other.words : this.words;
                var result = new short[biggerCount];
                for (var i = 0; i < smallerCount; ++i)
                {
                    result[i] = unchecked((short)(smaller[i] ^ bigger[i]));
                }
                Array.Copy(
                  bigger,
                  smallerCount,
                  result,
                  smallerCount,
                  biggerCount - smallerCount);
                smallerCount = (smallerCount == biggerCount) ?
                  CountWords(result) : biggerCount;
#if DEBUG
                if (!(smallerCount == CountWords(result)))
                {
                    throw new ArgumentException("doesn't satisfy" +
                      "\u0020smallerCount==CountWords(result)");
                }
#endif

                return (smallerCount == 0) ? EInteger.Zero :
                  new EInteger(smallerCount, result, false);
            }
            var valueXaNegative = false;
            var valueXaWordCount = 0;
            var valueXaReg = new short[this.wordCount];
            Array.Copy(this.words, valueXaReg, valueXaReg.Length);
            var valueXbNegative = false;
            var valueXbReg = new short[other.wordCount];
            Array.Copy(other.words, valueXbReg, valueXbReg.Length);
            valueXaNegative = this.negative;
            valueXaWordCount = this.wordCount;
            valueXbNegative = other.negative;
            valueXaReg = CleanGrow(
                valueXaReg,
                Math.Max(valueXaReg.Length, valueXbReg.Length));
            valueXbReg = CleanGrow(
                valueXbReg,
                Math.Max(valueXaReg.Length, valueXbReg.Length));
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            if (valueXbNegative)
            {
                TwosComplement(valueXbReg, 0, (int)valueXbReg.Length);
            }
            valueXaNegative ^= valueXbNegative;
            XorWords(valueXaReg, valueXaReg, valueXbReg, (int)valueXaReg.Length);
            if (valueXaNegative)
            {
                TwosComplement(valueXaReg, 0, (int)valueXaReg.Length);
            }
            valueXaWordCount = CountWords(valueXaReg);
            return (valueXaWordCount == 0) ? EInteger.Zero : new
              EInteger(valueXaWordCount, valueXaReg, valueXaNegative);
        }

        private short[] Copy()
        {
            var words = new short[this.words.Length];
            Array.Copy(this.words, words, this.wordCount);
            return words;
        }

        private static int WordsCompare(
          short[] words,
          int wordCount,
          short[] words2,
          int wordCount2)
        {
            return WordsCompare(words, 0, wordCount, words2, 0, wordCount2);
        }

        private static int WordsCompare(
          short[] words,
          int pos1,
          int wordCount,
          short[] words2,
          int pos2,
          int wordCount2)
        {
            // NOTE: Assumes the number is nonnegative
            int size = wordCount;
            if (size == 0)
            {
                return (wordCount2 == 0) ? 0 : -1;
            }
            else if (wordCount2 == 0)
            {
                return 1;
            }
            if (size == wordCount2)
            {
                if (size == 1 && words[pos1] == words2[pos2])
                {
                    return 0;
                }
                else
                {
                    int p1 = pos1 + size - 1;
                    int p2 = pos2 + size - 1;
                    while (unchecked(size--) != 0)
                    {
                        int an = ((int)words[p1]) & ShortMask;
                        int bn = ((int)words2[p2]) & ShortMask;
                        if (an > bn)
                        {
                            return 1;
                        }
                        if (an < bn)
                        {
                            return -1;
                        }
                        --p1;
                        --p2;
                    }
                    return 0;
                }
            }
            return (size > wordCount2) ? 1 : -1;
        }

        private static long WordsToLongUnchecked(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            var c = (int)wordCount;
            if (c == 0)
            {
                return 0L;
            }
            long ivv = 0;
            int intRetValue = ((int)words[0]) & ShortMask;
            if (c > 1)
            {
                intRetValue |= (((int)words[1]) & ShortMask) << 16;
            }
            if (c > 2)
            {
                int intRetValue2 = ((int)words[2]) & ShortMask;
                if (c > 3)
                {
                    intRetValue2 |= (((int)words[3]) & ShortMask) << 16;
                }
                ivv = ((long)intRetValue) & 0xffffffffL;
                ivv |= ((long)intRetValue2) << 32;
                return ivv;
            }
            ivv = ((long)intRetValue) & 0xffffffffL;
            return ivv;
        }

        private static bool WordsEqual(
          short[] words,
          int wordCount,
          short[] words2,
          int wordCount2)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount == wordCount2)
            {
                for (var i = 0; i < wordCount; ++i)
                {
                    if (words[i] != words2[i])
                    {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        private static bool WordsIsEven(short[] words, int wordCount)
        {
            return wordCount == 0 || (words[0] & 0x01) == 0;
        }

        private static int WordsShiftRightTwo(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                var carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xfffc) >> 2) | carry;
                    carry = (w << 14) & 0xc000;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsShiftRightEight(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                var carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xff00) >> 8) | carry;
                    carry = (w << 8) & 0xff00;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsShiftRightFour(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                var carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xfff0) >> 4) | carry;
                    carry = (w << 12) & 0xf000;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsShiftRightOne(short[] words, int wordCount)
        {
            // NOTE: Assumes the number is nonnegative
            if (wordCount != 0)
            {
                int u;
                var carry = 0;
                for (int i = wordCount - 1; i >= 0; --i)
                {
                    int w = words[i];
                    u = ((w & 0xfffe) >> 1) | carry;
                    carry = (w << 15) & 0x8000;
                    words[i] = unchecked((short)u);
                }
                if (words[wordCount - 1] == 0)
                {
                    --wordCount;
                }
            }
            return wordCount;
        }

        private static int WordsSubtract(
          short[] words,
          int wordCount,
          short[] subtrahendWords,
          int subtrahendCount)
        {
            // NOTE: Assumes this value is at least as high as the subtrahend
            // and both numbers are nonnegative
            var borrow = (short)SubtractInternal(
                words,
                0,
                words,
                0,
                subtrahendWords,
                0,
                subtrahendCount);
            if (borrow != 0)
            {
                DecrementWords(
                  words,
                  subtrahendCount,
                  (int)(wordCount - subtrahendCount),
                  borrow);
            }
            while (wordCount != 0 && words[wordCount - 1] == 0)
            {
                --wordCount;
            }
            return wordCount;
        }

        /// <summary>Returns an arbitrary-precision integer with the bits
        /// shifted to the right. For this operation, the arbitrary-precision
        /// integer is treated as a two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ).
        /// Thus, for negative values, the arbitrary-precision integer is
        /// sign-extended.</summary>
        /// <param name='numberBits'>The number of bits to shift. Can be
        /// negative, in which case this is the same as shiftLeft with the
        /// absolute value of this parameter.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        public EInteger ShiftRight(int numberBits)
        {
            if (numberBits == 0 || this.wordCount == 0)
            {
                return this;
            }
            if (numberBits < 0)
            {
                return (numberBits == Int32.MinValue) ?
                  this.ShiftLeft(1).ShiftLeft(Int32.MaxValue) :
                  this.ShiftLeft(-numberBits);
            }
            var numWords = (int)this.wordCount;
            var shiftWords = (int)(numberBits >> 4);
            var shiftBits = (int)(numberBits & 15);
            short[] ret;
            int retWordCount;
            if (this.negative)
            {
                ret = new short[this.words.Length];
                Array.Copy(this.words, ret, numWords);
                TwosComplement(ret, 0, (int)ret.Length);
                ShiftWordsRightByWordsSignExtend(ret, 0, numWords, shiftWords);
                if (numWords > shiftWords)
                {
                    ShiftWordsRightByBitsSignExtend(
                      ret,
                      0,
                      numWords - shiftWords,
                      shiftBits);
                }
                TwosComplement(ret, 0, (int)ret.Length);
                retWordCount = ret.Length;
            }
            else
            {
                if (shiftWords >= numWords)
                {
                    return EInteger.Zero;
                }
                ret = new short[this.words.Length];
                Array.Copy(this.words, shiftWords, ret, 0, numWords - shiftWords);
                if (shiftBits != 0)
                {
                    ShiftWordsRightByBits(ret, 0, numWords - shiftWords, shiftBits);
                }
                retWordCount = numWords - shiftWords;
            }
            while (retWordCount != 0 &&
              ret[retWordCount - 1] == 0)
            {
                --retWordCount;
            }
            if (retWordCount == 0)
            {
                return EInteger.Zero;
            }
            if (shiftWords > 2)
            {
                ret = ShortenArray(ret, retWordCount);
            }
            return new EInteger(retWordCount, ret, this.negative);
        }

        /// <summary>Finds the square root of this instance's value, rounded
        /// down.</summary>
        /// <returns>The square root of this object's value. Returns 0 if this
        /// value is 0 or less.</returns>
        public EInteger Sqrt()
        {
            EInteger[] srrem = this.SqrtRemInternal(false);
            return srrem[0];
        }

        /// <summary>Calculates the square root and the remainder.</summary>
        /// <returns>An array of two arbitrary-precision integers: the first
        /// integer is the square root, and the second is the difference
        /// between this value and the square of the first integer. Returns two
        /// zeros if this value is 0 or less, or one and zero if this value
        /// equals 1.</returns>
        public EInteger[] SqrtRem()
        {
            return this.SqrtRemInternal(true);
        }

        /// <summary>Finds the nth root of this instance's value, rounded
        /// down.</summary>
        /// <param name='root'>The root to find; must be 1 or greater. If this
        /// value is 2, this method finds the square root; if 3, the cube root,
        /// and so on.</param>
        /// <returns>The square root of this object's value. Returns 0 if this
        /// value is 0 or less.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='root'/> is null.</exception>
        public EInteger Root(EInteger root)
        {
            if (root == null)
            {
                throw new ArgumentNullException(nameof(root));
            }
            EInteger[] srrem = this.RootRemInternal(root, false);
            return srrem[0];
        }

        /// <summary>Calculates the nth root and the remainder.</summary>
        /// <param name='root'>The root to find; must be 1 or greater. If this
        /// value is 2, this method finds the square root; if 3, the cube root,
        /// and so on.</param>
        /// <returns>An array of two arbitrary-precision integers: the first
        /// integer is the nth root, and the second is the difference between
        /// this value and the nth power of the first integer. Returns two
        /// zeros if this value is 0 or less, or one and zero if this value
        /// equals 1.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='root'/> is null.</exception>
        public EInteger[] RootRem(EInteger root)
        {
            if (root == null)
            {
                throw new ArgumentNullException(nameof(root));
            }
            return this.RootRemInternal(root, true);
        }

        /// <summary>Finds the nth root of this instance's value, rounded
        /// down.</summary>
        /// <param name='root'>The root to find; must be 1 or greater. If this
        /// value is 2, this method finds the square root; if 3, the cube root,
        /// and so on.</param>
        /// <returns>The square root of this object's value. Returns 0 if this
        /// value is 0 or less.</returns>
        public EInteger Root(int root)
        {
            EInteger[] srrem = this.RootRemInternal(EInteger.FromInt32(root), false);
            return srrem[0];
        }

        /// <summary>Calculates the nth root and the remainder.</summary>
        /// <param name='root'>The root to find; must be 1 or greater. If this
        /// value is 2, this method finds the square root; if 3, the cube root,
        /// and so on.</param>
        /// <returns>An array of two arbitrary-precision integers: the first
        /// integer is the nth root, and the second is the difference between
        /// this value and the nth power of the first integer. Returns two
        /// zeros if this value is 0 or less, or one and zero if this value
        /// equals 1.</returns>
        public EInteger[] RootRem(int root)
        {
            return this.RootRemInternal(EInteger.FromInt32(root), true);
        }

        /// <summary>Subtracts an arbitrary-precision integer from this
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='subtrahend'>Another arbitrary-precision
        /// integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision integer minus another arbitrary-precision
        /// integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='subtrahend'/> is null.</exception>
        public EInteger Subtract(EInteger subtrahend)
        {
            if (subtrahend == null)
            {
                throw new ArgumentNullException(nameof(subtrahend));
            }
            return (this.wordCount == 0) ? subtrahend.Negate() :
              ((subtrahend.wordCount == 0) ? this : this.Add(subtrahend.Negate()));
        }

        /// <summary>Returns a byte array of this integer's value. The byte
        /// array will take the number's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ),
        /// using the fewest bytes necessary to store its value unambiguously.
        /// If this value is negative, the bits that appear beyond the most
        /// significant bit of the number will be all ones. The resulting byte
        /// array can be passed to the <c>FromBytes()</c> method (with the same
        /// byte order) to reconstruct this integer's value.</summary>
        /// <param name='littleEndian'>See the 'littleEndian' parameter of the
        /// <c>FromBytes()</c> method.</param>
        /// <returns>A byte array. If this value is 0, returns a byte array
        /// with the single element 0.</returns>
        public byte[] ToBytes(bool littleEndian)
        {
            int sign = this.Sign;
            if (sign == 0)
            {
                return new[] { (byte)0 };
            }
            if (sign > 0)
            {
                int byteCount = this.ByteCount();
                int byteArrayLength = byteCount;
                if (this.GetUnsignedBit((byteCount * 8) - 1))
                {
                    ++byteArrayLength;
                }
                var bytes = new byte[byteArrayLength];
                var j = 0;
                for (var i = 0; i < byteCount; i += 2, j++)
                {
                    int index = littleEndian ? i : bytes.Length - 1 - i;
                    int index2 = littleEndian ? i + 1 : bytes.Length - 2 - i;
                    bytes[index] = (byte)(this.words[j] & 0xff);
                    if (index2 >= 0 && index2 < byteArrayLength)
                    {
                        bytes[index2] = (byte)((this.words[j] >> 8) & 0xff);
                    }
                }
                return bytes;
            }
            else
            {
                var regdata = new short[this.words.Length];
                Array.Copy(this.words, regdata, this.words.Length);
                TwosComplement(regdata, 0, (int)regdata.Length);
                int byteCount = regdata.Length * 2;
                for (int i = regdata.Length - 1; i >= 0; --i)
                {
                    if (regdata[i] == unchecked((short)0xffff))
                    {
                        byteCount -= 2;
                    }
                    else if ((regdata[i] & 0xff80) == 0xff80)
                    {
                        // signed first byte, 0xff second
                        --byteCount;
                        break;
                    }
                    else if ((regdata[i] & 0x8000) == 0x8000)
                    {
                        // signed second byte
                        break;
                    }
                    else
                    {
                        // unsigned second byte
                        ++byteCount;
                        break;
                    }
                }
                if (byteCount == 0)
                {
                    byteCount = 1;
                }
                var bytes = new byte[byteCount];
                bytes[littleEndian ? bytes.Length - 1 : 0] = (byte)0xff;
                byteCount = Math.Min(byteCount, regdata.Length * 2);
                var j = 0;
                for (var i = 0; i < byteCount; i += 2, j++)
                {
                    int index = littleEndian ? i : bytes.Length - 1 - i;
                    int index2 = littleEndian ? i + 1 : bytes.Length - 2 - i;
                    bytes[index] = (byte)(regdata[j] & 0xff);
                    if (index2 >= 0 && index2 < byteCount)
                    {
                        bytes[index2] = (byte)((regdata[j] >> 8) & 0xff);
                    }
                }
                return bytes;
            }
        }

        /// <summary>Converts this object's value to a 32-bit signed integer,
        /// throwing an exception if it can't fit.</summary>
        /// <returns>A 32-bit signed integer.</returns>
        /// <exception cref=' T:System.OverflowException'>This object's value
        /// is too big to fit a 32-bit signed integer.</exception>
        public int ToInt32Checked()
        {
            int count = this.wordCount;
            if (count == 0)
            {
                return 0;
            }
            if (count > 2)
            {
                throw new OverflowException();
            }
            if (count == 2 && (this.words[1] & 0x8000) != 0)
            {
                if (this.negative && this.words[1] == unchecked((short)0x8000) &&
                  this.words[0] == 0)
                {
                    return Int32.MinValue;
                }
                throw new OverflowException();
            }
            return this.ToInt32Unchecked();
        }

        /// <summary>Converts this object's value to a 32-bit signed integer.
        /// If the value can't fit in a 32-bit integer, returns the lower 32
        /// bits of this object's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
        /// which case the return value might have a different sign than this
        /// object's value).</summary>
        /// <returns>A 32-bit signed integer.</returns>
        public int ToInt32Unchecked()
        {
            var c = (int)this.wordCount;
            if (c == 0)
            {
                return 0;
            }
            int intRetValue = ((int)this.words[0]) & ShortMask;
            if (c > 1)
            {
                intRetValue |= (((int)this.words[1]) & ShortMask) << 16;
            }
            if (this.negative)
            {
                intRetValue = unchecked(intRetValue - 1);
                intRetValue = unchecked(~intRetValue);
            }
            return intRetValue;
        }

        /// <summary>Converts this object's value to a 64-bit signed integer,
        /// throwing an exception if it can't fit.</summary>
        /// <returns>A 64-bit signed integer.</returns>
        /// <exception cref=' T:System.OverflowException'>This object's value
        /// is too big to fit a 64-bit signed integer.</exception>
        public long ToInt64Checked()
        {
            int count = this.wordCount;
            if (count == 0)
            {
                return 0L;
            }
            if (count > 4)
            {
                throw new OverflowException();
            }
            if (count == 4 && (this.words[3] & 0x8000) != 0)
            {
                if (this.negative && this.words[3] == unchecked((short)0x8000) &&
                  this.words[2] == 0 && this.words[1] == 0 &&
                  this.words[0] == 0)
                {
                    return Int64.MinValue;
                }
                throw new OverflowException();
            }
            return this.ToInt64Unchecked();
        }

        /// <summary>Converts this object's value to a 64-bit signed integer.
        /// If the value can't fit in a 64-bit integer, returns the lower 64
        /// bits of this object's two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) (in
        /// which case the return value might have a different sign than this
        /// object's value).</summary>
        /// <returns>A 64-bit signed integer.</returns>
        public long ToInt64Unchecked()
        {
            var c = (int)this.wordCount;
            if (c == 0)
            {
                return 0L;
            }
            long ivv = 0;
            int intRetValue = ((int)this.words[0]) & ShortMask;
            if (c > 1)
            {
                intRetValue |= (((int)this.words[1]) & ShortMask) << 16;
            }
            if (c > 2)
            {
                int intRetValue2 = ((int)this.words[2]) & ShortMask;
                if (c > 3)
                {
                    intRetValue2 |= (((int)this.words[3]) & ShortMask) << 16;
                }
                if (this.negative)
                {
                    if (intRetValue == 0)
                    {
                        intRetValue = unchecked(intRetValue - 1);
                        intRetValue2 = unchecked(intRetValue2 - 1);
                    }
                    else
                    {
                        intRetValue = unchecked(intRetValue - 1);
                    }
                    intRetValue = unchecked(~intRetValue);
                    intRetValue2 = unchecked(~intRetValue2);
                }
                ivv = ((long)intRetValue) & 0xffffffffL;
                ivv |= ((long)intRetValue2) << 32;
                return ivv;
            }
            ivv = ((long)intRetValue) & 0xffffffffL;
            if (this.negative)
            {
                ivv = -ivv;
            }
            return ivv;
        }

        // Estimated number of base-N digits, divided by 8 (or estimated
        // number of half-digits divided by 16) contained in each 16-bit
        // word of an EInteger. Used in divide-and-conquer to guess
        // the power-of-base needed to split an EInteger by roughly half.
        // Calculated from: ln(65536)*(16/2)/ln(base)
        private static int[] estimatedHalfDigitCountPerWord = {
      0, 0,
      128, 80, 64, 55, 49, 45, 42, 40, 38, 37, 35, 34, 33,
      32, 32, 31, 30, 30, 29, 29, 28, 28, 27, 27, 27, 26,
      26, 26, 26, 25, 25, 25, 25, 24, 24,
    };

        private void ToRadixStringGeneral(
          StringBuilder outputSB,
          int radix)
        {
#if DEBUG
            if (this.negative)
            {
                throw new InvalidOperationException("doesn't satisfy !this.negative");
            }
#endif

            var i = 0;
            if (this.wordCount >= 100)
            {
                var rightBuilder = new StringBuilder();
                long digits = ((long)estimatedHalfDigitCountPerWord[radix] *
                    this.wordCount) / 16;
                EInteger pow = null;
                if (radix == 10)
                {
                    pow = NumberUtility.FindPowerOfTen(digits);
                }
                else
                {
                    pow = (radix == 5) ?
                      NumberUtility.FindPowerOfFiveFromBig(EInteger.FromInt64(digits)) :
                      EInteger.FromInt32(radix).Pow(EInteger.FromInt64(digits));
                }
                EInteger[] divrem = this.DivRem(pow);
                // DebugUtility.Log("divrem wc=" + divrem[0].wordCount + " wc=" + (//
                // divrem[1].wordCount));
                divrem[0].ToRadixStringGeneral(outputSB, radix);
                divrem[1].ToRadixStringGeneral(rightBuilder, radix);
                for (i = rightBuilder.Length; i < digits; ++i)
                {
                    outputSB.Append('0');
                }
                outputSB.Append(rightBuilder.ToString());
                return;
            }
            char[] s;
            short[] tempReg;
            int numWordCount;
            if (radix == 10)
            {
                if (this.CanFitInInt64())
                {
                    outputSB.Append(FastInteger.LongToString(this.ToInt64Unchecked()));
                    return;
                }
                tempReg = new short[this.wordCount];
                Array.Copy(this.words, tempReg, tempReg.Length);
                numWordCount = tempReg.Length;
                while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
                {
                    --numWordCount;
                }
                s = new char[(numWordCount << 4) + 1];
                while (numWordCount != 0)
                {
                    if (numWordCount == 1 && tempReg[0] > 0 && tempReg[0] <= 0x7fff)
                    {
                        int rest = tempReg[0];
                        while (rest != 0)
                        {
                            // accurate approximation to rest/10 up to 43698,
                            // and rest can go up to 32767
                            int newrest = (rest * 26215) >> 18;
                            s[i++] = Digits[rest - (newrest * 10)];
                            rest = newrest;
                        }
                        break;
                    }
                    if (numWordCount == 2 && tempReg[1] > 0 && tempReg[1] <= 0x7fff)
                    {
                        int rest = ((int)tempReg[0]) & ShortMask;
                        rest |= (((int)tempReg[1]) & ShortMask) << 16;
                        while (rest != 0)
                        {
                            int newrest = (rest < 81920) ? (((rest * 52429) >> 19) & 8191) :
                              (rest / 10);
                            s[i++] = Digits[rest - (newrest * 10)];
                            rest = newrest;
                        }
                        break;
                    }
                    else
                    {
                        int wci = numWordCount;
                        short remainderShort = 0;
                        int quo, rem;
                        // Divide by 10000
                        while ((wci--) > 0)
                        {
                            int currentDividend = unchecked((int)((((int)tempReg[wci]) &
                                    0xffff) | ((int)remainderShort << 16)));
                            quo = currentDividend / 10000;
                            tempReg[wci] = unchecked((short)quo);
                            rem = currentDividend - (10000 * quo);
                            remainderShort = unchecked((short)rem);
                        }
                        int remainderSmall = remainderShort;
                        // Recalculate word count
                        while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
                        {
                            --numWordCount;
                        }
                        // accurate approximation to rest/10 up to 16388,
                        // and rest can go up to 9999
                        int newrest = (remainderSmall * 3277) >> 15;
                        s[i++] = Digits[(int)(remainderSmall - (newrest * 10))];
                        remainderSmall = newrest;
                        newrest = (remainderSmall * 3277) >> 15;
                        s[i++] = Digits[(int)(remainderSmall - (newrest * 10))];
                        remainderSmall = newrest;
                        newrest = (remainderSmall * 3277) >> 15;
                        s[i++] = Digits[(int)(remainderSmall - (newrest * 10))];
                        remainderSmall = newrest;
                        s[i++] = Digits[remainderSmall];
                    }
                }
                ReverseChars(s, 0, i);
                outputSB.Append(s, 0, i);
                return;
            }
            tempReg = new short[this.wordCount];
            Array.Copy(this.words, tempReg, tempReg.Length);
            numWordCount = tempReg.Length;
            while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
            {
                --numWordCount;
            }
            i = 0;
            s = new char[(numWordCount << 4) + 1];
            while (numWordCount != 0)
            {
                if (numWordCount == 1 && tempReg[0] > 0 && tempReg[0] <= 0x7fff)
                {
                    int rest = tempReg[0];
                    while (rest != 0)
                    {
                        int newrest = rest / radix;
                        s[i++] = Digits[rest - (newrest * radix)];
                        rest = newrest;
                    }
                    break;
                }
                if (numWordCount == 2 && tempReg[1] > 0 && tempReg[1] <= 0x7fff)
                {
                    int rest = ((int)tempReg[0]) & ShortMask;
                    rest |= (((int)tempReg[1]) & ShortMask) << 16;
                    while (rest != 0)
                    {
                        int newrest = rest / radix;
                        s[i++] = Digits[rest - (newrest * radix)];
                        rest = newrest;
                    }
                    break;
                }
                else
                {
                    int wci = numWordCount;
                    short remainderShort = 0;
                    int quo, rem;
                    // Divide by radix
                    while ((wci--) > 0)
                    {
                        int currentDividend = unchecked((int)((((int)tempReg[wci]) &
                                0xffff) | ((int)remainderShort << 16)));
                        quo = currentDividend / radix;
                        tempReg[wci] = unchecked((short)quo);
                        rem = currentDividend - (radix * quo);
                        remainderShort = unchecked((short)rem);
                    }
                    int remainderSmall = remainderShort;
                    // Recalculate word count
                    while (numWordCount != 0 && tempReg[numWordCount - 1] == 0)
                    {
                        --numWordCount;
                    }
                    s[i++] = Digits[remainderSmall];
                }
            }
            ReverseChars(s, 0, i);
            outputSB.Append(s, 0, i);
        }

        /// <summary>Generates a string representing the value of this object,
        /// in the given radix.</summary>
        /// <param name='radix'>A radix from 2 through 36. For example, to
        /// generate a hexadecimal (base-16) string, specify 16. To generate a
        /// decimal (base-10) string, specify 10.</param>
        /// <returns>A string representing the value of this object. If this
        /// value is 0, returns "0". If negative, the string will begin with a
        /// minus sign ("-", U+002D). Depending on the radix, the string will
        /// use the basic digits 0 to 9 (U+0030 to U+0039) and then the basic
        /// upper-case letters A to Z (U+0041 to U+005A). For example, 0-9 in
        /// radix 10, and 0-9, then A-F in radix 16.</returns>
        public string ToRadixString(int radix)
        {
            if (radix < 2)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is less than 2");
            }
            if (radix > 36)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is more than 36");
            }
            if (this.wordCount == 0)
            {
                return "0";
            }
            if (radix == 10)
            {
                // Decimal
                if (this.CanFitInInt64())
                {
                    return FastInteger.LongToString(this.ToInt64Unchecked());
                }
                var sb = new StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                this.Abs().ToRadixStringGeneral(sb, radix);
                return sb.ToString();
            }
            if (radix == 16)
            {
                // Hex
                var sb = new System.Text.StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                var firstBit = true;
                int word = this.words[this.wordCount - 1];
                for (int i = 0; i < 4; ++i)
                {
                    if (!firstBit || (word & 0xf000) != 0)
                    {
                        sb.Append(Digits[(word >> 12) & 0x0f]);
                        firstBit = false;
                    }
                    word <<= 4;
                }
                for (int j = this.wordCount - 2; j >= 0; --j)
                {
                    word = this.words[j];
                    for (int i = 0; i < 4; ++i)
                    {
                        sb.Append(Digits[(word >> 12) & 0x0f]);
                        word <<= 4;
                    }
                }
                return sb.ToString();
            }
            if (radix == 2)
            {
                // Binary
                var sb = new System.Text.StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                var firstBit = true;
                int word = this.words[this.wordCount - 1];
                for (int i = 0; i < 16; ++i)
                {
                    if (!firstBit || (word & 0x8000) != 0)
                    {
                        sb.Append((word & 0x8000) == 0 ? '0' : '1');
                        firstBit = false;
                    }
                    word <<= 1;
                }
                for (int j = this.wordCount - 2; j >= 0; --j)
                {
                    word = this.words[j];
                    for (int i = 0; i < 16; ++i)
                    {
                        sb.Append((word & 0x8000) == 0 ? '0' : '1');
                        word <<= 1;
                    }
                }
                return sb.ToString();
            }
            else
            {
                // Other radixes
                var sb = new StringBuilder();
                if (this.negative)
                {
                    sb.Append('-');
                }
                this.Abs().ToRadixStringGeneral(sb, radix);
                return sb.ToString();
            }
        }

        /// <summary>Converts this object to a text string in base
        /// 10.</summary>
        /// <returns>A string representation of this object. If this value is
        /// 0, returns "0". If negative, the string will begin with a minus
        /// sign ("-", U+002D). The string will use the basic digits 0 to 9
        /// (U+0030 to U+0039).</returns>
        public override string ToString()
        {
            if (this.IsZero)
            {
                return "0";
            }
            return this.CanFitInInt64() ?
              FastInteger.LongToString(this.ToInt64Unchecked()) :
              this.ToRadixString(10);
        }

        private static int AddInternal(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int n)
        {
            unchecked
            {
                int u;
                u = 0;
                bool evn = (n & 1) == 0;
                int valueNEven = evn ? n : n - 1;
                var i = 0;
                while (i < valueNEven)
                {
                    u = (((int)words1[astart + i]) & ShortMask) +
                      (((int)words2[bstart + i]) & ShortMask) + (u >> 16);
                    c[cstart + i] = (short)u;
                    ++i;
                    u = (((int)words1[astart + i]) & ShortMask) +
                      (((int)words2[bstart + i]) & ShortMask) + (u >> 16);
                    c[cstart + i] = (short)u;
                    ++i;
                }
                if (!evn)
                {
                    u = (((int)words1[astart + valueNEven]) & ShortMask) +
                      (((int)words2[bstart + valueNEven]) & ShortMask) + (u >> 16);
                    c[cstart + valueNEven] = (short)u;
                }
                return u >> 16;
            }
        }

        private static int AddUnevenSize(
          short[] c,
          int cstart,
          short[] wordsBigger,
          int astart,
          int acount,
          short[] wordsSmaller,
          int bstart,
          int bcount)
        {
#if DEBUG
            if (acount < bcount)
            {
                throw new ArgumentException("acount(" + acount + ") is less than " +
                  bcount);
            }
#endif
            unchecked
            {
                int u;
                u = 0;
                for (var i = 0; i < bcount; i += 1)
                {
                    u = (((int)wordsBigger[astart + i]) & ShortMask) +
                      (((int)wordsSmaller[bstart + i]) & ShortMask) + (short)(u >> 16);
                    c[cstart + i] = (short)u;
                }
                for (int i = bcount; i < acount; i += 1)
                {
                    u = (((int)wordsBigger[astart + i]) & ShortMask) + (short)(u >> 16);
                    c[cstart + i] = (short)u;
                }
                return ((int)u >> 16) & ShortMask;
            }
        }

        // Multiplies two operands of different sizes
        private static void AsymmetricMultiply(
          short[] resultArr,
          int resultStart, // uses words1Count + words2Count
          short[] tempArr,
          int tempStart, // uses words1Count + words2Count
          short[] words1,
          int words1Start,
          int words1Count,
          short[] words2,
          int words2Start,
          int words2Count)
        {
            // DebugUtility.Log("AsymmetricMultiply " + words1Count + " " +
            // words2Count + " [r=" + resultStart + " t=" + tempStart + " a=" +
            // words1Start + " b=" + words2Start + "]");
#if DEBUG
            if (resultArr == null)
            {
                throw new ArgumentNullException(nameof(resultArr));
            }

            if (resultStart < 0)
            {
                throw new ArgumentException("resultStart(" + resultStart +
                  ") is less than 0");
            }

            if (resultStart > resultArr.Length)
            {
                throw new ArgumentException("resultStart(" + resultStart +
                  ") is more than " + resultArr.Length);
            }

            if (words1Count + words2Count < 0)
            {
                throw new ArgumentException("words1Count plus words2Count(" +
                  (words1Count + words2Count) + ") is less than " +
                  "0");
            }

            if (words1Count + words2Count > resultArr.Length)
            {
                throw new ArgumentException("words1Count plus words2Count(" +
                  (words1Count + words2Count) + ") is more than " + resultArr.Length);
            }

            if (resultArr.Length - resultStart < words1Count + words2Count)
            {
                throw new ArgumentException("resultArr.Length minus resultStart(" +
                  (resultArr.Length - resultStart) + ") is less than " + (words1Count +
                    words2Count));
            }

            if (tempArr == null)
            {
                throw new ArgumentNullException(nameof(tempArr));
            }

            if (tempStart < 0)
            {
                throw new ArgumentException("tempStart(" + tempStart +
                  ") is less than 0");
            }

            if (tempStart > tempArr.Length)
            {
                throw new ArgumentException("tempStart(" + tempStart +
                  ") is more than " + tempArr.Length);
            }

            if (words1Count + words2Count < 0)
            {
                throw new ArgumentException("words1Count plus words2Count(" +
                  (words1Count + words2Count) + ") is less than " +
                  "0");
            }

            if (words1Count + words2Count > tempArr.Length)
            {
                throw new ArgumentException("words1Count plus words2Count(" +
                  (words1Count + words2Count) + ") is more than " + tempArr.Length);
            }

            if (tempArr.Length - tempStart < words1Count + words2Count)
            {
                throw new ArgumentException("tempArr.Length minus tempStart(" +
                  (tempArr.Length - tempStart) + ") is less than " + (words1Count +
                    words2Count));
            }

            if (words1 == null)
            {
                throw new ArgumentNullException(nameof(words1));
            }

            if (words1Start < 0)
            {
                throw new ArgumentException("words1Start(" + words1Start +
                  ") is less than 0");
            }

            if (words1Start > words1.Length)
            {
                throw new ArgumentException("words1Start(" + words1Start +
                  ") is more than " + words1.Length);
            }

            if (words1Count < 0)
            {
                throw new ArgumentException("words1Count(" + words1Count +
                  ") is less than 0");
            }

            if (words1Count > words1.Length)
            {
                throw new ArgumentException("words1Count(" + words1Count +
                  ") is more than " + words1.Length);
            }

            if (words1.Length - words1Start < words1Count)
            {
                throw new ArgumentException("words1.Length minus words1Start(" +
                  (words1.Length - words1Start) + ") is less than " + words1Count);
            }

            if (words2 == null)
            {
                throw new ArgumentNullException(nameof(words2));
            }

            if (words2Start < 0)
            {
                throw new ArgumentException("words2Start(" + words2Start +
                  ") is less than 0");
            }

            if (words2Start > words2.Length)
            {
                throw new ArgumentException("words2Start(" + words2Start +
                  ") is more than " + words2.Length);
            }

            if (words2Count < 0)
            {
                throw new ArgumentException("words2Count(" + words2Count +
                  ") is less than 0");
            }

            if (words2Count > words2.Length)
            {
                throw new ArgumentException("words2Count(" + words2Count +
                  ") is more than " + words2.Length);
            }

            if (words2.Length - words2Start < words2Count)
            {
                throw new ArgumentException("words2.Length minus words2Start(" +
                  (words2.Length - words2Start) + ") is less than " + words2Count);
            }
#endif

            if (words1Count == words2Count)
            {
                if (words1Start == words2Start && words1 == words2)
                {
                    // Both operands have the same value and the same word count
                    RecursiveSquare(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words1Count);
                }
                else if (words1Count == 2)
                {
                    // Both operands have a word count of 2
                    BaselineMultiply2(
                      resultArr,
                      resultStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start);
                }
                else
                {
                    // Other cases where both operands have the same word count
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      words1Count);
                }
                return;
            }
            if (words1Count > words2Count)
            {
                // Ensure that words1 is smaller by swapping if necessary
                short[] tmp1 = words1;
                words1 = words2;
                words2 = tmp1;
                int tmp3 = words1Start;
                words1Start = words2Start;
                words2Start = tmp3;
                int tmp2 = words1Count;
                words1Count = words2Count;
                words2Count = tmp2;
            }

            if (words1Count == 1 || (words1Count == 2 && words1[words1Start + 1] ==
                0))
            {
                switch (words1[words1Start])
                {
                    case 0:
                        // words1 is zero, so result is 0
                        Array.Clear((short[])resultArr, resultStart, words2Count + 2);
                        return;
                    case 1:
                        Array.Copy(
                          words2,
                          words2Start,
                          resultArr,
                          resultStart,
                          (int)words2Count);
                        resultArr[resultStart + words2Count] = (short)0;
                        resultArr[resultStart + words2Count + 1] = (short)0;
                        return;
                    default:
                        resultArr[resultStart + words2Count] = LinearMultiply(
                            resultArr,
                            resultStart,
                            words2,
                            words2Start,
                            words1[words1Start],
                            words2Count);
                        resultArr[resultStart + words2Count + 1] = (short)0;
                        return;
                }
            }
            if (words1Count == 2 && (words2Count & 1) == 0)
            {
                int a0 = ((int)words1[words1Start]) & ShortMask;
                int a1 = ((int)words1[words1Start + 1]) & ShortMask;
                resultArr[resultStart + words2Count] = (short)0;
                resultArr[resultStart + words2Count + 1] = (short)0;
                AtomicMultiplyOpt(
                  resultArr,
                  resultStart,
                  a0,
                  a1,
                  words2,
                  words2Start,
                  0,
                  words2Count);
                AtomicMultiplyAddOpt(
                  resultArr,
                  resultStart,
                  a0,
                  a1,
                  words2,
                  words2Start,
                  2,
                  words2Count);
                return;
            }
            if (words1Count <= MultRecursionThreshold && words2Count <=
              MultRecursionThreshold)
            {
                SchoolbookMultiply(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  words1Count,
                  words2,
                  words2Start,
                  words2Count);
            }
            else if (words1Count >= Toom4Threshold && words2Count >=
            Toom4Threshold)
            {
                Toom4(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  words1Count,
                  words2,
                  words2Start,
                  words2Count);
            }
            else if (words1Count >= Toom3Threshold && words2Count >=
            Toom3Threshold)
            {
                Toom3(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  words1Count,
                  words2,
                  words2Start,
                  words2Count);
            }
            else
            {
                int wordsRem = words2Count % words1Count;
                int evenmult = (words2Count / words1Count) & 1;
                int i;
                // DebugUtility.Log("counts=" + words1Count + "," + words2Count +
                // " res=" + (resultStart + words1Count) + " temp=" + (tempStart +
                // (words1Count << 1)) + " rem=" + wordsRem + " evenwc=" + evenmult);
                if (wordsRem == 0)
                {
                    // words2Count is divisible by words1count
                    if (evenmult == 0)
                    {
                        SameSizeMultiply(
                          resultArr,
                          resultStart,
                          tempArr,
                          tempStart,
                          words1,
                          words1Start,
                          words2,
                          words2Start,
                          words1Count);
                        Array.Copy(
                          resultArr,
                          resultStart + words1Count,
                          tempArr,
                          (int)(tempStart + (words1Count << 1)),
                          words1Count);
                        for (i = words1Count << 1; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              tempArr,
                              tempStart + words1Count + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                        for (i = words1Count; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              resultArr,
                              resultStart + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                    }
                    else
                    {
                        for (i = 0; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              resultArr,
                              resultStart + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                        for (i = words1Count; i < words2Count; i += words1Count << 1)
                        {
                            SameSizeMultiply(
                              tempArr,
                              tempStart + words1Count + i,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start + i,
                              words1Count);
                        }
                    }
                    if (
                      AddInternal(
                        resultArr,
                        resultStart + words1Count,
                        resultArr,
                        resultStart + words1Count,
                        tempArr,
                        tempStart + (words1Count << 1),
                        words2Count - words1Count) != 0)
                    {
                        IncrementWords(
                          resultArr,
                          (int)(resultStart + words2Count),
                          words1Count,
                          (short)1);
                    }
                }
                else if ((words1Count + words2Count) >= (words1Count << 2))
                {
                    // DebugUtility.Log("Chunked Linear Multiply long");
                    ChunkedLinearMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words2,
                      words2Start,
                      words2Count,
                      words1,
                      words1Start,
                      words1Count);
                }
                else if (words1Count + 1 == words2Count ||
                (words1Count + 2 == words2Count && words2[words2Start +
                    words2Count - 1] == 0))
                {
                    Array.Clear(
                      (short[])resultArr,
                      resultStart,
                      words1Count + words2Count);
                    // Multiply the low parts of each operand
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      words1Count);
                    // Multiply the high parts
                    // while adding carry from the high part of the product
                    short carry = LinearMultiplyAdd(
                        resultArr,
                        resultStart + words1Count,
                        words1,
                        words1Start,
                        words2[words2Start + words1Count],
                        words1Count);
                    resultArr[resultStart + words1Count + words1Count] = carry;
                }
                else
                {
                    var t2 = new short[words1Count << 2];
                    // DebugUtility.Log("Chunked Linear Multiply Short");
                    ChunkedLinearMultiply(
                      resultArr,
                      resultStart,
                      t2,
                      0,
                      words2,
                      words2Start,
                      words2Count,
                      words1,
                      words1Start,
                      words1Count);
                }
            }
        }

        private static void AtomicMultiplyAddOpt(
          short[] c,
          int valueCstart,
          int valueA0,
          int valueA1,
          short[] words2,
          int words2Start,
          int istart,
          int iend)
        {
            short s;
            int d;
            int first1MinusFirst0 = ((int)valueA1 - valueA0) & ShortMask;
            valueA1 &= 0xffff;
            valueA0 &= 0xffff;
            unchecked
            {
                if (valueA1 >= valueA0)
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int b0 = ((int)words2[words2Start + i]) & ShortMask;
                        int b1 = ((int)words2[words2Start + i + 1]) & ShortMask;
                        int csi = valueCstart + i;
                        if (b0 >= b1)
                        {
                            s = (short)0;
                            d = first1MinusFirst0 * (((int)b0 - b1) & ShortMask);
                        }
                        else
                        {
                            s = (short)first1MinusFirst0;
                            d = (((int)s) & ShortMask) * (((int)b0 - b1) & ShortMask);
                        }
                        int valueA0B0 = valueA0 * b0;
                        int a0b0high = (valueA0B0 >> 16) & ShortMask;
                        int tempInt;
                        tempInt = valueA0B0 + (((int)c[csi]) & ShortMask);
                        c[csi] = (short)(((int)tempInt) & ShortMask);

                        int valueA1B1 = valueA1 * b1;
                        int a1b1low = valueA1B1 & ShortMask;
                        int a1b1high = ((int)(valueA1B1 >> 16)) & ShortMask;
                        tempInt = (((int)(tempInt >> 16)) & ShortMask) +
                          (((int)valueA0B0) & 0xffff) + (((int)d) & ShortMask) + a1b1low +
                          (((int)c[csi + 1]) & ShortMask);
                        c[csi + 1] = (short)(((int)tempInt) & ShortMask);

                        tempInt = (((int)(tempInt >> 16)) & ShortMask) + a1b1low +
                          a0b0high + (((int)(d >> 16)) & ShortMask) +
                          a1b1high - (((int)s) & ShortMask) + (((int)c[csi + 2]) &
                            ShortMask);
                        c[csi + 2] = (short)(((int)tempInt) & ShortMask);

                        tempInt = (((int)(tempInt >> 16)) & ShortMask) + a1b1high +
                          (((int)c[csi + 3]) & ShortMask);
                        c[csi + 3] = (short)(((int)tempInt) & ShortMask);
                        if ((tempInt >> 16) != 0)
                        {
                            ++c[csi + 4];
                            c[csi + 5] += (short)((c[csi + 4] == 0) ? 1 : 0);
                        }
                    }
                }
                else
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int valueB0 = ((int)words2[words2Start + i]) & ShortMask;
                        int valueB1 = ((int)words2[words2Start + i + 1]) & ShortMask;
                        int csi = valueCstart + i;
                        if (valueB0 > valueB1)
                        {
                            s = (short)(((int)valueB0 - valueB1) & ShortMask);
                            d = first1MinusFirst0 * (((int)s) & ShortMask);
                        }
                        else
                        {
                            s = (short)0;
                            d = (((int)valueA0 - valueA1) & ShortMask) * (((int)valueB1 -
                                  valueB0) & ShortMask);
                        }
                        int valueA0B0 = valueA0 * valueB0;
                        int a0b0high = (valueA0B0 >> 16) & ShortMask;
                        int tempInt;
                        tempInt = valueA0B0 + (((int)c[csi]) & ShortMask);
                        c[csi] = (short)(((int)tempInt) & ShortMask);

                        int valueA1B1 = valueA1 * valueB1;
                        int a1b1low = valueA1B1 & ShortMask;
                        int a1b1high = (valueA1B1 >> 16) & ShortMask;
                        tempInt = (((int)(tempInt >> 16)) & ShortMask) +
                          (((int)valueA0B0) & 0xffff) + (((int)d) & ShortMask) + a1b1low +
                          (((int)c[csi + 1]) & ShortMask);
                        c[csi + 1] = (short)(((int)tempInt) & ShortMask);

                        tempInt = (((int)(tempInt >> 16)) & ShortMask) + a1b1low +
                          a0b0high + (((int)(d >> 16)) & ShortMask) +
                          a1b1high - (((int)s) & ShortMask) + (((int)c[csi + 2]) &
                            ShortMask);
                        c[csi + 2] = (short)(((int)tempInt) & ShortMask);

                        tempInt = (((int)(tempInt >> 16)) & ShortMask) + a1b1high +
                          (((int)c[csi + 3]) & ShortMask);
                        c[csi + 3] = (short)(((int)tempInt) & ShortMask);
                        if ((tempInt >> 16) != 0)
                        {
                            ++c[csi + 4];
                            c[csi + 5] += (short)((c[csi + 4] == 0) ? 1 : 0);
                        }
                    }
                }
            }
        }

        private static void AtomicMultiplyOpt(
          short[] c,
          int valueCstart,
          int valueA0,
          int valueA1,
          short[] words2,
          int words2Start,
          int istart,
          int iend)
        {
            short s;
            int d;
            int first1MinusFirst0 = ((int)valueA1 - valueA0) & ShortMask;
            valueA1 &= 0xffff;
            valueA0 &= 0xffff;
            unchecked
            {
                if (valueA1 >= valueA0)
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int valueB0 = ((int)words2[words2Start + i]) & ShortMask;
                        int valueB1 = ((int)words2[words2Start + i + 1]) & ShortMask;
                        int csi = valueCstart + i;
                        if (valueB0 >= valueB1)
                        {
                            s = (short)0;
                            d = first1MinusFirst0 * (((int)valueB0 - valueB1) & ShortMask);
                        }
                        else
                        {
                            s = (short)first1MinusFirst0;
                            d = (((int)s) & ShortMask) * (((int)valueB0 - valueB1) &
                                ShortMask);
                        }
                        int valueA0B0 = valueA0 * valueB0;
                        c[csi] = (short)(((int)valueA0B0) & ShortMask);
                        int a0b0high = (valueA0B0 >> 16) & ShortMask;
                        int valueA1B1 = valueA1 * valueB1;
                        int tempInt;
                        tempInt = a0b0high + (((int)valueA0B0) & ShortMask) + (((int)d) &
                            0xffff) + (((int)valueA1B1) & ShortMask);
                        c[csi + 1] = (short)tempInt;
                        tempInt = valueA1B1 + (((int)(tempInt >> 16)) & ShortMask) +
                          a0b0high + (((int)(d >> 16)) & ShortMask) + (((int)(valueA1B1 >>
                                16)) & ShortMask) - (((int)s) & ShortMask);
                        c[csi + 2] = (short)tempInt;
                        tempInt >>= 16;
                        c[csi + 3] = (short)tempInt;
                    }
                }
                else
                {
                    for (int i = istart; i < iend; i += 4)
                    {
                        int valueB0 = ((int)words2[words2Start + i]) & ShortMask;
                        int valueB1 = ((int)words2[words2Start + i + 1]) & ShortMask;
                        int csi = valueCstart + i;
                        if (valueB0 > valueB1)
                        {
                            s = (short)(((int)valueB0 - valueB1) & ShortMask);
                            d = first1MinusFirst0 * (((int)s) & ShortMask);
                        }
                        else
                        {
                            s = (short)0;
                            d = (((int)valueA0 - valueA1) & ShortMask) * (((int)valueB1 -
                                  valueB0) & ShortMask);
                        }
                        int valueA0B0 = valueA0 * valueB0;
                        int a0b0high = (valueA0B0 >> 16) & ShortMask;
                        c[csi] = (short)(((int)valueA0B0) & ShortMask);

                        int valueA1B1 = valueA1 * valueB1;
                        int tempInt;
                        tempInt = a0b0high + (((int)valueA0B0) & ShortMask) + (((int)d) &
                            0xffff) + (((int)valueA1B1) & ShortMask);
                        c[csi + 1] = (short)tempInt;

                        tempInt = valueA1B1 + (((int)(tempInt >> 16)) & ShortMask) +
                          a0b0high + (((int)(d >> 16)) & ShortMask) + (((int)(valueA1B1 >>
                                16)) & ShortMask) - (((int)s) & ShortMask);

                        c[csi + 2] = (short)tempInt;
                        tempInt >>= 16;
                        c[csi + 3] = (short)tempInt;
                    }
                }
            }
        }
        // Multiplies two words by two words with overflow checking
        private static void BaselineMultiply2(
          short[] result,
          int rstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart)
        {
            unchecked
            {
                int p;
                short c;
                int d;
                int a0 = ((int)words1[astart]) & ShortMask;
                int a1 = ((int)words1[astart + 1]) & ShortMask;
                int b0 = ((int)words2[bstart]) & ShortMask;
                int b1 = ((int)words2[bstart + 1]) & ShortMask;
                p = a0 * b0;
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                result[rstart] = c;
                c = (short)d;
                d = ((int)d >> 16) & ShortMask;
                p = a0 * b1;
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = a1 * b0;
                p += ((int)c) & ShortMask;
                d += ((int)p >> 16) & ShortMask;
                result[rstart + 1] = (short)p;
                p = a1 * b1;
                p += d;
                result[rstart + 2] = (short)p;
                result[rstart + 3] = (short)(p >> 16);
            }
        }

        // Multiplies four words by four words with overflow checking
        private static void BaselineMultiply4(
          short[] result,
          int rstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart)
        {
            long p;
            int c;
            long d;
            unchecked
            {
                // DebugUtility.Log("ops={0:X4}{1:X4}{2:X4}{3:X4} {4:X4}{5:X4}{6:X4}{7:X4}",
                // words1[astart + 3], words1[astart + 2], words1[astart + 1], words1[astart],
                // words2[bstart + 3], words2[bstart + 2], words2[bstart + 1],
                // words2[bstart]);
                long a0 = ((long)words1[astart]) & 0xffffL;
                a0 |= (((long)words1[astart + 1]) & 0xffffL) << 16;
                long a1 = ((long)words1[astart + 2]) & 0xffffL;
                a1 |= (((long)words1[astart + 3]) & 0xffffL) << 16;
                long b0 = ((long)words2[bstart]) & 0xffffL;
                b0 |= (((long)words2[bstart + 1]) & 0xffffL) << 16;
                long b1 = ((long)words2[bstart + 2]) & 0xffffL;
                b1 |= (((long)words2[bstart + 3]) & 0xffffL) << 16;
                p = a0 * b0;
                d = (p >> 32) & 0xffffffffL;
                result[rstart] = (short)p;
                result[rstart + 1] = (short)(p >> 16);
                c = (int)d;
                d = (d >> 32) & 0xffffffffL;
                p = a0 * b1;
                p += ((long)c) & 0xffffffffL;
                c = (int)p;
                d += (p >> 32) & 0xffffffffL;
                p = a1 * b0;
                p += ((long)c) & 0xffffffffL;
                d += (p >> 32) & 0xffffffffL;
                result[rstart + 2] = (short)p;
                result[rstart + 3] = (short)(p >> 16);
                p = a1 * b1;
                p += d;
                // DebugUtility.Log("opsx={0:X16} {1:X16}",a1,b1);
                result[rstart + 4] = (short)p;
                result[rstart + 5] = (short)(p >> 16);
                result[rstart + 6] = (short)(p >> 32);
                result[rstart + 7] = (short)(p >> 48);
            }
        }

        // Multiplies eight words by eight words without overflow
        private static void BaselineMultiply8(
          short[] result,
          int rstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart)
        {
            unchecked
            {
                int p;
                short c;
                int d;
                const int SMask = ShortMask;
                int a0 = ((int)words1[astart]) & SMask;
                int a1 = ((int)words1[astart + 1]) & SMask;
                int a2 = ((int)words1[astart + 2]) & SMask;
                int a3 = ((int)words1[astart + 3]) & SMask;
                int a4 = ((int)words1[astart + 4]) & SMask;
                int a5 = ((int)words1[astart + 5]) & SMask;
                int a6 = ((int)words1[astart + 6]) & SMask;
                int a7 = ((int)words1[astart + 7]) & SMask;
                int b0 = ((int)words2[bstart]) & SMask;
                int b1 = ((int)words2[bstart + 1]) & SMask;
                int b2 = ((int)words2[bstart + 2]) & SMask;
                int b3 = ((int)words2[bstart + 3]) & SMask;
                int b4 = ((int)words2[bstart + 4]) & SMask;
                int b5 = ((int)words2[bstart + 5]) & SMask;
                int b6 = ((int)words2[bstart + 6]) & SMask;
                int b7 = ((int)words2[bstart + 7]) & SMask;
                p = a0 * b0;
                c = (short)p;
                d = ((int)p >> 16) & SMask;
                result[rstart] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b0;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 1] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a2 * b0;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 2] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a2 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a3 * b0;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 3] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b3;
                p += ((int)c) & SMask;
                d += ((int)p >> 16) & SMask;
                p = (a2 * b2) + (p & ShortMask);
                d += ((int)p >> 16) & SMask;
                p = (a3 * b1) + (p & ShortMask);
                d += ((int)p >> 16) & SMask;
                p = (a4 * b0) + (p & ShortMask);
                d += ((int)p >> 16) & SMask;
                result[rstart + 4] = (short)p;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a2 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a3 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a4 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b0;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 5] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a2 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a3 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a4 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b0;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 6] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a0 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a1 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a2 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a3 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a4 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b0;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 7] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a1 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a2 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a3 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a4 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b1;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 8] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a2 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a3 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a4 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b2;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 9] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a3 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a4 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b3;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 10] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a4 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a5 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b4;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 11] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a5 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a6 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b5;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 12] = c;
                c = (short)d;
                d = ((int)d >> 16) & SMask;
                p = a6 * b7;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                p = a7 * b6;
                p += ((int)c) & SMask;
                c = (short)p;
                d += ((int)p >> 16) & SMask;
                result[rstart + 13] = c;
                p = a7 * b7;
                p += d;
                result[rstart + 14] = (short)p;
                result[rstart + 15] =
                  (short)(p >> 16);
            }
        }
        //-----------------------------
        // Baseline Square
        //-----------------------------
        private static void BaselineSquare2(
          short[] result,
          int rstart,
          short[] words1,
          int astart)
        {
            unchecked
            {
                int p;
                short c;
                int d;
                int e;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart]) &
                    0xffff);
                result[rstart] = (short)p;
                e = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 1]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 1] = c;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        1]) & ShortMask);
                p += e;
                result[rstart + 2] = (short)p;
                result[rstart + 3] = (short)(p >>
                    16);
            }
        }

        private static void BaselineSquare4(
          short[] result,
          int rstart,
          short[] words1,
          int astart)
        {
            unchecked
            {
                int p;
                short c;
                int d;
                int e;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart]) &
                    0xffff);
                result[rstart] = (short)p;
                e = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 1]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 1] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 2]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        1]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 2] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 3]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        2]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 3] = c;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        3]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        2]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 4] = c;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        3]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + (2 * 4) - 3] = c;
                p = (((int)words1[astart + 3]) & ShortMask) * (((int)words1[astart +
                        3]) & ShortMask);
                p += e;
                result[rstart + 6] = (short)p;
                result[rstart + 7] = (short)(p >>
                    16);
            }
        }

        private static void BaselineSquare8(
          short[] result,
          int rstart,
          short[] words1,
          int astart)
        {
            unchecked
            {
                int p;
                short c;
                int d;
                int e;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart]) &
                    0xffff);
                result[rstart] = (short)p;
                e = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 1]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 1] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 2]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        1]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 2] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 3]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        2]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 3] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 4]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        3]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        2]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 4] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 5]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        4]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        3]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 5] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 6]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        5]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        4]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 3]) & ShortMask) * (((int)words1[astart +
                        3]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 6] = c;
                p = (((int)words1[astart]) & ShortMask) * (((int)words1[astart + 7]) &
                    0xffff);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        6]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        5]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 3]) & ShortMask) * (((int)words1[astart +
                        4]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 7] = c;
                p = (((int)words1[astart + 1]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        6]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 3]) & ShortMask) * (((int)words1[astart +
                        5]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 4]) & ShortMask) * (((int)words1[astart +
                        4]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 8] = c;
                p = (((int)words1[astart + 2]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 3]) & ShortMask) * (((int)words1[astart +
                        6]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 4]) & ShortMask) * (((int)words1[astart +
                        5]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 9] = c;
                p = (((int)words1[astart + 3]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 4]) & ShortMask) * (((int)words1[astart +
                        6]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 5]) & ShortMask) * (((int)words1[astart +
                        5]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 10] = c;
                p = (((int)words1[astart + 4]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                p = (((int)words1[astart + 5]) & ShortMask) * (((int)words1[astart +
                        6]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 11] = c;
                p = (((int)words1[astart + 5]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                p = (((int)words1[astart + 6]) & ShortMask) * (((int)words1[astart +
                        6]) & ShortMask);
                p += ((int)c) & ShortMask;
                c = (short)p;
                d += ((int)p >> 16) & ShortMask;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) & ShortMask);
                result[rstart + 12] = c;
                p = (((int)words1[astart + 6]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                c = (short)p;
                d = ((int)p >> 16) & ShortMask;
                d = (int)((d << 1) + (((int)c >> 15) & 1));
                c <<= 1;
                e += ((int)c) & ShortMask;
                c = (short)e;
                e = d + (((int)e >> 16) &
                    0xffff);
                result[rstart + 13] = c;
                p = (((int)words1[astart + 7]) & ShortMask) * (((int)words1[astart +
                        7]) & ShortMask);
                p += e;
                result[rstart + 14] = (short)p;
                result[rstart + 15] =
                  (short)(p >> 16);
            }
        }

        private static int BitPrecision(short numberValue)
        {
            if (numberValue == 0)
            {
                return 0;
            }
            var i = 16;
            unchecked
            {
                if ((numberValue >> 8) == 0)
                {
                    numberValue <<= 8;
                    i -= 8;
                }

                if ((numberValue >> 12) == 0)
                {
                    numberValue <<= 4;
                    i -= 4;
                }

                if ((numberValue >> 14) == 0)
                {
                    numberValue <<= 2;
                    i -= 2;
                }

                if ((numberValue >> 15) == 0)
                {
                    --i;
                }
            }
            return i;
        }

        private static int BitsToWords(int bitCount)
        {
            return (bitCount + 15) >> 4;
        }

        private static void ChunkedLinearMultiply(
          short[] productArr,
          int cstart,
          short[] tempArr,
          int tempStart, // uses bcount*4 space
          short[] words1,
          int astart,
          int acount, // Equal size or longer
          short[] words2,
          int bstart,
          int bcount)
        {
#if DEBUG
            if (acount < bcount)
            {
                throw new ArgumentException("acount(" + acount + ") is less than " +
                  bcount);
            }

            if (productArr == null)
            {
                throw new ArgumentNullException(nameof(productArr));
            }

            if (cstart < 0)
            {
                throw new ArgumentException("cstart(" + cstart + ") is less than " +
                  "0");
            }

            if (cstart > productArr.Length)
            {
                throw new ArgumentException("cstart(" + cstart + ") is more than " +
                  productArr.Length);
            }

            if (acount + bcount < 0)
            {
                throw new ArgumentException("acount plus bcount(" + (acount +
                    bcount) + ") is less than 0");
            }

            if (acount + bcount > productArr.Length)
            {
                throw new ArgumentException("acount plus bcount(" + (acount +
                    bcount) + ") is more than " + productArr.Length);
            }

            if (productArr.Length - cstart < acount + bcount)
            {
                throw new ArgumentException("productArr.Length minus cstart(" +
                  (productArr.Length - cstart) + ") is less than " + (acount + bcount));
            }

            if (tempArr == null)
            {
                throw new ArgumentNullException(nameof(tempArr));
            }

            if (tempStart < 0)
            {
                throw new ArgumentException("tempStart(" + tempStart +
                  ") is less than 0");
            }

            if (tempStart > tempArr.Length)
            {
                throw new ArgumentException("tempStart(" + tempStart +
                  ") is more than " + tempArr.Length);
            }

            if ((bcount * 4) < 0)
            {
                throw new ArgumentException("bcount * 4 less than 0(" + (bcount * 4) +
                  ")");
            }

            if ((bcount * 4) > tempArr.Length)
            {
                throw new ArgumentException("bcount * 4 more than " + tempArr.Length +
                  " (" + (bcount * 4) + ")");
            }

            if (tempArr.Length - tempStart < bcount * 4)
            {
                throw new ArgumentException("tempArr.Length minus tempStart(" +
                  (tempArr.Length - tempStart) + ") is less than " + (bcount * 4));
            }

            if (words1 == null)
            {
                throw new ArgumentNullException(nameof(words1));
            }

            if (astart < 0)
            {
                throw new ArgumentException("astart(" + astart + ") is less than " +
                  "0");
            }

            if (astart > words1.Length)
            {
                throw new ArgumentException("astart(" + astart + ") is more than " +
                  words1.Length);
            }

            if (acount < 0)
            {
                throw new ArgumentException("acount(" + acount + ") is less than " +
                  "0");
            }

            if (acount > words1.Length)
            {
                throw new ArgumentException("acount(" + acount + ") is more than " +
                  words1.Length);
            }

            if (words1.Length - astart < acount)
            {
                throw new ArgumentException("words1.Length minus astart(" +
                  (words1.Length - astart) + ") is less than " +
                  acount);
            }

            if (words2 == null)
            {
                throw new ArgumentNullException(nameof(words2));
            }

            if (bstart < 0)
            {
                throw new ArgumentException("bstart(" + bstart + ") is less than " +
                  "0");
            }

            if (bstart > words2.Length)
            {
                throw new ArgumentException("bstart(" + bstart + ") is more than " +
                  words2.Length);
            }

            if (bcount < 0)
            {
                throw new ArgumentException("bcount(" + bcount + ") is less than " +
                  "0");
            }

            if (bcount > words2.Length)
            {
                throw new ArgumentException("bcount(" + bcount + ") is more than " +
                  words2.Length);
            }

            if (words2.Length - bstart < bcount)
            {
                throw new ArgumentException("words2.Length minus bstart(" +
                  (words2.Length - bstart) + ") is less than " +
                  bcount);
            }
#endif

            unchecked
            {
                var carryPos = 0;
                // Set carry to zero
                Array.Clear((short[])productArr, cstart, bcount);
                for (var i = 0; i < acount; i += bcount)
                {
                    int diff = acount - i;
                    if (diff > bcount)
                    {
                        SameSizeMultiply(
                          tempArr,
                          tempStart,
                          tempArr,
                          tempStart + bcount + bcount,
                          words1,
                          astart + i,
                          words2,
                          bstart,
                          bcount);
                        // Add carry
                        AddUnevenSize(
                          tempArr,
                          tempStart,
                          tempArr,
                          tempStart,
                          bcount + bcount,
                          productArr,
                          cstart + carryPos,
                          bcount);
                        // Copy product and carry
                        Array.Copy(
                          tempArr,
                          tempStart,
                          productArr,
                          cstart + i,
                          bcount + bcount);
                        carryPos += bcount;
                    }
                    else
                    {
                        AsymmetricMultiply(
                          tempArr,
                          tempStart, // uses diff + bcount space
                          tempArr,
                          tempStart + diff + bcount, // uses diff + bcount
                          words1,
                          astart + i,
                          diff,
                          words2,
                          bstart,
                          bcount);
                        // Add carry
                        AddUnevenSize(
                          tempArr,
                          tempStart,
                          tempArr,
                          tempStart,
                          diff + bcount,
                          productArr,
                          cstart + carryPos,
                          bcount);
                        // Copy product without carry
                        Array.Copy(
                          tempArr,
                          tempStart,
                          productArr,
                          cstart + i,
                          diff + bcount);
                    }
                }
            }
        }

        internal static short[] CleanGrow(short[] a, int size)
        {
            if (size > a.Length)
            {
                var newa = new short[size];
                Array.Copy(a, newa, a.Length);
                return newa;
            }
            return a;
        }

        private static int Compare(
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int n)
        {
            while (unchecked(n--) != 0)
            {
                int an = ((int)words1[astart + n]) & ShortMask;
                int bn = ((int)words2[bstart + n]) & ShortMask;
                if (an > bn)
                {
                    return 1;
                }
                if (an < bn)
                {
                    return -1;
                }
            }
            return 0;
        }

        private static int CompareWithWords1IsOneBigger(
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int words1Count)
        {
            // NOTE: Assumes that words2's count is 1 less
            if (words1[astart + words1Count - 1] != 0)
            {
                return 1;
            }
            int w1c = words1Count;
            --w1c;
            while (unchecked(w1c--) != 0)
            {
                int an = ((int)words1[astart + w1c]) & ShortMask;
                int bn = ((int)words2[bstart + w1c]) & ShortMask;
                if (an > bn)
                {
                    return 1;
                }
                if (an < bn)
                {
                    return -1;
                }
            }
            return 0;
        }

        internal static int CountWords(short[] array)
        {
            int n = array.Length;
            while (n != 0 && array[n - 1] == 0)
            {
                --n;
            }
            return (int)n;
        }

        internal static int CountWords(short[] array, int pos, int len)
        {
            int n = len;
            while (n != 0 && array[pos + n - 1] == 0)
            {
                --n;
            }
            return (int)n;
        }

        private static int DecrementWords(
          short[] words1,
          int words1Start,
          int n,
          short words2)
        {
            unchecked
            {
                short tmp = words1[words1Start];
                words1[words1Start] = (short)(tmp - words2);
                if ((((int)words1[words1Start]) & ShortMask) <= (((int)tmp) &
                    ShortMask))
                {
                    return 0;
                }
                for (int i = 1; i < n; ++i)
                {
                    tmp = words1[words1Start + i];
                    --words1[words1Start + i];
                    if (tmp != 0)
                    {
                        return 0;
                    }
                }
                return 1;
            }
        }

        private static short Divide32By16(
          int dividendLow,
          short divisorShort,
          bool returnRemainder)
        {
            int tmpInt;
            var dividendHigh = 0;
            int intDivisor = ((int)divisorShort) & ShortMask;
            for (var i = 0; i < 32; ++i)
            {
                tmpInt = dividendHigh >> 31;
                dividendHigh <<= 1;
                dividendHigh = unchecked((int)(dividendHigh | ((int)((dividendLow >>
                            31) & 1))));
                dividendLow <<= 1;
                tmpInt |= dividendHigh;
                // unsigned greater-than-or-equal check
                if (((tmpInt >> 31) != 0) || (tmpInt >= intDivisor))
                {
                    unchecked
                    {
                        dividendHigh -= intDivisor;
                        ++dividendLow;
                    }
                }
            }
            return returnRemainder ? unchecked((short)(((int)dividendHigh) &
                  0xffff)) : unchecked((short)(((int)dividendLow) &
                  0xffff));
        }

        private static short DivideUnsigned(int x, short y)
        {
            if ((x >> 31) == 0)
            {
                // x is already nonnegative
                int iy = ((int)y) & ShortMask;
                return unchecked((short)((int)x / iy));
            }
            else
            {
                long longX = ((long)x) & 0xffffffffL;
                int iy = ((int)y) & ShortMask;
                return unchecked((short)(longX / iy));
            }
        }

        private static void FastDivide(
          short[] quotientReg,
          short[] dividendReg,
          int count,
          short divisorSmall)
        {
            switch (divisorSmall)
            {
                case 2:
                    FastDivideAndRemainderTwo(quotientReg, 0, dividendReg, 0, count);
                    break;
                case 10:
                    FastDivideAndRemainderTen(quotientReg, 0, dividendReg, 0, count);
                    break;
                default:
                    FastDivideAndRemainder(
                      quotientReg,
                      0,
                      dividendReg,
                      0,
                      count,
                      divisorSmall);
                    break;
            }
        }

        private static short FastDivideAndRemainderTwo(
          short[] quotientReg,
          int quotientStart,
          short[] dividendReg,
          int dividendStart,
          int count)
        {
            int quo;
            var rem = 0;
            int currentDividend;
            int ds = dividendStart + count - 1;
            int qs = quotientStart + count - 1;
            for (var i = 0; i < count; ++i)
            {
                currentDividend = ((int)dividendReg[ds]) & ShortMask;
                currentDividend |= rem << 16;
                quo = currentDividend >> 1;
                quotientReg[qs] = unchecked((short)quo);
                rem = currentDividend & 1;
                --ds;
                --qs;
            }
            return unchecked((short)rem);
        }

        private static short FastDivideAndRemainderTen(
          short[] quotientReg,
          int quotientStart,
          short[] dividendReg,
          int dividendStart,
          int count)
        {
            int quo;
            var rem = 0;
            int currentDividend;
            int ds = dividendStart + count - 1;
            int qs = quotientStart + count - 1;
            for (var i = 0; i < count; ++i)
            {
                currentDividend = ((int)dividendReg[ds]) & ShortMask;
                currentDividend |= rem << 16;
                // Fast division by 10
                quo = (currentDividend >= 81920) ? currentDividend / 10 :
                  (((currentDividend * 52429) >> 19) & 8191);
                quotientReg[qs] = unchecked((short)quo);
                rem = currentDividend - (10 * quo);
                --ds;
                --qs;
            }
            return unchecked((short)rem);
        }

        private static short FastDivideAndRemainder(
          short[] quotientReg,
          int quotientStart,
          short[] dividendReg,
          int dividendStart,
          int count,
          short divisorSmall)
        {
            int idivisor = ((int)divisorSmall) & ShortMask;
            int quo;
            var rem = 0;
            int ds = dividendStart + count - 1;
            int qs = quotientStart + count - 1;
            int currentDividend;
            if (idivisor < 0x8000)
            {
                for (var i = 0; i < count; ++i)
                {
                    currentDividend = ((int)dividendReg[ds]) & ShortMask;
                    currentDividend |= rem << 16;
                    quo = currentDividend / idivisor;
                    quotientReg[qs] = unchecked((short)quo);
                    rem = currentDividend - (idivisor * quo);
                    --ds;
                    --qs;
                }
            }
            else
            {
                for (var i = 0; i < count; ++i)
                {
                    currentDividend = ((int)dividendReg[ds]) & ShortMask;
                    currentDividend |= rem << 16;
                    if ((currentDividend >> 31) == 0)
                    {
                        quo = currentDividend / idivisor;
                        quotientReg[qs] = unchecked((short)quo);
                        rem = currentDividend - (idivisor * quo);
                    }
                    else
                    {
                        quo = ((int)DivideUnsigned(
                              currentDividend,
                              divisorSmall)) & ShortMask;
                        quotientReg[qs] = unchecked((short)quo);
                        rem = unchecked(currentDividend - (idivisor * quo));
                    }
                    --ds;
                    --qs;
                }
            }
            return unchecked((short)rem);
        }

        private static short FastRemainder(
          short[] dividendReg,
          int count,
          short divisorSmall)
        {
            int i = count;
            short remainder = 0;
            while ((i--) > 0)
            {
                int dividendSmall = unchecked((int)((((int)dividendReg[i]) &
                        ShortMask) | ((int)remainder << 16)));
                remainder = RemainderUnsigned(
                    dividendSmall,
                    divisorSmall);
            }
            return remainder;
        }

        private static short GetHighHalfAsBorrow(int val)
        {
            return unchecked((short)(0 - ((val >> 16) & ShortMask)));
        }

        private static int GetLowHalf(int val)
        {
            return val & ShortMask;
        }

        private static int GetUnsignedBitLengthEx(int numberValue, int wordCount)
        {
            // NOTE: Currently called only if wordCount <= 1000000,
            // so that overflow issues with Int32s are not present
            int wc = wordCount;
            if (wc != 0)
            {
                wc = (wc - 1) << 4;
                if (numberValue == 0)
                {
                    return wc;
                }
                wc += 16;
                unchecked
                {
                    if ((numberValue >> 8) == 0)
                    {
                        numberValue <<= 8;
                        wc -= 8;
                    }
                    if ((numberValue >> 12) == 0)
                    {
                        numberValue <<= 4;
                        wc -= 4;
                    }
                    if ((numberValue >> 14) == 0)
                    {
                        numberValue <<= 2;
                        wc -= 2;
                    }
                    if ((numberValue >> 15) == 0)
                    {
                        --wc;
                    }
                }
                return wc;
            }
            return 0;
        }

        internal static short[] GrowForCarry(short[] a, short carry)
        {
            int oldLength = a.Length;
            short[] ret = CleanGrow(a, oldLength + 1);
            ret[oldLength] = carry;
            return ret;
        }

        internal static int IncrementWords(
          short[] words1,
          int words1Start,
          int n,
          short words2)
        {
            unchecked
            {
                short tmp = words1[words1Start];
                words1[words1Start] = (short)(tmp + words2);
                if ((((int)words1[words1Start]) & ShortMask) >= (((int)tmp) &
                    ShortMask))
                {
                    return 0;
                }
                for (int i = 1; i < n; ++i)
                {
                    ++words1[words1Start + i];
                    if (words1[words1Start + i] != 0)
                    {
                        return 0;
                    }
                }
                return 1;
            }
        }

        private static short LinearMultiply(
          short[] productArr,
          int cstart,
          short[] words1,
          int astart,
          short words2,
          int n)
        {
            unchecked
            {
                short carry = 0;
                int bint = ((int)words2) & ShortMask;
                for (var i = 0; i < n; ++i)
                {
                    int p;
                    p = (((int)words1[astart + i]) & ShortMask) * bint;
                    p += ((int)carry) & ShortMask;
                    productArr[cstart + i] = (short)p;
                    carry = (short)(p >> 16);
                }
                return carry;
            }
        }

        private static short LinearMultiplyAdd(
          short[] productArr,
          int cstart,
          short[] words1,
          int astart,
          short words2,
          int n)
        {
            short carry = 0;
            int bint = ((int)words2) & ShortMask;
            for (var i = 0; i < n; ++i)
            {
                int p;
                p = unchecked((((int)words1[astart + i]) & ShortMask) * bint);
                p = unchecked(p + (((int)carry) & ShortMask));
                p = unchecked(p + (((int)productArr[cstart + i]) & ShortMask));
                productArr[cstart + i] = unchecked((short)p);
                carry = (short)(p >> 16);
            }
            return carry;
        }

        private static void RecursiveSquare(
          short[] resultArr,
          int resultStart,
          short[] tempArr,
          int tempStart,
          short[] words1,
          int words1Start,
          int count)
        {
            if (count <= MultRecursionThreshold)
            {
                switch (count)
                {
                    case 2:
                        BaselineSquare2(resultArr, resultStart, words1, words1Start);
                        break;
                    case 4:
                        BaselineSquare4(resultArr, resultStart, words1, words1Start);
                        break;
                    case 8:
                        BaselineSquare8(resultArr, resultStart, words1, words1Start);
                        break;
                    default:
                        SchoolbookSquare(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          count);
                        break;
                }
            }
            else if (count >= Toom4Threshold)
            {
                Toom4(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  count,
                  words1,
                  words1Start,
                  count);
            }
            else if (count >= Toom3Threshold)
            {
                Toom3(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  count,
                  words1,
                  words1Start,
                  count);
            }
            else if ((count & 1) == 0)
            {
                int count2 = count >> 1;
                RecursiveSquare(
                  resultArr,
                  resultStart,
                  tempArr,
                  tempStart + count,
                  words1,
                  words1Start,
                  count2);
                RecursiveSquare(
                  resultArr,
                  resultStart + count,
                  tempArr,
                  tempStart + count,
                  words1,
                  words1Start + count2,
                  count2);
                SameSizeMultiply(
                  tempArr,
                  tempStart,
                  tempArr,
                  tempStart + count,
                  words1,
                  words1Start,
                  words1,
                  words1Start + count2,
                  count2);
                int carry = AddInternal(
                    resultArr,
                    resultStart + count2,
                    resultArr,
                    resultStart + count2,
                    tempArr,
                    tempStart,
                    count);
                carry += AddInternal(
                    resultArr,
                    resultStart + count2,
                    resultArr,
                    resultStart + count2,
                    tempArr,
                    tempStart,
                    count);
                IncrementWords(
                  resultArr,
                  (int)(resultStart + count + count2),
                  count2,
                  (short)carry);
            }
            else
            {
                SameSizeMultiply(
                  resultArr,
                  resultStart,
                  tempArr,
                  tempStart,
                  words1,
                  words1Start,
                  words1,
                  words1Start,
                  count);
            }
        }

        private static short RemainderUnsigned(int x, short y)
        {
            unchecked
            {
                int iy = ((int)y) & ShortMask;
                return ((x >> 31) == 0) ? ((short)(((int)x % iy) & ShortMask)) :
                  Divide32By16(x, y, true);
            }
        }

        private static void ReverseChars(char[] chars, int offset, int length)
        {
            int half = length >> 1;
            int right = offset + length - 1;
            for (var i = 0; i < half; i++, right--)
            {
                char value = chars[offset + i];
                chars[offset + i] = chars[right];
                chars[right] = value;
            }
        }

        // NOTE: Renamed from RecursiveMultiply to better show that
        // this function only takes operands of the same size, as opposed
        // to AsymmetricMultiply.
        private static void SameSizeMultiply(
          short[] resultArr, // size 2*count
          int resultStart,
          short[] tempArr, // size 2*count
          int tempStart,
          short[] words1,
          int words1Start, // size count
          short[] words2,
          int words2Start, // size count
          int count)
        {
            // DebugUtility.Log("RecursiveMultiply " + count + " " + count +
            // " [r=" + resultStart + " t=" + tempStart + " a=" + words1Start +
            // " b=" + words2Start + "]");
#if DEBUG
            if (resultArr == null)
            {
                throw new ArgumentNullException(nameof(resultArr));
            }

            if (resultStart < 0)
            {
                throw new ArgumentException("resultStart(" + resultStart +
                  ") is less than 0");
            }

            if (resultStart > resultArr.Length)
            {
                throw new ArgumentException("resultStart(" + resultStart +
                  ") is more than " + resultArr.Length);
            }

            if (count + count < 0)
            {
                throw new ArgumentException("count plus count(" + (count + count) +
                  ") is less than 0");
            }
            if (count + count > resultArr.Length)
            {
                throw new ArgumentException("count plus count(" + (count + count) +
                  ") is more than " + resultArr.Length);
            }

            if (resultArr.Length - resultStart < count + count)
            {
                throw new ArgumentException("resultArr.Length minus resultStart(" +
                  (resultArr.Length - resultStart) +
                  ") is less than " + (count + count));
            }

            if (tempArr == null)
            {
                throw new ArgumentNullException(nameof(tempArr));
            }

            if (tempStart < 0)
            {
                throw new ArgumentException("tempStart(" + tempStart +
                  ") is less than 0");
            }

            if (tempStart > tempArr.Length)
            {
                throw new ArgumentException("tempStart(" + tempStart +
                  ") is more than " + tempArr.Length);
            }

            if (count + count < 0)
            {
                throw new ArgumentException("count plus count(" + (count + count) +
                  ") is less than 0");
            }

            if (count + count > tempArr.Length)
            {
                throw new ArgumentException("count plus count(" + (count + count) +
                  ") is more than " + tempArr.Length);
            }

            if (tempArr.Length - tempStart < count + count)
            {
                throw new ArgumentException("tempArr.Length minus tempStart(" +
                  (tempArr.Length - tempStart) + ") is less than " + (count + count));
            }

            if (words1 == null)
            {
                throw new ArgumentNullException(nameof(words1));
            }

            if (words1Start < 0)
            {
                throw new ArgumentException("words1Start(" + words1Start +
                  ") is less than 0");
            }

            if (words1Start > words1.Length)
            {
                throw new ArgumentException("words1Start(" + words1Start +
                  ") is more than " + words1.Length);
            }

            if (count < 0)
            {
                throw new ArgumentException("count(" + count + ") is less than " +
                  "0");
            }

            if (count > words1.Length)
            {
                throw new ArgumentException("count(" + count + ") is more than " +
                  words1.Length);
            }

            if (words1.Length - words1Start < count)
            {
                throw new ArgumentException("words1.Length minus words1Start(" +
                  (words1.Length - words1Start) + ") is less than " +
                  count);
            }

            if (words2 == null)
            {
                throw new ArgumentNullException(nameof(words2));
            }

            if (words2Start < 0)
            {
                throw new ArgumentException("words2Start(" + words2Start +
                  ") is less than 0");
            }

            if (words2Start > words2.Length)
            {
                throw new ArgumentException("words2Start(" + words2Start +
                  ") is more than " + words2.Length);
            }

            if (count < 0)
            {
                throw new ArgumentException("count(" + count + ") is less than " +
                  "0");
            }

            if (count > words2.Length)
            {
                throw new ArgumentException("count(" + count + ") is more than " +
                  words2.Length);
            }

            if (words2.Length - words2Start < count)
            {
                throw new ArgumentException("words2.Length minus words2Start(" +
                  (words2.Length - words2Start) + ") is less than " +
                  count);
            }
#endif

            if (count <= MultRecursionThreshold)
            {
                switch (count)
                {
                    case 2:
                        BaselineMultiply2(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          words2,
                          words2Start);
                        break;
                    case 4:
                        BaselineMultiply4(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          words2,
                          words2Start);
                        break;
                    case 8:
                        BaselineMultiply8(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          words2,
                          words2Start);
                        break;
                    default:
                        SchoolbookMultiply(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          count,
                          words2,
                          words2Start,
                          count);
                        break;
                }
            }
            else if (count >= Toom4Threshold)
            {
                Toom4(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  count,
                  words2,
                  words2Start,
                  count);
            }
            else if (count >= Toom3Threshold)
            {
                Toom3(
                  resultArr,
                  resultStart,
                  words1,
                  words1Start,
                  count,
                  words2,
                  words2Start,
                  count);
            }
            else
            {
                int countA = count;
                while (countA != 0 && words1[words1Start + countA - 1] == 0)
                {
                    --countA;
                }
                int countB = count;
                while (countB != 0 && words2[words2Start + countB - 1] == 0)
                {
                    --countB;
                }
                var offset2For1 = 0;
                var offset2For2 = 0;
                if (countA == 0 || countB == 0)
                {
                    // words1 or words2 is empty, so result is 0
                    Array.Clear((short[])resultArr, resultStart, count << 1);
                    return;
                }
                // Split words1 and words2 in two parts each
                // Words1 is split into HighA and LowA
                // Words2 is split into HighB and LowB
                if ((count & 1) == 0)
                {
                    // Count is even, so each part will be equal size
                    int count2 = count >> 1;
                    if (countA <= count2 && countB <= count2)
                    {
                        // Both words1 and words2 are smaller than half the
                        // count (their high parts are 0)
                        // DebugUtility.Log("Can be smaller: " + AN + "," + BN + "," +
                        // (count2));
                        Array.Clear((short[])resultArr, resultStart + count, count);
                        if (count2 == 8)
                        {
                            BaselineMultiply8(
                              resultArr,
                              resultStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start);
                        }
                        else
                        {
                            SameSizeMultiply(
                              resultArr,
                              resultStart,
                              tempArr,
                              tempStart,
                              words1,
                              words1Start,
                              words2,
                              words2Start,
                              count2);
                        }
                        return;
                    }
                    int resultMediumHigh = resultStart + count;
                    int resultHigh = resultMediumHigh + count2;
                    int resultMediumLow = resultStart + count2;
                    int tsn = tempStart + count;
                    // Find the part of words1 with the higher value
                    // so we can compute the absolute value
                    offset2For1 = Compare(
                        words1,
                        words1Start,
                        words1,
                        words1Start + count2,
                        count2) > 0 ? 0 : count2;
                    var tmpvar = (int)(words1Start + (count2 ^
                          offset2For1));
                    // Abs(LowA - HighA)
                    SubtractInternal(
                      resultArr,
                      resultStart,
                      words1,
                      words1Start + offset2For1,
                      words1,
                      tmpvar,
                      count2);
                    // Find the part of words2 with the higher value
                    // so we can compute the absolute value
                    offset2For2 = Compare(
                        words2,
                        words2Start,
                        words2,
                        words2Start + count2,
                        count2) > 0 ? 0 : count2;
                    // Abs(LowB - HighB)
                    int tmp = words2Start + (count2 ^ offset2For2);
                    SubtractInternal(
                      resultArr,
                      resultMediumLow,
                      words2,
                      words2Start + offset2For2,
                      words2,
                      tmp,
                      count2);
                    // Medium-high/high result = HighA * HighB
                    SameSizeMultiply(
                      resultArr,
                      resultMediumHigh,
                      tempArr,
                      tsn,
                      words1,
                      words1Start + count2,
                      words2,
                      words2Start + count2,
                      count2);
                    // Temp = Abs(LowA-HighA) * Abs(LowB-HighB)
                    SameSizeMultiply(
                      tempArr,
                      tempStart,
                      tempArr,
                      tsn,
                      resultArr,
                      resultStart,
                      resultArr,
                      resultMediumLow,
                      count2);
                    // Low/Medium-low result = LowA * LowB
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tsn,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      count2);
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB)
                    int c2 = AddInternal(
                        resultArr,
                        resultMediumHigh,
                        resultArr,
                        resultMediumHigh,
                        resultArr,
                        resultMediumLow,
                        count2);
                    int c3 = c2;
                    // Medium low result = Low(HighA * HighB) + High(LowA * LowB) +
                    // Low(LowA * LowB)
                    c2 += AddInternal(
                        resultArr,
                        resultMediumLow,
                        resultArr,
                        resultMediumHigh,
                        resultArr,
                        resultStart,
                        count2);
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB) +
                    // High(HighA * HighB)
                    c3 += AddInternal(
                        resultArr,
                        resultMediumHigh,
                        resultArr,
                        resultMediumHigh,
                        resultArr,
                        resultHigh,
                        count2);
                    if (offset2For1 == offset2For2)
                    {
                        // If high parts of both words were greater
                        // than their low parts
                        // or if low parts of both words were greater
                        // than their high parts
                        // Medium low/Medium high result = Medium low/Medium high result
                        // - Low(Temp)
                        c3 -= SubtractInternal(
                            resultArr,
                            resultMediumLow,
                            resultArr,
                            resultMediumLow,
                            tempArr,
                            tempStart,
                            count);
                    }
                    else
                    {
                        // Medium low/Medium high result = Medium low/Medium high result
                        // + Low(Temp)
                        c3 += AddInternal(
                            resultArr,
                            resultMediumLow,
                            resultArr,
                            resultMediumLow,
                            tempArr,
                            tempStart,
                            count);
                    }
                    // Add carry
                    c3 += IncrementWords(resultArr, resultMediumHigh, count2, (short)c2);
                    if (c3 != 0)
                    {
                        IncrementWords(resultArr, resultHigh, count2, (short)c3);
                    }
                }
                else
                {
                    // Count is odd, high part will be 1 shorter
                    int countHigh = count >> 1; // Shorter part
                    int countLow = count - countHigh; // Longer part
                    offset2For1 = CompareWithWords1IsOneBigger(
                        words1,
                        words1Start,
                        words1,
                        words1Start + countLow,
                        countLow) > 0 ? 0 : countLow;
                    // Abs(LowA - HighA)
                    if (offset2For1 == 0)
                    {
                        SubtractWords1IsOneBigger(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start,
                          words1,
                          words1Start + countLow,
                          countLow);
                    }
                    else
                    {
                        SubtractWords2IsOneBigger(
                          resultArr,
                          resultStart,
                          words1,
                          words1Start + countLow,
                          words1,
                          words1Start,
                          countLow);
                    }
                    offset2For2 = CompareWithWords1IsOneBigger(
                        words2,
                        words2Start,
                        words2,
                        words2Start + countLow,
                        countLow) > 0 ? 0 : countLow;
                    // Abs(LowB, HighB)
                    if (offset2For2 == 0)
                    {
                        SubtractWords1IsOneBigger(
                          tempArr,
                          tempStart,
                          words2,
                          words2Start,
                          words2,
                          words2Start + countLow,
                          countLow);
                    }
                    else
                    {
                        SubtractWords2IsOneBigger(
                          tempArr,
                          tempStart,
                          words2,
                          words2Start + countLow,
                          words2,
                          words2Start,
                          countLow);
                    }
                    // Temp = Abs(LowA-HighA) * Abs(LowB-HighB)
                    int shorterOffset = countHigh << 1;
                    int longerOffset = countLow << 1;
                    SameSizeMultiply(
                      tempArr,
                      tempStart + shorterOffset,
                      resultArr,
                      resultStart + shorterOffset,
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      countLow);
                    // Save part of temp since temp will overlap in part
                    // in the Low/Medium low result multiply
                    short resultTmp0 = tempArr[tempStart + shorterOffset];
                    short resultTmp1 = tempArr[tempStart + shorterOffset + 1];
                    // Medium high/high result = HighA * HighB
                    SameSizeMultiply(
                      resultArr,
                      resultStart + longerOffset,
                      resultArr,
                      resultStart,
                      words1,
                      words1Start + countLow,
                      words2,
                      words2Start + countLow,
                      countHigh);
                    // Low/Medium low result = LowA * LowB
                    SameSizeMultiply(
                      resultArr,
                      resultStart,
                      tempArr,
                      tempStart,
                      words1,
                      words1Start,
                      words2,
                      words2Start,
                      countLow);
                    // Restore part of temp
                    tempArr[tempStart + shorterOffset] = resultTmp0;
                    tempArr[tempStart + shorterOffset + 1] = resultTmp1;
                    int countMiddle = countLow << 1;
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB)
                    int c2 = AddInternal(
                        resultArr,
                        resultStart + countMiddle,
                        resultArr,
                        resultStart + countMiddle,
                        resultArr,
                        resultStart + countLow,
                        countLow);
                    int c3 = c2;
                    // Medium low result = Low(HighA * HighB) + High(LowA * LowB) +
                    // Low(LowA * LowB)
                    c2 += AddInternal(
                        resultArr,
                        resultStart + countLow,
                        resultArr,
                        resultStart + countMiddle,
                        resultArr,
                        resultStart,
                        countLow);
                    // Medium high result = Low(HighA * HighB) + High(LowA * LowB) +
                    // High(HighA * HighB)
                    c3 += AddUnevenSize(
                        resultArr,
                        resultStart + countMiddle,
                        resultArr,
                        resultStart + countMiddle,
                        countLow,
                        resultArr,
                        resultStart + countMiddle + countLow,
                        countLow - 2);
                    if (offset2For1 == offset2For2)
                    {
                        // If high parts of both words were greater
                        // than their low parts
                        // or if low parts of both words were greater
                        // than their high parts
                        // Medium low/Medium high result = Medium low/Medium high result
                        // - Low(Temp)
                        c3 -= SubtractInternal(
                            resultArr,
                            resultStart + countLow,
                            resultArr,
                            resultStart + countLow,
                            tempArr,
                            tempStart + shorterOffset,
                            countLow << 1);
                    }
                    else
                    {
                        // Medium low/Medium high result = Medium low/Medium high result
                        // + Low(Temp)
                        c3 += AddInternal(
                            resultArr,
                            resultStart + countLow,
                            resultArr,
                            resultStart + countLow,
                            tempArr,
                            tempStart + shorterOffset,
                            countLow << 1);
                    }
                    // Add carry
                    c3 += IncrementWords(
                        resultArr,
                        resultStart + countMiddle,
                        countLow,
                        (short)c2);
                    if (c3 != 0)
                    {
                        IncrementWords(
                          resultArr,
                          resultStart + countMiddle + countLow,
                          countLow - 2,
                          (short)c3);
                    }
                }
            }
        }

        private static void SchoolbookMultiplySameLengthEven(
          short[] resultArr,
          int resultStart,
          short[] words1,
          int words1Start,
          short[] words2,
          int words2Start,
          int count)
        {
            int resultPos;
            long carry = 0;
            long p;
            long valueBint;
            unchecked
            {
                valueBint = ((int)words2[words2Start]) & ShortMask;
                valueBint |= (((long)words2[words2Start + 1]) & ShortMask) << 16;
                for (int j = 0; j < count; j += 2)
                {
                    p = ((int)words1[words1Start + j]) & ShortMask;
                    p |= (((long)words1[words1Start + j + 1]) & ShortMask) << 16;
                    p *= valueBint + carry;
                    resultArr[resultStart + j] = (short)p;
                    resultArr[resultStart + j + 1] = (short)(p >> 16);
                    carry = (p >> 32) & 0xffffffffL;
                }
                resultArr[resultStart + count] = (short)carry;
                resultArr[resultStart + count + 1] = (short)(carry >> 16);
                for (int i = 2; i < count; i += 2)
                {
                    resultPos = resultStart + i;
                    carry = 0;
                    valueBint = ((int)words2[words2Start + i]) & ShortMask;
                    valueBint |= (((long)words2[words2Start + i + 1]) & ShortMask) << 16;
                    for (int j = 0; j < count; j += 2, resultPos += 2)
                    {
                        p = ((int)words1[words1Start + j]) & ShortMask;
                        p |= (((long)words1[words1Start + j + 1]) & ShortMask) << 16;
                        p *= valueBint + carry;
                        p += ((int)resultArr[resultPos]) & ShortMask;
                        p += (((int)resultArr[resultPos + 1]) & ShortMask) << 16;
                        resultArr[resultPos] = (short)p;
                        resultArr[resultPos + 1] = (short)(p >> 16);
                        carry = (p >> 32) & 0xffffffffL;
                    }
                    resultArr[resultStart + i + count] = (short)carry;
                    resultArr[resultStart + i + count + 1] = (short)(carry >> 16);
                }
            }
        }

        private static void SchoolbookMultiplySameLengthOdd(
          short[] resultArr,
          int resultStart,
          short[] words1,
          int words1Start,
          short[] words2,
          int words2Start,
          int count)
        {
            int resultPos;
            long carry = 0;
            long p;
            long valueBint;
            unchecked
            {
                valueBint = ((int)words2[words2Start]) & ShortMask;
                valueBint |= (count > 1) ? (((long)words2[words2Start + 1]) &
                    ShortMask) << 16 : 0;
                for (int j = 0; j < count; j += 2)
                {
                    p = ((int)words1[words1Start + j]) & ShortMask;
                    if (j + 1 < count)
                    {
                        p |= ((long)words1[words1Start + j + 1]) & ShortMask;
                    }
                    p *= valueBint + carry;
                    resultArr[resultStart + j] = (short)p;
                    if (j + 1 < count)
                    {
                        resultArr[resultStart + j + 1] = (short)(p >> 16);
                    }
                    carry = (p >> 32) & 0xffffffffL;
                }
                resultArr[resultStart + count] = (short)carry;
                if (count > 1)
                {
                    resultArr[resultStart + count + 1] = (short)(carry >> 16);
                }
                for (int i = 2; i < count; i += 2)
                {
                    resultPos = resultStart + i;
                    carry = 0;
                    valueBint = ((int)words2[words2Start + i]) & ShortMask;
                    if (i + 1 < count)
                    {
                        valueBint |= (((long)words2[words2Start + i + 1]) & ShortMask) <<
                          16;
                    }
                    for (int j = 0; j < count; j += 2, resultPos += 2)
                    {
                        p = ((int)words1[words1Start + j]) & ShortMask;
                        if (j + 1 < count)
                        {
                            p |= (((long)words1[words1Start + j + 1]) & ShortMask) << 16;
                        }
                        p *= valueBint + carry;
                        p += ((int)resultArr[resultPos]) & ShortMask;
                        if (j + 1 < count)
                        {
                            p += (((int)resultArr[resultPos + 1]) & ShortMask) << 16;
                            resultArr[resultPos] = (short)p;
                            resultArr[resultPos + 1] = (short)(p >> 16);
                            carry = (p >> 32) & 0xffffffffL;
                        }
                        else
                        {
                            resultArr[resultPos] = (short)p;
                            carry = p >> 16;
                        }
                    }
                    resultArr[resultStart + i + count] = (short)carry;
                    if (i + 1 < count)
                    {
                        resultArr[resultStart + i + count + 1] = (short)(carry >> 16);
                    }
                }
            }
        }

        private static void SchoolbookMultiply(
          short[] resultArr,
          int resultStart,
          short[] words1,
          int words1Start,
          int words1Count,
          short[] words2,
          int words2Start,
          int words2Count)
        {
#if DEBUG
            // Avoid overlaps
            if (resultArr == words1)
            {
                int m1 = Math.Max(resultStart, words1Start);
                int m2 = Math.Min(
                    resultStart + words1Count + words2Count,
                    words1Start + words1Count);
                if (m1 < m2)
                {
                    throw new InvalidOperationException();
                }
            }
            if (resultArr == words2)
            {
                int m1 = Math.Max(resultStart, words2Start);
                int m2 = Math.Min(
                    resultStart + words1Count + words2Count,
                    words2Start + words2Count);
                if (m1 < m2)
                {
                    throw new InvalidOperationException();
                }
            }
            if (words1Count <= 0)
            {
                throw new ArgumentException("words1Count(" + words1Count +
                  ") is not greater than 0");
            }
            if (words2Count <= 0)
            {
                throw new ArgumentException("words2Count(" + words2Count +
                  ") is not greater than 0");
            }
#endif
            if (words1Count == words2Count && (words1Count & 1) == 0)
            {
                /* if ((words1Count & 1) == 0) {
                          SchoolbookMultiplySameLengthEven(
                            resultArr,
                            resultStart,
                            words1,
                            words1Start,
                            words2,
                            words2Start,
                            words1Count);
                          return;
                        } else {
                          SchoolbookMultiplySameLengthOdd(
                            resultArr,
                            resultStart,
                            words1,
                            words1Start,
                            words2,
                            words2Start,
                            words1Count);
                  return;
                       }
                 */
            }
            int resultPos, carry, valueBint;
            if (words1Count < words2Count)
            {
                // words1 is shorter than words2, so put words2 on top
                carry = 0;
                valueBint = ((int)words1[words1Start]) & ShortMask;
                for (int j = 0; j < words2Count; ++j)
                {
                    int p;
                    p = unchecked((((int)words2[words2Start + j]) & ShortMask) *
                        valueBint);
                    p = unchecked(p + carry);
                    resultArr[resultStart + j] = unchecked((short)p);
                    carry = (p >> 16) & ShortMask;
                }
                resultArr[resultStart + words2Count] = unchecked((short)carry);
                for (var i = 1; i < words1Count; ++i)
                {
                    resultPos = resultStart + i;
                    carry = 0;
                    valueBint = ((int)words1[words1Start + i]) & ShortMask;
                    for (int j = 0; j < words2Count; ++j, ++resultPos)
                    {
                        int p;
                        p = unchecked((((int)words2[words2Start + j]) & ShortMask) *
                            valueBint);
                        p = unchecked(p + carry);
                        p = unchecked(p + (((int)resultArr[resultPos]) & ShortMask));
                        resultArr[resultPos] = unchecked((short)p);
                        carry = (p >> 16) & ShortMask;
                    }
                    resultArr[resultStart + i + words2Count] = unchecked((short)carry);
                }
            }
            else
            {
                // words2 is shorter or the same length as words1
                carry = 0;
                valueBint = ((int)words2[words2Start]) & ShortMask;
                for (int j = 0; j < words1Count; ++j)
                {
                    int p;
                    p = unchecked((((int)words1[words1Start + j]) & ShortMask) *
                        valueBint);
                    p = unchecked(p + carry);
                    resultArr[resultStart + j] = unchecked((short)p);
                    carry = (p >> 16) & ShortMask;
                }
                resultArr[resultStart + words1Count] = unchecked((short)carry);
                for (var i = 1; i < words2Count; ++i)
                {
                    resultPos = resultStart + i;
                    carry = 0;
                    valueBint = ((int)words2[words2Start + i]) & ShortMask;
                    for (int j = 0; j < words1Count; ++j, ++resultPos)
                    {
                        int p;
                        p = unchecked((((int)words1[words1Start + j]) & ShortMask) *
                            valueBint);
                        p = unchecked(p + carry);
                        p = unchecked(p + (((int)resultArr[resultPos]) & ShortMask));
                        resultArr[resultPos] = unchecked((short)p);
                        carry = (p >> 16) & ShortMask;
                    }
                    resultArr[resultStart + i + words1Count] = unchecked((short)carry);
                }
            }
        }

        private static void SchoolbookSquare(
          short[] resultArr,
          int resultStart,
          short[] words1,
          int words1Start,
          int words1Count)
        {
            // Method assumes that resultArr was already zeroed,
            // if resultArr is the same as words1
            int cstart;
            for (var i = 0; i < words1Count; ++i)
            {
                cstart = resultStart + i;
                unchecked
                {
                    short carry = 0;
                    int valueBint = ((int)words1[words1Start + i]) & ShortMask;
                    for (int j = 0; j < words1Count; ++j)
                    {
                        int p;
                        p = (((int)words1[words1Start + j]) & ShortMask) * valueBint;
                        p += ((int)carry) & ShortMask;
                        if (i != 0)
                        {
                            p += ((int)resultArr[cstart + j]) & ShortMask;
                        }
                        resultArr[cstart + j] = (short)p;
                        carry = (short)(p >> 16);
                    }
                    resultArr[cstart + words1Count] = carry;
                }
            }
        }

        private static short ShiftWordsLeftByBits(
          short[] r,
          int rstart,
          int count,
          int shiftBits)
        {
#if DEBUG
            if (shiftBits >= 16)
            {
                throw new ArgumentException("doesn't satisfy shiftBits<16");
            }
#endif
            int u;
            var carry = 0;
            if (shiftBits != 0)
            {
                int sb16 = 16 - shiftBits;
                int rs = rstart;
                for (var i = 0; i < count; ++i, ++rs)
                {
                    u = r[rs];
                    r[rs] = unchecked((short)((u << shiftBits) | carry));
                    carry = (u & ShortMask) >> sb16;
                }
            }
            return unchecked((short)carry);
        }

        private static void ShiftWordsLeftByWords(
          short[] r,
          int rstart,
          int n,
          int shiftWords)
        {
            shiftWords = Math.Min(shiftWords, n);
            if (shiftWords != 0)
            {
                for (int i = n - 1; i >= shiftWords; --i)
                {
                    r[rstart + i] = r[rstart + i - shiftWords];
                }
                Array.Clear((short[])r, rstart, shiftWords);
            }
        }

        private static short ShiftWordsRightByBits(
          short[] r,
          int rstart,
          int n,
          int shiftBits)
        {
            short u, carry = 0;
            unchecked
            {
                if (shiftBits != 0)
                {
                    for (int i = n; i > 0; --i)
                    {
                        u = r[rstart + i - 1];
                        r[rstart + i - 1] = (short)((((((int)u) & ShortMask) >>
                                (int)shiftBits) & ShortMask) | (((int)carry) &
                              0xffff));
                        carry = (short)((((int)u) & ShortMask) << (int)(16 - shiftBits));
                    }
                }
                return carry;
            }
        }

        private static short ShiftWordsRightByBitsSignExtend(
          short[] r,
          int rstart,
          int n,
          int shiftBits)
        {
            unchecked
            {
                short u, carry = (short)((int)0xffff << (int)(16 - shiftBits));
                if (shiftBits != 0)
                {
                    for (int i = n; i > 0; --i)
                    {
                        u = r[rstart + i - 1];
                        r[rstart + i - 1] = (short)(((((int)u) & ShortMask) >>
                              (int)shiftBits) | (((int)carry) & ShortMask));
                        carry = (short)((((int)u) & ShortMask) << (int)(16 - shiftBits));
                    }
                }
                return carry;
            }
        }

        private static void ShiftWordsRightByWordsSignExtend(
          short[] r,
          int rstart,
          int n,
          int shiftWords)
        {
            shiftWords = Math.Min(shiftWords, n);
            if (shiftWords != 0)
            {
                for (var i = 0; i + shiftWords < n; ++i)
                {
                    r[rstart + i] = r[rstart + i + shiftWords];
                }
                rstart += n - shiftWords;
                // Sign extend
                for (var i = 0; i < shiftWords; ++i)
                {
                    r[rstart + i] = unchecked((short)0xffff);
                }
            }
        }

        private static short[] ShortenArray(short[] reg, int wordCount)
        {
            if (reg.Length > 32)
            {
                int newLength = wordCount;
                if (newLength < reg.Length && (reg.Length - newLength) >= 16)
                {
                    // Reallocate the array if the desired length
                    // is much smaller than the current length
                    var newreg = new short[newLength];
                    Array.Copy(reg, newreg, Math.Min(newLength, reg.Length));
                    reg = newreg;
                }
            }
            return reg;
        }

        private static int SubtractWords1IsOneBigger(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int words1Count)
        {
            // Assumes that words2's count is 1 less
            unchecked
            {
                int u;
                u = 0;
                int cm1 = words1Count - 1;
                for (var i = 0; i < cm1; i += 1)
                {
                    u = (((int)words1[astart]) & ShortMask) - (((int)words2[bstart]) &
                        0xffff) - (int)((u >> 31) & 1);
                    c[cstart++] = (short)u;
                    ++astart;
                    ++bstart;
                }
                u = (((int)words1[astart]) & ShortMask) - (int)((u >> 31) & 1);
                c[cstart++] = (short)u;
                return (int)((u >> 31) & 1);
            }
        }

        private static int SubtractWords2IsOneBigger(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int words2Count)
        {
            // Assumes that words1's count is 1 less
            int u;
            u = 0;
            int cm1 = words2Count - 1;
            for (var i = 0; i < cm1; i += 1)
            {
                u = unchecked((((int)words1[astart]) & ShortMask) -
                    (((int)words2[bstart]) & ShortMask) - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                ++astart;
                ++bstart;
            }
            u = 0 - unchecked((((int)words2[bstart]) & ShortMask) - (int)((u >>
                    31) & 1));
            c[cstart++] = unchecked((short)u);
            return (int)((u >> 31) & 1);
        }

        private static int SubtractInternal(
          short[] c,
          int cstart,
          short[] words1,
          int astart,
          short[] words2,
          int bstart,
          int n)
        {
            var u = 0;
            bool odd = (n & 1) != 0;
            if (odd)
            {
                --n;
            }
            var mask = 0xffff;
            for (var i = 0; i < n; i += 2)
            {
                int wb0 = words2[bstart] & mask;
                int wb1 = words2[bstart + 1] & mask;
                int wa0 = words1[astart] & mask;
                int wa1 = words1[astart + 1] & mask;
                u = unchecked(wa0 - wb0 - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                u = unchecked(wa1 - wb1 - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                astart += 2;
                bstart += 2;
            }
            if (odd)
            {
                u = unchecked((((int)words1[astart]) & mask) -
                    (((int)words2[bstart]) & mask) - (int)((u >> 31) & 1));
                c[cstart++] = unchecked((short)u);
                ++astart;
                ++bstart;
            }
            return (int)((u >> 31) & 1);
        }

        private static void TwosComplement(
          short[] words1,
          int words1Start,
          int n)
        {
            DecrementWords(words1, words1Start, n, (short)1);
            for (var i = 0; i < n; ++i)
            {
                words1[words1Start + i] = unchecked((short)(~words1[words1Start +
                        i]));
            }
        }

        private int ByteCount()
        {
            int wc = this.wordCount;
            if (wc == 0)
            {
                return 0;
            }
            short s = this.words[wc - 1];
            wc = (wc - 1) << 1;
            return (s == 0) ? wc : (((s >> 8) == 0) ? wc + 1 : wc + 2);
        }

        private int PositiveCompare(EInteger t)
        {
            int size = this.wordCount, tempSize = t.wordCount;
            return (
                size == tempSize) ? Compare(
                this.words,
                0,
                t.words,
                0,
                (int)size) : (size > tempSize ? 1 : -1);
        }

        private EInteger[] RootRemInternal(EInteger root, bool useRem)
        {
            if (root.CompareTo(1) == 0)
            {
                EInteger thisValue = this;
                return new[] { thisValue, EInteger.Zero };
            }
            if (root.CompareTo(1) < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(root));
            }
            if (root.CompareTo(2) == 0)
            {
                return this.SqrtRemInternal(useRem);
            }
            if (this.Sign <= 0)
            {
                return new[] { EInteger.Zero, EInteger.Zero };
            }
            if (this.Equals(EInteger.One))
            {
                return new[] { EInteger.One, EInteger.Zero };
            }
            // if (this.CanFitInInt64()) {
            // long v = this.ToInt64Checked();
            // int bl = NumberUtility.BitLength(v);
            // }
            EInteger bl = this.GetUnsignedBitLengthAsEInteger();
            EInteger rm1 = root.Subtract(1);
            EInteger shift = EInteger.Max(
                EInteger.Zero,
                bl.Multiply(rm1).Divide(root).Subtract(1));
            EInteger ret = this.ShiftRight(shift);
            // NOTE: ret is an upper bound of the root
            if (ret.Sign > 0)
            {
                // DebugUtility.Log("this->"+this+" initial->"+ret);
                while (true)
                {
                    EInteger oldret = ret;
                    // DebugUtility.Log(" thiswc -> " + this.wordCount +
                    // " :: wc -> " + ret.wordCount + (ret.wordCount==1 ?
                    // ("=>"+this) : ""));
                    ret = this.Divide(ret.Pow(rm1)).Add(ret.Multiply(rm1)).Divide(root);
                    if (oldret.Equals(ret))
                    {
                        break;
                    }
                    if (ret.CompareTo(oldret) > 0)
                    {
                        // Starting to vacillate; break
                        ret = oldret;
                        break;
                    }
                }
            }
            if (useRem)
            {
                EInteger erem = this.Subtract(ret.Pow(root));
                if (erem.Sign < 0)
                {
                    throw new InvalidOperationException();
                }
                return new[] { ret, erem };
            }
            else
            {
                return new[] { ret, null };
            }
        }

        private EInteger[] SqrtRemInternal(bool useRem)
        {
            if (this.Sign <= 0)
            {
                return new[] { EInteger.Zero, EInteger.Zero };
            }
            if (this.Equals(EInteger.One))
            {
                return new[] { EInteger.One, EInteger.Zero };
            }
            EInteger bigintX;
            EInteger bigintY;
            EInteger thisValue = this;
            if (thisValue.CanFitInInt32())
            {
                int smallValue = thisValue.ToInt32Checked();
                int smallPowerBits =
                  (thisValue.GetUnsignedBitLengthAsEInteger().ToInt32Checked() + 1)
                  / 2;
                // No need to check for zero; already done above
                var smallintX = 0;
                int smallintY = 1 << smallPowerBits;
                do
                {
                    smallintX = smallintY;
                    smallintY = smallValue / smallintX;
                    smallintY += smallintX;
                    smallintY >>= 1;
                } while (smallintY < smallintX);
                if (!useRem)
                {
                    return new[] { (EInteger)smallintX, null };
                }
                smallintY = smallintX * smallintX;
                smallintY = smallValue - smallintY;
                return new[] {
          (EInteger)smallintX, (EInteger)smallintY,
        };
            }
            EInteger valueEPowerBits =
              thisValue.GetUnsignedBitLengthAsEInteger().Add(1).Divide(2);
            if (this.wordCount >= 4)
            {
                int wordsPerPart = (this.wordCount >> 2) +
                  ((this.wordCount & 3) > 0 ? 1 : 0);
                long bitsPerPart = wordsPerPart * 16;
                EInteger valueEBitsPerPart = EInteger.FromInt64(bitsPerPart);
                long totalBits = bitsPerPart * 4;
                EInteger valueEBitLength = this.GetUnsignedBitLengthAsEInteger();
                bool bitLengthEven = valueEBitLength.IsEven;
                bigintX = this;
                EInteger eshift = EInteger.Zero;
                if (valueEBitLength.CompareTo(EInteger.FromInt64(totalBits).Subtract(
                      1)) < 0)
                {
                    long targetLength = bitLengthEven ? totalBits : (totalBits - 1);
                    eshift = EInteger.FromInt64(targetLength).Subtract(valueEBitLength);
                    bigintX = bigintX.ShiftLeft(eshift);
                }
                // DebugUtility.Log("this=" + (this.ToRadixString(16)));
                // DebugUtility.Log("bigx=" + (bigintX.ToRadixString(16)));
                short[] ww = bigintX.words;
                var w1 = new short[wordsPerPart];
                var w2 = new short[wordsPerPart];
                var w3 = new short[wordsPerPart * 2];
                Array.Copy(ww, 0, w1, 0, wordsPerPart);
                Array.Copy(ww, wordsPerPart, w2, 0, wordsPerPart);
                Array.Copy(ww, wordsPerPart * 2, w3, 0, wordsPerPart * 2);
#if DEBUG
                if (!((ww[(wordsPerPart * 4) - 1] & 0xc000) != 0))
                {
                    throw new ArgumentException("doesn't satisfy" +
                      "\u0020(ww[wordsPerPart*4-1]&0xC000)!=0");
                }
#endif
                var e1 = new EInteger(CountWords(w1), w1, false);
                var e2 = new EInteger(CountWords(w2), w2, false);
                var e3 = new EInteger(CountWords(w3), w3, false);
                EInteger[] srem = e3.SqrtRemInternal(true);
                // DebugUtility.Log("sqrt0({0})[depth={3}] = {1},{2}"
                // , e3, srem[0], srem[1], 0);
                // DebugUtility.Log("sqrt1({0})[depth={3}] = {1},{2}"
                // , e3, srem2[0], srem2[1], 0);
                // if (!srem[0].Equals(srem2[0]) || !srem[1].Equals(srem2[1])) {
                // throw new InvalidOperationException(this.ToString());
                // }
                EInteger[] qrem = srem[1].ShiftLeft(
                    valueEBitsPerPart).Add(e2).DivRem(
                    srem[0].ShiftLeft(1));
                EInteger sqroot =
                  srem[0].ShiftLeft(valueEBitsPerPart).Add(qrem[0]);
                EInteger sqrem = qrem[1].ShiftLeft(
                    valueEBitsPerPart).Add(e1).Subtract(
                    qrem[0].Multiply(qrem[0]));
                // DebugUtility.Log("sqrem=" + sqrem + ",sqroot=" + sqroot);
                if (sqrem.Sign < 0)
                {
                    if (useRem)
                    {
                        sqrem = sqrem.Add(sqroot.ShiftLeft(1)).Subtract(EInteger.One);
                    }
                    sqroot = sqroot.Subtract(EInteger.One);
#if DEBUG
                    if (!(sqroot.Sign >= 0))
                    {
                        throw new ArgumentException("doesn't satisfy sqroot.Sign>= 0");
                    }
#endif
                }
                var retarr = new EInteger[2];
                retarr[0] = sqroot.ShiftRight(eshift.ShiftRight(1));
                if (useRem)
                {
                    if (eshift.IsZero)
                    {
                        retarr[1] = sqrem;
                    }
                    else
                    {
                        retarr[1] = this.Subtract(retarr[0].Multiply(retarr[0]));
                    }
                }
                return retarr;
            }
            bigintX = EInteger.Zero;
            bigintY = EInteger.One.ShiftLeft(valueEPowerBits);
            do
            {
                bigintX = bigintY;
                // DebugUtility.Log("" + thisValue + " " + bigintX);
                bigintY = thisValue / (EInteger)bigintX;
                bigintY += bigintX;
                bigintY >>= 1;
            } while (bigintY != null && bigintY.CompareTo(bigintX) < 0);
            if (!useRem)
            {
                return new[] { bigintX, null };
            }
            bigintY = bigintX * (EInteger)bigintX;
            bigintY = thisValue - (EInteger)bigintY;
            return new[] {
        bigintX, bigintY,
      };
        }

        /// <summary>Returns one added to this arbitrary-precision
        /// integer.</summary>
        /// <returns>The given arbitrary-precision integer plus one.</returns>
        public EInteger Increment()
        {
            return this.Add(EInteger.One);
        }

        /// <summary>Returns one subtracted from this arbitrary-precision
        /// integer.</summary>
        /// <returns>The given arbitrary-precision integer minus one.</returns>
        public EInteger Decrement()
        {
            return this.Subtract(EInteger.One);
        }

        // Begin integer conversions

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255).</summary>
        /// <returns>This number's value as a byte (from 0 to 255).</returns>
        /// <exception cref='OverflowException'>This value is less than 0 or
        /// greater than 255.</exception>
        public byte ToByteChecked()
        {
            int val = this.ToInt32Checked();
            if (val < 0 || val > 255)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((byte)(val & 0xff));
        }

        /// <summary>Converts this number to a byte (from 0 to 255), returning
        /// the least-significant bits of this number's two's-complement
        /// form.</summary>
        /// <returns>This number, converted to a byte (from 0 to
        /// 255).</returns>
        public byte ToByteUnchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((byte)(val & 0xff));
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>This number's value as an arbitrary-precision
        /// integer.</returns>
        public static EInteger FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer.</summary>
        /// <returns>This number's value as a 16-bit signed integer.</returns>
        /// <exception cref='OverflowException'>This value is less than -32768
        /// or greater than 32767.</exception>
        public short ToInt16Checked()
        {
            int val = this.ToInt32Checked();
            if (val < -32768 || val > 32767)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((short)(val & ShortMask));
        }

        /// <summary>Converts this number to a 16-bit signed integer, returning
        /// the least-significant bits of this number's two's-complement
        /// form.</summary>
        /// <returns>This number, converted to a 16-bit signed
        /// integer.</returns>
        public short ToInt16Unchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((short)(val & ShortMask));
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision
        /// integer.</returns>
        public static EInteger FromInt16(short inputInt16)
        {
            var val = (int)inputInt16;
            return FromInt32(val);
        }

        // End integer conversions
    }

    public sealed partial class EInteger
    {
        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision integer.</summary>
        /// <param name='ulongValue'>The number to convert as a 64-bit unsigned
        /// integer.</param>
        /// <returns>The value of <paramref name='ulongValue'/> as an
        /// arbitrary-precision integer.</returns>
        public static EInteger FromUInt64(ulong ulongValue)
        {
            if (ulongValue <= Int64.MaxValue)
            {
                return FromInt64((long)ulongValue);
            }
            else
            {
                ulongValue &= (1UL << 63) - 1;
                return EInteger.One.ShiftLeft(63).Add(FromInt64((long)ulongValue));
            }
        }

        /// <summary>Adds an arbitrary-precision integer and another
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='bthis'>The first operand.</param>
        /// <param name='augend'>The second operand.</param>
        /// <returns>The sum of the two numbers, that is, an
        /// arbitrary-precision integer plus another arbitrary-precision
        /// integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EInteger operator +(EInteger bthis, EInteger augend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(augend);
        }

        /// <summary>Subtracts two arbitrary-precision integer
        /// values.</summary>
        /// <param name='bthis'>An arbitrary-precision integer.</param>
        /// <param name='subtrahend'>Another arbitrary-precision
        /// integer.</param>
        /// <returns>The difference of the two objects.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EInteger operator -(
          EInteger bthis,
          EInteger subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <summary>Adds one to an arbitrary-precision integer.</summary>
        /// <param name='bthis'>An arbitrary-precision integer.</param>
        /// <returns>The given arbitrary-precision integer plus one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EInteger operator ++(EInteger bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(1);
        }

        /// <summary>Subtracts one from an arbitrary-precision
        /// integer.</summary>
        /// <param name='bthis'>An arbitrary-precision integer.</param>
        /// <returns>The given arbitrary-precision integer minus one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static EInteger operator --(EInteger bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(1);
        }

        /// <summary>Multiplies an arbitrary-precision integer by another
        /// arbitrary-precision integer and returns the result.</summary>
        /// <param name='operand1'>The first operand.</param>
        /// <param name='operand2'>The second operand.</param>
        /// <returns>The product of the two numbers, that is, an
        /// arbitrary-precision integer times another arbitrary-precision
        /// integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='operand1'/> is null.</exception>
        public static EInteger operator *(
          EInteger operand1,
          EInteger operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <summary>Divides an arbitrary-precision integer by the value of an
        /// arbitrary-precision integer object.</summary>
        /// <param name='dividend'>The number that will be divided by the
        /// divisor.</param>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The quotient of the two objects.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> is null.</exception>
        public static EInteger operator /(
          EInteger dividend,
          EInteger divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <summary>Returns the remainder that would result when an
        /// arbitrary-precision integer is divided by another
        /// arbitrary-precision integer. The remainder is the number that
        /// remains when the absolute value of an arbitrary-precision integer
        /// is divided by the absolute value of the other arbitrary-precision
        /// integer; the remainder has the same sign (positive or negative) as
        /// this arbitrary-precision integer.</summary>
        /// <param name='dividend'>The first operand.</param>
        /// <param name='divisor'>The number to divide by.</param>
        /// <returns>The remainder that would result when an
        /// arbitrary-precision integer is divided by another
        /// arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> is null.</exception>
        public static EInteger operator %(
          EInteger dividend,
          EInteger divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor);
        }

        /// <summary>Returns an arbitrary-precision integer with the bits
        /// shifted to the left by a number of bits. A value of 1 doubles this
        /// value, a value of 2 multiplies it by 4, a value of 3 by 8, a value
        /// of 4 by 16, and so on.</summary>
        /// <param name='bthis'>The arbitrary-precision integer to shift
        /// left.</param>
        /// <param name='bitCount'>The number of bits to shift. Can be
        /// negative, in which case this is the same as shiftRight with the
        /// absolute value of this parameter.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ShiftLeft.")]
        public static EInteger operator <<(EInteger bthis, int bitCount)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.ShiftLeft(bitCount);
        }

        /// <summary>Calculates the remainder when an arbitrary-precision
        /// integer raised to a certain power is divided by another
        /// arbitrary-precision integer.</summary>
        /// <param name='bigintValue'>The starting operand.</param>
        /// <param name='pow'>The power to raise this integer by.</param>
        /// <param name='mod'>The integer to divide the raised number
        /// by.</param>
        /// <returns>The value ( <paramref name='bigintValue'/> ^ <paramref
        /// name='pow'/> )% <paramref name='mod'/>.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigintValue'/> is null.</exception>
        public static EInteger ModPow(
          EInteger bigintValue,
          EInteger pow,
          EInteger mod)
        {
            if (bigintValue == null)
            {
                throw new ArgumentNullException(nameof(bigintValue));
            }
            return bigintValue.ModPow(pow, mod);
        }

        /// <summary>Shifts the bits of an arbitrary-precision integer to the
        /// right.</summary>
        /// <param name='bthis'>Another arbitrary-precision integer.</param>
        /// <param name='smallValue'>The parameter <paramref
        /// name='smallValue'/> is a 32-bit signed integer.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        /// <remarks>For this operation, the arbitrary-precision integer is
        /// treated as a two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ).
        /// Thus, for negative values, the arbitrary-precision integer is
        /// sign-extended.</remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ShiftRight.")]
        public static EInteger operator >>(EInteger bthis, int smallValue)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.ShiftRight(smallValue);
        }

        /// <summary>Negates an arbitrary-precision integer.</summary>
        /// <param name='bigValue'>An arbitrary-precision integer to
        /// negate.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static EInteger operator -(EInteger bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer.</summary>
        /// <returns>This number's value as a 64-bit signed integer.</returns>
        /// <exception cref='OverflowException'>This value is outside the range
        /// of a 64-bit signed integer.</exception>
        public ulong ToUInt64Checked()
        {
            if (this.negative || this.wordCount > 4)
            {
                throw new OverflowException("This object's value is out of range");
            }
            long ret = this.ToInt64Unchecked();
            if (this.GetSignedBit(63))
            {
                ret |= 1L << 63;
            }
            return unchecked((ulong)ret);
        }

        /// <summary>Converts this number to a 64-bit signed integer, returning
        /// the least-significant bits of this number's two's-complement
        /// form.</summary>
        /// <returns>This number, converted to a 64-bit signed
        /// integer.</returns>
        public ulong ToUInt64Unchecked()
        {
            long ret = this.ToInt64Unchecked();
            if (this.GetSignedBit(63))
            {
                ret |= 1L << 63;
            }
            return unchecked((ulong)ret);
        }

        /// <summary>Determines whether an arbitrary-precision integer is less
        /// than another arbitrary-precision integer.</summary>
        /// <param name='thisValue'>The first arbitrary-precision
        /// integer.</param>
        /// <param name='otherValue'>The second arbitrary-precision
        /// integer.</param>
        /// <returns><c>true</c> if <paramref name='thisValue'/> is less than
        /// <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        public static bool operator <(EInteger thisValue, EInteger otherValue)
        {
            return (thisValue == null) ? (otherValue != null) :
      (thisValue.CompareTo(otherValue) < 0);
        }

        /// <summary>Determines whether an arbitrary-precision integer is up to
        /// another arbitrary-precision integer.</summary>
        /// <param name='thisValue'>The first arbitrary-precision
        /// integer.</param>
        /// <param name='otherValue'>The second arbitrary-precision
        /// integer.</param>
        /// <returns><c>true</c> if <paramref name='thisValue'/> is up to
        /// <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        public static bool operator <=(
          EInteger thisValue,
          EInteger otherValue)
        {
            return (thisValue == null) || (thisValue.CompareTo(otherValue) <= 0);
        }

        /// <summary>Determines whether an arbitrary-precision integer is
        /// greater than another arbitrary-precision integer.</summary>
        /// <param name='thisValue'>The first arbitrary-precision
        /// integer.</param>
        /// <param name='otherValue'>The second arbitrary-precision
        /// integer.</param>
        /// <returns><c>true</c> if <paramref name='thisValue'/> is greater
        /// than <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        public static bool operator >(EInteger thisValue, EInteger otherValue)
        {
            return (thisValue != null) && (thisValue.CompareTo(otherValue) > 0);
        }

        /// <summary>Determines whether an arbitrary-precision integer value is
        /// greater than another arbitrary-precision integer.</summary>
        /// <param name='thisValue'>The first arbitrary-precision
        /// integer.</param>
        /// <param name='otherValue'>The second arbitrary-precision
        /// integer.</param>
        /// <returns><c>true</c> if <paramref name='thisValue'/> is at least
        /// <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
        public static bool operator >=(
          EInteger thisValue,
          EInteger otherValue)
        {
            return (thisValue == null) ? (otherValue == null) :
      (thisValue.CompareTo(otherValue) >= 0);
        }

        /// <summary>Returns an arbitrary-precision integer with every bit
        /// flipped.</summary>
        /// <param name='thisValue'>The operand as an arbitrary-precision
        /// integer.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='thisValue'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named Xor.")]
        public static EInteger operator ~(
          EInteger thisValue)
        {
            return Not(thisValue);
        }

        /// <summary>Does an AND operation between two arbitrary-precision
        /// integer values. For each bit of the result, that bit is 1 if the
        /// corresponding bits of the two operands are both 1, or is 0
        /// otherwise.</summary>
        /// <param name='thisValue'>The first operand.</param>
        /// <param name='otherValue'>The second operand.</param>
        /// <returns>The result of the operation.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "a" or "b" is
        /// null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named And.")]
        public static EInteger operator &(
          EInteger thisValue,
          EInteger otherValue)
        {
            return And(thisValue, otherValue);
        }

        /// <summary>Does an OR operation between two arbitrary-precision
        /// integer instances. For each bit of the result, that bit is 1 if
        /// either or both of the corresponding bits of the two operands are 1,
        /// or is 0 otherwise.</summary>
        /// <param name='thisValue'>An arbitrary-precision integer.</param>
        /// <param name='otherValue'>Another arbitrary-precision
        /// integer.</param>
        /// <returns>The result of the operation.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "first" or
        /// "second" is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named Or.")]
        public static EInteger operator |(
          EInteger thisValue,
          EInteger otherValue)
        {
            return Or(thisValue, otherValue);
        }

        /// <summary>Finds the exclusive "or" of two arbitrary-precision
        /// integer objects. For each bit of the result, that bit is 1 if
        /// either of the corresponding bits of the two operands, but not both,
        /// is 1, or is 0 otherwise.
        /// <para>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</para></summary>
        /// <param name='a'>The first arbitrary-precision integer.</param>
        /// <param name='b'>The second arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// it's set in one input integer but not the other.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='a'/> or <paramref name='b'/> is null.</exception>
        public static EInteger operator ^(
          EInteger a,
          EInteger b)
        {
            return Xor(a, b);
        }

        /// <summary>Retrieves bits from this integer's two's-complement
        /// form.</summary>
        /// <param name='index'>Zero-based index of the first bit to retrieve,
        /// where 0 is the least-significant bit of the number.</param>
        /// <param name='numberBits'>The number of bits to retrieve, starting
        /// with the first. Must be from 0 through 64.</param>
        /// <returns>A 64-bit signed integer containing the bits from this
        /// integer's two's-complement form. The least significant bit is the
        /// first bit, and any unused bits are set to 0.</returns>
        public long GetBits(int index, int numberBits)
        {
            if (numberBits < 0 || numberBits > 64)
            {
                throw new ArgumentOutOfRangeException(nameof(numberBits));
            }
            long v = 0;
            for (int j = 0; j < numberBits; ++j)
            {
                v |= (long)(this.GetSignedBit((int)(index + j)) ? 1 : 0) << j;
            }
            return v;
        }

        /// <summary>Divides this arbitrary-precision integer by another
        /// arbitrary-precision integer and returns a two-item array containing
        /// the result of the division and the remainder, in that order. The
        /// result of the division is rounded down (the fractional part is
        /// discarded). Except if the result of the division is 0, it will be
        /// negative if this arbitrary-precision integer is positive and the
        /// other arbitrary-precision integer is negative, or vice versa, and
        /// will be positive if both are positive or both are negative. The
        /// remainder is the number that remains when the absolute value of
        /// this arbitrary-precision integer is divided by the absolute value
        /// of the other arbitrary-precision integer; the remainder has the
        /// same sign (positive or negative) as this arbitrary-precision
        /// integer.</summary>
        /// <param name='dividend'>The arbitrary-precision integer to be
        /// divided.</param>
        /// <param name='divisor'>The arbitrary-precision integer to divide
        /// by.</param>
        /// <param name='remainder'>An arbitrary-precision integer.</param>
        /// <returns>An array of two items: the first is the result of the
        /// division as an arbitrary-precision integer, and the second is the
        /// remainder as an arbitrary-precision integer. The result of division
        /// is the result of the Divide method on the two operands, and the
        /// remainder is the result of the Remainder method on the two
        /// operands.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='dividend'/> or <paramref name='divisor'/> is
        /// null.</exception>
        [Obsolete("Use the DivRem instance method instead.")]
        public static EInteger DivRem(
          EInteger dividend,
          EInteger divisor,
          out EInteger remainder)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            if (divisor == null)
            {
                throw new ArgumentNullException(nameof(divisor));
            }
            EInteger[] result = dividend.DivRem(divisor);
            remainder = result[1];
            return result[0];
        }

        /// <summary>Determines whether this object and another object are
        /// equal.</summary>
        /// <param name='other'>Another arbitrary-precision integer.</param>
        /// <returns><c>true</c> if this object and another object are equal;
        /// otherwise, <c>false</c>.</returns>
        public bool Equals(EInteger other)
        {
            return (other != null) && (this.CompareTo(other) == 0);
        }

        /// <summary>Returns an arbitrary-precision integer with every bit
        /// flipped.</summary>
        /// <param name='valueA'>The operand as an arbitrary-precision
        /// integer.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='valueA'/> is null.</exception>
        public static EInteger Not(EInteger valueA)
        {
            if (valueA == null)
            {
                throw new ArgumentNullException(nameof(valueA));
            }
            return valueA.Not();
        }

        /// <summary>Does an AND operation between two arbitrary-precision
        /// integer values.</summary>
        /// <param name='a'>The first arbitrary-precision integer.</param>
        /// <param name='b'>The second arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bits of the two integers are both set.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='a'/> or <paramref name='b'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public static EInteger And(EInteger a, EInteger b)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            return a.And(b);
        }

        /// <summary>Does an OR operation between two arbitrary-precision
        /// integer instances.</summary>
        /// <param name='first'>The first operand.</param>
        /// <param name='second'>The second operand.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        /// <remarks>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</remarks>
        public static EInteger Or(EInteger first, EInteger second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            return first.Or(second);
        }

        /// <summary>Finds the exclusive "or" of two arbitrary-precision
        /// integer objects.
        /// <para>Each arbitrary-precision integer is treated as a
        /// two's-complement form (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see> ) for
        /// the purposes of this operator.</para></summary>
        /// <param name='a'>The first arbitrary-precision integer.</param>
        /// <param name='b'>The second arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision integer in which each bit is set if
        /// the corresponding bit is set in one input integer but not in the
        /// other.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='a'/> or <paramref name='b'/> is null.</exception>
        public static EInteger Xor(EInteger a, EInteger b)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            return a.Xor(b);
        }
        // Begin integer conversions

        /// <summary>Converts an arbitrary-precision integer to a byte (from 0
        /// to 255) if it can fit in a byte (from 0 to 255).</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a byte (from 0 to
        /// 255).</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than 0 or greater than 255.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToByteChecked.")]
        public static explicit operator byte(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// integer.</summary>
        /// <param name='boolValue'>Either <c>true</c> or <c>false</c>.</param>
        /// <returns>The value of <paramref name='boolValue'/> as an
        /// arbitrary-precision integer.</returns>
        public static explicit operator EInteger(bool boolValue)
        {
            return EInteger.FromBoolean(boolValue);
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>The value of <paramref name='inputByte'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(byte inputByte)
        {
            return EInteger.FromByte(inputByte);
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer.</summary>
        /// <returns>This number's value as an 8-bit signed integer.</returns>
        /// <exception cref='OverflowException'>This value is less than -128 or
        /// greater than 127.</exception>
        public sbyte ToSByteChecked()
        {
            int val = this.ToInt32Checked();
            if (val < -128 || val > 127)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((sbyte)(val & 0xff));
        }

        /// <summary>Converts this number to an 8-bit signed integer, returning
        /// the least-significant bits of this number's two's-complement
        /// form.</summary>
        /// <returns>This number, converted to an 8-bit signed
        /// integer.</returns>
        public sbyte ToSByteUnchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((sbyte)(val & 0xff));
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision
        /// integer.</returns>
        public static EInteger FromSByte(sbyte inputSByte)
        {
            var val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision integer to an 8-bit signed
        /// integer if it can fit in an 8-bit signed integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as an 8-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than -128 or greater than 127.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToSByteChecked.")]
        public static explicit operator sbyte(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputSByte'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(sbyte inputSByte)
        {
            return EInteger.FromSByte(inputSByte);
        }

        /// <summary>Converts an arbitrary-precision integer to a 16-bit signed
        /// integer if it can fit in a 16-bit signed integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a 16-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than -32768 or greater than
        /// 32767.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt16Checked.")]
        public static explicit operator short(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt16'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(short inputInt16)
        {
            return EInteger.FromInt16(inputInt16);
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer.</summary>
        /// <returns>This number's value as a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is less than 0 or
        /// greater than 65535.</exception>
        public ushort ToUInt16Checked()
        {
            int val = this.ToInt32Checked();
            if (val < 0 || val > 65535)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((ushort)(val & 0xffff));
        }

        /// <summary>Converts this number to a 16-bit unsigned integer,
        /// returning the least-significant bits of this number's
        /// two's-complement form.</summary>
        /// <returns>This number, converted to a 16-bit unsigned
        /// integer.</returns>
        public ushort ToUInt16Unchecked()
        {
            int val = this.ToInt32Unchecked();
            return unchecked((ushort)(val & 0xffff));
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision integer.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision
        /// integer.</returns>
        public static EInteger FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision integer to a 16-bit
        /// unsigned integer if it can fit in a 16-bit unsigned
        /// integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than 0 or greater than 65535.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt16Checked.")]
        public static explicit operator ushort(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision integer.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt16'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(ushort inputUInt16)
        {
            return EInteger.FromUInt16(inputUInt16);
        }

        /// <summary>Converts an arbitrary-precision integer to a 32-bit signed
        /// integer if it can fit in a 32-bit signed integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than -2147483648 or greater than
        /// 2147483647.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt32Checked.")]
        public static explicit operator int(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt32'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(int inputInt32)
        {
            return EInteger.FromInt32(inputInt32);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>This value is less than 0 or
        /// greater than 4294967295.</exception>
        public uint ToUInt32Checked()
        {
            long val = this.ToInt64Checked();
            if (val < 0 || val > 4294967295L)
            {
                throw new OverflowException("This object's value is out of range");
            }
            return unchecked((uint)(val & 0xffffffffL));
        }

        /// <summary>Converts this number to a 32-bit signed integer, returning
        /// the least-significant bits of this number's two's-complement
        /// form.</summary>
        /// <returns>This number, converted to a 32-bit signed
        /// integer.</returns>
        public uint ToUInt32Unchecked()
        {
            long val = this.ToInt64Unchecked();
            return unchecked((uint)(val & 0xffffffffL));
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision
        /// integer.</returns>
        public static EInteger FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <summary>Converts an arbitrary-precision integer to a 32-bit signed
        /// integer if it can fit in a 32-bit signed integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than 0 or greater than
        /// 4294967295.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt32Checked.")]
        public static explicit operator uint(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputUInt32'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(uint inputUInt32)
        {
            return EInteger.FromUInt32(inputUInt32);
        }

        /// <summary>Converts an arbitrary-precision integer to a 64-bit signed
        /// integer if it can fit in a 64-bit signed integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a 64-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt64Checked.")]
        public static explicit operator long(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt64Checked();
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// integer.</summary>
        /// <param name='inputInt64'>The number to convert as a 64-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt64'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(long inputInt64)
        {
            return EInteger.FromInt64(inputInt64);
        }

        /// <summary>Converts an arbitrary-precision integer to a 64-bit
        /// unsigned integer if it can fit in a 64-bit unsigned
        /// integer.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// integer.</param>
        /// <returns>The value of <paramref name='input'/> as a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is less than 0 or greater than
        /// 18446744073709551615.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt64Checked.")]
        public static explicit operator ulong(EInteger input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision integer.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt64'/> as an
        /// arbitrary-precision integer.</returns>
        public static implicit operator EInteger(ulong inputUInt64)
        {
            return EInteger.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    internal static class EIntegerTextString
    {
        private const int ShortMask = 0xffff;

        public static EInteger FromRadixSubstringImpl(
          string cs,
          int radix,
          int index,
          int endIndex)
        {
            if (radix < 2)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is less than 2");
            }
            if (radix > 36)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is more than 36");
            }
            if (index < 0)
            {
                throw new ArgumentException("index(" + index + ") is less than " +
                  "0");
            }
            if (index > cs.Length)
            {
                throw new ArgumentException("index(" + index + ") is more than " +
                  cs.Length);
            }
            if (endIndex < 0)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is less than 0");
            }
            if (endIndex > cs.Length)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is more than " + cs.Length);
            }
            if (endIndex < index)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is less than " + index);
            }
            if (index == endIndex)
            {
                throw new FormatException("No digits");
            }
            var negative = false;
            if (cs[index] == '-')
            {
                ++index;
                if (index == endIndex)
                {
                    throw new FormatException("No digits");
                }
                negative = true;
            }
            // Skip leading zeros
            for (; index < endIndex; ++index)
            {
                char c = cs[index];
                if (c != 0x30)
                {
                    break;
                }
            }
            int effectiveLength = endIndex - index;
            if (effectiveLength == 0)
            {
                return EInteger.Zero;
            }
            int[] c2d = EInteger.CharToDigit;
            short[] bigint;
            if (radix == 16)
            {
                // Special case for hexadecimal radix
                int leftover = effectiveLength & 3;
                int wordCount = effectiveLength >> 2;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    var extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 4;
                        char c = cs[index + i];
                        int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                        if (digit >= 16)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
#if DEBUG
                if ((endIndex - index) % 4 != 0)
                {
                    throw new InvalidOperationException(
                      "doesn't satisfy (endIndex - index) % 4 == 0");
                }
#endif
                while (index < endIndex)
                {
                    char c = cs[index + 3];
                    int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    int word = digit;
                    c = cs[index + 2];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 4;
                    c = cs[index + 1];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 8;
                    c = cs[index];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    word |= digit << 12;
                    index += 4;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
                int count = EInteger.CountWords(bigint);
                return (count == 0) ? EInteger.Zero : new EInteger(
                    count,
                    bigint,
                    negative);
            }
            else if (radix == 2)
            {
                // Special case for binary radix
                int leftover = effectiveLength & 15;
                int wordCount = effectiveLength >> 4;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    var extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 1;
                        char c = cs[index + i];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
                while (index < endIndex)
                {
                    var word = 0;
                    int idx = index + 15;
                    for (var i = 0; i < 16; ++i)
                    {
                        char c = cs[idx];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        --idx;
                        word |= digit << i;
                    }
                    index += 16;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
                int count = EInteger.CountWords(bigint);
                return (count == 0) ? EInteger.Zero : new EInteger(
                    count,
                    bigint,
                    negative);
            }
            else
            {
                return FromRadixSubstringGeneral(
                    cs,
                    radix,
                    index,
                    endIndex,
                    negative);
            }
        }

        private static EInteger FromRadixSubstringGeneral(
          string cs,
          int radix,
          int index,
          int endIndex,
          bool negative)
        {
            if (endIndex - index > 72)
            {
                int midIndex = index + ((endIndex - index) / 2);
                EInteger eia = FromRadixSubstringGeneral(
                    cs,
                    radix,
                    index,
                    midIndex,
                    false);
                // DebugUtility.Log("eia="+eia);
                EInteger eib = FromRadixSubstringGeneral(
                    cs,
                    radix,
                    midIndex,
                    endIndex,
                    false);
                // DebugUtility.Log("eib="+eib);
                EInteger mult = null;
                int intpow = endIndex - midIndex;
                if (radix == 10)
                {
                    eia = NumberUtility.MultiplyByPowerOfFive(eia,
                        intpow).ShiftLeft(intpow);
                }
                else if (radix == 5)
                {
                    eia = NumberUtility.MultiplyByPowerOfFive(eia, intpow);
                }
                else
                {
                    mult = EInteger.FromInt32(radix).Pow(endIndex - midIndex);
                    eia = eia.Multiply(mult);
                }
                eia = eia.Add(eib);
                // DebugUtility.Log("index={0} {1} {2} [pow={3}] [pow={4} ms, muladd={5} ms]",
                // index, midIndex, endIndex, endIndex-midIndex, swPow.ElapsedMilliseconds,
                // swMulAdd.ElapsedMilliseconds);
                if (negative)
                {
                    eia = eia.Negate();
                }
                // DebugUtility.Log("eia now="+eia);
                return eia;
            }
            else
            {
                return FromRadixSubstringInner(cs, radix, index, endIndex, negative);
            }
        }

        private static EInteger FromRadixSubstringInner(
          string cs,
          int radix,
          int index,
          int endIndex,
          bool negative)
        {
            if (radix <= 10)
            {
                long rv = 0;
                var digitCount = 0;
                if (radix == 10)
                {
                    for (int i = index; i < endIndex; ++i)
                    {
                        char c = cs[i];
                        var digit = (int)c - 0x30;
                        if (digit >= radix || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || digit != 0)
                        {
                            ++digitCount;
                        }
                        rv = (rv * 10) + digit;
                    }
                    // DebugUtility.Log("short="+(negative ? -rv : rv));
                    if (digitCount >= 0)
                    {
                        return EInteger.FromInt64(negative ? -rv : rv);
                    }
                }
                else
                {
                    for (int i = index; i < endIndex; ++i)
                    {
                        char c = cs[i];
                        int digit = (c >= 0x80) ? 36 : ((int)c - 0x30);
                        if (digit >= radix || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || digit != 0)
                        {
                            ++digitCount;
                        }
                        rv = (rv * radix) + digit;
                    }
                    if (digitCount >= 0)
                    {
                        return EInteger.FromInt64(negative ? -rv : rv);
                    }
                }
            }
            int[] c2d = EInteger.CharToDigit;
            int[] d2w = EInteger.DigitsInWord;
            long lsize = ((long)(endIndex - index) * 100 / d2w[radix]) + 1;
            lsize = Math.Min(lsize, Int32.MaxValue);
            lsize = Math.Max(lsize, 5);
            var bigint = new short[(int)lsize];
            if (radix == 10)
            {
                long rv = 0;
                int ei = endIndex - index <= 18 ? endIndex : index + 18;
                for (int i = index; i < ei; ++i)
                {
                    char c = cs[i];
                    var digit = (int)c - 0x30;
                    if (digit >= radix || digit < 0)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    rv = (rv * 10) + digit;
                }
                bigint[0] = unchecked((short)(rv & ShortMask));
                bigint[1] = unchecked((short)((rv >> 16) & ShortMask));
                bigint[2] = unchecked((short)((rv >> 32) & ShortMask));
                bigint[3] = unchecked((short)((rv >> 48) & ShortMask));
                int bn = Math.Min(bigint.Length, 5);
                for (int i = ei; i < endIndex; ++i)
                {
                    short carry = 0;
                    var digit = 0;
                    var overf = 0;
                    if (i < endIndex - 3)
                    {
                        overf = 55536; // 2**16 minus 10**4
                        var d1 = (int)cs[i] - 0x30;
                        var d2 = (int)cs[i + 1] - 0x30;
                        var d3 = (int)cs[i + 2] - 0x30;
                        var d4 = (int)cs[i + 3] - 0x30;
                        i += 3;
                        if (d1 >= 10 || d1 < 0 || d2 >= 10 || d2 < 0 || d3 >= 10 ||
                          d3 < 0 || d4 >= 10 || d4 < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        digit = (d1 * 1000) + (d2 * 100) + (d3 * 10) + d4;
                        // Multiply by 10**4
                        for (int j = 0; j < bn; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) *
              10000);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                    }
                    else
                    {
                        overf = 65526; // 2**16 minus radix 10
                        char c = cs[i];
                        digit = (int)c - 0x30;
                        if (digit >= 10 || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        // Multiply by 10
                        for (int j = 0; j < bn; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) * 10);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                    }
                    if (carry != 0)
                    {
                        bigint = EInteger.GrowForCarry(bigint, carry);
                    }
                    // Add the parsed digit
                    if (digit != 0)
                    {
                        int d = bigint[0] & ShortMask;
                        if (d <= overf)
                        {
                            bigint[0] = unchecked((short)(d + digit));
                        }
                        else if (EInteger.IncrementWords(
                          bigint,
                          0,
                          bigint.Length,
                          (short)digit) != 0)
                        {
                            bigint = EInteger.GrowForCarry(bigint, (short)1);
                        }
                    }
                    bn = Math.Min(bigint.Length, bn + 1);
                }
            }
            else
            {
                var haveSmallInt = true;
                int[] msi = EInteger.MaxSafeInts;
                int maxSafeInt = msi[radix - 2];
                int maxShortPlusOneMinusRadix = 65536 - radix;
                var smallInt = 0;
                for (int i = index; i < endIndex; ++i)
                {
                    char c = cs[i];
                    int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= radix)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    if (haveSmallInt && smallInt < maxSafeInt)
                    {
                        smallInt = (smallInt * radix) + digit;
                    }
                    else
                    {
                        if (haveSmallInt)
                        {
                            bigint[0] = unchecked((short)(smallInt &
              ShortMask));
                            bigint[1] = unchecked((short)((smallInt >> 16) &
              ShortMask));
                            haveSmallInt = false;
                        }
                        // Multiply by the radix
                        short carry = 0;
                        int n = bigint.Length;
                        for (int j = 0; j < n; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) *
              radix);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                        if (carry != 0)
                        {
                            bigint = EInteger.GrowForCarry(bigint, carry);
                        }
                        // Add the parsed digit
                        if (digit != 0)
                        {
                            int d = bigint[0] & ShortMask;
                            if (d <= maxShortPlusOneMinusRadix)
                            {
                                bigint[0] = unchecked((short)(d + digit));
                            }
                            else if (EInteger.IncrementWords(
                              bigint,
                              0,
                              bigint.Length,
                              (short)digit) != 0)
                            {
                                bigint = EInteger.GrowForCarry(bigint, (short)1);
                            }
                        }
                    }
                }
                if (haveSmallInt)
                {
                    bigint[0] = unchecked((short)(smallInt & ShortMask));
                    bigint[1] = unchecked((short)((smallInt >> 16) &
          ShortMask));
                }
            }
            int count = EInteger.CountWords(bigint);
            return (count == 0) ? EInteger.Zero : new EInteger(
                count,
                bigint,
                negative);
        }
    }

    internal static class EIntegerByteArrayString
    {
        private const int ShortMask = 0xffff;

        public static EInteger FromRadixSubstringImpl(
          byte[] cs,
          int radix,
          int index,
          int endIndex)
        {
            if (radix < 2)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is less than 2");
            }
            if (radix > 36)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is more than 36");
            }
            if (index < 0)
            {
                throw new ArgumentException("index(" + index + ") is less than " +
                  "0");
            }
            if (index > cs.Length)
            {
                throw new ArgumentException("index(" + index + ") is more than " +
                  cs.Length);
            }
            if (endIndex < 0)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is less than 0");
            }
            if (endIndex > cs.Length)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is more than " + cs.Length);
            }
            if (endIndex < index)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is less than " + index);
            }
            if (index == endIndex)
            {
                throw new FormatException("No digits");
            }
            var negative = false;
            if (cs[index] == '-')
            {
                ++index;
                if (index == endIndex)
                {
                    throw new FormatException("No digits");
                }
                negative = true;
            }
            // Skip leading zeros
            for (; index < endIndex; ++index)
            {
                byte c = cs[index];
                if (c != 0x30)
                {
                    break;
                }
            }
            int effectiveLength = endIndex - index;
            if (effectiveLength == 0)
            {
                return EInteger.Zero;
            }
            int[] c2d = EInteger.CharToDigit;
            short[] bigint;
            if (radix == 16)
            {
                // Special case for hexadecimal radix
                int leftover = effectiveLength & 3;
                int wordCount = effectiveLength >> 2;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    var extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 4;
                        byte c = cs[index + i];
                        int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                        if (digit >= 16)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
#if DEBUG
                if ((endIndex - index) % 4 != 0)
                {
                    throw new InvalidOperationException(
                      "doesn't satisfy (endIndex - index) % 4 == 0");
                }
#endif
                while (index < endIndex)
                {
                    byte c = cs[index + 3];
                    int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    int word = digit;
                    c = cs[index + 2];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 4;
                    c = cs[index + 1];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 8;
                    c = cs[index];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    word |= digit << 12;
                    index += 4;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
                int count = EInteger.CountWords(bigint);
                return (count == 0) ? EInteger.Zero : new EInteger(
                    count,
                    bigint,
                    negative);
            }
            else if (radix == 2)
            {
                // Special case for binary radix
                int leftover = effectiveLength & 15;
                int wordCount = effectiveLength >> 4;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    var extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 1;
                        byte c = cs[index + i];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
                while (index < endIndex)
                {
                    var word = 0;
                    int idx = index + 15;
                    for (var i = 0; i < 16; ++i)
                    {
                        byte c = cs[idx];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        --idx;
                        word |= digit << i;
                    }
                    index += 16;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
                int count = EInteger.CountWords(bigint);
                return (count == 0) ? EInteger.Zero : new EInteger(
                    count,
                    bigint,
                    negative);
            }
            else
            {
                return FromRadixSubstringGeneral(
                    cs,
                    radix,
                    index,
                    endIndex,
                    negative);
            }
        }

        private static EInteger FromRadixSubstringGeneral(
          byte[] cs,
          int radix,
          int index,
          int endIndex,
          bool negative)
        {
            if (endIndex - index > 72)
            {
                int midIndex = index + ((endIndex - index) / 2);
                EInteger eia = FromRadixSubstringGeneral(
                    cs,
                    radix,
                    index,
                    midIndex,
                    false);
                // DebugUtility.Log("eia="+eia);
                EInteger eib = FromRadixSubstringGeneral(
                    cs,
                    radix,
                    midIndex,
                    endIndex,
                    false);
                // DebugUtility.Log("eib="+eib);
                EInteger mult = null;
                int intpow = endIndex - midIndex;
                if (radix == 10)
                {
                    eia = NumberUtility.MultiplyByPowerOfFive(eia,
                        intpow).ShiftLeft(intpow);
                }
                else if (radix == 5)
                {
                    eia = NumberUtility.MultiplyByPowerOfFive(eia, intpow);
                }
                else
                {
                    mult = EInteger.FromInt32(radix).Pow(endIndex - midIndex);
                    eia = eia.Multiply(mult);
                }
                eia = eia.Add(eib);
                // DebugUtility.Log("index={0} {1} {2} [pow={3}] [pow={4} ms, muladd={5} ms]",
                // index, midIndex, endIndex, endIndex-midIndex, swPow.ElapsedMilliseconds,
                // swMulAdd.ElapsedMilliseconds);
                if (negative)
                {
                    eia = eia.Negate();
                }
                // DebugUtility.Log("eia now="+eia);
                return eia;
            }
            else
            {
                return FromRadixSubstringInner(cs, radix, index, endIndex, negative);
            }
        }

        private static EInteger FromRadixSubstringInner(
          byte[] cs,
          int radix,
          int index,
          int endIndex,
          bool negative)
        {
            if (radix <= 10)
            {
                long rv = 0;
                var digitCount = 0;
                if (radix == 10)
                {
                    for (int i = index; i < endIndex; ++i)
                    {
                        byte c = cs[i];
                        var digit = (int)c - 0x30;
                        if (digit >= radix || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || digit != 0)
                        {
                            ++digitCount;
                        }
                        rv = (rv * 10) + digit;
                    }
                    // DebugUtility.Log("short="+(negative ? -rv : rv));
                    if (digitCount >= 0)
                    {
                        return EInteger.FromInt64(negative ? -rv : rv);
                    }
                }
                else
                {
                    for (int i = index; i < endIndex; ++i)
                    {
                        byte c = cs[i];
                        int digit = (c >= 0x80) ? 36 : ((int)c - 0x30);
                        if (digit >= radix || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || digit != 0)
                        {
                            ++digitCount;
                        }
                        rv = (rv * radix) + digit;
                    }
                    if (digitCount >= 0)
                    {
                        return EInteger.FromInt64(negative ? -rv : rv);
                    }
                }
            }
            int[] c2d = EInteger.CharToDigit;
            int[] d2w = EInteger.DigitsInWord;
            long lsize = ((long)(endIndex - index) * 100 / d2w[radix]) + 1;
            lsize = Math.Min(lsize, Int32.MaxValue);
            lsize = Math.Max(lsize, 5);
            var bigint = new short[(int)lsize];
            if (radix == 10)
            {
                long rv = 0;
                int ei = endIndex - index <= 18 ? endIndex : index + 18;
                for (int i = index; i < ei; ++i)
                {
                    byte c = cs[i];
                    var digit = (int)c - 0x30;
                    if (digit >= radix || digit < 0)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    rv = (rv * 10) + digit;
                }
                bigint[0] = unchecked((short)(rv & ShortMask));
                bigint[1] = unchecked((short)((rv >> 16) & ShortMask));
                bigint[2] = unchecked((short)((rv >> 32) & ShortMask));
                bigint[3] = unchecked((short)((rv >> 48) & ShortMask));
                int bn = Math.Min(bigint.Length, 5);
                for (int i = ei; i < endIndex; ++i)
                {
                    short carry = 0;
                    var digit = 0;
                    var overf = 0;
                    if (i < endIndex - 3)
                    {
                        overf = 55536; // 2**16 minus 10**4
                        var d1 = (int)cs[i] - 0x30;
                        var d2 = (int)cs[i + 1] - 0x30;
                        var d3 = (int)cs[i + 2] - 0x30;
                        var d4 = (int)cs[i + 3] - 0x30;
                        i += 3;
                        if (d1 >= 10 || d1 < 0 || d2 >= 10 || d2 < 0 || d3 >= 10 ||
                          d3 < 0 || d4 >= 10 || d4 < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        digit = (d1 * 1000) + (d2 * 100) + (d3 * 10) + d4;
                        // Multiply by 10**4
                        for (int j = 0; j < bn; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) *
              10000);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                    }
                    else
                    {
                        overf = 65526; // 2**16 minus radix 10
                        byte c = cs[i];
                        digit = (int)c - 0x30;
                        if (digit >= 10 || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        // Multiply by 10
                        for (int j = 0; j < bn; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) * 10);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                    }
                    if (carry != 0)
                    {
                        bigint = EInteger.GrowForCarry(bigint, carry);
                    }
                    // Add the parsed digit
                    if (digit != 0)
                    {
                        int d = bigint[0] & ShortMask;
                        if (d <= overf)
                        {
                            bigint[0] = unchecked((short)(d + digit));
                        }
                        else if (EInteger.IncrementWords(
                          bigint,
                          0,
                          bigint.Length,
                          (short)digit) != 0)
                        {
                            bigint = EInteger.GrowForCarry(bigint, (short)1);
                        }
                    }
                    bn = Math.Min(bigint.Length, bn + 1);
                }
            }
            else
            {
                var haveSmallInt = true;
                int[] msi = EInteger.MaxSafeInts;
                int maxSafeInt = msi[radix - 2];
                int maxShortPlusOneMinusRadix = 65536 - radix;
                var smallInt = 0;
                for (int i = index; i < endIndex; ++i)
                {
                    byte c = cs[i];
                    int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= radix)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    if (haveSmallInt && smallInt < maxSafeInt)
                    {
                        smallInt = (smallInt * radix) + digit;
                    }
                    else
                    {
                        if (haveSmallInt)
                        {
                            bigint[0] = unchecked((short)(smallInt &
              ShortMask));
                            bigint[1] = unchecked((short)((smallInt >> 16) &
              ShortMask));
                            haveSmallInt = false;
                        }
                        // Multiply by the radix
                        short carry = 0;
                        int n = bigint.Length;
                        for (int j = 0; j < n; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) *
              radix);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                        if (carry != 0)
                        {
                            bigint = EInteger.GrowForCarry(bigint, carry);
                        }
                        // Add the parsed digit
                        if (digit != 0)
                        {
                            int d = bigint[0] & ShortMask;
                            if (d <= maxShortPlusOneMinusRadix)
                            {
                                bigint[0] = unchecked((short)(d + digit));
                            }
                            else if (EInteger.IncrementWords(
                              bigint,
                              0,
                              bigint.Length,
                              (short)digit) != 0)
                            {
                                bigint = EInteger.GrowForCarry(bigint, (short)1);
                            }
                        }
                    }
                }
                if (haveSmallInt)
                {
                    bigint[0] = unchecked((short)(smallInt & ShortMask));
                    bigint[1] = unchecked((short)((smallInt >> 16) &
          ShortMask));
                }
            }
            int count = EInteger.CountWords(bigint);
            return (count == 0) ? EInteger.Zero : new EInteger(
                count,
                bigint,
                negative);
        }
    }

    internal static class EIntegerCharArrayString
    {
        private const int ShortMask = 0xffff;

        public static EInteger FromRadixSubstringImpl(
          char[] cs,
          int radix,
          int index,
          int endIndex)
        {
            if (radix < 2)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is less than 2");
            }
            if (radix > 36)
            {
                throw new ArgumentException("radix(" + radix +
                  ") is more than 36");
            }
            if (index < 0)
            {
                throw new ArgumentException("index(" + index + ") is less than " +
                  "0");
            }
            if (index > cs.Length)
            {
                throw new ArgumentException("index(" + index + ") is more than " +
                  cs.Length);
            }
            if (endIndex < 0)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is less than 0");
            }
            if (endIndex > cs.Length)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is more than " + cs.Length);
            }
            if (endIndex < index)
            {
                throw new ArgumentException("endIndex(" + endIndex +
                  ") is less than " + index);
            }
            if (index == endIndex)
            {
                throw new FormatException("No digits");
            }
            var negative = false;
            if (cs[index] == '-')
            {
                ++index;
                if (index == endIndex)
                {
                    throw new FormatException("No digits");
                }
                negative = true;
            }
            // Skip leading zeros
            for (; index < endIndex; ++index)
            {
                char c = cs[index];
                if (c != 0x30)
                {
                    break;
                }
            }
            int effectiveLength = endIndex - index;
            if (effectiveLength == 0)
            {
                return EInteger.Zero;
            }
            int[] c2d = EInteger.CharToDigit;
            short[] bigint;
            if (radix == 16)
            {
                // Special case for hexadecimal radix
                int leftover = effectiveLength & 3;
                int wordCount = effectiveLength >> 2;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    var extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 4;
                        char c = cs[index + i];
                        int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                        if (digit >= 16)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
#if DEBUG
                if ((endIndex - index) % 4 != 0)
                {
                    throw new InvalidOperationException(
                      "doesn't satisfy (endIndex - index) % 4 == 0");
                }
#endif
                while (index < endIndex)
                {
                    char c = cs[index + 3];
                    int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    int word = digit;
                    c = cs[index + 2];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 4;
                    c = cs[index + 1];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }

                    word |= digit << 8;
                    c = cs[index];
                    digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= 16)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    word |= digit << 12;
                    index += 4;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
                int count = EInteger.CountWords(bigint);
                return (count == 0) ? EInteger.Zero : new EInteger(
                    count,
                    bigint,
                    negative);
            }
            else if (radix == 2)
            {
                // Special case for binary radix
                int leftover = effectiveLength & 15;
                int wordCount = effectiveLength >> 4;
                if (leftover != 0)
                {
                    ++wordCount;
                }
                bigint = new short[wordCount];
                int currentDigit = wordCount - 1;
                // Get most significant digits if effective
                // length is not divisible by 4
                if (leftover != 0)
                {
                    var extraWord = 0;
                    for (int i = 0; i < leftover; ++i)
                    {
                        extraWord <<= 1;
                        char c = cs[index + i];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        extraWord |= digit;
                    }
                    bigint[currentDigit] = unchecked((short)extraWord);
                    --currentDigit;
                    index += leftover;
                }
                while (index < endIndex)
                {
                    var word = 0;
                    int idx = index + 15;
                    for (var i = 0; i < 16; ++i)
                    {
                        char c = cs[idx];
                        int digit = (c == '0') ? 0 : ((c == '1') ? 1 : 2);
                        if (digit >= 2)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        --idx;
                        word |= digit << i;
                    }
                    index += 16;
                    bigint[currentDigit] = unchecked((short)word);
                    --currentDigit;
                }
                int count = EInteger.CountWords(bigint);
                return (count == 0) ? EInteger.Zero : new EInteger(
                    count,
                    bigint,
                    negative);
            }
            else
            {
                return FromRadixSubstringGeneral(
                    cs,
                    radix,
                    index,
                    endIndex,
                    negative);
            }
        }

        private static EInteger FromRadixSubstringGeneral(
          char[] cs,
          int radix,
          int index,
          int endIndex,
          bool negative)
        {
            if (endIndex - index > 72)
            {
                int midIndex = index + ((endIndex - index) / 2);
                EInteger eia = FromRadixSubstringGeneral(
                    cs,
                    radix,
                    index,
                    midIndex,
                    false);
                // DebugUtility.Log("eia="+eia);
                EInteger eib = FromRadixSubstringGeneral(
                    cs,
                    radix,
                    midIndex,
                    endIndex,
                    false);
                // DebugUtility.Log("eib="+eib);
                EInteger mult = null;
                int intpow = endIndex - midIndex;
                if (radix == 10)
                {
                    eia = NumberUtility.MultiplyByPowerOfFive(eia,
                        intpow).ShiftLeft(intpow);
                }
                else if (radix == 5)
                {
                    eia = NumberUtility.MultiplyByPowerOfFive(eia, intpow);
                }
                else
                {
                    mult = EInteger.FromInt32(radix).Pow(endIndex - midIndex);
                    eia = eia.Multiply(mult);
                }
                eia = eia.Add(eib);
                // DebugUtility.Log("index={0} {1} {2} [pow={3}] [pow={4} ms, muladd={5} ms]",
                // index, midIndex, endIndex, endIndex-midIndex, swPow.ElapsedMilliseconds,
                // swMulAdd.ElapsedMilliseconds);
                if (negative)
                {
                    eia = eia.Negate();
                }
                // DebugUtility.Log("eia now="+eia);
                return eia;
            }
            else
            {
                return FromRadixSubstringInner(cs, radix, index, endIndex, negative);
            }
        }

        private static EInteger FromRadixSubstringInner(
          char[] cs,
          int radix,
          int index,
          int endIndex,
          bool negative)
        {
            if (radix <= 10)
            {
                long rv = 0;
                var digitCount = 0;
                if (radix == 10)
                {
                    for (int i = index; i < endIndex; ++i)
                    {
                        char c = cs[i];
                        var digit = (int)c - 0x30;
                        if (digit >= radix || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || digit != 0)
                        {
                            ++digitCount;
                        }
                        rv = (rv * 10) + digit;
                    }
                    // DebugUtility.Log("short="+(negative ? -rv : rv));
                    if (digitCount >= 0)
                    {
                        return EInteger.FromInt64(negative ? -rv : rv);
                    }
                }
                else
                {
                    for (int i = index; i < endIndex; ++i)
                    {
                        char c = cs[i];
                        int digit = (c >= 0x80) ? 36 : ((int)c - 0x30);
                        if (digit >= radix || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        if (digitCount < 0 || digitCount >= 18)
                        {
                            digitCount = -1;
                            break;
                        }
                        else if (digitCount > 0 || digit != 0)
                        {
                            ++digitCount;
                        }
                        rv = (rv * radix) + digit;
                    }
                    if (digitCount >= 0)
                    {
                        return EInteger.FromInt64(negative ? -rv : rv);
                    }
                }
            }
            int[] c2d = EInteger.CharToDigit;
            int[] d2w = EInteger.DigitsInWord;
            long lsize = ((long)(endIndex - index) * 100 / d2w[radix]) + 1;
            lsize = Math.Min(lsize, Int32.MaxValue);
            lsize = Math.Max(lsize, 5);
            var bigint = new short[(int)lsize];
            if (radix == 10)
            {
                long rv = 0;
                int ei = endIndex - index <= 18 ? endIndex : index + 18;
                for (int i = index; i < ei; ++i)
                {
                    char c = cs[i];
                    var digit = (int)c - 0x30;
                    if (digit >= radix || digit < 0)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    rv = (rv * 10) + digit;
                }
                bigint[0] = unchecked((short)(rv & ShortMask));
                bigint[1] = unchecked((short)((rv >> 16) & ShortMask));
                bigint[2] = unchecked((short)((rv >> 32) & ShortMask));
                bigint[3] = unchecked((short)((rv >> 48) & ShortMask));
                int bn = Math.Min(bigint.Length, 5);
                for (int i = ei; i < endIndex; ++i)
                {
                    short carry = 0;
                    var digit = 0;
                    var overf = 0;
                    if (i < endIndex - 3)
                    {
                        overf = 55536; // 2**16 minus 10**4
                        var d1 = (int)cs[i] - 0x30;
                        var d2 = (int)cs[i + 1] - 0x30;
                        var d3 = (int)cs[i + 2] - 0x30;
                        var d4 = (int)cs[i + 3] - 0x30;
                        i += 3;
                        if (d1 >= 10 || d1 < 0 || d2 >= 10 || d2 < 0 || d3 >= 10 ||
                          d3 < 0 || d4 >= 10 || d4 < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        digit = (d1 * 1000) + (d2 * 100) + (d3 * 10) + d4;
                        // Multiply by 10**4
                        for (int j = 0; j < bn; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) *
              10000);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                    }
                    else
                    {
                        overf = 65526; // 2**16 minus radix 10
                        char c = cs[i];
                        digit = (int)c - 0x30;
                        if (digit >= 10 || digit < 0)
                        {
                            throw new FormatException("Illegal character found");
                        }
                        // Multiply by 10
                        for (int j = 0; j < bn; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) * 10);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                    }
                    if (carry != 0)
                    {
                        bigint = EInteger.GrowForCarry(bigint, carry);
                    }
                    // Add the parsed digit
                    if (digit != 0)
                    {
                        int d = bigint[0] & ShortMask;
                        if (d <= overf)
                        {
                            bigint[0] = unchecked((short)(d + digit));
                        }
                        else if (EInteger.IncrementWords(
                          bigint,
                          0,
                          bigint.Length,
                          (short)digit) != 0)
                        {
                            bigint = EInteger.GrowForCarry(bigint, (short)1);
                        }
                    }
                    bn = Math.Min(bigint.Length, bn + 1);
                }
            }
            else
            {
                var haveSmallInt = true;
                int[] msi = EInteger.MaxSafeInts;
                int maxSafeInt = msi[radix - 2];
                int maxShortPlusOneMinusRadix = 65536 - radix;
                var smallInt = 0;
                for (int i = index; i < endIndex; ++i)
                {
                    char c = cs[i];
                    int digit = (c >= 0x80) ? 36 : c2d[(int)c];
                    if (digit >= radix)
                    {
                        throw new FormatException("Illegal character found");
                    }
                    if (haveSmallInt && smallInt < maxSafeInt)
                    {
                        smallInt = (smallInt * radix) + digit;
                    }
                    else
                    {
                        if (haveSmallInt)
                        {
                            bigint[0] = unchecked((short)(smallInt &
              ShortMask));
                            bigint[1] = unchecked((short)((smallInt >> 16) &
              ShortMask));
                            haveSmallInt = false;
                        }
                        // Multiply by the radix
                        short carry = 0;
                        int n = bigint.Length;
                        for (int j = 0; j < n; ++j)
                        {
                            int p;
                            p = unchecked((((int)bigint[j]) & ShortMask) *
              radix);
                            int p2 = ((int)carry) & ShortMask;
                            p = unchecked(p + p2);
                            bigint[j] = unchecked((short)p);
                            carry = unchecked((short)(p >> 16));
                        }
                        if (carry != 0)
                        {
                            bigint = EInteger.GrowForCarry(bigint, carry);
                        }
                        // Add the parsed digit
                        if (digit != 0)
                        {
                            int d = bigint[0] & ShortMask;
                            if (d <= maxShortPlusOneMinusRadix)
                            {
                                bigint[0] = unchecked((short)(d + digit));
                            }
                            else if (EInteger.IncrementWords(
                              bigint,
                              0,
                              bigint.Length,
                              (short)digit) != 0)
                            {
                                bigint = EInteger.GrowForCarry(bigint, (short)1);
                            }
                        }
                    }
                }
                if (haveSmallInt)
                {
                    bigint[0] = unchecked((short)(smallInt & ShortMask));
                    bigint[1] = unchecked((short)((smallInt >> 16) &
          ShortMask));
                }
            }
            int count = EInteger.CountWords(bigint);
            return (count == 0) ? EInteger.Zero : new EInteger(
                count,
                bigint,
                negative);
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.ERational"]/*'/>
    [System.Diagnostics.CodeAnalysis.SuppressMessage(
      "Microsoft.Design",
      "CA1036",
      Justification = "Awaiting advice at dotnet/dotnet-api-docs#2937.")]
    public sealed partial class ERational : IComparable<ERational>,
    IEquatable<ERational>
    {
        /// <summary>A not-a-number value.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational NaN = new ERational(
          FastIntegerFixed.Zero,
          FastIntegerFixed.One,
          (byte)BigNumberFlags.FlagQuietNaN);

        /// <summary>Negative infinity, less than any other number.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational NegativeInfinity =
          new ERational(
            FastIntegerFixed.Zero,
            FastIntegerFixed.One,
            (byte)(BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative));

        /// <summary>A rational number for negative zero.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational NegativeZero =
          new ERational(
              FastIntegerFixed.Zero,
              FastIntegerFixed.One,
              (byte)BigNumberFlags.FlagNegative);

        /// <summary>The rational number one.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational One = FromEInteger(EInteger.One);

        /// <summary>Positive infinity, greater than any other
        /// number.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational PositiveInfinity =
          new ERational(
            FastIntegerFixed.Zero,
            FastIntegerFixed.One,
            (byte)BigNumberFlags.FlagInfinity);

        /// <summary>A signaling not-a-number value.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational SignalingNaN =
          new ERational(
            FastIntegerFixed.Zero,
            FastIntegerFixed.One,
            (byte)BigNumberFlags.FlagSignalingNaN);

        /// <summary>The rational number ten.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational Ten = FromEInteger((EInteger)10);

        /// <summary>A rational number for zero.</summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Microsoft.Security",
            "CA2104",
            Justification = "ERational is immutable")]
        public static readonly ERational Zero = FromEInteger(EInteger.Zero);

        private readonly FastIntegerFixed denominator;

        private readonly byte flags;
        private readonly FastIntegerFixed unsignedNumerator;

        private ERational(
          FastIntegerFixed numerator,
          FastIntegerFixed denominator,
          byte flags)
        {
#if DEBUG
            if (numerator == null)
            {
                throw new ArgumentNullException(nameof(numerator));
            }
            if (denominator == null)
            {
                throw new ArgumentNullException(nameof(denominator));
            }
            if (denominator.IsValueZero)
            {
                throw new ArgumentException("Denominator is zero.");
            }
#endif
            this.unsignedNumerator = numerator;
            this.denominator = denominator;
            this.flags = flags;
        }

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.ERational'/> class.</summary>
        /// <param name='numerator'>An arbitrary-precision integer serving as
        /// the numerator.</param>
        /// <param name='denominator'>An arbitrary-precision integer serving as
        /// the denominator.</param>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='numerator'/> or <paramref name='denominator'/> is
        /// null.</exception>
        /// <exception cref='ArgumentException'>Denominator is
        /// zero.</exception>
        [Obsolete("Use the Create method instead.")]
        public ERational(EInteger numerator, EInteger denominator)
        {
            if (numerator == null)
            {
                throw new ArgumentNullException(nameof(numerator));
            }
            if (denominator == null)
            {
                throw new ArgumentNullException(nameof(denominator));
            }
            if (denominator.IsZero)
            {
                throw new ArgumentException("denominator is zero");
            }
            bool numNegative = numerator.Sign < 0;
            bool denNegative = denominator.Sign < 0;
            this.flags = (byte)((numNegative != denNegative) ?
              BigNumberFlags.FlagNegative : 0);
            if (numNegative)
            {
                numerator = numerator.Negate();
            }
            if (denNegative)
            {
                denominator = denominator.Negate();
            }
            this.unsignedNumerator = FastIntegerFixed.FromBig(numerator);
            this.denominator = FastIntegerFixed.FromBig(denominator);
        }

        /// <summary>Creates a copy of this arbitrary-precision rational
        /// number.</summary>
        /// <returns>An arbitrary-precision rational number.</returns>
        public ERational Copy()
        {
            return new ERational(
                this.unsignedNumerator,
                this.denominator,
                this.flags);
        }

        /// <summary>Gets this object's denominator.</summary>
        /// <value>This object's denominator.</value>
        public EInteger Denominator
        {
            get
            {
                return this.denominator.ToEInteger();
            }
        }

        /// <summary>Gets a value indicating whether this object is finite (not
        /// infinity or NaN).</summary>
        /// <value><c>true</c> if this object is finite (not infinity or NaN);
        /// otherwise, <c>false</c>.</value>
        public bool IsFinite
        {
            get
            {
                return !this.IsNaN() && !this.IsInfinity();
            }
        }

        /// <summary>Gets a value indicating whether this object's value is
        /// negative (including negative zero).</summary>
        /// <value><c>true</c> if this object's value is negative (including
        /// negative zero); otherwise, <c>false</c>. <c>true</c> if this
        /// object's value is negative; otherwise, <c>false</c>.</value>
        public bool IsNegative
        {
            get
            {
                return (this.flags & BigNumberFlags.FlagNegative) != 0;
            }
        }

        /// <summary>Gets a value indicating whether this object's value equals
        /// 0.</summary>
        /// <value><c>true</c> if this object's value equals 0; otherwise,
        /// <c>false</c>. <c>true</c> if this object's value equals 0;
        /// otherwise, <c>false</c>.</value>
        public bool IsZero
        {
            get
            {
                return ((this.flags & (BigNumberFlags.FlagInfinity |
                        BigNumberFlags.FlagNaN)) == 0) &&
        this.unsignedNumerator.IsValueZero;
            }
        }

        /// <summary>Returns whether this object's value is an
        /// integer.</summary>
        /// <returns><c>true</c> if this object's value is an integer;
        /// otherwise, <c>false</c>.</returns>
        public bool IsInteger()
        {
            if (!this.IsFinite)
            {
                return false;
            }
            if (this.denominator.IsEvenNumber &&
                 !this.unsignedNumerator.IsEvenNumber)
            {
                // Even denominator, odd numerator, so not an integer
                return false;
            }
            EInteger rem = this.Numerator.Remainder(this.Denominator);
            return rem.IsZero;
        }

        /// <summary>Gets this object's numerator.</summary>
        /// <value>This object's numerator. If this object is a not-a-number
        /// value, returns the diagnostic information (which will be negative
        /// if this object is negative).</value>
        public EInteger Numerator
        {
            get
            {
                return this.IsNegative ? this.unsignedNumerator.Negate().ToEInteger() :
                  this.unsignedNumerator.ToEInteger();
            }
        }

        /// <summary>Gets the sign of this rational number.</summary>
        /// <value>The sign of this rational number.</value>
        public int Sign
        {
            get
            {
                return ((this.flags & (BigNumberFlags.FlagInfinity |
                        BigNumberFlags.FlagNaN)) != 0) ? (this.IsNegative ? -1 : 1) :
                  (this.unsignedNumerator.IsValueZero ? 0 : (this.IsNegative ? -1 : 1));
            }
        }

        /// <summary>Gets this object's numerator with the sign
        /// removed.</summary>
        /// <value>This object's numerator. If this object is a not-a-number
        /// value, returns the diagnostic information.</value>
        public EInteger UnsignedNumerator
        {
            get
            {
                return this.unsignedNumerator.ToEInteger();
            }
        }

        /// <summary>Creates a rational number with the given numerator and
        /// denominator.</summary>
        /// <param name='numeratorSmall'>The numerator.</param>
        /// <param name='denominatorSmall'>The denominator.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentException'>The denominator is
        /// zero.</exception>
        public static ERational Create(
          int numeratorSmall,
          int denominatorSmall)
        {
            return Create((EInteger)numeratorSmall, (EInteger)denominatorSmall);
        }

        /// <summary>Creates a rational number with the given numerator and
        /// denominator.</summary>
        /// <param name='numeratorLong'>The numerator.</param>
        /// <param name='denominatorLong'>The denominator.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentException'>The denominator is
        /// zero.</exception>
        public static ERational Create(
          long numeratorLong,
          long denominatorLong)
        {
            return Create((EInteger)numeratorLong, (EInteger)denominatorLong);
        }

        /// <summary>Creates a rational number with the given numerator and
        /// denominator.</summary>
        /// <param name='numerator'>The numerator.</param>
        /// <param name='denominator'>The denominator.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentException'>The denominator is
        /// zero.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='numerator'/> or <paramref name='denominator'/> is
        /// null.</exception>
        public static ERational Create(
          EInteger numerator,
          EInteger denominator)
        {
            if (numerator == null)
            {
                throw new ArgumentNullException(nameof(numerator));
            }
            if (denominator == null)
            {
                throw new ArgumentNullException(nameof(denominator));
            }
            if (denominator.IsZero)
            {
                throw new ArgumentException("denominator is zero");
            }
            bool numNegative = numerator.Sign < 0;
            bool denNegative = denominator.Sign < 0;
            var bflags = (byte)((numNegative != denNegative) ?
              BigNumberFlags.FlagNegative : 0);
            if (numNegative)
            {
                numerator = numerator.Negate();
            }
            if (denNegative)
            {
                denominator = denominator.Negate();
            }
            return new ERational(
               FastIntegerFixed.FromBig(numerator),
               FastIntegerFixed.FromBig(denominator),
               bflags);
        }

        /// <summary>Creates a not-a-number arbitrary-precision rational
        /// number.</summary>
        /// <param name='diag'>An integer, 0 or greater, to use as diagnostic
        /// information associated with this object. If none is needed, should
        /// be zero. To get the diagnostic information from another
        /// arbitrary-precision rational number, use that object's
        /// <c>UnsignedNumerator</c> property.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='diag'/> is less than 0.</exception>
        public static ERational CreateNaN(EInteger diag)
        {
            return CreateNaN(diag, false, false);
        }

        /// <summary>Creates a not-a-number arbitrary-precision rational
        /// number.</summary>
        /// <param name='diag'>An integer, 0 or greater, to use as diagnostic
        /// information associated with this object. If none is needed, should
        /// be zero. To get the diagnostic information from another
        /// arbitrary-precision rational number, use that object's
        /// <c>UnsignedNumerator</c> property.</param>
        /// <param name='signaling'>Whether the return value will be signaling
        /// (true) or quiet (false).</param>
        /// <param name='negative'>Whether the return value is
        /// negative.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='diag'/> is less than 0.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='diag'/> is null.</exception>
        public static ERational CreateNaN(
          EInteger diag,
          bool signaling,
          bool negative)
        {
            if (diag == null)
            {
                throw new ArgumentNullException(nameof(diag));
            }
            if (diag.Sign < 0)
            {
                throw new ArgumentException("Diagnostic information must be 0 or" +
                  "\u0020greater," + "\u0020 was: " + diag);
            }
            if (diag.IsZero && !negative)
            {
                return signaling ? SignalingNaN : NaN;
            }
            var flags = 0;
            if (negative)
            {
                flags |= BigNumberFlags.FlagNegative;
            }
            flags |= signaling ? BigNumberFlags.FlagSignalingNaN :
              BigNumberFlags.FlagQuietNaN;
            return new ERational(FastIntegerFixed.FromBig(diag),
        FastIntegerFixed.One,
        (byte)flags);
        }

        /// <summary>Converts a 64-bit floating-point number to a rational
        /// number. This method computes the exact value of the floating point
        /// number, not an approximation, as is often the case by converting
        /// the number to a string.</summary>
        /// <param name='flt'>The parameter <paramref name='flt'/> is a 64-bit
        /// floating-point number.</param>
        /// <returns>A rational number with the same value as <paramref
        /// name='flt'/>.</returns>
        public static ERational FromDouble(double flt)
        {
            return FromEFloat(EFloat.FromDouble(flt));
        }

        /// <summary>Converts an arbitrary-precision decimal number to a
        /// rational number.</summary>
        /// <param name='ef'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        [Obsolete("Renamed to FromEDecimal.")]
        public static ERational FromExtendedDecimal(EDecimal ef)
        {
            return FromEDecimal(ef);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a rational number.</summary>
        /// <param name='ef'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        [Obsolete("Renamed to FromEFloat.")]
        public static ERational FromExtendedFloat(EFloat ef)
        {
            return FromEFloat(ef);
        }

        /// <summary>Converts an arbitrary-precision decimal number to a
        /// rational number.</summary>
        /// <param name='ef'>The number to convert as an arbitrary-precision
        /// decimal number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ef'/> is null.</exception>
        public static ERational FromEDecimal(EDecimal ef)
        {
            if (ef == null)
            {
                throw new ArgumentNullException(nameof(ef));
            }
            if (!ef.IsFinite)
            {
                return ef.IsInfinity() ? (ef.IsNegative ? NegativeInfinity :
        PositiveInfinity) : CreateNaN(
                         ef.UnsignedMantissa,
                         ef.IsSignalingNaN(),
                         ef.IsNegative);
            }
            EInteger num = ef.Mantissa;
            EInteger exp = ef.Exponent;
            if (exp.IsZero)
            {
                return FromEInteger(num);
            }
            bool neg = num.Sign < 0;
            num = num.Abs();
            EInteger den = EInteger.One;
            if (exp.Sign < 0)
            {
                exp = -(EInteger)exp;
                den = NumberUtility.FindPowerOfTenFromBig(exp);
            }
            else
            {
                EInteger powerOfTen = NumberUtility.FindPowerOfTenFromBig(exp);
                num *= (EInteger)powerOfTen;
            }
            if (neg)
            {
                num = -(EInteger)num;
            }
            return ERational.Create(num, den);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to a rational number.</summary>
        /// <param name='ef'>The number to convert as an arbitrary-precision
        /// binary floating-point number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='ef'/> is null.</exception>
        public static ERational FromEFloat(EFloat ef)
        {
            if (ef == null)
            {
                throw new ArgumentNullException(nameof(ef));
            }
            if (!ef.IsFinite)
            {
                return ef.IsInfinity() ? (ef.IsNegative ? NegativeInfinity :
        PositiveInfinity) : CreateNaN(
                         ef.UnsignedMantissa,
                         ef.IsSignalingNaN(),
                         ef.IsNegative);
            }
            EInteger num = ef.Mantissa;
            EInteger exp = ef.Exponent;
            if (exp.IsZero)
            {
                return FromEInteger(num);
            }
            bool neg = num.Sign < 0;
            num = num.Abs();
            EInteger den = EInteger.One;
            if (exp.Sign < 0)
            {
                exp = -(EInteger)exp;
                den = den.ShiftLeft(exp);
            }
            else
            {
                num = num.ShiftLeft(exp);
            }
            if (neg)
            {
                num = -(EInteger)num;
            }
            return ERational.Create(num, den);
        }

        /// <summary>Converts an arbitrary-precision integer to a rational
        /// number.</summary>
        /// <param name='bigint'>The number to convert as an
        /// arbitrary-precision integer.</param>
        /// <returns>The exact value of the integer as a rational
        /// number.</returns>
        public static ERational FromEInteger(EInteger bigint)
        {
            return ERational.Create(bigint, EInteger.One);
        }

        /// <summary>Converts a 32-bit binary floating-point number to a
        /// rational number. This method computes the exact value of the
        /// floating point number, not an approximation, as is often the case
        /// by converting the number to a string.</summary>
        /// <param name='flt'>The parameter <paramref name='flt'/> is a 32-bit
        /// binary floating-point number.</param>
        /// <returns>A rational number with the same value as <paramref
        /// name='flt'/>.</returns>
        public static ERational FromSingle(float flt)
        {
            return FromEFloat(EFloat.FromSingle(flt));
        }

        /// <summary>Creates a binary rational number from a 32-bit
        /// floating-point number encoded in the IEEE 754 binary32 format. This
        /// method computes the exact value of the floating point number, not
        /// an approximation, as is often the case by converting the number to
        /// a string.</summary>
        /// <param name='value'>A 32-bit integer encoded in the IEEE 754
        /// binary32 format.</param>
        /// <returns>A rational number with the same floating-point value as
        /// <paramref name='value'/>.</returns>
        public static ERational FromSingleBits(int value)
        {
            return FromEFloat(EFloat.FromSingleBits(value));
        }

        /// <summary>Creates a binary rational number from a 64-bit
        /// floating-point number encoded in the IEEE 754 binary64 format. This
        /// method computes the exact value of the floating point number, not
        /// an approximation, as is often the case by converting the number to
        /// a string.</summary>
        /// <param name='value'>A 64-bit integer encoded in the IEEE 754
        /// binary64 format.</param>
        /// <returns>A rational number with the same floating-point value as
        /// <paramref name='value'/>.</returns>
        public static ERational FromDoubleBits(long value)
        {
            return FromEFloat(EFloat.FromDoubleBits(value));
        }

        /// <summary>Creates a rational number from a text string that
        /// represents a number. See <c>FromString(String, int, int)</c> for
        /// more information.</summary>
        /// <param name='str'>A string that represents a number.</param>
        /// <returns>An arbitrary-precision rational number with the same value
        /// as the given string.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='str'/> is not a correctly formatted number
        /// string.</exception>
        public static ERational FromString(string str)
        {
            return FromString(str, 0, str == null ? 0 : str.Length);
        }

        /// <summary>
        /// <para>Creates a rational number from a text string that represents
        /// a number.</para>
        /// <para>The format of the string generally consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if '-' , the value is negative.)</item>
        /// <item>The numerator in the form of one or more digits (these digits
        /// may begin with any number of zeros).</item>
        /// <item>Optionally, "/" followed by the denominator in the form of
        /// one or more digits (these digits may begin with any number of
        /// zeros). If a denominator is not given, it's equal to
        /// 1.</item></list>
        /// <para>The string can also be "-INF", "-Infinity", "Infinity",
        /// "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits,
        /// or signaling NaN ("sNaN" /"-sNaN") followed by any number of
        /// digits, all in any combination of upper and lower case.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
        /// allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='str'>A text string, a portion of which represents a
        /// number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='str'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='str'/> (but not more than <paramref
        /// name='str'/> 's length).</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='str'/> is not a correctly formatted number
        /// string.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='str'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='str'/> 's length, or <paramref
        /// name='str'/> 's length minus <paramref name='offset'/> is less than
        /// <paramref name='length'/>.</exception>
        public static ERational FromString(
          string str,
          int offset,
          int length)
        {
            return ERationalTextString.FromString(str, offset, length);
        }

        /// <summary>Creates a rational number from a sequence of <c>char</c> s
        /// that represents a number. See <c>FromString(String, int, int)</c>
        /// for more information.</summary>
        /// <param name='chars'>A sequence of <c>char</c> s that represents a
        /// number.</param>
        /// <returns>An arbitrary-precision rational number with the same value
        /// as the given sequence of <c>char</c> s.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='chars'/> is not a correctly formatted sequence of <c>char</c>
        /// s.</exception>
        public static ERational FromString(char[] chars)
        {
            return FromString(chars, 0, chars == null ? 0 : chars.Length);
        }

        /// <summary>
        /// <para>Creates a rational number from a sequence of <c>char</c> s
        /// that represents a number.</para>
        /// <para>The format of the sequence of <c>char</c> s generally
        /// consists of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if '-' , the value is negative.)</item>
        /// <item>The numerator in the form of one or more digits (these digits
        /// may begin with any number of zeros).</item>
        /// <item>Optionally, "/" followed by the denominator in the form of
        /// one or more digits (these digits may begin with any number of
        /// zeros). If a denominator is not given, it's equal to
        /// 1.</item></list>
        /// <para>The sequence of <c>char</c> s can also be "-INF",
        /// "-Infinity", "Infinity", "INF", quiet NaN ("NaN" /"-NaN") followed
        /// by any number of digits, or signaling NaN ("sNaN" /"-sNaN")
        /// followed by any number of digits, all in any combination of upper
        /// and lower case.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The sequence of
        /// <c>char</c> s is not allowed to contain white space characters,
        /// including spaces.</para></summary>
        /// <param name='chars'>A sequence of <c>char</c> s, a portion of which
        /// represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='chars'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='chars'/> (but not more than <paramref
        /// name='chars'/> 's length).</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='chars'/> is not a correctly formatted sequence of <c>char</c>
        /// s.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='chars'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='chars'/> 's length, or <paramref
        /// name='chars'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static ERational FromString(
          char[] chars,
          int offset,
          int length)
        {
            return ERationalCharArrayString.FromString(chars, offset, length);
        }

        /// <summary>Creates a rational number from a sequence of bytes that
        /// represents a number. See <c>FromString(String, int, int)</c> for
        /// more information.</summary>
        /// <param name='bytes'>A sequence of bytes that represents a
        /// number.</param>
        /// <returns>An arbitrary-precision rational number with the same value
        /// as the given sequence of bytes.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='bytes'/> is not a correctly formatted sequence of
        /// bytes.</exception>
        public static ERational FromString(byte[] bytes)
        {
            return FromString(bytes, 0, bytes == null ? 0 : bytes.Length);
        }

        /// <summary>
        /// <para>Creates a rational number from a sequence of bytes that
        /// represents a number.</para>
        /// <para>The format of the sequence of bytes generally consists
        /// of:</para>
        /// <list type=''>
        /// <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
        /// U+002D) (if '-' , the value is negative.)</item>
        /// <item>The numerator in the form of one or more digits (these digits
        /// may begin with any number of zeros).</item>
        /// <item>Optionally, "/" followed by the denominator in the form of
        /// one or more digits (these digits may begin with any number of
        /// zeros). If a denominator is not given, it's equal to
        /// 1.</item></list>
        /// <para>The sequence of bytes can also be "-INF", "-Infinity",
        /// "Infinity", "INF", quiet NaN ("NaN" /"-NaN") followed by any number
        /// of digits, or signaling NaN ("sNaN" /"-sNaN") followed by any
        /// number of digits, all in any combination of upper and lower
        /// case.</para>
        /// <para>All characters mentioned above are the corresponding
        /// characters in the Basic Latin range. In particular, the digits must
        /// be the basic digits 0 to 9 (U+0030 to U+0039). The sequence of
        /// bytes is not allowed to contain white space characters, including
        /// spaces.</para></summary>
        /// <param name='bytes'>A sequence of bytes, a portion of which
        /// represents a number.</param>
        /// <param name='offset'>An index starting at 0 showing where the
        /// desired portion of <paramref name='bytes'/> begins.</param>
        /// <param name='length'>The length, in code units, of the desired
        /// portion of <paramref name='bytes'/> (but not more than <paramref
        /// name='bytes'/> 's length).</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='FormatException'>The parameter <paramref
        /// name='bytes'/> is not a correctly formatted sequence of
        /// bytes.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bytes'/> is null.</exception>
        /// <exception cref='ArgumentException'>Either <paramref
        /// name='offset'/> or <paramref name='length'/> is less than 0 or
        /// greater than <paramref name='bytes'/> 's length, or <paramref
        /// name='bytes'/> 's length minus <paramref name='offset'/> is less
        /// than <paramref name='length'/>.</exception>
        public static ERational FromString(
          byte[] bytes,
          int offset,
          int length)
        {
            return ERationalByteArrayString.FromString(bytes, offset, length);
        }

        /// <summary>Compares the absolute values of this object and another
        /// object, imposing a total ordering on all possible values (ignoring
        /// their signs). In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// denominator has a greater "absolute value".</item>
        /// <item>Negative zero and positive zero are considered equal.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item></list></summary>
        /// <param name='other'>An arbitrary-precision rational number to
        /// compare with this one.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotalMagnitude(ERational other)
        {
            if (other == null)
            {
                return 1;
            }
            var valueIThis = 0;
            var valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return 1;
            }
            else if (valueIThis < valueIOther)
            {
                return -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedNumerator.CompareTo(
                    other.unsignedNumerator);
                return cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.Abs().CompareTo(other.Abs());
                if (cmp == 0)
                {
                    cmp = this.denominator.CompareTo(
                        other.denominator);
                    return cmp;
                }
                return cmp;
            }
        }

        /// <summary>Compares the values of this object and another object,
        /// imposing a total ordering on all possible values. In this method:
        /// <list>
        /// <item>For objects with the same value, the one with the higher
        /// denominator has a greater "absolute value".</item>
        /// <item>Negative zero is less than positive zero.</item>
        /// <item>Quiet NaN has a higher "absolute value" than signaling NaN.
        /// If both objects are quiet NaN or both are signaling NaN, the one
        /// with the higher diagnostic information has a greater "absolute
        /// value".</item>
        /// <item>NaN has a higher "absolute value" than infinity.</item>
        /// <item>Infinity has a higher "absolute value" than any finite
        /// number.</item>
        /// <item>Negative numbers are less than positive
        /// numbers.</item></list></summary>
        /// <param name='other'>An arbitrary-precision rational number to
        /// compare with this one.</param>
        /// <returns>The number 0 if both objects have the same value, or -1 if
        /// this object is less than the other value, or 1 if this object is
        /// greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToTotal(ERational other)
        {
            if (other == null)
            {
                return 1;
            }
            bool neg1 = this.IsNegative;
            bool neg2 = other.IsNegative;
            if (neg1 != neg2)
            {
                return neg1 ? -1 : 1;
            }
            var valueIThis = 0;
            var valueIOther = 0;
            int cmp;
            if (this.IsSignalingNaN())
            {
                valueIThis = 2;
            }
            else if (this.IsNaN())
            {
                valueIThis = 3;
            }
            else if (this.IsInfinity())
            {
                valueIThis = 1;
            }
            if (other.IsSignalingNaN())
            {
                valueIOther = 2;
            }
            else if (other.IsNaN())
            {
                valueIOther = 3;
            }
            else if (other.IsInfinity())
            {
                valueIOther = 1;
            }
            if (valueIThis > valueIOther)
            {
                return neg1 ? -1 : 1;
            }
            else if (valueIThis < valueIOther)
            {
                return neg1 ? 1 : -1;
            }
            if (valueIThis >= 2)
            {
                cmp = this.unsignedNumerator.CompareTo(
                    other.unsignedNumerator);
                return neg1 ? -cmp : cmp;
            }
            else if (valueIThis == 1)
            {
                return 0;
            }
            else
            {
                cmp = this.CompareTo(other);
                if (cmp == 0)
                {
                    cmp = this.denominator.CompareTo(
                        other.denominator);
                    return neg1 ? -cmp : cmp;
                }
                return cmp;
            }
        }

        /// <summary>Returns the absolute value of this rational number, that
        /// is, a number with the same value as this one but as a nonnegative
        /// number.</summary>
        /// <returns>An arbitrary-precision rational number.</returns>
        public ERational Abs()
        {
            if (this.IsNegative)
            {
                return new ERational(
                    this.unsignedNumerator,
                    this.denominator,
                    (byte)(this.flags & ~BigNumberFlags.FlagNegative));
            }
            return this;
        }

        /// <summary>Adds this arbitrary-precision rational number and another
        /// arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='otherValue'>Another arbitrary-precision rational
        /// number.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision rational number plus another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public ERational Add(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.UnsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
                    otherValue.UnsignedNumerator,
                    false,
                    otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            if (this.IsInfinity())
            {
                return otherValue.IsInfinity() ? ((this.IsNegative ==
                      otherValue.IsNegative) ? this : NaN) : this;
            }
            if (otherValue.IsInfinity())
            {
                return otherValue;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            EInteger bd = this.Denominator * (EInteger)otherValue.Denominator;
            ad += (EInteger)bc;
            return ERational.Create(ad, bd);
        }

        /// <summary>Compares the mathematical value of an arbitrary-precision
        /// rational number with that of this instance. This method currently
        /// uses the rules given in the CompareToValue method, so that it it is
        /// not consistent with the Equals method, but it may change in a
        /// future version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='other'>An arbitrary-precision rational number.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareTo(ERational other)
        {
            return this.CompareToValue(other);
        }

        /// <summary>Compares the mathematical value of an arbitrary-precision
        /// rational number with that of this instance. In this method, NaN
        /// values are greater than any other ERational value, and two NaN
        /// values (even if their payloads differ) are treated as equal by this
        /// method. This method is not consistent with the Equals
        /// method.</summary>
        /// <param name='other'>An arbitrary-precision rational number.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToValue(ERational other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this == other)
            {
                return 0;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            if (other.IsNaN())
            {
                return -1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy other.IsFinite");
            }
#endif

            int dencmp = this.denominator.CompareTo(other.denominator);
            // At this point, the signs are equal so we can compare
            // their absolute values instead
            int numcmp = this.unsignedNumerator.CompareTo(other.unsignedNumerator);
            if (signA < 0)
            {
                numcmp = -numcmp;
            }
            if (numcmp == 0)
            {
                // Special case: numerators are equal, so the
                // number with the lower denominator is greater
                return signA < 0 ? dencmp : -dencmp;
            }
            if (dencmp == 0)
            {
                // denominators are equal
                return numcmp;
            }
            EInteger ea = this.Numerator;
            EInteger eb = this.Denominator;
            EInteger ec = other.Numerator;
            EInteger ed = other.Denominator;
            int cmpThis = ea.Abs().CompareTo(eb);
            int cmpOther = ec.Abs().CompareTo(ed);
            if (cmpThis == 0 && cmpOther == 0)
            {
                // Both numbers' absolute values are 1
                return 0;
            }
            else if (cmpThis == 0)
            {
                // This number's abs is 1, the other's isn't.
                return signA < 0 ? cmpOther : -cmpOther;
            }
            else if (cmpOther == 0)
            {
                // The other number's abs is 1, this one's isn't.
                return signA < 0 ? -cmpThis : cmpThis;
            }
            else if (cmpThis < 0 && cmpOther > 0)
            {
                return signA < 0 ? 1 : -1;
            }
            else if (cmpThis > 0 && cmpOther < 0)
            {
                return signA < 0 ? -1 : 1;
            }
            // Compare the number of bits of the products
            EInteger bitsADUpper = ea.GetUnsignedBitLengthAsEInteger().Add(
                ed.GetUnsignedBitLengthAsEInteger());
            EInteger bitsBCUpper = eb.GetUnsignedBitLengthAsEInteger().Add(
                ec.GetUnsignedBitLengthAsEInteger());
            EInteger bitsADLower = bitsADUpper.Subtract(1);
            EInteger bitsBCLower = bitsBCUpper.Subtract(1);
            if (bitsADLower.CompareTo(bitsBCUpper) > 0)
            {
                return signA < 0 ? -1 : 1;
            }
            if (bitsBCLower.CompareTo(bitsADUpper) > 0)
            {
                return signA < 0 ? 1 : -1;
            }
            EInteger ad = ea.Multiply(ed);
            EInteger bc = eb.Multiply(ec);
            return ad.CompareTo(bc);
        }

        /// <summary>Gets the greater value between two rational
        /// numbers.</summary>
        /// <param name='first'>An arbitrary-precision rational number.</param>
        /// <param name='second'>Another arbitrary-precision rational
        /// number.</param>
        /// <returns>The larger value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the positive zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the larger denominator. If the two numbers are negative
        /// and have the same value, returns the one with the smaller
        /// denominator.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static ERational Max(
          ERational first,
          ERational second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            int cmp = first.CompareToValue(second);
            if (cmp == 0)
            {
                if (first.IsNegative)
                {
                    return (!second.IsNegative) ? second :
          (first.Denominator.CompareTo(second.Denominator) > 0 ?

                        first : second);
                }
                else
                {
                    return second.IsNegative ? first :
          (first.Denominator.CompareTo(second.Denominator) < 0 ?

                        first : second);
                }
            }
            return cmp > 0 ? first : second;
        }

        /// <summary>Gets the greater value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Max.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The larger value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static ERational MaxMagnitude(
          ERational first,
          ERational second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            int cmp = first.Abs().CompareToValue(second.Abs());
            return (cmp == 0) ? Max(first, second) : (cmp > 0 ? first : second);
        }

        /// <summary>Gets the lesser value between two rational
        /// numbers.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The smaller value of the two numbers. If one is positive
        /// zero and the other is negative zero, returns the negative zero. If
        /// the two numbers are positive and have the same value, returns the
        /// one with the smaller denominator. If the two numbers are negative
        /// and have the same value, returns the one with the larger
        /// denominator.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static ERational Min(
          ERational first,
          ERational second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            int cmp = first.CompareToValue(second);
            if (cmp == 0)
            {
                if (first.IsNegative)
                {
                    return (!second.IsNegative) ? first : (
                        first.Denominator.CompareTo(second.Denominator) < 0 ?
                        first : second);
                }
                else
                {
                    return second.IsNegative ? second : (
                        first.Denominator.CompareTo(second.Denominator) > 0 ?
                        first : second);
                }
            }
            return cmp < 0 ? first : second;
        }

        /// <summary>Gets the lesser value between two values, ignoring their
        /// signs. If the absolute values are equal, has the same effect as
        /// Min.</summary>
        /// <param name='first'>The first value to compare.</param>
        /// <param name='second'>The second value to compare.</param>
        /// <returns>The smaller value of the two numbers, ignoring their
        /// signs.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='first'/> or <paramref name='second'/> is null.</exception>
        public static ERational MinMagnitude(
          ERational first,
          ERational second)
        {
            if (first == null)
            {
                throw new ArgumentNullException(nameof(first));
            }
            if (second == null)
            {
                throw new ArgumentNullException(nameof(second));
            }
            int cmp = first.Abs().CompareToValue(second.Abs());
            return (cmp == 0) ? Min(first, second) : (cmp < 0 ? first : second);
        }

        /// <summary>Compares the mathematical value of an arbitrary-precision
        /// rational number with that of this instance. This method currently
        /// uses the rules given in the CompareToValue method, so that it it is
        /// not consistent with the Equals method, but it may change in a
        /// future version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is
        /// greater.</returns>
        public int CompareTo(int intOther)
        {
            return this.CompareToValue(ERational.FromInt32(intOther));
        }

        /// <summary>Compares the mathematical value of an arbitrary-precision
        /// rational number with that of this instance. In this method, NaN
        /// values are greater than any other ERational value, and two NaN
        /// values (even if their payloads differ) are treated as equal by this
        /// method. This method is not consistent with the Equals
        /// method.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 32-bit signed integer.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is
        /// greater.</returns>
        public int CompareToValue(int intOther)
        {
            return this.CompareToValue(ERational.FromInt32(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values.
        /// <para>This method is not consistent with the Equals method because
        /// two different numbers with the same mathematical value, but
        /// different exponents, will compare as equal.</para>
        /// <para>In this method, negative zero and positive zero are
        /// considered equal.</para>
        /// <para>If this object is a quiet NaN or signaling NaN, this method
        /// will not trigger an error. Instead, NaN will compare greater than
        /// any other number, including infinity.</para></summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 64-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareToValue(long intOther)
        {
            return this.CompareToValue(FromInt64(intOther));
        }

        /// <summary>Compares the mathematical values of this object and
        /// another object, accepting NaN values. This method currently uses
        /// the rules given in the CompareToValue method, so that it it is not
        /// consistent with the Equals method, but it may change in a future
        /// version to use the rules for the CompareToTotal method
        /// instead.</summary>
        /// <param name='intOther'>The parameter <paramref name='intOther'/> is
        /// a 64-bit signed integer.</param>
        /// <returns>Less than 0 if this object's value is less than the other
        /// value, or greater than 0 if this object's value is greater than the
        /// other value, or 0 if both values are equal.</returns>
        public int CompareTo(long intOther)
        {
            return this.CompareToValue(FromInt64(intOther));
        }

        /// <summary>Compares an arbitrary-precision binary floating-point
        /// number with this instance. In this method, NaN values are greater
        /// than any other ERational or EFloat value, and two NaN values (even
        /// if their payloads differ) are treated as equal by this
        /// method.</summary>
        /// <param name='other'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToBinary(EFloat other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy other.IsFinite");
            }
#endif
            EInteger bigExponent = other.Exponent;
            if (bigExponent.IsZero)
            {
                // Special case: other has exponent 0
                EInteger otherMant = other.Mantissa;
                EInteger bcx = this.Denominator * (EInteger)otherMant;
                return this.Numerator.CompareTo(bcx);
            }
            if (bigExponent.Abs().CompareTo((EInteger)1000) > 0)
            {
                // Other has a high absolute value of exponent, so try different
                // approaches to
                // comparison
                EInteger thisRem;
                EInteger thisInt;
                {
                    EInteger[] divrem = this.UnsignedNumerator.DivRem(this.Denominator);
                    thisInt = divrem[0];
                    thisRem = divrem[1];
                }
                EFloat otherAbs = other.Abs();
                EFloat thisIntDec = EFloat.FromEInteger(thisInt);
                if (thisRem.IsZero)
                {
                    // This object's value is an integer
                    // Console.WriteLine("Shortcircuit IV");
                    int ret = thisIntDec.CompareTo(otherAbs);
                    return this.IsNegative ? -ret : ret;
                }
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit I");
                    return this.IsNegative ? -1 : 1;
                }
                // Round up
                thisInt = thisInt.Add(EInteger.One);
                thisIntDec = EFloat.FromEInteger(thisInt);
                if (thisIntDec.CompareTo(otherAbs) < 0)
                {
                    // Absolute value rounded up is less than other's unrounded
                    // absolute value
                    // Console.WriteLine("Shortcircuit II");
                    return this.IsNegative ? 1 : -1;
                }
                thisIntDec = EFloat.FromEInteger(this.UnsignedNumerator).Divide(
                    EFloat.FromEInteger(this.Denominator),
                    EContext.ForPrecisionAndRounding(256, ERounding.Down));
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit III");
                    return this.IsNegative ? -1 : 1;
                }
                if (other.Exponent.Sign > 0)
                {
                    // NOTE: if unsigned numerator is 0, bitLength will return
                    // 0 instead of 1, but the possibility of 0 was already excluded
                    EInteger bigDigitCount =
                      this.UnsignedNumerator.GetSignedBitLengthAsEInteger()
                      .Subtract(1);
                    if (bigDigitCount.CompareTo(other.Exponent) < 0)
                    {
                        // Numerator's digit count minus 1 is less than the other's
                        // exponent,
                        // and other's exponent is positive, so this value's absolute
                        // value is less
                        return this.IsNegative ? 1 : -1;
                    }
                }
            }
            // Convert to rational number and use usual rational number
            // comparison
            // Console.WriteLine("no shortcircuit");
            // Console.WriteLine(this);
            // Console.WriteLine(other);
            ERational otherRational = ERational.FromEFloat(other);
            return this.CompareToValue(otherRational);
        }

        /// <summary>Compares an arbitrary-precision decimal number with this
        /// instance.</summary>
        /// <param name='other'>An arbitrary-precision decimal number.</param>
        /// <returns>Zero if the values are equal; a negative number if this
        /// instance is less, or a positive number if this instance is greater.
        /// <para>This implementation returns a positive number if <paramref
        /// name='other'/> is null, to conform to the.NET definition of
        /// CompareTo. This is the case even in the Java version of this
        /// library, for consistency's sake, even though implementations of
        /// <c>Comparable.compareTo()</c> in Java ought to throw an exception
        /// if they receive a null argument rather than treating null as less
        /// or greater than any object.</para>.</returns>
        public int CompareToDecimal(EDecimal other)
        {
            if (other == null)
            {
                return 1;
            }
            if (this.IsNaN())
            {
                return other.IsNaN() ? 0 : 1;
            }
            int signA = this.Sign;
            int signB = other.Sign;
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            if (this.IsInfinity())
            {
                if (other.IsInfinity())
                {
                    // if we get here, this only means that
                    // both are positive infinity or both
                    // are negative infinity
                    return 0;
                }
                return this.IsNegative ? -1 : 1;
            }
            if (other.IsInfinity())
            {
                return other.IsNegative ? 1 : -1;
            }
            // At this point, both numbers are finite and
            // have the same sign
#if DEBUG
            if (!this.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy this.IsFinite");
            }
            if (!other.IsFinite)
            {
                throw new InvalidOperationException("doesn't satisfy other.IsFinite");
            }
#endif

            if (other.Exponent.IsZero)
            {
                // Special case: other has exponent 0
                EInteger otherMant = other.Mantissa;
                EInteger bcx = this.Denominator * (EInteger)otherMant;
                return this.Numerator.CompareTo(bcx);
            }
            if (other.Exponent.Abs().CompareTo((EInteger)50) > 0)
            {
                // Other has a high absolute value of exponent, so try different
                // approaches to
                // comparison
                EInteger thisRem;
                EInteger thisInt;
                {
                    EInteger[] divrem = this.UnsignedNumerator.DivRem(this.Denominator);
                    thisInt = divrem[0];
                    thisRem = divrem[1];
                }
                EDecimal otherAbs = other.Abs();
                EDecimal thisIntDec = EDecimal.FromEInteger(thisInt);
                if (thisRem.IsZero)
                {
                    // This object's value is an integer
                    // Console.WriteLine("Shortcircuit IV");
                    int ret = thisIntDec.CompareTo(otherAbs);
                    return this.IsNegative ? -ret : ret;
                }
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit I");
                    return this.IsNegative ? -1 : 1;
                }
                // Round up
                thisInt = thisInt.Add(EInteger.One);
                thisIntDec = EDecimal.FromEInteger(thisInt);
                if (thisIntDec.CompareTo(otherAbs) < 0)
                {
                    // Absolute value rounded up is less than other's unrounded
                    // absolute value
                    // Console.WriteLine("Shortcircuit II");
                    return this.IsNegative ? 1 : -1;
                }
                // Conservative approximation of this rational number's absolute value,
                // as a decimal number. The true value will be greater or equal.
                thisIntDec = EDecimal.FromEInteger(this.UnsignedNumerator).Divide(
                    EDecimal.FromEInteger(this.Denominator),
                    EContext.ForPrecisionAndRounding(20, ERounding.Down));
                if (thisIntDec.CompareTo(otherAbs) > 0)
                {
                    // Truncated absolute value is greater than other's untruncated
                    // absolute value
                    // Console.WriteLine("Shortcircuit III");
                    return this.IsNegative ? -1 : 1;
                }
                // Console.WriteLine("---" + this + " " + other);
                if (other.Exponent.Sign > 0)
                {
                    EInteger bigDigitCount =
                      this.UnsignedNumerator.GetDigitCountAsEInteger()
                      .Subtract(1);
                    if (bigDigitCount.CompareTo(other.Exponent) < 0)
                    {
                        // Numerator's digit count minus 1 is less than the other's
                        // exponent,
                        // and other's exponent is positive, so this value's absolute
                        // value is less
                        return this.IsNegative ? 1 : -1;
                    }
                }
            }
            // Convert to rational number and use usual rational number
            // comparison
            ERational otherRational = ERational.FromEDecimal(other);
            return this.CompareToValue(otherRational);
        }

        /// <summary>Returns a number with the same value as this one, but
        /// copying the sign (positive or negative) of another
        /// number.</summary>
        /// <param name='other'>A number whose sign will be copied.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='other'/> is null.</exception>
        public ERational CopySign(ERational other)
        {
            if (other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            if (this.IsNegative)
            {
                return other.IsNegative ? this : this.Negate();
            }
            else
            {
                return other.IsNegative ? this.Negate() : this;
            }
        }

        /// <summary>Divides this arbitrary-precision rational number by
        /// another arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='otherValue'>An arbitrary-precision rational
        /// number.</param>
        /// <returns>The result of dividing this arbitrary-precision rational
        /// number by another arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public ERational Divide(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.UnsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
                    otherValue.UnsignedNumerator,
                    false,
                    otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            bool resultNeg = this.IsNegative ^ otherValue.IsNegative;
            if (this.IsInfinity())
            {
                return otherValue.IsInfinity() ? NaN : (resultNeg ? NegativeInfinity :
                    PositiveInfinity);
            }
            if (otherValue.IsInfinity())
            {
                return resultNeg ? NegativeZero : Zero;
            }
            if (otherValue.IsZero)
            {
                return this.IsZero ? NaN : (resultNeg ? NegativeInfinity :
                    PositiveInfinity);
            }
            if (this.IsZero)
            {
                return resultNeg ? NegativeZero : Zero;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            return Create(ad, bc);
        }

        /// <summary>Determines whether this object's numerator, denominator,
        /// and properties are equal to those of another object and that other
        /// object is an arbitrary-precision rational number. Not-a-number
        /// values are considered equal if the rest of their properties are
        /// equal.</summary>
        /// <param name='obj'>The parameter <paramref name='obj'/> is an
        /// arbitrary object.</param>
        /// <returns><c>true</c> if the objects are equal; otherwise,
        /// <c>false</c>. In this method, two objects are not equal if they
        /// don't have the same type or if one is null and the other
        /// isn't.</returns>
        public override bool Equals(object obj)
        {
            var other = obj as ERational;
            return (
                other != null) && (
                Object.Equals(
                  this.unsignedNumerator,
                  other.unsignedNumerator) && Object.Equals(
                  this.denominator,
                  other.denominator) && this.flags == other.flags);
        }

        /// <summary>Determines whether this object's numerator, denominator,
        /// and properties are equal to those of another object. Not-a-number
        /// values are considered equal if the rest of their properties are
        /// equal.</summary>
        /// <param name='other'>An arbitrary-precision rational number to
        /// compare to.</param>
        /// <returns>Either <c>true</c> or <c>false</c>.</returns>
        public bool Equals(ERational other)
        {
            return this.Equals((object)other);
        }

        /// <summary>Returns the hash code for this instance. No application or
        /// process IDs are used in the hash code calculation.</summary>
        /// <returns>A 32-bit signed integer.</returns>
        public override int GetHashCode()
        {
            var hashCode = 1857066527;
            unchecked
            {
                if (this.unsignedNumerator != null)
                {
                    hashCode += 1857066539 * this.unsignedNumerator.GetHashCode();
                }
                if (this.denominator != null)
                {
                    hashCode += 1857066551 * this.denominator.GetHashCode();
                }
                hashCode += 1857066623 * this.flags;
            }
            return hashCode;
        }

        /// <summary>Gets a value indicating whether this object's value is
        /// infinity.</summary>
        /// <returns><c>true</c> if this object's value is infinity; otherwise,
        /// <c>false</c>.</returns>
        public bool IsInfinity()
        {
            return (this.flags & BigNumberFlags.FlagInfinity) != 0;
        }

        /// <summary>Returns whether this object is a not-a-number
        /// value.</summary>
        /// <returns><c>true</c> if this object is a not-a-number value;
        /// otherwise, <c>false</c>.</returns>
        public bool IsNaN()
        {
            return (this.flags & BigNumberFlags.FlagNaN) != 0;
        }

        /// <summary>Returns whether this object is negative
        /// infinity.</summary>
        /// <returns><c>true</c> if this object is negative infinity;
        /// otherwise, <c>false</c>.</returns>
        public bool IsNegativeInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNegative)) ==
              (BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative);
        }

        /// <summary>Returns whether this object is positive
        /// infinity.</summary>
        /// <returns><c>true</c> if this object is positive infinity;
        /// otherwise, <c>false</c>.</returns>
        public bool IsPositiveInfinity()
        {
            return (this.flags & (BigNumberFlags.FlagInfinity |
                  BigNumberFlags.FlagNegative)) == BigNumberFlags.FlagInfinity;
        }

        /// <summary>Returns whether this object is a quiet not-a-number
        /// value.</summary>
        /// <returns><c>true</c> if this object is a quiet not-a-number value;
        /// otherwise, <c>false</c>.</returns>
        public bool IsQuietNaN()
        {
            return (this.flags & BigNumberFlags.FlagQuietNaN) != 0;
        }

        /// <summary>Returns whether this object is a signaling not-a-number
        /// value (which causes an error if the value is passed to any
        /// arithmetic operation in this class).</summary>
        /// <returns><c>true</c> if this object is a signaling not-a-number
        /// value (which causes an error if the value is passed to any
        /// arithmetic operation in this class); otherwise, <c>false</c>.</returns>
        public bool IsSignalingNaN()
        {
            return (this.flags & BigNumberFlags.FlagSignalingNaN) != 0;
        }

        /// <summary>Multiplies this arbitrary-precision rational number by
        /// another arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='otherValue'>An arbitrary-precision rational
        /// number.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision rational number times another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public ERational Multiply(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.UnsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
                    otherValue.UnsignedNumerator,
                    false,
                    otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            bool resultNeg = this.IsNegative ^ otherValue.IsNegative;
            if (this.IsInfinity())
            {
                return otherValue.IsZero ? NaN : (resultNeg ? NegativeInfinity :
                    PositiveInfinity);
            }
            if (otherValue.IsInfinity())
            {
                return this.IsZero ? NaN : (resultNeg ? NegativeInfinity :
                    PositiveInfinity);
            }
            EInteger ac = this.Numerator * (EInteger)otherValue.Numerator;
            EInteger bd = this.Denominator * (EInteger)otherValue.Denominator;
            return ac.IsZero ? (resultNeg ? NegativeZero : Zero) :
              Create(ac, bd);
        }

        /// <summary>Returns a rational number with the same value as this one
        /// but with the sign reversed.</summary>
        /// <returns>An arbitrary-precision rational number.</returns>
        public ERational Negate()
        {
            return new ERational(
                this.unsignedNumerator,
                this.denominator,
                (byte)(this.flags ^ BigNumberFlags.FlagNegative));
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision rational number is divided by another
        /// arbitrary-precision rational number.</summary>
        /// <param name='otherValue'>An arbitrary-precision rational
        /// number.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision rational number is divided by another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public ERational Remainder(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.UnsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
                    otherValue.UnsignedNumerator,
                    false,
                    otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            if (this.IsInfinity())
            {
                return NaN;
            }
            if (otherValue.IsInfinity())
            {
                return this;
            }
            if (otherValue.IsZero)
            {
                return NaN;
            }
            if (this.IsZero)
            {
                return this;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            EInteger quo = ad / (EInteger)bc; // Find the integer quotient
            EInteger tnum = quo * (EInteger)otherValue.Numerator;
            EInteger tden = otherValue.Denominator;
            EInteger thisDen = this.Denominator;
            ad = this.Numerator * (EInteger)tden;
            bc = thisDen * (EInteger)tnum;
            tden *= (EInteger)thisDen;
            ad -= (EInteger)bc;
            return Create(ad, tden);
        }

        /// <summary>Subtracts an arbitrary-precision rational number from this
        /// arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='otherValue'>An arbitrary-precision rational
        /// number.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision rational number minus another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='otherValue'/> is null.</exception>
        public ERational Subtract(ERational otherValue)
        {
            if (otherValue == null)
            {
                throw new ArgumentNullException(nameof(otherValue));
            }
            if (this.IsSignalingNaN())
            {
                return CreateNaN(this.UnsignedNumerator, false, this.IsNegative);
            }
            if (otherValue.IsSignalingNaN())
            {
                return CreateNaN(
                    otherValue.UnsignedNumerator,
                    false,
                    otherValue.IsNegative);
            }
            if (this.IsQuietNaN())
            {
                return this;
            }
            if (otherValue.IsQuietNaN())
            {
                return otherValue;
            }
            if (this.IsInfinity())
            {
                if (otherValue.IsInfinity())
                {
                    return (this.IsNegative != otherValue.IsNegative) ?
                      (this.IsNegative ? PositiveInfinity : NegativeInfinity) : NaN;
                }
                return this.IsNegative ? PositiveInfinity : NegativeInfinity;
            }
            if (otherValue.IsInfinity())
            {
                return otherValue.IsNegative ? PositiveInfinity : NegativeInfinity;
            }
            EInteger ad = this.Numerator * (EInteger)otherValue.Denominator;
            EInteger bc = this.Denominator * (EInteger)otherValue.Numerator;
            EInteger bd = this.Denominator * (EInteger)otherValue.Denominator;
            ad -= (EInteger)bc;
            return ERational.Create(ad, bd);
        }

        /// <summary>Converts this value to a 64-bit floating-point number. The
        /// half-even rounding mode is used.</summary>
        /// <returns>The closest 64-bit floating-point number to this value.
        /// The return value can be positive infinity or negative infinity if
        /// this value exceeds the range of a 64-bit floating point
        /// number.</returns>
        public double ToDouble()
        {
            if (!this.IsFinite)
            {
                return this.ToEFloat(EContext.Binary64).ToDouble();
            }
            if (this.IsNegative && this.IsZero)
            {
                return EFloat.NegativeZero.ToDouble();
            }
            return EFloat.FromEInteger(this.Numerator)
              .Divide(EFloat.FromEInteger(this.Denominator), EContext.Binary64)
              .ToDouble();
        }

        /// <summary>Converts this value to its closest equivalent as a 64-bit
        /// floating-point number, expressed as an integer in the IEEE 754
        /// binary64 format. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 64-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN.</para></summary>
        /// <returns>The closest 64-bit binary floating-point number to this
        /// value, expressed as an integer in the IEEE 754 binary64 format. The
        /// return value can be positive infinity or negative infinity if this
        /// value exceeds the range of a 64-bit floating point
        /// number.</returns>
        public long ToDoubleBits()
        {
            if (!this.IsFinite)
            {
                return this.ToEFloat(EContext.Binary64).ToDoubleBits();
            }
            if (this.IsNegative && this.IsZero)
            {
                return EFloat.NegativeZero.ToDoubleBits();
            }
            return EFloat.FromEInteger(this.Numerator)
              .Divide(EFloat.FromEInteger(this.Denominator), EContext.Binary64)
              .ToDoubleBits();
        }

        /// <summary>Converts this value to its closest equivalent as 32-bit
        /// floating-point number, expressed as an integer in the IEEE 754
        /// binary32 format. The half-even rounding mode is used.
        /// <para>If this value is a NaN, sets the high bit of the 32-bit
        /// floating point number's significand area for a quiet NaN, and
        /// clears it for a signaling NaN. Then the other bits of the
        /// significand area are set to the lowest bits of this object's
        /// unsigned significand, and the next-highest bit of the significand
        /// area is set if those bits are all zeros and this is a signaling
        /// NaN.</para></summary>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value, expressed as an integer in the IEEE 754 binary32 format. The
        /// return value can be positive infinity or negative infinity if this
        /// value exceeds the range of a 32-bit floating point
        /// number.</returns>
        public int ToSingleBits()
        {
            if (!this.IsFinite)
            {
                return this.ToEFloat(EContext.Binary32).ToSingleBits();
            }
            if (this.IsNegative && this.IsZero)
            {
                return EFloat.NegativeZero.ToSingleBits();
            }
            return EFloat.FromEInteger(this.Numerator)
              .Divide(EFloat.FromEInteger(this.Denominator), EContext.Binary32)
              .ToSingleBits();
        }

        /// <summary>Converts this value to its form in lowest terms. For
        /// example, (8/4) becomes (4/1).</summary>
        /// <returns>An arbitrary-precision rational with the same value as
        /// this one but in lowest terms. Returns this object if it is infinity
        /// or NaN. Returns ERational.NegativeZero if this object is a negative
        /// zero. Returns ERational.Zero if this object is a positive
        /// zero.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        public ERational ToLowestTerms()
        {
            if (!this.IsFinite)
            {
                return this;
            }
            if (this.IsZero)
            {
                return this.IsNegative ? NegativeZero : Zero;
            }
            EInteger num = this.Numerator;
            EInteger den = this.Denominator;
            EInteger gcd = num.Abs().Gcd(den);
            return Create(num.Divide(gcd), den.Divide(gcd));
        }

        /// <summary>Converts this value to an arbitrary-precision integer by
        /// dividing the numerator by the denominator, discarding its
        /// fractional part, and checking whether the resulting integer
        /// overflows the given signed bit count.</summary>
        /// <param name='maxBitLength'>The maximum number of signed bits the
        /// integer can have. The integer's value may not be less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN), or this number's value, once converted to an
        /// integer by dividing the numerator by the denominator and discarding
        /// its fractional part, is less than -(2^maxBitLength) or greater than
        /// (2^maxBitLength) - 1.</exception>
        public EInteger ToSizedEInteger(int maxBitLength)
        {
            if (maxBitLength < 0)
            {
                throw new ArgumentException("maxBitLength (" + maxBitLength + ") is" +
                  "\u0020not greater or equal to 0");
            }
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            EInteger unum = this.UnsignedNumerator;
            EInteger uden = this.Denominator;
            if (unum.CompareTo(uden) < 0)
            {
                return EInteger.Zero;
            }
            EInteger numBits = unum.GetUnsignedBitLengthAsEInteger();
            EInteger denBits = uden.GetUnsignedBitLengthAsEInteger();
            if (numBits.Subtract(2).Subtract(denBits).CompareTo(maxBitLength) >
      0)
            {
                throw new OverflowException("Value out of range");
            }
            unum = this.ToEInteger();
            if (unum.GetSignedBitLengthAsInt64() > maxBitLength)
            {
                throw new OverflowException("Value out of range");
            }
            return unum;
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// only if this number's value is an exact integer and that integer
        /// does not overflow the given signed bit count.</summary>
        /// <param name='maxBitLength'>The maximum number of signed bits the
        /// integer can have. The integer's value may not be less than
        /// -(2^maxBitLength) or greater than (2^maxBitLength) - 1.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN), or this number's value as an integer is less
        /// than -(2^maxBitLength) or greater than (2^maxBitLength) -
        /// 1.</exception>
        /// <exception cref='ArithmeticException'>This object's value is not an
        /// exact integer.</exception>
        public EInteger ToSizedEIntegerIfExact(int maxBitLength)
        {
            if (maxBitLength < 0)
            {
                throw new ArgumentException("maxBitLength (" + maxBitLength + ") is" +
                  "\u0020not greater or equal to 0");
            }
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            EInteger unum = this.UnsignedNumerator;
            EInteger uden = this.Denominator;
            if (unum.IsZero)
            {
                return EInteger.Zero;
            }
            if (unum.CompareTo(uden) < 0)
            {
                throw new ArithmeticException("Value is not an integer");
            }
            EInteger numBits = unum.GetUnsignedBitLengthAsEInteger();
            EInteger denBits = uden.GetUnsignedBitLengthAsEInteger();
            if (numBits.Subtract(2).Subtract(denBits).CompareTo(maxBitLength) >
      0)
            {
                throw new OverflowException("Value out of range");
            }
            unum = this.ToEIntegerIfExact();
            if (unum.GetSignedBitLengthAsInt64() > maxBitLength)
            {
                throw new OverflowException("Value out of range");
            }
            return unum;
        }

        /// <summary>Converts this value to an arbitrary-precision integer by
        /// dividing the numerator by the denominator and discarding the
        /// fractional part of the result.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        public EInteger ToEInteger()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.Numerator.Divide(this.Denominator);
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// checking whether the value is an exact integer.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        [Obsolete("Renamed to ToEIntegerIfExact.")]
        public EInteger ToEIntegerExact()
        {
            return this.ToEIntegerIfExact();
        }

        /// <summary>Converts this value to an arbitrary-precision integer,
        /// checking whether the value is an exact integer.</summary>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        public EInteger ToEIntegerIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.denominator.IsEvenNumber &&
                 !this.unsignedNumerator.IsEvenNumber)
            {
                // Even denominator, odd numerator, so not an integer
                throw new ArithmeticException("Value is not an integer");
            }
            EInteger rem;
            EInteger quo;
            EInteger[] divrem = this.Numerator.DivRem(this.Denominator);
            quo = divrem[0];
            rem = divrem[1];
            if (!rem.IsZero)
            {
                throw new ArithmeticException("Value is not an integer");
            }
            return quo;
        }

        /// <summary>Converts this rational number to an arbitrary-precision
        /// decimal number.</summary>
        /// <returns>The exact value of the rational number, or not-a-number
        /// (NaN) if the result can't be exact because it has a nonterminating
        /// decimal expansion.</returns>
        public EDecimal ToEDecimal()
        {
            return this.ToEDecimal(null);
        }

        /// <summary>Converts this rational number to an arbitrary-precision
        /// decimal number and rounds the result to the given
        /// precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. If HasFlags
        /// of the context is true, will also store the flags resulting from
        /// the operation (the flags are in addition to the pre-existing
        /// flags). Can be null, in which case the precision is unlimited and
        /// no rounding is needed.</param>
        /// <returns>The value of the rational number, rounded to the given
        /// precision. Returns not-a-number (NaN) if the context is null and
        /// the result can't be exact because it has a nonterminating decimal
        /// expansion.</returns>
        public EDecimal ToEDecimal(EContext ctx)
        {
            if (this.IsNaN())
            {
                return EDecimal.CreateNaN(
                    this.UnsignedNumerator,
                    this.IsSignalingNaN(),
                    this.IsNegative,
                    ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EDecimal.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EDecimal.NegativeInfinity.RoundToPrecision(ctx);
            }
            EDecimal ef = (this.IsNegative && this.IsZero) ?
              EDecimal.NegativeZero : EDecimal.FromEInteger(this.Numerator);
            return ef.Divide(EDecimal.FromEInteger(this.Denominator), ctx);
        }

        /// <summary>Converts this rational number to an arbitrary-precision
        /// decimal number, but if the result would have a nonterminating
        /// decimal expansion, rounds that result to the given
        /// precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only if the exact result would have a nonterminating
        /// decimal expansion. If HasFlags of the context is true, will also
        /// store the flags resulting from the operation (the flags are in
        /// addition to the pre-existing flags). Can be null, in which case the
        /// precision is unlimited and no rounding is needed.</param>
        /// <returns>The exact value of the rational number if possible;
        /// otherwise, the rounded version of the result if a context is given.
        /// Returns not-a-number (NaN) if the context is null and the result
        /// can't be exact because it has a nonterminating decimal
        /// expansion.</returns>
        public EDecimal ToEDecimalExactIfPossible(EContext
          ctx)
        {
            if (ctx == null)
            {
                return this.ToEDecimal(null);
            }
            if (this.IsNaN())
            {
                return EDecimal.CreateNaN(
                    this.UnsignedNumerator,
                    this.IsSignalingNaN(),
                    this.IsNegative,
                    ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EDecimal.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EDecimal.NegativeInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegative && this.IsZero)
            {
                return EDecimal.NegativeZero;
            }
            EInteger num = this.Numerator;
            EInteger den = this.Denominator;
            EDecimal valueEdNum = (this.IsNegative && this.IsZero) ?
              EDecimal.NegativeZero : EDecimal.FromEInteger(num);
            EDecimal valueEdDen = EDecimal.FromEInteger(den);
            EDecimal ed = valueEdNum.Divide(valueEdDen, null);
            if (ed.IsNaN())
            {
                // Result would be inexact, try again using the precision context
                ed = valueEdNum.Divide(valueEdDen, ctx);
            }
            return ed;
        }

        /// <summary>Converts this rational number to an arbitrary-precision
        /// decimal number.</summary>
        /// <returns>The exact value of the rational number, or not-a-number
        /// (NaN) if the result can't be exact because it has a nonterminating
        /// decimal expansion.</returns>
        [Obsolete("Renamed to ToEDecimal.")]
        public EDecimal ToExtendedDecimal()
        {
            return this.ToEDecimal();
        }

        /// <summary>Converts this rational number to an arbitrary-precision
        /// decimal number and rounds the result to the given
        /// precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. If HasFlags
        /// of the context is true, will also store the flags resulting from
        /// the operation (the flags are in addition to the pre-existing
        /// flags). Can be null, in which case the precision is unlimited and
        /// no rounding is needed.</param>
        /// <returns>The value of the rational number, rounded to the given
        /// precision. Returns not-a-number (NaN) if the context is null and
        /// the result can't be exact because it has a nonterminating decimal
        /// expansion.</returns>
        [Obsolete("Renamed to ToEDecimal.")]
        public EDecimal ToExtendedDecimal(EContext ctx)
        {
            return this.ToEDecimal(ctx);
        }

        /// <summary>Converts this rational number to an arbitrary-precision
        /// decimal number, but if the result would have a nonterminating
        /// decimal expansion, rounds that result to the given
        /// precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only if the exact result would have a nonterminating
        /// decimal expansion. If HasFlags of the context is true, will also
        /// store the flags resulting from the operation (the flags are in
        /// addition to the pre-existing flags). Can be null, in which case the
        /// precision is unlimited and no rounding is needed.</param>
        /// <returns>The exact value of the rational number if possible;
        /// otherwise, the rounded version of the result if a context is given.
        /// Returns not-a-number (NaN) if the context is null and the result
        /// can't be exact because it has a nonterminating decimal
        /// expansion.</returns>
        [Obsolete("Renamed to ToEDecimalExactIfPossible.")]
        public EDecimal ToExtendedDecimalExactIfPossible(EContext ctx)
        {
            return this.ToEDecimalExactIfPossible(ctx);
        }

        /// <summary>Converts this rational number to a binary floating-point
        /// number.</summary>
        /// <returns>The exact value of the rational number, or not-a-number
        /// (NaN) if the result can't be exact because it has a nonterminating
        /// binary expansion.</returns>
        public EFloat ToEFloat()
        {
            return this.ToEFloat(null);
        }

        /// <summary>Converts this rational number to a binary floating-point
        /// number and rounds that result to the given precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. If HasFlags
        /// of the context is true, will also store the flags resulting from
        /// the operation (the flags are in addition to the pre-existing
        /// flags). Can be null, in which case the precision is unlimited and
        /// no rounding is needed.</param>
        /// <returns>The value of the rational number, rounded to the given
        /// precision. Returns not-a-number (NaN) if the context is null and
        /// the result can't be exact because it has a nonterminating binary
        /// expansion.</returns>
        public EFloat ToEFloat(EContext ctx)
        {
            if (this.IsNaN())
            {
                return EFloat.CreateNaN(
                    this.UnsignedNumerator,
                    this.IsSignalingNaN(),
                    this.IsNegative,
                    ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EFloat.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EFloat.NegativeInfinity.RoundToPrecision(ctx);
            }
            EFloat ef = (this.IsNegative && this.IsZero) ?
              EFloat.NegativeZero : EFloat.FromEInteger(this.Numerator);
            return ef.Divide(EFloat.FromEInteger(this.Denominator), ctx);
        }

        /// <summary>Converts this rational number to a binary floating-point
        /// number, but if the result would have a nonterminating binary
        /// expansion, rounds that result to the given precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only if the exact result would have a nonterminating
        /// binary expansion. If HasFlags of the context is true, will also
        /// store the flags resulting from the operation (the flags are in
        /// addition to the pre-existing flags). Can be null, in which case the
        /// precision is unlimited and no rounding is needed.</param>
        /// <returns>The exact value of the rational number if possible;
        /// otherwise, the rounded version of the result if a context is given.
        /// Returns not-a-number (NaN) if the context is null and the result
        /// can't be exact because it has a nonterminating binary
        /// expansion.</returns>
        public EFloat ToEFloatExactIfPossible(EContext ctx)
        {
            if (ctx == null)
            {
                return this.ToEFloat(null);
            }
            if (this.IsNaN())
            {
                return EFloat.CreateNaN(
                    this.UnsignedNumerator,
                    this.IsSignalingNaN(),
                    this.IsNegative,
                    ctx);
            }
            if (this.IsPositiveInfinity())
            {
                return EFloat.PositiveInfinity.RoundToPrecision(ctx);
            }
            if (this.IsNegativeInfinity())
            {
                return EFloat.NegativeInfinity.RoundToPrecision(ctx);
            }
            if (this.IsZero)
            {
                return this.IsNegative ? EFloat.NegativeZero :
                  EFloat.Zero;
            }
            EFloat valueEdNum = (this.IsNegative && this.IsZero) ?
              EFloat.NegativeZero : EFloat.FromEInteger(this.Numerator);
            EFloat valueEdDen = EFloat.FromEInteger(this.Denominator);
            EFloat ed = valueEdNum.Divide(valueEdDen, null);
            if (ed.IsNaN())
            {
                // Result would be inexact, try again using the precision context
                ed = valueEdNum.Divide(valueEdDen, ctx);
            }
            return ed;
        }

        /// <summary>Converts this rational number to a binary floating-point
        /// number.</summary>
        /// <returns>The exact value of the rational number, or not-a-number
        /// (NaN) if the result can't be exact because it has a nonterminating
        /// binary expansion.</returns>
        [Obsolete("Renamed to ToEFloat.")]
        public EFloat ToExtendedFloat()
        {
            return this.ToEFloat();
        }

        /// <summary>Converts this rational number to a binary floating-point
        /// number and rounds that result to the given precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. If HasFlags
        /// of the context is true, will also store the flags resulting from
        /// the operation (the flags are in addition to the pre-existing
        /// flags). Can be null, in which case the precision is unlimited and
        /// no rounding is needed.</param>
        /// <returns>The value of the rational number, rounded to the given
        /// precision. Returns not-a-number (NaN) if the context is null and
        /// the result can't be exact because it has a nonterminating binary
        /// expansion.</returns>
        [Obsolete("Renamed to ToEFloat.")]
        public EFloat ToExtendedFloat(EContext ctx)
        {
            return this.ToEFloat(ctx);
        }

        /// <summary>Converts this rational number to a binary floating-point
        /// number, but if the result would have a nonterminating binary
        /// expansion, rounds that result to the given precision.</summary>
        /// <param name='ctx'>An arithmetic context object to control the
        /// precision, rounding, and exponent range of the result. This context
        /// will be used only if the exact result would have a nonterminating
        /// binary expansion. If HasFlags of the context is true, will also
        /// store the flags resulting from the operation (the flags are in
        /// addition to the pre-existing flags). Can be null, in which case the
        /// precision is unlimited and no rounding is needed.</param>
        /// <returns>The exact value of the rational number if possible;
        /// otherwise, the rounded version of the result if a context is given.
        /// Returns not-a-number (NaN) if the context is null and the result
        /// can't be exact because it has a nonterminating binary
        /// expansion.</returns>
        [Obsolete("Renamed to ToEFloatExactIfPossible.")]
        public EFloat ToExtendedFloatExactIfPossible(EContext ctx)
        {
            return this.ToEFloatExactIfPossible(ctx);
        }

        /// <summary>Converts this value to a 32-bit binary floating-point
        /// number. The half-even rounding mode is used.</summary>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value. The return value can be positive infinity or negative
        /// infinity if this value exceeds the range of a 32-bit floating point
        /// number.</returns>
        public float ToSingle()
        {
            if (!this.IsFinite)
            {
                return this.ToEFloat(EContext.Binary32).ToSingle();
            }
            if (this.IsNegative && this.IsZero)
            {
                return EFloat.NegativeZero.ToSingle();
            }
            return EFloat.FromEInteger(this.Numerator)
              .Divide(EFloat.FromEInteger(this.Denominator), EContext.Binary32)
              .ToSingle();
        }

        /// <summary>Converts this object to a text string.</summary>
        /// <returns>A string representation of this object. If this object's
        /// value is infinity or not-a-number, the result is the analogous
        /// return value of the <c>EDecimal.ToString</c> method. Otherwise, the
        /// return value has the following form:
        /// <c>[-]numerator/denominator</c>.</returns>
        public override string ToString()
        {
            if (!this.IsFinite)
            {
                if (this.IsSignalingNaN())
                {
                    if (this.unsignedNumerator.IsValueZero)
                    {
                        return this.IsNegative ? "-sNaN" : "sNaN";
                    }
                    return this.IsNegative ? "-sNaN" + this.unsignedNumerator :
                      "sNaN" + this.unsignedNumerator;
                }
                if (this.IsQuietNaN())
                {
                    if (this.unsignedNumerator.IsValueZero)
                    {
                        return this.IsNegative ? "-NaN" : "NaN";
                    }
                    return this.IsNegative ? "-NaN" + this.unsignedNumerator :
                      "NaN" + this.unsignedNumerator;
                }
                if (this.IsInfinity())
                {
                    return this.IsNegative ? "-Infinity" : "Infinity";
                }
            }
            return (this.unsignedNumerator.IsValueZero && this.IsNegative) ? ("-0/" +
                this.Denominator) : (this.Numerator + "/" + this.Denominator);
        }

        /// <summary>Adds one to an arbitrary-precision rational
        /// number.</summary>
        /// <returns>The given arbitrary-precision rational number plus
        /// one.</returns>
        public ERational Increment()
        {
            return this.Add(FromInt32(1));
        }

        /// <summary>Subtracts one from an arbitrary-precision rational
        /// number.</summary>
        /// <returns>The given arbitrary-precision rational number minus
        /// one.</returns>
        public ERational Decrement()
        {
            return this.Subtract(FromInt32(1));
        }

        /// <summary>Adds this arbitrary-precision rational number and a 32-bit
        /// signed integer and returns the result.</summary>
        /// <param name='v'>A 32-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision rational number plus a 32-bit signed
        /// integer.</returns>
        public ERational Add(int v)
        {
            return this.Add(FromInt32(v));
        }

        /// <summary>Subtracts a 32-bit signed integer from this
        /// arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='v'>The parameter <paramref name='v'/> is a 32-bit
        /// signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision rational number minus a 32-bit signed
        /// integer.</returns>
        public ERational Subtract(int v)
        {
            return this.Subtract(FromInt32(v));
        }

        /// <summary>Multiplies this arbitrary-precision rational number by a
        /// 32-bit signed integer and returns the result.</summary>
        /// <param name='v'>The parameter <paramref name='v'/> is a 32-bit
        /// signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision rational number times a 32-bit signed
        /// integer.</returns>
        public ERational Multiply(int v)
        {
            return this.Multiply(FromInt32(v));
        }

        /// <summary>Divides this arbitrary-precision rational number by a
        /// 32-bit signed integer and returns the result.</summary>
        /// <param name='v'>The parameter <paramref name='v'/> is a 32-bit
        /// signed integer.</param>
        /// <returns>The result of dividing this arbitrary-precision rational
        /// number by a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>The parameter <paramref
        /// name='v'/> is zero.</exception>
        public ERational Divide(int v)
        {
            return this.Divide(FromInt32(v));
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision rational number is divided by a 32-bit signed
        /// integer.</summary>
        /// <param name='v'>The divisor.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision rational number is divided by a 32-bit signed
        /// integer.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='v'/> is zero.</exception>
        public ERational Remainder(int v)
        {
            return this.Remainder(FromInt32(v));
        }

        /// <summary>Adds this arbitrary-precision rational number and a 64-bit
        /// signed integer and returns the result.</summary>
        /// <param name='v'>A 64-bit signed integer.</param>
        /// <returns>The sum of the two numbers, that is, this
        /// arbitrary-precision rational number plus a 64-bit signed
        /// integer.</returns>
        public ERational Add(long v)
        {
            return this.Add(FromInt64(v));
        }

        /// <summary>Subtracts a 64-bit signed integer from this
        /// arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='v'>The parameter <paramref name='v'/> is a 64-bit
        /// signed integer.</param>
        /// <returns>The difference between the two numbers, that is, this
        /// arbitrary-precision rational number minus a 64-bit signed
        /// integer.</returns>
        public ERational Subtract(long v)
        {
            return this.Subtract(FromInt64(v));
        }

        /// <summary>Multiplies this arbitrary-precision rational number by a
        /// 64-bit signed integer and returns the result.</summary>
        /// <param name='v'>The parameter <paramref name='v'/> is a 64-bit
        /// signed integer.</param>
        /// <returns>The product of the two numbers, that is, this
        /// arbitrary-precision rational number times a 64-bit signed
        /// integer.</returns>
        public ERational Multiply(long v)
        {
            return this.Multiply(FromInt64(v));
        }

        /// <summary>Divides this arbitrary-precision rational number by a
        /// 64-bit signed integer and returns the result.</summary>
        /// <param name='v'>The parameter <paramref name='v'/> is a 64-bit
        /// signed integer.</param>
        /// <returns>The result of dividing this arbitrary-precision rational
        /// number by a 64-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>The parameter <paramref
        /// name='v'/> is zero.</exception>
        public ERational Divide(long v)
        {
            return this.Divide(FromInt64(v));
        }

        /// <summary>Returns the remainder that would result when this
        /// arbitrary-precision rational number is divided by a 64-bit signed
        /// integer.</summary>
        /// <param name='v'>The divisor.</param>
        /// <returns>The remainder that would result when this
        /// arbitrary-precision rational number is divided by a 64-bit signed
        /// integer.</returns>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='v'/> is zero.</exception>
        public ERational Remainder(long v)
        {
            return this.Remainder(FromInt64(v));
        }

        // Begin integer conversions
        private void CheckTrivialOverflow(int maxBits)
        {
            if (this.IsZero)
            {
                return;
            }
            if (!this.IsFinite)
            {
                throw new OverflowException("Value out of range");
            }
            EInteger bignum = this.UnsignedNumerator;
            EInteger bigden = this.Denominator;
            EInteger numbits = bignum.GetUnsignedBitLengthAsEInteger();
            EInteger denbits = bigden.GetUnsignedBitLengthAsEInteger();
            if (numbits.CompareTo(denbits.Add(1).Add(maxBits)) > 0)
            {
                throw new OverflowException("Value out of range");
            }
        }

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255) after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a byte (from 0 to
        /// 255).</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 255.</exception>
        public byte ToByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsNegative && !this.IsZero &&
              this.UnsignedNumerator.CompareTo(this.Denominator) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            this.CheckTrivialOverflow(8);
            return this.IsZero ? ((byte)0) : this.ToEInteger().ToByteChecked();
        }

        /// <summary>Converts this number's value to an integer (using
        /// ToEInteger), and returns the least-significant bits of that
        /// integer's two's-complement form as a byte (from 0 to
        /// 255).</summary>
        /// <returns>This number, converted to a byte (from 0 to 255). Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public byte ToByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToByteUnchecked() : (byte)0;
        }

        /// <summary>Converts this number's value to a byte (from 0 to 255) if
        /// it can fit in a byte (from 0 to 255) without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a byte (from 0 to 255).</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 255.</exception>
        public byte ToByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            if (this.IsNegative && !this.IsZero &&
              this.UnsignedNumerator.CompareTo(this.Denominator) >= 0)
            {
                throw new OverflowException("Value out of range");
            }
            this.CheckTrivialOverflow(8);
            return this.IsZero ? ((byte)0) : this.ToEIntegerIfExact().ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromByte(byte inputByte)
        {
            int val = ((int)inputByte) & 0xff;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 16-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -32768 or greater than
        /// 32767.</exception>
        public short ToInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(15);
            return this.IsZero ? ((short)0) : this.ToEInteger().ToInt16Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 16-bit signed integer.</summary>
        /// <returns>This number, converted to a 16-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public short ToInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt16Unchecked() : (short)0;
        }

        /// <summary>Converts this number's value to a 16-bit signed integer if
        /// it can fit in a 16-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 16-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -32768 or
        /// greater than 32767.</exception>
        public short ToInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(15);
            return this.IsZero ? ((short)0) :
              this.ToEIntegerIfExact().ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromInt16(short inputInt16)
        {
            var val = (int)inputInt16;
            return FromInt32(val);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -2147483648 or greater
        /// than 2147483647.</exception>
        public int ToInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(31);
            return this.IsZero ? ((int)0) : this.ToEInteger().ToInt32Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 32-bit signed integer.</summary>
        /// <returns>This number, converted to a 32-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public int ToInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt32Unchecked() : (int)0;
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -2147483648
        /// or greater than 2147483647.</exception>
        public int ToInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(31);
            return this.IsZero ? ((int)0) : this.ToEIntegerIfExact().ToInt32Checked();
        }

        /// <summary>Converts a boolean value (true or false) to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>The number 1 if <paramref name='boolValue'/> is true;
        /// otherwise, 0.</returns>
        public static ERational FromBoolean(bool boolValue)
        {
            return FromInt32(boolValue ? 1 : 0);
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromInt32(int inputInt32)
        {
            return FromEInteger(EInteger.FromInt32(inputInt32));
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 64-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -9223372036854775808
        /// or greater than 9223372036854775807.</exception>
        public long ToInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(63);
            return this.IsZero ? 0L : this.ToEInteger().ToInt64Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 64-bit signed integer.</summary>
        /// <returns>This number, converted to a 64-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public long ToInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToInt64Unchecked() : 0L;
        }

        /// <summary>Converts this number's value to a 64-bit signed integer if
        /// it can fit in a 64-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 64-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than
        /// -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        public long ToInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            this.CheckTrivialOverflow(63);
            return this.IsZero ? 0L : this.ToEIntegerIfExact().ToInt64Checked();
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputInt64'>The number to convert as a 64-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromInt64(long inputInt64)
        {
            return FromEInteger(EInteger.FromInt64(inputInt64));
        }

        // End integer conversions
    }

    public sealed partial class ERational
    {
        /// <summary>Converts a boolean value (true or false) to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='boolValue'>Either true or false.</param>
        /// <returns>1 if <paramref name='boolValue'/> is true; otherwise,
        /// 0.</returns>
        public static explicit operator ERational(bool boolValue)
        {
            return FromBoolean(boolValue);
        }

        /// <summary>Converts an arbitrary-precision integer to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='eint'>An arbitrary-precision integer.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        public static implicit operator ERational(EInteger eint)
        {
            return FromEInteger(eint);
        }

        /// <summary>Converts an arbitrary-precision decimal floating-point
        /// number to an arbitrary-precision rational number.</summary>
        /// <param name='eint'>The parameter <paramref name='eint'/> is an
        /// arbitrary-precision decimal floating-point number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        public static implicit operator ERational(EDecimal eint)
        {
            return FromEDecimal(eint);
        }

        /// <summary>Converts an arbitrary-precision binary floating-point
        /// number to an arbitrary-precision rational number.</summary>
        /// <param name='eint'>An arbitrary-precision binary floating-point
        /// number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        public static implicit operator ERational(EFloat eint)
        {
            return FromEFloat(eint);
        }

        /// <summary>Converts a <c>decimal</c> under the Common Language
        /// Infrastructure (usually a.NET Framework decimal) to a rational
        /// number.</summary>
        /// <param name='eint'>The number to convert as a <c>decimal</c> under
        /// the Common Language Infrastructure (usually a.NET Framework
        /// decimal).</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        public static ERational FromDecimal(decimal eint)
        {
            return FromEDecimal(EDecimal.FromDecimal(eint));
        }

        /// <summary>Converts a <c>decimal</c> under the Common Language
        /// Infrastructure (usually a.NET Framework decimal). to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='eint'>A <c>decimal</c> under the Common Language
        /// Infrastructure (usually a.NET Framework decimal).</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        public static implicit operator ERational(decimal eint)
        {
            return FromDecimal(eint);
        }

        /// <summary>Converts a 32-bit binary floating-point number to a
        /// rational number.</summary>
        /// <param name='eint'>The parameter <paramref name='eint'/> is a
        /// 32-bit binary floating-point number.</param>
        /// <returns>The value of <paramref name='eint'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(float eint)
        {
            return ERational.FromSingle(eint);
        }

        /// <summary>Converts a 64-bit floating-point number to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='eint'>The parameter <paramref name='eint'/> is a
        /// 64-bit floating-point number.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        public static implicit operator ERational(double eint)
        {
            return ERational.FromDouble(eint);
        }

        /// <summary>Adds an arbitrary-precision rational number and another
        /// arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='bthis'>The first operand.</param>
        /// <param name='augend'>The second operand.</param>
        /// <returns>The sum of the two numbers, that is, an
        /// arbitrary-precision rational number plus another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "otherValue"
        /// is null.</exception>
        public static ERational operator +(ERational bthis, ERational augend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(augend);
        }

        /// <summary>Subtracts an arbitrary-precision rational number from this
        /// instance.</summary>
        /// <param name='bthis'>The first operand.</param>
        /// <param name='subtrahend'>The second operand.</param>
        /// <returns>The difference of the two objects.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "otherValue"
        /// is null.</exception>
        public static ERational operator -(
          ERational bthis,
          ERational subtrahend)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(subtrahend);
        }

        /// <summary>Adds one to an arbitrary-precision rational
        /// number.</summary>
        /// <param name='bthis'>An arbitrary-precision rational number.</param>
        /// <returns>The number given in <paramref name='bthis'/> plus
        /// one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static ERational operator ++(ERational bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Add(1);
        }

        /// <summary>Subtracts one from an arbitrary-precision rational
        /// number.</summary>
        /// <param name='bthis'>An arbitrary-precision rational number.</param>
        /// <returns>The number given in <paramref name='bthis'/> minus
        /// one.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bthis'/> is null.</exception>
        public static ERational operator --(ERational bthis)
        {
            if (bthis == null)
            {
                throw new ArgumentNullException(nameof(bthis));
            }
            return bthis.Subtract(1);
        }

        /// <summary>Multiplies an arbitrary-precision rational number by
        /// another arbitrary-precision rational number and returns the
        /// result.</summary>
        /// <param name='operand1'>The first operand.</param>
        /// <param name='operand2'>The second operand.</param>
        /// <returns>The product of the two numbers, that is, an
        /// arbitrary-precision rational number times another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "otherValue"
        /// is null.</exception>
        public static ERational operator *(
          ERational operand1,
          ERational operand2)
        {
            if (operand1 == null)
            {
                throw new ArgumentNullException(nameof(operand1));
            }
            return operand1.Multiply(operand2);
        }

        /// <summary>Divides an arbitrary-precision rational number by the
        /// value of another arbitrary-precision rational number
        /// object.</summary>
        /// <param name='dividend'>An arbitrary-precision rational number
        /// serving as the dividend.</param>
        /// <param name='divisor'>An arbitrary-precision rational number
        /// serving as the divisor.</param>
        /// <returns>The quotient of the two objects.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "otherValue"
        /// is null.</exception>
        public static ERational operator /(
          ERational dividend,
          ERational divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Divide(divisor);
        }

        /// <summary>Returns the remainder that would result when an
        /// arbitrary-precision rational number is divided by another
        /// arbitrary-precision rational number.</summary>
        /// <param name='dividend'>The dividend.</param>
        /// <param name='divisor'>The divisor.</param>
        /// <returns>The remainder that would result when an
        /// arbitrary-precision rational number is divided by another
        /// arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter "otherValue"
        /// is null.</exception>
        public static ERational operator %(
          ERational dividend,
          ERational divisor)
        {
            if (dividend == null)
            {
                throw new ArgumentNullException(nameof(dividend));
            }
            return dividend.Remainder(divisor);
        }

        /// <summary>Returns an arbitrary-precision rational number with the
        /// same value as the given one but with its sign reversed.</summary>
        /// <param name='bigValue'>An arbitrary-precision rational number to
        /// negate.</param>
        /// <returns>An arbitrary-precision rational number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static ERational operator -(ERational bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.Negate();
        }

        /// <summary>Converts this value to a <c>decimal</c> under the Common
        /// Language Infrastructure (usually a.NET Framework decimal).
        /// Currently, converts this value to the precision and range of a.NET
        /// Framework decimal.</summary>
        /// <returns>A <c>decimal</c> under the Common Language Infrastructure
        /// (usually a.NET Framework decimal).</returns>
        public decimal ToDecimal()
        {
            ERational extendedNumber = this;
            if (extendedNumber.IsInfinity() || extendedNumber.IsNaN())
            {
                throw new OverflowException("This object's value is out of range");
            }
            try
            {
                EDecimal newDecimal = EDecimal.FromEInteger(extendedNumber.Numerator)
                  .Divide(
                    EDecimal.FromEInteger(extendedNumber.Denominator),
                    EContext.CliDecimal.WithTraps(EContext.FlagOverflow));
                return (decimal)newDecimal;
            }
            catch (ETrapException ex)
            {
                throw new OverflowException("This object's value is out of range", ex);
            }
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// <c>decimal</c> under the Common Language Infrastructure (see
        /// <see cref='PeterO.Numbers.EDecimal'>"Forms of numbers"</see>
        /// ).</summary>
        /// <param name='extendedNumber'>The number to convert as an
        /// arbitrary-precision rational number.</param>
        /// <returns>A <c>decimal</c> under the Common Language Infrastructure
        /// (usually a.NET Framework decimal).</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='extendedNumber'/> is null.</exception>
        public static explicit operator decimal(
          ERational extendedNumber)
        {
            if (extendedNumber == null)
            {
                throw new ArgumentNullException(nameof(extendedNumber));
            }
            return extendedNumber.ToDecimal();
        }

        /// <summary>Converts an arbitrary-precision rational number to an
        /// arbitrary-precision integer. Any fractional part in the value will
        /// be discarded when converting to an arbitrary-precision
        /// integer.</summary>
        /// <param name='bigValue'>An arbitrary-precision rational
        /// number.</param>
        /// <returns>An arbitrary-precision integer.</returns>
        /// <exception cref='OverflowException'>This object's value is infinity
        /// or not-a-number (NaN).</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator EInteger(ERational bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToEInteger();
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 64-bit floating-point number. The half-even rounding mode is
        /// used.</summary>
        /// <param name='bigValue'>The number to convert as an
        /// arbitrary-precision rational number.</param>
        /// <returns>The closest 64-bit floating-point number to this value.
        /// The return value can be positive infinity or negative infinity if
        /// this value exceeds the range of a 64-bit floating point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator double(ERational bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToDouble();
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 32-bit binary floating-point number. The half-even rounding mode is
        /// used.</summary>
        /// <param name='bigValue'>The number to convert as an
        /// arbitrary-precision rational number.</param>
        /// <returns>The closest 32-bit binary floating-point number to this
        /// value. The return value can be positive infinity or negative
        /// infinity if this value exceeds the range of a 32-bit floating point
        /// number.</returns>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='bigValue'/> is null.</exception>
        public static explicit operator float(ERational bigValue)
        {
            if (bigValue == null)
            {
                throw new ArgumentNullException(nameof(bigValue));
            }
            return bigValue.ToSingle();
        }

        // Begin integer conversions

        /// <summary>Converts an arbitrary-precision rational number to a byte
        /// (from 0 to 255) if it can fit in a byte (from 0 to 255) after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// byte (from 0 to 255).</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 255.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToByteChecked.")]
        public static explicit operator byte(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToByteChecked();
        }

        /// <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputByte'>The number to convert as a byte (from 0 to
        /// 255).</param>
        /// <returns>The value of <paramref name='inputByte'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(byte inputByte)
        {
            return ERational.FromByte(inputByte);
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to an 8-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than -128 or greater than
        /// 127.</exception>
        public sbyte ToSByteChecked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) :
              this.ToEInteger().ToSByteChecked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as an 8-bit signed integer.</summary>
        /// <returns>This number, converted to an 8-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public sbyte ToSByteUnchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToSByteUnchecked() : (sbyte)0;
        }

        /// <summary>Converts this number's value to an 8-bit signed integer if
        /// it can fit in an 8-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as an 8-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than -128 or
        /// greater than 127.</exception>
        public sbyte ToSByteIfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((sbyte)0) :
              this.ToEIntegerIfExact().ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromSByte(sbyte inputSByte)
        {
            var val = (int)inputSByte;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision rational number to an
        /// 8-bit signed integer if it can fit in an 8-bit signed integer after
        /// converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to an
        /// 8-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -128 or greater than 127.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToSByteChecked.")]
        public static explicit operator sbyte(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToSByteChecked();
        }

        /// <summary>Converts an 8-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputSByte'>The number to convert as an 8-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputSByte'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(sbyte inputSByte)
        {
            return ERational.FromSByte(inputSByte);
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 16-bit signed integer if it can fit in a 16-bit signed integer
        /// after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 16-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -32768 or greater than 32767.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt16Checked.")]
        public static explicit operator short(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt16Checked();
        }

        /// <summary>Converts a 16-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputInt16'>The number to convert as a 16-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt16'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(short inputInt16)
        {
            return ERational.FromInt16(inputInt16);
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer after converting it to
        /// an integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 65535.</exception>
        public ushort ToUInt16Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ?
              ((ushort)0) : this.ToEInteger().ToUInt16Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 16-bit unsigned integer.</summary>
        /// <returns>This number, converted to a 16-bit unsigned integer.
        /// Returns 0 if this value is infinity or not-a-number.</returns>
        public ushort ToUInt16Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt16Unchecked() : (ushort)0;
        }

        /// <summary>Converts this number's value to a 16-bit unsigned integer
        /// if it can fit in a 16-bit unsigned integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 16-bit unsigned
        /// integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 65535.</exception>
        public ushort ToUInt16IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? ((ushort)0) :
              this.ToEIntegerIfExact().ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromUInt16(ushort inputUInt16)
        {
            int val = ((int)inputUInt16) & 0xffff;
            return FromInt32(val);
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 16-bit unsigned integer if it can fit in a 16-bit unsigned integer
        /// after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 16-bit unsigned integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 65535.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt16Checked.")]
        public static explicit operator ushort(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt16Checked();
        }

        /// <summary>Converts a 16-bit unsigned integer to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='inputUInt16'>The number to convert as a 16-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt16'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(ushort inputUInt16)
        {
            return ERational.FromUInt16(inputUInt16);
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 32-bit signed integer if it can fit in a 32-bit signed integer
        /// after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -2147483648 or greater than 2147483647.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt32Checked.")]
        public static explicit operator int(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt32'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(int inputInt32)
        {
            return ERational.FromInt32(inputInt32);
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer after converting it to an
        /// integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 32-bit signed
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 4294967295.</exception>
        public uint ToUInt32Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0U : this.ToEInteger().ToUInt32Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 32-bit signed integer.</summary>
        /// <returns>This number, converted to a 32-bit signed integer. Returns
        /// 0 if this value is infinity or not-a-number.</returns>
        public uint ToUInt32Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt32Unchecked() : 0U;
        }

        /// <summary>Converts this number's value to a 32-bit signed integer if
        /// it can fit in a 32-bit signed integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 32-bit signed integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 4294967295.</exception>
        public uint ToUInt32IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0U :
              this.ToEIntegerIfExact().ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromUInt32(uint inputUInt32)
        {
            long val = ((long)inputUInt32) & 0xffffffffL;
            return FromInt64(val);
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 32-bit signed integer if it can fit in a 32-bit signed integer
        /// after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 32-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 4294967295.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt32Checked.")]
        public static explicit operator uint(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt32Checked();
        }

        /// <summary>Converts a 32-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputUInt32'>The number to convert as a 32-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputUInt32'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(uint inputUInt32)
        {
            return ERational.FromUInt32(inputUInt32);
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 64-bit signed integer if it can fit in a 64-bit signed integer
        /// after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 64-bit signed integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than -9223372036854775808 or greater than
        /// 9223372036854775807.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToInt64Checked.")]
        public static explicit operator long(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToInt64Checked();
        }

        /// <summary>Converts a 64-bit signed integer to an arbitrary-precision
        /// rational number.</summary>
        /// <param name='inputInt64'>The number to convert as a 64-bit signed
        /// integer.</param>
        /// <returns>The value of <paramref name='inputInt64'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(long inputInt64)
        {
            return ERational.FromInt64(inputInt64);
        }

        /// <summary>Converts this number's value to a 64-bit unsigned integer
        /// if it can fit in a 64-bit unsigned integer after converting it to
        /// an integer by discarding its fractional part.</summary>
        /// <returns>This number's value, truncated to a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='OverflowException'>This value is infinity or
        /// not-a-number, or the number, once converted to an integer by
        /// discarding its fractional part, is less than 0 or greater than
        /// 18446744073709551615.</exception>
        public ulong ToUInt64Checked()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0UL :
              this.ToEInteger().ToUInt64Checked();
        }

        /// <summary>Converts this number's value to an integer by discarding
        /// its fractional part, and returns the least-significant bits of its
        /// two's-complement form as a 64-bit unsigned integer.</summary>
        /// <returns>This number, converted to a 64-bit unsigned integer.
        /// Returns 0 if this value is infinity or not-a-number.</returns>
        public ulong ToUInt64Unchecked()
        {
            return this.IsFinite ? this.ToEInteger().ToUInt64Unchecked() : 0UL;
        }

        /// <summary>Converts this number's value to a 64-bit unsigned integer
        /// if it can fit in a 64-bit unsigned integer without rounding to a
        /// different numerical value.</summary>
        /// <returns>This number's value as a 64-bit unsigned
        /// integer.</returns>
        /// <exception cref='ArithmeticException'>This value is infinity or
        /// not-a-number, is not an exact integer, or is less than 0 or greater
        /// than 18446744073709551615.</exception>
        public ulong ToUInt64IfExact()
        {
            if (!this.IsFinite)
            {
                throw new OverflowException("Value is infinity or NaN");
            }
            return this.IsZero ? 0UL :
              this.ToEIntegerIfExact().ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>This number's value as an arbitrary-precision rational
        /// number.</returns>
        public static ERational FromUInt64(ulong inputUInt64)
        {
            return FromEInteger(EInteger.FromUInt64(inputUInt64));
        }

        /// <summary>Converts an arbitrary-precision rational number to a
        /// 64-bit unsigned integer if it can fit in a 64-bit unsigned integer
        /// after converting it to an integer by discarding its fractional
        /// part.</summary>
        /// <param name='input'>The number to convert as an arbitrary-precision
        /// rational number.</param>
        /// <returns>The value of <paramref name='input'/>, truncated to a
        /// 64-bit unsigned integer.</returns>
        /// <exception cref='OverflowException'>The parameter <paramref
        /// name='input'/> is infinity or not-a-number, or the number, once
        /// converted to an integer by discarding its fractional part, is less
        /// than 0 or greater than 18446744073709551615.</exception>
        /// <exception cref='ArgumentNullException'>The parameter <paramref
        /// name='input'/> is null.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
          "Microsoft.Usage",
          "CA2225",
          Justification = "Class implements an alternate method named ToUInt64Checked.")]
        public static explicit operator ulong(ERational input)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }
            return input.ToUInt64Checked();
        }

        /// <summary>Converts a 64-bit unsigned integer to an
        /// arbitrary-precision rational number.</summary>
        /// <param name='inputUInt64'>The number to convert as a 64-bit
        /// unsigned integer.</param>
        /// <returns>The value of <paramref name='inputUInt64'/> as an
        /// arbitrary-precision rational number.</returns>
        public static implicit operator ERational(ulong inputUInt64)
        {
            return ERational.FromUInt64(inputUInt64);
        }

        // End integer conversions
    }

    internal static class ERationalTextString
    {
        private const int MaxSafeInt = EDecimal.MaxSafeInt;

        public static ERational FromString(
          string chars,
          int offset,
          int length)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset(" + tmpoffset + ") is less than " +
                  "0");
            }
            if (tmpoffset > chars.Length)
            {
                throw new FormatException("offset(" + tmpoffset + ") is more than " +
                  chars.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length(" + length + ") is less than " +
                  "0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is more than " +
                  chars.Length);
            }
            if (chars.Length - tmpoffset < length)
            {
                throw new FormatException("chars's length minus " + tmpoffset + "(" +
                  (chars.Length - tmpoffset) + ") is less than " + length);
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            var negative = false;
            int endStr = tmpoffset + length;
            if (chars[tmpoffset] == '+' || chars[tmpoffset] == '-')
            {
                negative = chars[tmpoffset] == '-';
                ++tmpoffset;
            }
            var numerInt = 0;
            EInteger numer = null;
            var haveDigits = false;
            var haveDenominator = false;
            var ndenomInt = 0;
            EInteger ndenom = null;
            int i = tmpoffset;
            if (i + 8 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') &&
                  (chars[i + 2] == 'F' || chars[i + 2] == 'f') &&
                  (chars[i + 3] == 'I' || chars[i + 3] == 'i') && (chars[i + 4] ==
        'N' ||
                    chars[i + 4] == 'n') && (chars[i + 5] == 'I' || chars[i + 5] ==
        'i') &&
                  (chars[i + 6] == 'T' || chars[i + 6] == 't') && (chars[i + 7] ==
        'Y' ||
                    chars[i + 7] == 'y'))
                {
                    return negative ? ERational.NegativeInfinity :
          ERational.PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') && (chars[i + 2] ==
        'F' ||
                    chars[i + 2] == 'f'))
                {
                    return negative ? ERational.NegativeInfinity :
          ERational.PositiveInfinity;
                }
            }
            var numerStart = 0;
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((chars[i] == 'N' || chars[i] == 'n') && (chars[i + 1] == 'A' ||
        chars[i +
                      1] == 'a') && (chars[i + 2] == 'N' || chars[i + 2] == 'n'))
                {
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? ERational.NaN : ERational.NaN.Negate();
                    }
                    i += 3;
                    numerStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            if (numerInt <= MaxSafeInt)
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (numerInt > MaxSafeInt)
                    {
                        numer = EInteger.FromSubstring(chars, numerStart, endStr);
                        return ERational.CreateNaN(numer, false, negative);
                    }
                    else
                    {
                        return ERational.CreateNaN(
                           EInteger.FromInt32(numerInt),
                           false,
                           negative);
                    }
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((chars[i] == 'S' || chars[i] == 's') && (chars[i + 1] == 'N' ||
        chars[i +
                      1] == 'n') && (chars[i + 2] == 'A' || chars[i + 2] == 'a') &&
                  (chars[i + 3] == 'N' || chars[i + 3] == 'n'))
                {
                    if (i + 4 == endStr)
                    {
                        return (!negative) ? ERational.SignalingNaN :
            ERational.SignalingNaN.Negate();
                    }
                    i += 4;
                    numerStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (numerInt <= MaxSafeInt)
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    if (numerInt > MaxSafeInt)
                    {
                        numer = EInteger.FromSubstring(chars, numerStart, endStr);
                        return ERational.CreateNaN(numer, true, negative);
                    }
                    else
                    {
                        return ERational.CreateNaN(
                          EInteger.FromInt32(numerInt),
                          true,
                          negative);
                    }
                }
            }
            // Ordinary number
            numerStart = i;
            int numerEnd = i;
            for (; i < endStr; ++i)
            {
                if (chars[i] >= '0' && chars[i] <= '9')
                {
                    var thisdigit = (int)(chars[i] - '0');
                    numerEnd = i + 1;
                    if (numerInt <= MaxSafeInt)
                    {
                        numerInt *= 10;
                        numerInt += thisdigit;
                    }
                    haveDigits = true;
                }
                else if (chars[i] == '/')
                {
                    haveDenominator = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (numerInt > MaxSafeInt)
            {
                numer = EInteger.FromSubstring(chars, numerStart, numerEnd);
            }
            if (haveDenominator)
            {
                EInteger denom = null;
                var denomInt = 0;
                tmpoffset = 1;
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                numerStart = i;
                for (; i < endStr; ++i)
                {
                    if (chars[i] >= '0' && chars[i] <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(chars[i] - '0');
                        numerEnd = i + 1;
                        if (denomInt <= MaxSafeInt)
                        {
                            denomInt *= 10;
                            denomInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                if (denomInt > MaxSafeInt)
                {
                    denom = EInteger.FromSubstring(chars, numerStart, numerEnd);
                }
                if (denom == null)
                {
                    ndenomInt = denomInt;
                }
                else
                {
                    ndenom = denom;
                }
            }
            else
            {
                ndenomInt = 1;
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (ndenom == null ? (ndenomInt == 0) : ndenom.IsZero)
            {
                throw new FormatException();
            }
            ERational erat = ERational.Create(
                numer == null ? (EInteger)numerInt : numer,
                ndenom == null ? (EInteger)ndenomInt : ndenom);
            return negative ? erat.Negate() : erat;
        }
    }

    internal static class ERationalByteArrayString
    {
        private const int MaxSafeInt = EDecimal.MaxSafeInt;

        public static ERational FromString(
          byte[] chars,
          int offset,
          int length)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset(" + tmpoffset + ") is less than " +
                  "0");
            }
            if (tmpoffset > chars.Length)
            {
                throw new FormatException("offset(" + tmpoffset + ") is more than " +
                  chars.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length(" + length + ") is less than " +
                  "0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is more than " +
                  chars.Length);
            }
            if (chars.Length - tmpoffset < length)
            {
                throw new FormatException("chars's length minus " + tmpoffset + "(" +
                  (chars.Length - tmpoffset) + ") is less than " + length);
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            var negative = false;
            int endStr = tmpoffset + length;
            if (chars[tmpoffset] == '+' || chars[tmpoffset] == '-')
            {
                negative = chars[tmpoffset] == '-';
                ++tmpoffset;
            }
            var numerInt = 0;
            EInteger numer = null;
            var haveDigits = false;
            var haveDenominator = false;
            var ndenomInt = 0;
            EInteger ndenom = null;
            int i = tmpoffset;
            if (i + 8 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') &&
                  (chars[i + 2] == 'F' || chars[i + 2] == 'f') &&
                  (chars[i + 3] == 'I' || chars[i + 3] == 'i') && (chars[i + 4] ==
        'N' ||
                    chars[i + 4] == 'n') && (chars[i + 5] == 'I' || chars[i + 5] ==
        'i') &&
                  (chars[i + 6] == 'T' || chars[i + 6] == 't') && (chars[i + 7] ==
        'Y' ||
                    chars[i + 7] == 'y'))
                {
                    return negative ? ERational.NegativeInfinity :
          ERational.PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') && (chars[i + 2] ==
        'F' ||
                    chars[i + 2] == 'f'))
                {
                    return negative ? ERational.NegativeInfinity :
          ERational.PositiveInfinity;
                }
            }
            var numerStart = 0;
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((chars[i] == 'N' || chars[i] == 'n') && (chars[i + 1] == 'A' ||
        chars[i +
                      1] == 'a') && (chars[i + 2] == 'N' || chars[i + 2] == 'n'))
                {
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? ERational.NaN : ERational.NaN.Negate();
                    }
                    i += 3;
                    numerStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            if (numerInt <= MaxSafeInt)
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (numerInt > MaxSafeInt)
                    {
                        numer = EInteger.FromSubstring(chars, numerStart, endStr);
                        return ERational.CreateNaN(numer, false, negative);
                    }
                    else
                    {
                        return ERational.CreateNaN(
                           EInteger.FromInt32(numerInt),
                           false,
                           negative);
                    }
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((chars[i] == 'S' || chars[i] == 's') && (chars[i + 1] == 'N' ||
        chars[i +
                      1] == 'n') && (chars[i + 2] == 'A' || chars[i + 2] == 'a') &&
                  (chars[i + 3] == 'N' || chars[i + 3] == 'n'))
                {
                    if (i + 4 == endStr)
                    {
                        return (!negative) ? ERational.SignalingNaN :
            ERational.SignalingNaN.Negate();
                    }
                    i += 4;
                    numerStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (numerInt <= MaxSafeInt)
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    if (numerInt > MaxSafeInt)
                    {
                        numer = EInteger.FromSubstring(chars, numerStart, endStr);
                        return ERational.CreateNaN(numer, true, negative);
                    }
                    else
                    {
                        return ERational.CreateNaN(
                          EInteger.FromInt32(numerInt),
                          true,
                          negative);
                    }
                }
            }
            // Ordinary number
            numerStart = i;
            int numerEnd = i;
            for (; i < endStr; ++i)
            {
                if (chars[i] >= '0' && chars[i] <= '9')
                {
                    var thisdigit = (int)(chars[i] - '0');
                    numerEnd = i + 1;
                    if (numerInt <= MaxSafeInt)
                    {
                        numerInt *= 10;
                        numerInt += thisdigit;
                    }
                    haveDigits = true;
                }
                else if (chars[i] == '/')
                {
                    haveDenominator = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (numerInt > MaxSafeInt)
            {
                numer = EInteger.FromSubstring(chars, numerStart, numerEnd);
            }
            if (haveDenominator)
            {
                EInteger denom = null;
                var denomInt = 0;
                tmpoffset = 1;
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                numerStart = i;
                for (; i < endStr; ++i)
                {
                    if (chars[i] >= '0' && chars[i] <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(chars[i] - '0');
                        numerEnd = i + 1;
                        if (denomInt <= MaxSafeInt)
                        {
                            denomInt *= 10;
                            denomInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                if (denomInt > MaxSafeInt)
                {
                    denom = EInteger.FromSubstring(chars, numerStart, numerEnd);
                }
                if (denom == null)
                {
                    ndenomInt = denomInt;
                }
                else
                {
                    ndenom = denom;
                }
            }
            else
            {
                ndenomInt = 1;
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (ndenom == null ? (ndenomInt == 0) : ndenom.IsZero)
            {
                throw new FormatException();
            }
            ERational erat = ERational.Create(
                numer == null ? (EInteger)numerInt : numer,
                ndenom == null ? (EInteger)ndenomInt : ndenom);
            return negative ? erat.Negate() : erat;
        }
    }

    internal static class ERationalCharArrayString
    {
        private const int MaxSafeInt = EDecimal.MaxSafeInt;

        public static ERational FromString(
          char[] chars,
          int offset,
          int length)
        {
            int tmpoffset = offset;
            if (chars == null)
            {
                throw new ArgumentNullException(nameof(chars));
            }
            if (tmpoffset < 0)
            {
                throw new FormatException("offset(" + tmpoffset + ") is less than " +
                  "0");
            }
            if (tmpoffset > chars.Length)
            {
                throw new FormatException("offset(" + tmpoffset + ") is more than " +
                  chars.Length);
            }
            if (length < 0)
            {
                throw new FormatException("length(" + length + ") is less than " +
                  "0");
            }
            if (length > chars.Length)
            {
                throw new FormatException("length(" + length + ") is more than " +
                  chars.Length);
            }
            if (chars.Length - tmpoffset < length)
            {
                throw new FormatException("chars's length minus " + tmpoffset + "(" +
                  (chars.Length - tmpoffset) + ") is less than " + length);
            }
            if (length == 0)
            {
                throw new FormatException();
            }
            var negative = false;
            int endStr = tmpoffset + length;
            if (chars[tmpoffset] == '+' || chars[tmpoffset] == '-')
            {
                negative = chars[tmpoffset] == '-';
                ++tmpoffset;
            }
            var numerInt = 0;
            EInteger numer = null;
            var haveDigits = false;
            var haveDenominator = false;
            var ndenomInt = 0;
            EInteger ndenom = null;
            int i = tmpoffset;
            if (i + 8 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') &&
                  (chars[i + 2] == 'F' || chars[i + 2] == 'f') &&
                  (chars[i + 3] == 'I' || chars[i + 3] == 'i') && (chars[i + 4] ==
        'N' ||
                    chars[i + 4] == 'n') && (chars[i + 5] == 'I' || chars[i + 5] ==
        'i') &&
                  (chars[i + 6] == 'T' || chars[i + 6] == 't') && (chars[i + 7] ==
        'Y' ||
                    chars[i + 7] == 'y'))
                {
                    return negative ? ERational.NegativeInfinity :
          ERational.PositiveInfinity;
                }
            }
            if (i + 3 == endStr)
            {
                if ((chars[i] == 'I' || chars[i] == 'i') &&
                  (chars[i + 1] == 'N' || chars[i + 1] == 'n') && (chars[i + 2] ==
        'F' ||
                    chars[i + 2] == 'f'))
                {
                    return negative ? ERational.NegativeInfinity :
          ERational.PositiveInfinity;
                }
            }
            var numerStart = 0;
            if (i + 3 <= endStr)
            {
                // Quiet NaN
                if ((chars[i] == 'N' || chars[i] == 'n') && (chars[i + 1] == 'A' ||
        chars[i +
                      1] == 'a') && (chars[i + 2] == 'N' || chars[i + 2] == 'n'))
                {
                    if (i + 3 == endStr)
                    {
                        return (!negative) ? ERational.NaN : ERational.NaN.Negate();
                    }
                    i += 3;
                    numerStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            if (numerInt <= MaxSafeInt)
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    if (numerInt > MaxSafeInt)
                    {
                        numer = EInteger.FromSubstring(chars, numerStart, endStr);
                        return ERational.CreateNaN(numer, false, negative);
                    }
                    else
                    {
                        return ERational.CreateNaN(
                           EInteger.FromInt32(numerInt),
                           false,
                           negative);
                    }
                }
            }
            if (i + 4 <= endStr)
            {
                // Signaling NaN
                if ((chars[i] == 'S' || chars[i] == 's') && (chars[i + 1] == 'N' ||
        chars[i +
                      1] == 'n') && (chars[i + 2] == 'A' || chars[i + 2] == 'a') &&
                  (chars[i + 3] == 'N' || chars[i + 3] == 'n'))
                {
                    if (i + 4 == endStr)
                    {
                        return (!negative) ? ERational.SignalingNaN :
            ERational.SignalingNaN.Negate();
                    }
                    i += 4;
                    numerStart = i;
                    for (; i < endStr; ++i)
                    {
                        if (chars[i] >= '0' && chars[i] <= '9')
                        {
                            var thisdigit = (int)(chars[i] - '0');
                            haveDigits = haveDigits || thisdigit != 0;
                            if (numerInt <= MaxSafeInt)
                            {
                                numerInt *= 10;
                                numerInt += thisdigit;
                            }
                        }
                        else
                        {
                            throw new FormatException();
                        }
                    }
                    int flags3 = (negative ? BigNumberFlags.FlagNegative : 0) |
                      BigNumberFlags.FlagSignalingNaN;
                    if (numerInt > MaxSafeInt)
                    {
                        numer = EInteger.FromSubstring(chars, numerStart, endStr);
                        return ERational.CreateNaN(numer, true, negative);
                    }
                    else
                    {
                        return ERational.CreateNaN(
                          EInteger.FromInt32(numerInt),
                          true,
                          negative);
                    }
                }
            }
            // Ordinary number
            numerStart = i;
            int numerEnd = i;
            for (; i < endStr; ++i)
            {
                if (chars[i] >= '0' && chars[i] <= '9')
                {
                    var thisdigit = (int)(chars[i] - '0');
                    numerEnd = i + 1;
                    if (numerInt <= MaxSafeInt)
                    {
                        numerInt *= 10;
                        numerInt += thisdigit;
                    }
                    haveDigits = true;
                }
                else if (chars[i] == '/')
                {
                    haveDenominator = true;
                    ++i;
                    break;
                }
                else
                {
                    throw new FormatException();
                }
            }
            if (!haveDigits)
            {
                throw new FormatException();
            }
            if (numerInt > MaxSafeInt)
            {
                numer = EInteger.FromSubstring(chars, numerStart, numerEnd);
            }
            if (haveDenominator)
            {
                EInteger denom = null;
                var denomInt = 0;
                tmpoffset = 1;
                haveDigits = false;
                if (i == endStr)
                {
                    throw new FormatException();
                }
                numerStart = i;
                for (; i < endStr; ++i)
                {
                    if (chars[i] >= '0' && chars[i] <= '9')
                    {
                        haveDigits = true;
                        var thisdigit = (int)(chars[i] - '0');
                        numerEnd = i + 1;
                        if (denomInt <= MaxSafeInt)
                        {
                            denomInt *= 10;
                            denomInt += thisdigit;
                        }
                    }
                    else
                    {
                        throw new FormatException();
                    }
                }
                if (!haveDigits)
                {
                    throw new FormatException();
                }
                if (denomInt > MaxSafeInt)
                {
                    denom = EInteger.FromSubstring(chars, numerStart, numerEnd);
                }
                if (denom == null)
                {
                    ndenomInt = denomInt;
                }
                else
                {
                    ndenom = denom;
                }
            }
            else
            {
                ndenomInt = 1;
            }
            if (i != endStr)
            {
                throw new FormatException();
            }
            if (ndenom == null ? (ndenomInt == 0) : ndenom.IsZero)
            {
                throw new FormatException();
            }
            ERational erat = ERational.Create(
                numer == null ? (EInteger)numerInt : numer,
                ndenom == null ? (EInteger)ndenomInt : ndenom);
            return negative ? erat.Negate() : erat;
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.ERounding"]/*'/>
    public enum ERounding
    {
        /// <summary>Indicates that rounding will not be used. If rounding to
        /// an inexact value is required, the rounding operation will report an
        /// error.</summary>
        None,

        /// <summary>If there is a fractional part, the number is rounded to
        /// the closest representable number away from zero.</summary>
        Up,

        /// <summary>The fractional part is discarded (the number is
        /// truncated).</summary>
        Down,

        /// <summary>Rounded to the nearest number; if the fractional part is
        /// exactly half, the number is rounded to the closest representable
        /// number away from zero. This is the most familiar rounding mode for
        /// many people.</summary>
        HalfUp,

        /// <summary>Rounded to the nearest number; if the fractional part is
        /// exactly half, it is discarded.</summary>
        HalfDown,

        /// <summary>Rounded to the nearest number; if the fractional part is
        /// exactly half, the number is rounded to the closest representable
        /// number that is even. This is sometimes also known as "banker's
        /// rounding".</summary>
        HalfEven,

        /// <summary>If there is a fractional part, the number is rounded to
        /// the highest representable number that's closest to it.</summary>
        Ceiling,

        /// <summary>If there is a fractional part, the number is rounded to
        /// the lowest representable number that's closest to it.</summary>
        Floor,

        /// <summary>If there is a fractional part and the whole number part is
        /// even, the number is rounded to the closest representable odd number
        /// away from zero.</summary>
        [Obsolete("Consider using ERounding.OddOrZeroFiveUp instead.")]
        Odd,

        /// <summary>If there is a fractional part and if the last digit before
        /// rounding is 0 or half the radix, the number is rounded to the
        /// closest representable number away from zero; otherwise the
        /// fractional part is discarded. In overflow, the fractional part is
        /// always discarded.</summary>
        [Obsolete("Use ERounding.OddOrZeroFiveUp instead.")]
        ZeroFiveUp,

        /// <summary>For binary floating point numbers, this is the same as
        /// Odd. For other bases (including decimal numbers), this is the same
        /// as ZeroFiveUp. This rounding mode is useful for rounding
        /// intermediate results at a slightly higher precision (at least 2
        /// bits more for binary) than the final precision.</summary>
        OddOrZeroFiveUp,
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.ETrapException"]/*'/>
#if NET20 || NET40
  [Serializable]
#endif
    public sealed class ETrapException : ArithmeticException
    {
        private readonly Object result;
        private readonly EContext ctx;

        /// <summary>Gets the arithmetic context used during the operation that
        /// triggered the trap. May be null.</summary>
        /// <value>The arithmetic context used during the operation that
        /// triggered the trap. May be null.</value>
        public EContext Context
        {
            get
            {
                return this.ctx;
            }
        }

        private readonly int error;

        private readonly int errors;

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.ETrapException'/> class.</summary>
        public ETrapException() : this(FlagToMessage(EContext.FlagInvalid))
        {
        }

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.ETrapException'/> class.</summary>
        /// <param name='message'>The parameter <paramref name='message'/> is a
        /// text string.</param>
        public ETrapException(string message) : base(message)
        {
            this.error = EContext.FlagInvalid;
            this.errors = EContext.FlagInvalid;
            this.ctx = null;
            this.result = null;
        }

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.ETrapException'/> class.</summary>
        /// <param name='message'>The parameter <paramref name='message'/> is a
        /// text string.</param>
        /// <param name='innerException'>The parameter <paramref
        /// name='innerException'/> is an Exception object.</param>
        public ETrapException(string message, Exception innerException)
          : base(message, innerException)
        {
            this.error = EContext.FlagInvalid;
            this.errors = EContext.FlagInvalid;
            this.ctx = (this.ctx == null) ? null : this.ctx.Copy();
            this.result = null;
        }

        /// <summary>Gets the defined result of the operation that caused the
        /// trap.</summary>
        /// <value>The defined result of the operation that caused the
        /// trap.</value>
        public Object Result
        {
            get
            {
                return this.result;
            }
        }

        /// <summary>Gets the flag that specifies the primary kind of error in
        /// one or more operations (EContext.FlagXXX). This will only be one
        /// flag, such as <c>FlagInexact</c> or FlagSubnormal.</summary>
        /// <value>The flag that specifies the primary kind of error in one or
        /// more operations.</value>
        public int Error
        {
            get
            {
                return this.error;
            }
        }

        /// <summary>Gets the flags that were signaled as the result of one or
        /// more operations. This includes the flag specified in the "flag"
        /// parameter, but can include other flags. For instance, if "flag" is
        /// <c>EContext.FlagInexact</c>, this parameter might be
        /// <c>EContext.FlagInexact | EContext.FlagRounded</c>.</summary>
        /// <value>The flags that specify the errors in one or more
        /// operations.</value>
        public int Errors
        {
            get
            {
                return this.errors;
            }
        }

        /// <summary>Returns whether this trap exception specifies all the
        /// flags given. (Flags are signaled in a trap exception as the result
        /// of one or more operations involving arbitrary-precision numbers,
        /// such as multiplication of two EDecimals.).</summary>
        /// <param name='flag'>A combination of one or more flags, such as
        /// <c>EContext.FlagInexact | EContext.FlagRounded</c>.</param>
        /// <returns>True if this exception pertains to all of the flags given
        /// in <paramref name='flag'/> ; otherwise, false.</returns>
        public bool HasError(int flag)
        {
            return (this.Error & flag) == flag;
        }

        private static string FlagToMessage(int flags)
        {
            var sb = new System.Text.StringBuilder();
            var first = true;
            for (var i = 0; i < 32; ++i)
            {
                int flag = 1 << i;
                if ((flags & flag) != 0)
                {
                    if (!first)
                    {
                        sb.Append(", ");
                    }
                    first = false;
                    string str = (flag == EContext.FlagClamped) ? "Clamped" : ((flag ==
                          EContext.FlagDivideByZero) ? "DivideByZero" : ((flag ==
                            EContext.FlagInexact) ? "Inexact" : ((flag ==
                              EContext.FlagInvalid) ? "Invalid" : ((flag ==
                                EContext.FlagOverflow) ? "Overflow" : ((flag ==
                                  EContext.FlagRounded) ? "Rounded" : ((flag ==
                                    EContext.FlagSubnormal) ? "Subnormal" : ((flag ==
                                      EContext.FlagUnderflow) ? "Underflow" :
          "Trap")))))));
                    sb.Append(str);
                }
            }
            return sb.ToString();
        }

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.ETrapException'/> class.</summary>
        /// <param name='flag'>The flag that specifies the kind of error from
        /// one or more operations (EContext.FlagXXX). This will only be one
        /// flag, such as <c>FlagInexact</c> or FlagSubnormal.</param>
        /// <param name='ctx'>The arithmetic context used during the operation
        /// that triggered the trap. Can be null.</param>
        /// <param name='result'>The defined result of the operation that
        /// caused the trap.</param>
        public ETrapException(int flag, EContext ctx, Object result)
          : this(flag, flag, ctx, result)
        {
        }

        /// <summary>Initializes a new instance of the
        /// <see cref='PeterO.Numbers.ETrapException'/> class.</summary>
        /// <param name='flags'>Specifies the flags that were signaled as the
        /// result of one or more operations. This includes the flag specified
        /// in the "flag" parameter, but can include other flags. For instance,
        /// if "flag" is <c>EContext.FlagInexact</c>, this parameter might be
        /// <c>EContext.FlagInexact | EContext.FlagRounded</c>.</param>
        /// <param name='flag'>Specifies the flag that specifies the primary
        /// kind of error from one or more operations (EContext.FlagXXX). This
        /// will only be one flag, such as <c>FlagInexact</c> or
        /// FlagSubnormal.</param>
        /// <param name='ctx'>The arithmetic context used during the operation
        /// that triggered the trap. Can be null.</param>
        /// <param name='result'>The defined result of the operation that
        /// caused the trap.</param>
        /// <exception cref='ArgumentException'>The parameter <paramref
        /// name='flags'/> doesn't include all the flags in the <paramref
        /// name='flag'/> parameter.</exception>
        public ETrapException(int flags, int flag, EContext ctx, Object result)
          : base(FlagToMessage(flags))
        {
            if ((flags & flag) != flag)
            {
                throw new ArgumentException("flags doesn't include flag");
            }
            this.error = flag;
            this.errors = flags;
            this.ctx = (ctx == null) ? null : ctx.Copy();
            this.result = result;
        }

#if NET20 || NET40
    private ETrapException(
      System.Runtime.Serialization.SerializationInfo info,
      System.Runtime.Serialization.StreamingContext context)
      : base(info, context) {
    }
#endif
    }

    internal class ExtendedOrSimpleRadixMath<T> : IRadixMath<T>
    {
        private readonly RadixMath<T> ext;
        private readonly SimpleRadixMath<T> simp;

        public ExtendedOrSimpleRadixMath(IRadixMathHelper<T> helper)
        {
            this.ext = new RadixMath<T>(helper);
            this.simp = new SimpleRadixMath<T>(this.ext);
        }

        public IRadixMathHelper<T> GetHelper()
        {
            // Both RadixMath implementations return the
            // same helper, so use the ext implementation
            return this.ext.GetHelper();
        }

        public T DivideToIntegerNaturalScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.DivideToIntegerNaturalScale(thisValue, divisor, ctx) :
              this.simp.DivideToIntegerNaturalScale(thisValue, divisor, ctx);
        }

        public T DivideToIntegerZeroScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.DivideToIntegerZeroScale(thisValue, divisor, ctx) :
              this.simp.DivideToIntegerZeroScale(thisValue, divisor, ctx);
        }

        public T Abs(T value, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Abs(value, ctx) :
              this.simp.Abs(value, ctx);
        }

        public T Negate(T value, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Negate(value, ctx) :
              this.simp.Negate(value, ctx);
        }

        public T Remainder(
          T thisValue,
          T divisor,
          EContext ctx,
          bool roundAfterDivide)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.Remainder(thisValue, divisor, ctx, roundAfterDivide) :
              this.simp.Remainder(thisValue, divisor, ctx, roundAfterDivide);
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.RemainderNear(thisValue, divisor, ctx) :
              this.simp.RemainderNear(thisValue, divisor, ctx);
        }

        public T Pi(EContext ctx)
        {
            return (!ctx.IsSimplified) ? this.ext.Pi(ctx) : this.simp.Pi(ctx);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.Power(
                thisValue,
                pow,
                ctx) : this.simp.Power(thisValue, pow, ctx);
        }

        public T Ln(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Ln(thisValue, ctx) :
              this.simp.Ln(thisValue, ctx);
        }

        public T Exp(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Exp(thisValue,
        ctx) : this.simp.Exp(thisValue, ctx);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.SquareRoot(
                thisValue,
                ctx) : this.simp.SquareRoot(
                thisValue,
                ctx);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.NextMinus(thisValue, ctx) : this.simp.NextMinus(
                thisValue,
                ctx);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.NextToward(thisValue, otherValue, ctx) :
              this.simp.NextToward(thisValue, otherValue, ctx);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.NextPlus(thisValue, ctx) : this.simp.NextPlus(thisValue,
        ctx);
        }

        public T DivideToExponent(
          T thisValue,
          T divisor,
          EInteger desiredExponent,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.DivideToExponent(thisValue, divisor, desiredExponent, ctx) :
              this.simp.DivideToExponent(thisValue, divisor, desiredExponent, ctx);
        }
        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.Divide(
                thisValue,
                divisor,
                ctx) : this.simp.Divide(thisValue, divisor, ctx);
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.MinMagnitude(
                a,
                b,
                ctx) : this.simp.MinMagnitude(a, b, ctx);
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.MaxMagnitude(
                a,
                b,
                ctx) : this.simp.MaxMagnitude(a, b, ctx);
        }

        public T Max(T a, T b, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Max(a, b, ctx) :
              this.simp.Max(a, b, ctx);
        }

        public T Min(T a, T b, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ? this.ext.Min(a, b, ctx) :
              this.simp.Min(a, b, ctx);
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.Multiply(thisValue, other, ctx) :
              this.simp.Multiply(thisValue, other, ctx);
        }

        public T MultiplyAndAdd(
          T thisValue,
          T multiplicand,
          T augend,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.MultiplyAndAdd(thisValue, multiplicand, augend, ctx) :
              this.simp.MultiplyAndAdd(thisValue, multiplicand, augend, ctx);
        }

        public T Plus(T thisValue, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.Plus(
                thisValue,
                ctx) : this.simp.Plus(thisValue, ctx);
        }

        public T RoundToPrecision(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.RoundToPrecision(thisValue, ctx) :
              this.simp.RoundToPrecision(thisValue, ctx);
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.RoundAfterConversion(thisValue, ctx) :
              this.simp.RoundAfterConversion(thisValue, ctx);
        }

        public T SignalOverflow(EContext ctx, bool neg)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.SignalOverflow(ctx, neg) : this.simp.SignalOverflow(ctx, neg);
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.Quantize(thisValue, otherValue, ctx) :
              this.simp.Quantize(thisValue, otherValue, ctx);
        }

        public T RoundToExponentExact(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.RoundToExponentExact(thisValue, expOther, ctx) :
              this.simp.RoundToExponentExact(thisValue, expOther, ctx);
        }

        public T RoundToExponentSimple(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.RoundToExponentSimple(thisValue, expOther, ctx) :
              this.simp.RoundToExponentSimple(thisValue, expOther, ctx);
        }

        public T RoundToExponentNoRoundedFlag(
          T thisValue,
          EInteger exponent,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.RoundToExponentNoRoundedFlag(thisValue, exponent, ctx) :
              this.simp.RoundToExponentNoRoundedFlag(thisValue, exponent, ctx);
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.Reduce(
                thisValue,
                ctx) : this.simp.Reduce(thisValue, ctx);
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.Add(
                thisValue,
                other,
                ctx) : this.simp.Add(thisValue, other, ctx);
        }

        public T AddEx(
          T thisValue,
          T other,
          EContext ctx,
          bool roundToOperandPrecision)
        {
            return (
                ctx == null || !ctx.IsSimplified) ? this.ext.AddEx(
                thisValue,
                other,
                ctx,
                roundToOperandPrecision) :
              this.simp.AddEx(thisValue, other, ctx, roundToOperandPrecision);
        }

        public T CompareToWithContext(
          T thisValue,
          T otherValue,
          bool treatQuietNansAsSignaling,
          EContext ctx)
        {
            return (ctx == null || !ctx.IsSimplified) ?
              this.ext.CompareToWithContext(
                thisValue,
                otherValue,
                treatQuietNansAsSignaling,
                ctx) : this.simp.CompareToWithContext(
                thisValue,
                otherValue,
                treatQuietNansAsSignaling,
                ctx);
        }

        public int CompareTo(T thisValue, T otherValue)
        {
            return this.ext.CompareTo(thisValue, otherValue);
        }
    }

    internal static class Extras
    {
        public static byte[] CharsConcat(
          byte[] c1,
          int offset1,
          int length1,
          byte[] c2,
          int offset2,
          int length2)
        {
            var chars = new byte[length1 + length2];
            Array.Copy(c1, offset1, chars, 0, length1);
            Array.Copy(c2, offset2, chars, length1, length2);
            return chars;
        }
        public static string CharsConcat(
          string s1,
          int offset1,
          int length1,
          string s2,
          int offset2,
          int length2)
        {
            // DebugUtility.Log(s1.Substring(offset1, length1));
            // DebugUtility.Log(s2.Substring(offset2, length2));
            return s1.Substring(offset1, length1) +
                     s2.Substring(offset2, length2);
        }

        public static char[] CharsConcat(
          char[] c1,
          int offset1,
          int length1,
          char[] c2,
          int offset2,
          int length2)
        {
            var chars = new char[length1 + length2];
            Array.Copy(c1, offset1, chars, 0, length1);
            Array.Copy(c2, offset2, chars, length1, length2);
            return chars;
        }

        public static int[] DoubleToIntegers(double dbl)
        {
            long value = BitConverter.ToInt64(
                BitConverter.GetBytes((double)dbl),
                0);
            var ret = new int[2];
            ret[0] = unchecked((int)(value & 0xffffffffL));
            ret[1] = unchecked((int)((value >> 32) & 0xffffffffL));
            return ret;
        }

        public static double IntegersToDouble(int[] integers)
        {
            // NOTE: least significant word first
            return IntegersToDouble(integers[0], integers[1]);
        }

        public static double IntegersToDouble(int lsw, int msw)
        {
            // NOTE: least significant word first
            long value = ((long)lsw) & 0xffffffffL;
            value |= (((long)msw) & 0xffffffffL) << 32;
            return BitConverter.ToDouble(BitConverter.GetBytes((long)value), 0);
        }
    }

    internal sealed class FastInteger : IComparable<FastInteger>
    {
        private sealed class MutableNumber
        {
            private int[] data;
            private int wordCount;

            internal static MutableNumber FromEInteger(EInteger bigintVal)
            {
                var mnum = new MutableNumber(0);
                if (bigintVal.Sign < 0)
                {
                    throw new ArgumentException("bigintVal's sign(" + bigintVal.Sign +
                      ") is less than " + "0 ");
                }
                byte[] bytes = bigintVal.ToBytes(true);
                int len = bytes.Length;
                int newWordCount = Math.Max(4, (len / 4) + 1);
                if (newWordCount > mnum.data.Length)
                {
                    mnum.data = new int[newWordCount];
                }
                mnum.wordCount = newWordCount;
                unchecked
                {
                    for (var i = 0; i < len; i += 4)
                    {
                        int x = ((int)bytes[i]) & 0xff;
                        if (i + 1 < len)
                        {
                            x |= (((int)bytes[i + 1]) & 0xff) << 8;
                        }
                        if (i + 2 < len)
                        {
                            x |= (((int)bytes[i + 2]) & 0xff) << 16;
                        }
                        if (i + 3 < len)
                        {
                            x |= (((int)bytes[i + 3]) & 0xff) << 24;
                        }
                        mnum.data[i >> 2] = x;
                    }
                }
                // Calculate the correct data length
                while (mnum.wordCount != 0 && mnum.data[mnum.wordCount - 1] == 0)
                {
                    --mnum.wordCount;
                }
                return mnum;
            }

            internal MutableNumber(int val)
            {
                if (val < 0)
                {
                    throw new ArgumentException("val(" + val + ") is less than " +
          "0 ");
                }
                this.data = new int[4];
                this.wordCount = (val == 0) ? 0 : 1;
                this.data[0] = val;
            }

            internal MutableNumber SetInt(int val)
            {
                if (val < 0)
                {
                    throw new ArgumentException("val(" + val + ") is less than " +
          "0 ");
                }
                this.wordCount = (val == 0) ? 0 : 1;
                this.data[0] = val;
                return this;
            }

            internal EInteger ToEInteger()
            {
                if (this.wordCount == 1 && (this.data[0] >> 31) == 0)
                {
                    return (EInteger)((int)this.data[0]);
                }
                if (this.wordCount == 2 && (this.data[1] >> 31) == 0)
                {
                    long longV = unchecked((long)this.data[0]);
                    longV &= 0xffffffffL;
                    longV |= unchecked(((long)this.data[1]) << 32);
                    return EInteger.FromInt64(longV);
                }
                return EInteger.FromInts(this.data, this.wordCount);
            }

            internal int[] GetLastWordsInternal(int numWords32Bit)
            {
                var ret = new int[numWords32Bit];
                Array.Copy(this.data, ret, Math.Min(numWords32Bit, this.wordCount));
                return ret;
            }

            internal bool CanFitInInt32()
            {
                return this.wordCount == 0 || (this.wordCount == 1 && (this.data[0] >>
                      31) == 0);
            }

            internal int ToInt32()
            {
                return this.wordCount == 0 ? 0 : this.data[0];
            }
            public static MutableNumber FromInt64(long longVal)
            {
                if (longVal < 0)
                {
                    throw new ArgumentOutOfRangeException(nameof(longVal));
                }
                if (longVal == 0)
                {
                    return new MutableNumber(0);
                }
                var mbi = new MutableNumber(0);
                mbi.data[0] = unchecked((int)longVal);
                int mbd = unchecked((int)(longVal >> 32));
                mbi.data[1] = mbd;
                mbi.wordCount = (mbd == 0) ? 1 : 2;
                return mbi;
            }

            internal MutableNumber Copy()
            {
                var mbi = new MutableNumber(0);
                if (this.wordCount > mbi.data.Length)
                {
                    mbi.data = new int[this.wordCount];
                }
                Array.Copy(this.data, mbi.data, this.wordCount);
                mbi.wordCount = this.wordCount;
                return mbi;
            }
            internal MutableNumber Multiply(int multiplicand)
            {
                if (multiplicand < 0)
                {
                    throw new ArgumentException("multiplicand(" + multiplicand +
                      ") is less than " + "0 ");
                }
                if (multiplicand != 0)
                {
                    var carry = 0;
                    if (this.wordCount == 0)
                    {
                        if (this.data.Length == 0)
                        {
                            this.data = new int[4];
                        }
                        this.data[0] = 0;
                        this.wordCount = 1;
                    }
                    int result0, result1, result2, result3;
                    if (multiplicand < 65536)
                    {
                        if (this.wordCount == 2 && (this.data[1] >> 16) == 0)
                        {
                            long longV = unchecked((long)this.data[0]);
                            longV &= 0xffffffffL;
                            longV |= unchecked(((long)this.data[1]) << 32);
                            longV = unchecked(longV * multiplicand);
                            this.data[0] = unchecked((int)longV);
                            this.data[1] = unchecked((int)(longV >> 32));
                            carry = 0;
                        }
                        else if (this.wordCount == 1)
                        {
                            long longV = unchecked((long)this.data[0]);
                            longV &= 0xffffffffL;
                            longV = unchecked(longV * multiplicand);
                            this.data[0] = unchecked((int)longV);
                            carry = unchecked((int)(longV >> 32));
                        }
                        else
                        {
                            for (var i = 0; i < this.wordCount; ++i)
                            {
                                int x0 = this.data[i];
                                int x1 = x0;
                                int y0 = multiplicand;
                                x0 &= 65535;
                                x1 = (x1 >> 16) & 65535;
                                int temp = unchecked(x0 * y0); // a * c
                                result1 = (temp >> 16) & 65535;
                                result0 = temp & 65535;
                                result2 = 0;
                                temp = unchecked(x1 * y0); // b * c
                                result2 += (temp >> 16) & 65535;
                                result1 += temp & 65535;
                                result2 += (result1 >> 16) & 65535;
                                result1 &= 65535;
                                result3 = (result2 >> 16) & 65535;
                                result2 &= 65535;
                                // Add carry
                                x0 = unchecked((int)(result0 | (result1 << 16)));
                                x1 = unchecked((int)(result2 | (result3 << 16)));
                                int x2 = unchecked(x0 + carry);
                                if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &
                                      Int32.MaxValue)) : ((x2 >> 31) == 0))
                                {
                                    // Carry in addition
                                    x1 = unchecked(x1 + 1);
                                }
                                this.data[i] = x2;
                                carry = x1;
                            }
                        }
                    }
                    else
                    {
                        if (this.wordCount == 1)
                        {
                            long longV = unchecked((long)this.data[0]);
                            longV &= 0xffffffffL;
                            longV = unchecked(longV * multiplicand);
                            this.data[0] = unchecked((int)longV);
                            carry = unchecked((int)(longV >> 32));
                        }
                        else
                        {
                            for (var i = 0; i < this.wordCount; ++i)
                            {
                                int x0 = this.data[i];
                                int x1 = x0;
                                int y0 = multiplicand;
                                int y1 = y0;
                                x0 &= 65535;
                                y0 &= 65535;
                                x1 = (x1 >> 16) & 65535;
                                y1 = (y1 >> 16) & 65535;
                                int temp = unchecked(x0 * y0); // a * c
                                result1 = (temp >> 16) & 65535;
                                result0 = temp & 65535;
                                temp = unchecked(x0 * y1); // a * d
                                result2 = (temp >> 16) & 65535;
                                result1 += temp & 65535;
                                result2 += (result1 >> 16) & 65535;
                                result1 &= 65535;
                                temp = unchecked(x1 * y0); // b * c
                                result2 += (temp >> 16) & 65535;
                                result1 += temp & 65535;
                                result2 += (result1 >> 16) & 65535;
                                result1 &= 65535;
                                result3 = (result2 >> 16) & 65535;
                                result2 &= 65535;
                                temp = unchecked(x1 * y1); // b * d
                                result3 += (temp >> 16) & 65535;
                                result2 += temp & 65535;
                                result3 += (result2 >> 16) & 65535;
                                result2 &= 65535;
                                // Add carry
                                x0 = unchecked((int)(result0 | (result1 << 16)));
                                x1 = unchecked((int)(result2 | (result3 << 16)));
                                int x2 = unchecked(x0 + carry);
                                if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &
                                      Int32.MaxValue)) : ((x2 >> 31) == 0))
                                {
                                    // Carry in addition
                                    x1 = unchecked(x1 + 1);
                                }
                                this.data[i] = x2;
                                carry = x1;
                            }
                        }
                    }
                    if (carry != 0)
                    {
                        if (this.wordCount >= this.data.Length)
                        {
                            var newdata = new int[this.wordCount + 20];
                            Array.Copy(this.data, 0, newdata, 0, this.data.Length);
                            this.data = newdata;
                        }
                        this.data[this.wordCount] = carry;
                        ++this.wordCount;
                    }
                    // Calculate the correct data length
                    while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                    {
                        --this.wordCount;
                    }
                }
                else
                {
                    if (this.data.Length > 0)
                    {
                        this.data[0] = 0;
                    }
                    this.wordCount = 0;
                }
                return this;
            }

            internal int Sign
            {
                get
                {
                    return this.wordCount == 0 ? 0 : 1;
                }
            }
            internal bool IsEvenNumber
            {
                get
                {
                    return this.wordCount == 0 || (this.data[0] & 1) == 0;
                }
            }

            internal int CompareToInt(int val)
            {
                if (val < 0 || this.wordCount > 1)
                {
                    return 1;
                }
                if (this.wordCount == 0)
                {
                    // this value is 0
                    return (val == 0) ? 0 : -1;
                }
                if (this.data[0] == val)
                {
                    return 0;
                }
                return (((this.data[0] >> 31) == (val >> 31)) ? ((this.data[0] &
                        Int32.MaxValue) < (val & Int32.MaxValue)) :
                    ((this.data[0] >> 31) == 0)) ? -1 : 1;
            }

            internal MutableNumber SubtractInt(int other)
            {
                if (other < 0)
                {
                    throw new ArgumentException("other(" + other + ") is less than " +
                      "0 ");
                }
                // NOTE: Mutable numbers are always zero or positive,
                // and this method assumes 'other' is less than or equal to this number
                // Console.WriteLine("sub1="+this.ToEInteger());
                // Console.WriteLine("sub2="+other);
                if (other != 0)
                {
                    unchecked
                    {
                        // Ensure a length of at least 1
                        if (this.wordCount == 0)
                        {
                            if (this.data.Length == 0)
                            {
                                this.data = new int[4];
                            }
                            this.data[0] = 0;
                            this.wordCount = 1;
                        }
                        int borrow;
                        int u;
                        int a = this.data[0];
                        u = a - other;
                        borrow = ((((a >> 31) == (u >> 31)) ?
                              ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :
                              ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;
                        this.data[0] = (int)u;
                        if (borrow != 0)
                        {
                            for (int i = 1; i < this.wordCount; ++i)
                            {
                                u = this.data[i] - borrow;
                                borrow = (((this.data[i] >> 31) == (u >> 31)) ?
                                    ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :
                                    ((this.data[i] >> 31) == 0)) ? 1 : 0;
                                this.data[i] = (int)u;
                            }
                        }
                        // Calculate the correct data length
                        while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                        {
                            --this.wordCount;
                        }
                    }
                }
                // Console.WriteLine("result="+this.ToEInteger());
                return this;
            }

            internal MutableNumber Subtract(MutableNumber other)
            {
                // NOTE: Mutable numbers are always zero or positive,
                // and this method assumes 'other' is less than or equal to this number
                unchecked
                {
                    {
                        // Console.WriteLine("sub1="+this.ToEInteger());
                        // Console.WriteLine("sub2="+other.ToEInteger());
                        int neededSize = (this.wordCount > other.wordCount) ?
                          this.wordCount : other.wordCount;
                        if (this.data.Length < neededSize)
                        {
                            var newdata = new int[neededSize + 20];
                            Array.Copy(this.data, 0, newdata, 0, this.data.Length);
                            this.data = newdata;
                        }
                        neededSize = (this.wordCount < other.wordCount) ? this.wordCount :
                          other.wordCount;
                        var u = 0;
                        var borrow = 0;
                        for (var i = 0; i < neededSize; ++i)
                        {
                            int a = this.data[i];
                            u = (a - other.data[i]) - borrow;
                            borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <
                                    (u & Int32.MaxValue)) :
                                  ((a >> 31) == 0)) || (a == u && other.data[i] !=
                                  0)) ? 1 : 0;
                            this.data[i] = (int)u;
                        }
                        if (borrow != 0)
                        {
                            for (int i = neededSize; i < this.wordCount; ++i)
                            {
                                int a = this.data[i];
                                int b = i >= other.wordCount ? 0 : other.data[i];
                                u = (a - b) - borrow;
                                borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <
                                        (u & Int32.MaxValue)) :
                                      ((a >> 31) == 0)) || (a == u && b != 0)) ? 1 : 0;
                                this.data[i] = (int)u;
                            }
                        }
                        // Calculate the correct data length
                        while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                        {
                            --this.wordCount;
                        }
                        // Console.WriteLine("result="+this.ToEInteger());
                        return this;
                    }
                }
            }

            public int CompareTo(MutableNumber other)
            {
                if (this.wordCount != other.wordCount)
                {
                    return (this.wordCount < other.wordCount) ? -1 : 1;
                }
                int valueN = this.wordCount;
                while (unchecked(valueN--) != 0)
                {
                    int an = this.data[valueN];
                    int bn = other.data[valueN];
                    // Unsigned less-than check
                    if (((an >> 31) == (bn >> 31)) ?
                      ((an & Int32.MaxValue) < (bn & Int32.MaxValue)) :
                      ((an >> 31) == 0))
                    {
                        return -1;
                    }
                    if (an != bn)
                    {
                        return 1;
                    }
                }
                return 0;
            }
            internal MutableNumber Add(int augend)
            {
                if (augend < 0)
                {
                    throw new ArgumentException("augend(" + augend + ") is less than " +
                      "0 ");
                }
                unchecked
                {
                    if (augend != 0)
                    {
                        var carry = 0;
                        // Ensure a length of at least 1
                        if (this.wordCount == 0)
                        {
                            if (this.data.Length == 0)
                            {
                                this.data = new int[4];
                            }
                            this.data[0] = 0;
                            this.wordCount = 1;
                        }
                        for (var i = 0; i < this.wordCount; ++i)
                        {
                            int u;
                            int a = this.data[i];
                            u = (a + augend) + carry;
                            carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &
                                      Int32.MaxValue)) :
                                  ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;
                            this.data[i] = u;
                            if (carry == 0)
                            {
                                return this;
                            }
                            augend = 0;
                        }
                        if (carry != 0)
                        {
                            if (this.wordCount >= this.data.Length)
                            {
                                var newdata = new int[this.wordCount + 20];
                                Array.Copy(this.data, 0, newdata, 0, this.data.Length);
                                this.data = newdata;
                            }
                            this.data[this.wordCount] = carry;
                            ++this.wordCount;
                        }
                    }
                    // Calculate the correct data length
                    while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0)
                    {
                        --this.wordCount;
                    }
                    return this;
                }
            }
        }

        // Hexadecimal digits
        private const string Digits = "0123456789ABCDEF";
        private int smallValue; // if integerMode is 0
        private MutableNumber mnum; // if integerMode is 1
        private EInteger largeValue; // if integerMode is 2
        private int integerMode;
        private bool frozen;

        private static readonly EInteger ValueInt32MinValue =
          (EInteger)Int32.MinValue;

        private static readonly EInteger ValueInt32MaxValue =
          (EInteger)Int32.MaxValue;

        private static readonly EInteger ValueNegativeInt32MinValue =
          -(EInteger)ValueInt32MinValue;

        internal FastInteger(int value)
        {
            this.smallValue = value;
        }

        internal FastInteger Copy()
        {
            var fi = new FastInteger(this.smallValue);
            fi.integerMode = this.integerMode;
            fi.largeValue = this.largeValue;
            fi.mnum = (this.mnum == null || this.integerMode != 1) ? null :
              this.mnum.Copy();
            return fi;
        }

        internal static FastInteger CopyFrozen(FastInteger value)
        {
            var fi = new FastInteger(value.smallValue);
            fi.integerMode = value.integerMode;
            fi.largeValue = value.largeValue;
            fi.mnum = (value.mnum == null || value.integerMode != 1) ? null :
              value.mnum.Copy();
            fi.frozen = true;
            return fi;
        }

        internal static FastInteger FromInt64(long longVal)
        {
            return (longVal >= Int32.MinValue && longVal <= Int32.MaxValue) ? new
      FastInteger((int)longVal) : FromBig(EInteger.FromInt64(longVal));
        }

        internal static FastInteger FromBig(EInteger bigintVal)
        {
            if (bigintVal.CanFitInInt32())
            {
                return new FastInteger(bigintVal.ToInt32Unchecked());
            }
            if (bigintVal.Sign > 0 && bigintVal.GetUnsignedBitLengthAsInt64() <
      2048)
            {
                // Limit bit length because of the overhead of copying
                // to a mutable number
                var fi = new FastInteger(0);
                fi.integerMode = 1;
                fi.mnum = MutableNumber.FromEInteger(bigintVal);
                return fi;
            }
            else
            {
                var fi = new FastInteger(0);
                fi.integerMode = 2;
                fi.largeValue = bigintVal;
                return fi;
            }
        }

        internal int ToInt32()
        {
            switch (this.integerMode)
            {
                case 0:
                    return this.smallValue;
                case 1:
                    return this.mnum.ToInt32();
                case 2:
                    return (int)this.largeValue;
                default: throw new InvalidOperationException();
            }
        }

        public int CompareTo(EInteger ei)
        {
            switch (this.integerMode)
            {
                case 0:
                    return -ei.CompareTo(this.smallValue);
                case 1:
                    return this.ToEInteger().CompareTo(ei);
                case 2:
                    return this.largeValue.CompareTo(ei);
                default: throw new InvalidOperationException();
            }
        }

        public int CompareTo(FastInteger val)
        {
            switch ((this.integerMode << 2) | val.integerMode)
            {
                case (0 << 2) | 0:
                    {
                        int vsv = val.smallValue;
                        return (this.smallValue == vsv) ? 0 : (this.smallValue < vsv ? -1 :
                            1);
                    }
                case (0 << 2) | 1:
                    return -val.mnum.CompareToInt(this.smallValue);
                case (0 << 2) | 2:
                    return -val.largeValue.CompareTo(this.smallValue);
                case (1 << 2) | 0:
                    return this.mnum.CompareToInt(val.smallValue);
                case (1 << 2) | 1:
                    return this.mnum.CompareTo(val.mnum);
                case (1 << 2) | 2:
                    return this.ToEInteger().CompareTo(val.largeValue);
                case (2 << 2) | 0:
                case (2 << 2) | 1:
                case (2 << 2) | 2:
                    return this.largeValue.CompareTo(val.ToEInteger());
                default: throw new InvalidOperationException();
            }
        }

        internal FastInteger Abs()
        {
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
            switch (this.integerMode)
            {
                case 0:
                    if (this.smallValue == Int32.MinValue)
                    {
                        return this.Negate();
                    }
                    this.smallValue = Math.Abs(this.smallValue);
                    return this;
                default:
                    return (this.Sign < 0) ? this.Negate() : this;
            }
        }

        internal static int[] GetLastWords(EInteger bigint, int numWords32Bit)
        {
            return MutableNumber.FromEInteger(bigint).GetLastWordsInternal(
        numWords32Bit);
        }

        internal FastInteger SetInt(int val)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            this.smallValue = val;
            this.integerMode = 0;
            return this;
        }

        /// <summary>This is an internal API.</summary>
        /// <param name='val'>The parameter <paramref name='val'/> is an
        /// internal value.</param>
        /// <returns>A FastInteger object.</returns>
        internal FastInteger Multiply(int val)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (val == 0)
            {
                this.smallValue = 0;
                this.integerMode = 0;
            }
            else
            {
                switch (this.integerMode)
                {
                    case 0:
                        {
                            long amult = ((long)val) * ((long)this.smallValue);
                            if (amult > Int32.MaxValue || amult < Int32.MinValue)
                            {
                                // would overflow, convert to large
                                bool apos = this.smallValue > 0L;
                                bool bpos = val > 0L;
                                if (apos && bpos)
                                {
                                    // if both operands are nonnegative
                                    // convert to mutable big integer
                                    this.integerMode = 1;
                                    this.mnum = MutableNumber.FromInt64(amult);
                                }
                                else
                                {
                                    // if either operand is negative
                                    // convert to big integer
                                    this.integerMode = 2;
                                    this.largeValue = EInteger.FromInt64(amult);
                                }
                            }
                            else
                            {
                                this.smallValue = unchecked((int)amult);
                            }
                            break;
                        }
                    case 1:
                        if (val < 0)
                        {
                            this.integerMode = 2;
                            this.largeValue = this.mnum.ToEInteger();
                            this.largeValue *= (EInteger)val;
                        }
                        else
                        {
                            this.mnum.Multiply(val);
                        }
                        break;
                    case 2:
                        this.largeValue *= (EInteger)val;
                        break;
                    default: throw new InvalidOperationException();
                }
            }
            return this;
        }

        /// <summary>This is an internal API.</summary>
        /// <returns>A FastInteger object.</returns>
        internal FastInteger Negate()
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            switch (this.integerMode)
            {
                case 0:
                    if (this.smallValue == Int32.MinValue)
                    {
                        // would overflow, convert to large
                        this.integerMode = 1;
                        this.mnum =
                          MutableNumber.FromEInteger(ValueNegativeInt32MinValue);
                    }
                    else
                    {
                        this.smallValue = -this.smallValue;
                    }
                    break;
                case 1:
                    this.integerMode = 2;
                    this.largeValue = this.mnum.ToEInteger();
                    this.largeValue = -(EInteger)this.largeValue;
                    break;
                case 2:
                    this.largeValue = -(EInteger)this.largeValue;
                    break;
                default:
                    throw new InvalidOperationException();
            }
            return this;
        }

        /// <summary>This is an internal API.</summary>
        /// <param name='val'>The parameter <paramref name='val'/> is an
        /// internal value.</param>
        /// <returns>A FastInteger object.</returns>
        internal FastInteger Subtract(FastInteger val)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            EInteger valValue;
            switch (this.integerMode)
            {
                case 0:
                    if (val.integerMode == 0)
                    {
                        int vsv = val.smallValue;
                        if ((vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||
                          (vsv > 0 && Int32.MinValue + vsv > this.smallValue))
                        {
                            // would overflow, convert to large
                            this.integerMode = 2;
                            this.largeValue = (EInteger)this.smallValue;
                            this.largeValue -= (EInteger)vsv;
                        }
                        else
                        {
                            this.smallValue -= vsv;
                        }
                    }
                    else
                    {
                        this.integerMode = 2;
                        this.largeValue = (EInteger)this.smallValue;
                        valValue = val.ToEInteger();
                        this.largeValue -= (EInteger)valValue;
                    }
                    break;
                case 1:
                    if (val.integerMode == 1 && this.mnum.CompareTo(val.mnum) >= 0 &&
                        val.mnum.CompareToInt(0) >= 0)
                    {
                        this.mnum.Subtract(val.mnum);
                    }
                    else if (val.integerMode == 0 && val.smallValue >= 0 &&
                      this.mnum.CompareToInt(val.smallValue) >= 0)
                    {
                        this.mnum.SubtractInt(val.smallValue);
                    }
                    else
                    {
                        this.integerMode = 2;
                        this.largeValue = this.mnum.ToEInteger();
                        valValue = val.ToEInteger();
                        this.largeValue -= (EInteger)valValue;
                    }
                    break;
                case 2:
                    valValue = val.ToEInteger();
                    this.largeValue -= (EInteger)valValue;
                    break;
                default: throw new InvalidOperationException();
            }
            return this;
        }

        /// <summary>This is an internal API.</summary>
        /// <param name='val'>The parameter <paramref name='val'/> is an
        /// internal value.</param>
        /// <returns>A FastInteger object.</returns>
        internal FastInteger SubtractInt(int val)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (val == Int32.MinValue)
            {
                return this.AddBig(ValueNegativeInt32MinValue);
            }
            if (this.integerMode == 0)
            {
                if ((val < 0 && Int32.MaxValue + val < this.smallValue) ||
                  (val > 0 && Int32.MinValue + val > this.smallValue))
                {
                    // would overflow, convert to large
                    this.integerMode = 2;
                    this.largeValue = (EInteger)this.smallValue;
                    this.largeValue -= (EInteger)val;
                }
                else
                {
                    this.smallValue -= val;
                }
                return this;
            }
            return this.AddInt(-val);
        }

        /// <summary>This is an internal API.</summary>
        /// <param name='bigintVal'>The parameter <paramref name='bigintVal'/>
        /// is an internal value.</param>
        /// <returns>A FastInteger object.</returns>
        internal FastInteger AddBig(EInteger bigintVal)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            switch (this.integerMode)
            {
                case 0:
                    {
                        return bigintVal.CanFitInInt32() ? this.AddInt((int)bigintVal) :
                          this.Add(FastInteger.FromBig(bigintVal));
                    }
                case 1:
                    this.integerMode = 2;
                    this.largeValue = this.mnum.ToEInteger();
                    this.largeValue += bigintVal;
                    break;
                case 2:
                    this.largeValue += bigintVal;
                    break;
                default:
                    throw new InvalidOperationException();
            }
            return this;
        }

        /// <summary>This is an internal API.</summary>
        /// <param name='bigintVal'>The parameter <paramref name='bigintVal'/>
        /// is an internal value.</param>
        /// <returns>A FastInteger object.</returns>
        internal FastInteger SubtractBig(EInteger bigintVal)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (this.integerMode == 2)
            {
                this.largeValue -= (EInteger)bigintVal;
                return this;
            }
            else
            {
                int sign = bigintVal.Sign;
                if (sign == 0)
                {
                    return this;
                }
                // Check if this value fits an int, except if
                // it's MinValue
                if (sign < 0 && bigintVal.CompareTo(ValueInt32MinValue) > 0)
                {
                    return this.AddInt(-((int)bigintVal));
                }
                if (sign > 0 && bigintVal.CompareTo(ValueInt32MaxValue) <= 0)
                {
                    return this.SubtractInt((int)bigintVal);
                }
                bigintVal = -bigintVal;
                return this.AddBig(bigintVal);
            }
        }

        internal FastInteger Add(FastInteger val)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            EInteger valValue;
            switch (this.integerMode)
            {
                case 0:
                    if (val.integerMode == 0)
                    {
                        if ((this.smallValue < 0 && (int)val.smallValue < Int32.MinValue
                            - this.smallValue) ||
                          (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue
                            - this.smallValue))
                        {
                            // would overflow
                            if (val.smallValue >= 0)
                            {
                                this.integerMode = 1;
                                this.mnum = new MutableNumber(this.smallValue);
                                this.mnum.Add(val.smallValue);
                            }
                            else
                            {
                                this.integerMode = 2;
                                this.largeValue = (EInteger)this.smallValue;
                                this.largeValue += (EInteger)val.smallValue;
                            }
                        }
                        else
                        {
                            this.smallValue += val.smallValue;
                        }
                    }
                    else
                    {
                        this.integerMode = 2;
                        this.largeValue = (EInteger)this.smallValue;
                        valValue = val.ToEInteger();
                        this.largeValue += (EInteger)valValue;
                    }
                    break;
                case 1:
                    if (val.integerMode == 0 && val.smallValue >= 0)
                    {
                        this.mnum.Add(val.smallValue);
                    }
                    else
                    {
                        this.integerMode = 2;
                        this.largeValue = this.mnum.ToEInteger();
                        valValue = val.ToEInteger();
                        this.largeValue += (EInteger)valValue;
                    }
                    break;
                case 2:
                    valValue = val.ToEInteger();
                    this.largeValue += (EInteger)valValue;
                    break;
                default: throw new InvalidOperationException();
            }
            return this;
        }

        internal FastInteger Remainder(int divisor)
        {
            // Mod operator will always result in a
            // number that fits an int for int divisors
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (divisor != 0)
            {
                switch (this.integerMode)
                {
                    case 0:
                        this.smallValue %= divisor;
                        break;
                    case 1:
                        this.largeValue = this.mnum.ToEInteger();
                        this.largeValue %= (EInteger)divisor;
                        this.smallValue = (int)this.largeValue;
                        this.integerMode = 0;
                        break;
                    case 2:
                        this.largeValue %= (EInteger)divisor;
                        this.smallValue = (int)this.largeValue;
                        this.integerMode = 0;
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }
            else
            {
                throw new DivideByZeroException();
            }
            return this;
        }

        internal FastInteger Increment()
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (this.integerMode == 0)
            {
                if (this.smallValue != Int32.MaxValue)
                {
                    ++this.smallValue;
                }
                else
                {
                    this.integerMode = 1;
                    this.mnum = MutableNumber.FromEInteger(ValueNegativeInt32MinValue);
                }
                return this;
            }
            return this.AddInt(1);
        }

        internal FastInteger Decrement()
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (this.integerMode == 0)
            {
                if (this.smallValue != Int32.MinValue)
                {
                    --this.smallValue;
                }
                else
                {
                    this.integerMode = 1;
                    this.mnum = MutableNumber.FromEInteger(ValueInt32MinValue);
                    this.mnum.SubtractInt(1);
                }
                return this;
            }
            return this.SubtractInt(1);
        }

        internal FastInteger Divide(int divisor)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            if (divisor != 0)
            {
                switch (this.integerMode)
                {
                    case 0:
                        if (divisor == -1 && this.smallValue == Int32.MinValue)
                        {
                            // would overflow, convert to large
                            this.integerMode = 1;
                            this.mnum =
                              MutableNumber.FromEInteger(ValueNegativeInt32MinValue);
                        }
                        else
                        {
                            this.smallValue /= divisor;
                        }
                        break;
                    case 1:
                        this.integerMode = 2;
                        this.largeValue = this.mnum.ToEInteger();
                        this.largeValue /= (EInteger)divisor;
                        if (this.largeValue.IsZero)
                        {
                            this.integerMode = 0;
                            this.smallValue = 0;
                        }
                        break;
                    case 2:
                        this.largeValue /= (EInteger)divisor;
                        if (this.largeValue.IsZero)
                        {
                            this.integerMode = 0;
                            this.smallValue = 0;
                        }
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }
            else
            {
                throw new DivideByZeroException();
            }
            return this;
        }

        internal EInteger ShiftEIntegerLeftByThis(EInteger ei)
        {
            switch (this.integerMode)
            {
                case 0:
                    return ei.ShiftLeft(this.smallValue);
                case 1:
                    return ei.ShiftLeft(this.mnum.ToEInteger());
                case 2:
                    return ei.ShiftLeft(this.largeValue);
                default: throw new InvalidOperationException();
            }
        }

        internal bool IsEvenNumber
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return (this.smallValue & 1) == 0;
                    case 1:
                        return this.mnum.IsEvenNumber;
                    case 2:
                        return this.largeValue.IsEven;
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        internal FastInteger AddInt64(long longVal)
        {
            return longVal >= Int32.MinValue && longVal <= Int32.MaxValue ?
               this.AddInt((int)longVal) : this.AddBig(EInteger.FromInt64(longVal));
        }

        internal FastInteger SubtractInt64(long longVal)
        {
            return longVal >= Int32.MinValue && longVal <= Int32.MaxValue ?
               this.SubtractInt((int)longVal) :
      this.SubtractBig(EInteger.FromInt64(longVal));
        }

        internal FastInteger AddInt(int val)
        {
#if DEBUG
            if (this.frozen)
            {
                throw new InvalidOperationException();
            }
#endif
            EInteger valValue;
            switch (this.integerMode)
            {
                case 0:
                    if ((this.smallValue < 0 && (int)val < Int32.MinValue -
                        this.smallValue) || (this.smallValue > 0 && (int)val >
                        Int32.MaxValue - this.smallValue))
                    {
                        // would overflow
                        if (val >= 0)
                        {
                            this.integerMode = 1;
                            this.mnum = new MutableNumber(this.smallValue);
                            this.mnum.Add(val);
                        }
                        else
                        {
                            this.integerMode = 2;
                            this.largeValue = (EInteger)this.smallValue;
                            this.largeValue += (EInteger)val;
                        }
                    }
                    else
                    {
                        this.smallValue += val;
                    }
                    break;
                case 1:
                    if (val >= 0)
                    {
                        this.mnum.Add(val);
                    }
                    else
                    {
                        this.integerMode = 2;
                        this.largeValue = this.mnum.ToEInteger();
                        valValue = (EInteger)val;
                        this.largeValue += (EInteger)valValue;
                    }
                    break;
                case 2:
                    valValue = (EInteger)val;
                    this.largeValue += (EInteger)valValue;
                    break;
                default: throw new InvalidOperationException();
            }
            return this;
        }

        internal bool CanFitInInt32()
        {
            switch (this.integerMode)
            {
                case 0:
                    return true;
                case 1:
                    return this.mnum.CanFitInInt32();
                case 2:
                    return this.largeValue.CanFitInInt32();
                default: throw new InvalidOperationException();
            }
        }

        internal bool CanFitInInt64()
        {
            switch (this.integerMode)
            {
                case 0:
                    return true;
                case 1:
                    return this.ToEInteger().CanFitInInt64();
                case 2:
                    return this.largeValue.CanFitInInt64();

                default: throw new InvalidOperationException();
            }
        }

        internal long ToInt64()
        {
            switch (this.integerMode)
            {
                case 0:
                    return (long)this.smallValue;
                case 1:
                    return this.ToEInteger().ToInt64Unchecked();
                case 2:
                    return this.largeValue.ToInt64Unchecked();

                default: throw new InvalidOperationException();
            }
        }

        public static string IntToString(int value)
        {
            if (value == 0)
            {
                return "0";
            }
            if (value == Int32.MinValue)
            {
                return "-2147483648";
            }
            bool neg = value < 0;
            if (neg)
            {
                value = -value;
            }
            char[] chars;
            int count;
            if (value < 100000)
            {
                if (neg)
                {
                    chars = new char[6];
                    count = 5;
                }
                else
                {
                    chars = new char[5];
                    count = 4;
                }
                while (value > 9)
                {
                    int intdivvalue = unchecked((((value >> 1) * 52429) >> 18) & 16383);
                    char digit = Digits[(int)(value - (intdivvalue * 10))];
                    chars[count--] = digit;
                    value = intdivvalue;
                }
                if (value != 0)
                {
                    chars[count--] = Digits[(int)value];
                }
                if (neg)
                {
                    chars[count] = '-';
                }
                else
                {
                    ++count;
                }
                return new String(chars, count, chars.Length - count);
            }
            chars = new char[12];
            count = 11;
            while (value >= 163840)
            {
                int intdivvalue = value / 10;
                char digit = Digits[(int)(value - (intdivvalue * 10))];
                chars[count--] = digit;
                value = intdivvalue;
            }
            while (value > 9)
            {
                int intdivvalue = unchecked((((value >> 1) * 52429) >> 18) & 16383);
                char digit = Digits[(int)(value - (intdivvalue * 10))];
                chars[count--] = digit;
                value = intdivvalue;
            }
            if (value != 0)
            {
                chars[count--] = Digits[(int)value];
            }
            if (neg)
            {
                chars[count] = '-';
            }
            else
            {
                ++count;
            }
            return new String(chars, count, 12 - count);
        }

        public static string LongToString(long longValue)
        {
            if (longValue == Int64.MinValue)
            {
                return "-9223372036854775808";
            }
            if (longValue == 0L)
            {
                return "0";
            }
            bool neg = longValue < 0;
            var count = 0;
            char[] chars;
            int intlongValue = unchecked((int)longValue);
            if ((long)intlongValue == longValue)
            {
                return IntToString(intlongValue);
            }
            else
            {
                chars = new char[24];
                count = 23;
                if (neg)
                {
                    longValue = -longValue;
                }
                while (longValue >= 163840)
                {
                    long divValue = longValue / 10;
                    char digit = Digits[(int)(longValue - (divValue * 10))];
                    chars[count--] = digit;
                    longValue = divValue;
                }
                while (longValue > 9)
                {
                    long divValue = unchecked((((longValue >> 1) * 52429) >> 18) & 16383);
                    char digit = Digits[(int)(longValue - (divValue * 10))];
                    chars[count--] = digit;
                    longValue = divValue;
                }
                if (longValue != 0)
                {
                    chars[count--] = Digits[(int)longValue];
                }
                if (neg)
                {
                    chars[count] = '-';
                }
                else
                {
                    ++count;
                }
                return new String(chars, count, 24 - count);
            }
        }

        /// <summary>This is an internal API.</summary>
        /// <returns>A text string.</returns>
        public override string ToString()
        {
            switch (this.integerMode)
            {
                case 0:
                    return IntToString(this.smallValue);
                case 1:
                    return this.mnum.ToEInteger().ToString();
                case 2:
                    return this.largeValue.ToString();
                default: return String.Empty;
            }
        }

        /// <summary>Gets an internal value.</summary>
        /// <value>An internal value.</value>
        internal int Sign
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return (this.smallValue == 0) ? 0 : ((this.smallValue < 0) ? -1 :
                            1);
                    case 1:
                        return this.mnum.Sign;
                    case 2:
                        return this.largeValue.Sign;
                    default:
                        return 0;
                }
            }
        }

        internal bool IsValueZero
        {
            get
            {
                switch (this.integerMode)
                {
                    case 0:
                        return this.smallValue == 0;
                    case 1:
                        return this.mnum.Sign == 0;
                    case 2:
                        return this.largeValue.IsZero;
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        internal int CompareToInt(int val)
        {
            switch (this.integerMode)
            {
                case 0:
                    return (val == this.smallValue) ? 0 : (this.smallValue < val ? -1 :
                        1);
                case 1:
                    return this.mnum.ToEInteger().CompareTo((EInteger)val);
                case 2:
                    return this.largeValue.CompareTo((EInteger)val);
                default: throw new InvalidOperationException();
            }
        }

        internal EInteger ToEInteger()
        {
            switch (this.integerMode)
            {
                case 0:
                    return EInteger.FromInt32(this.smallValue);
                case 1:
                    return this.mnum.ToEInteger();
                case 2:
                    return this.largeValue;
                default: throw new InvalidOperationException();
            }
        }
    }

    internal sealed class FastIntegerFixed : IComparable<FastIntegerFixed>
    {
        // NOTE: Integer modes are mutually exclusive
        private enum IntegerMode : byte
        {
            SmallValue = 0,
            LargeValue = 2,
        }
        private const int CacheFirst = -24;
        private const int CacheLast = 128;

        private readonly int smallValue; // if integerMode is 0
        private readonly EInteger largeValue; // if integerMode is 2
        private readonly IntegerMode integerMode;

        public static readonly FastIntegerFixed Zero = new FastIntegerFixed(
          IntegerMode.SmallValue,
          0,
          null);
        public static readonly FastIntegerFixed One = new FastIntegerFixed(
          IntegerMode.SmallValue,
          1,
          null);

        private static readonly FastIntegerFixed[] Cache =
    FastIntegerFixedCache(CacheFirst,
      CacheLast);

        private static FastIntegerFixed[] FastIntegerFixedCache(
          int first,
          int last)
        {
#if DEBUG
            if (first < -65535)
            {
                throw new ArgumentException("first (" + first + ") is not greater or equal" +
              "\u0020to " + (-65535));
            }
            if (first > 65535)
            {
                throw new ArgumentException("first (" + first + ") is not less or equal to" +
              "\u002065535");
            }
            if (last < -65535)
            {
                throw new ArgumentException("last (" + last + ") is not greater or equal" +
              "\u0020to -65535");
            }
            if (last > 65535)
            {
                throw new ArgumentException("last (" + last + ") is not less or equal to" +
              "65535");
            }
#endif
            FastIntegerFixed[] cache = new FastIntegerFixed[(last - first) + 1];
            for (int i = first; i <= last; ++i)
            {
                if (i == 0)
                {
                    cache[i - first] = Zero;
                }
                else if (i == 1)
                {
                    cache[i - first] = One;
                }
                else
                {
                    cache[i - first] = new FastIntegerFixed(IntegerMode.SmallValue, i, null);
                }
            }
            return cache;
        }

        private FastIntegerFixed(
          IntegerMode integerMode,
          int smallValue,
          EInteger largeValue)
        {
            this.integerMode = integerMode;
            this.smallValue = smallValue;
            this.largeValue = largeValue;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is FastIntegerFixed fi))
            {
                return false;
            }
            if (this.integerMode != fi.integerMode)
            {
                return false;
            }
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return this.smallValue == fi.smallValue;
                case IntegerMode.LargeValue:
                    return this.largeValue.Equals(fi.largeValue);
                default:
                    return true;
            }
        }

        public override int GetHashCode()
        {
            int hash = this.integerMode.GetHashCode();
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    hash = unchecked((hash * 31) + this.smallValue);
                    break;
                case IntegerMode.LargeValue:
                    hash = unchecked((hash * 31) + this.largeValue.GetHashCode());
                    break;
            }
            return hash;
        }

        internal static FastIntegerFixed FromInt32(int intVal)
        {
            return (intVal >= CacheFirst && intVal <= CacheLast) ?
            Cache[intVal - CacheFirst] :
                  new FastIntegerFixed(IntegerMode.SmallValue, intVal, null);
        }

        internal static FastIntegerFixed FromInt64(long longVal)
        {
            return (longVal >= Int32.MinValue && longVal <= Int32.MaxValue) ?
      FromInt32((int)longVal) : new FastIntegerFixed(
                IntegerMode.LargeValue,
                0,
                EInteger.FromInt64(longVal));
        }

        internal static FastIntegerFixed FromBig(EInteger bigintVal)
        {
            return bigintVal.CanFitInInt32() ?
      FromInt32(bigintVal.ToInt32Unchecked()) : new
              FastIntegerFixed(IntegerMode.LargeValue, 0, bigintVal);
        }

        internal int ToInt32()
        {
            return (this.integerMode == IntegerMode.SmallValue) ?
              this.smallValue : this.largeValue.ToInt32Unchecked();
        }

        public static FastIntegerFixed FromFastInteger(FastInteger fi)
        {
            if (fi.CanFitInInt32())
            {
                return FromInt32(fi.ToInt32());
            }
            else
            {
                return FastIntegerFixed.FromBig(fi.ToEInteger());
            }
        }

        public FastInteger ToFastInteger()
        {
            if (this.integerMode == IntegerMode.SmallValue)
            {
                return new FastInteger(this.smallValue);
            }
            else
            {
                return FastInteger.FromBig(this.largeValue);
            }
        }

        public FastIntegerFixed Increment()
        {
            if (this.integerMode == IntegerMode.SmallValue && this.smallValue != Int32.MaxValue)
            {
                return FromInt32(this.smallValue + 1);
            }
            else
            {
                return Add(this, FastIntegerFixed.One);
            }
        }

        public int Mod(int value)
        {
            if (value < 0)
            {
                throw new NotSupportedException();
            }
            if (this.integerMode == IntegerMode.SmallValue && this.smallValue >= 0)
            {
                return this.smallValue % value;
            }
            else
            {
                EInteger retval = this.ToEInteger().Remainder(EInteger.FromInt32(
          value));
                return retval.ToInt32Checked();
            }
        }

        public static FastIntegerFixed Add(FastIntegerFixed a,
          FastIntegerFixed b)
        {
            if (a.integerMode == IntegerMode.SmallValue &&
                 b.integerMode == IntegerMode.SmallValue)
            {
                if (a.smallValue == 0)
                {
                    return b;
                }
                if (b.smallValue == 0)
                {
                    return a;
                }
                if (((a.smallValue | b.smallValue) >> 30) == 0)
                {
                    return FromInt32(a.smallValue + b.smallValue);
                }
                if ((a.smallValue < 0 && b.smallValue >= Int32.MinValue -
                    a.smallValue) || (a.smallValue > 0 && b.smallValue <=
                    Int32.MaxValue - a.smallValue))
                {
                    return FromInt32(a.smallValue + b.smallValue);
                }
            }
            EInteger bigA = a.ToEInteger();
            EInteger bigB = b.ToEInteger();
            return FastIntegerFixed.FromBig(bigA.Add(bigB));
        }

        public static FastIntegerFixed Subtract(
          FastIntegerFixed a,
          FastIntegerFixed b)
        {
            if (a.integerMode == IntegerMode.SmallValue && b.integerMode == IntegerMode.SmallValue)
            {
                if (b.smallValue == 0)
                {
                    return a;
                }
                if (
                  (b.smallValue < 0 && Int32.MaxValue + b.smallValue >= a.smallValue) ||
                  (b.smallValue > 0 && Int32.MinValue + b.smallValue <=
                    a.smallValue))
                {
                    return FromInt32(a.smallValue - b.smallValue);
                }
            }
            EInteger bigA = a.ToEInteger();
            EInteger bigB = b.ToEInteger();
            return FastIntegerFixed.FromBig(bigA.Subtract(bigB));
        }

        public FastIntegerFixed Add(int ib)
        {
            FastIntegerFixed a = this;
            if (this.integerMode == IntegerMode.SmallValue)
            {
                if (ib == 0)
                {
                    return this;
                }
                if (this.smallValue == 0)
                {
                    return FromInt32(ib);
                }
                if (((a.smallValue | ib) >> 30) == 0)
                {
                    return FromInt32(a.smallValue + ib);
                }
                if ((a.smallValue < 0 && ib >= Int32.MinValue -
                    a.smallValue) || (a.smallValue > 0 && ib <=
                    Int32.MaxValue - a.smallValue))
                {
                    return FromInt32(a.smallValue + ib);
                }
            }
            EInteger bigA = a.ToEInteger();
            return FastIntegerFixed.FromBig(bigA.Add(ib));
        }

        public FastIntegerFixed Subtract(int ib)
        {
            if (ib == 0)
            {
                return this;
            }
            if (this.integerMode == IntegerMode.SmallValue)
            {
                if (
                  (ib < 0 && Int32.MaxValue + ib >= this.smallValue) ||
                  (ib > 0 && Int32.MinValue + ib <= this.smallValue))
                {
                    return FromInt32(this.smallValue - ib);
                }
            }
            EInteger bigA = this.ToEInteger();
            return FastIntegerFixed.FromBig(bigA.Subtract(ib));
        }

        public FastIntegerFixed Add(
          FastIntegerFixed b)
        {
            return Add(this, b);
        }

        public FastIntegerFixed Subtract(
          FastIntegerFixed b)
        {
            return Subtract(this, b);
        }

        public FastIntegerFixed Add(
          EInteger b)
        {
            if (this.integerMode == IntegerMode.SmallValue && b.CanFitInInt32())
            {
                return this.Add(b.ToInt32Unchecked());
            }
            else
            {
                return FastIntegerFixed.FromBig(
                   this.ToEInteger().Add(b));
            }
        }

        public FastIntegerFixed Subtract(
          EInteger b)
        {
            if (this.integerMode == IntegerMode.SmallValue && b.CanFitInInt32())
            {
                return this.Subtract(b.ToInt32Unchecked());
            }
            else
            {
                return FastIntegerFixed.FromBig(
                   this.ToEInteger().Subtract(b));
            }
        }

        public FastIntegerFixed Abs()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    if (this.smallValue == Int32.MinValue)
                    {
                        return FastIntegerFixed.FromInt32(Int32.MaxValue).Increment();
                    }
                    else if (this.smallValue < 0)
                    {
                        return FastIntegerFixed.FromInt32(-this.smallValue);
                    }
                    else
                    {
                        return this;
                    }
                case IntegerMode.LargeValue:
                    return this.largeValue.Sign < 0 ? new
                      FastIntegerFixed(IntegerMode.LargeValue, 0, this.largeValue.Abs()) :
                      this;
                default: throw new InvalidOperationException();
            }
        }

        public FastIntegerFixed Negate()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    if (this.smallValue == Int32.MinValue)
                    {
                        return FastIntegerFixed.FromInt32(Int32.MaxValue).Increment();
                    }
                    else
                    {
                        return FastIntegerFixed.FromInt32(-this.smallValue);
                    }
                case IntegerMode.LargeValue:
                    return new FastIntegerFixed(IntegerMode.LargeValue, 0, this.largeValue.Negate());
                default: throw new InvalidOperationException();
            }
        }

        public int CompareTo(EInteger evalue)
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return -evalue.CompareTo(this.smallValue);
                case IntegerMode.LargeValue:
                    return this.largeValue.CompareTo(evalue);
                default: throw new InvalidOperationException();
            }
        }

        public int CompareTo(FastInteger fint)
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return -fint.CompareToInt(this.smallValue);
                case IntegerMode.LargeValue:
                    return -fint.CompareTo(this.largeValue);
                default: throw new InvalidOperationException();
            }
        }

        public int CompareTo(FastIntegerFixed val)
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    switch (val.integerMode)
                    {
                        case IntegerMode.SmallValue:
                            int vsv = val.smallValue;
                            return (this.smallValue == vsv) ? 0 : (this.smallValue < vsv ? -1 :
                                1);
                        case IntegerMode.LargeValue:
                            return -val.largeValue.CompareTo(this.smallValue);
                    }
                    break;
                case IntegerMode.LargeValue:
                    return this.largeValue.CompareTo(val.ToEInteger());
            }
            throw new InvalidOperationException();
        }

        internal FastIntegerFixed Copy()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return FromInt32(this.smallValue);
                case IntegerMode.LargeValue:
                    return FastIntegerFixed.FromBig(this.largeValue);
                default: throw new InvalidOperationException();
            }
        }

        internal bool IsEvenNumber
        {
            get
            {
                switch (this.integerMode)
                {
                    case IntegerMode.SmallValue:
                        return (this.smallValue & 1) == 0;
                    case IntegerMode.LargeValue:
                        return this.largeValue.IsEven;
                    default:
                        throw new InvalidOperationException();
                }
            }
        }

        internal bool CanFitInInt32()
        {
            return this.integerMode == IntegerMode.SmallValue || this.largeValue.CanFitInInt32();
        }

        /// <summary>This is an internal API.</summary>
        /// <returns>A text string.</returns>
        public override string ToString()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return FastInteger.IntToString(this.smallValue);
                case IntegerMode.LargeValue:
                    return this.largeValue.ToString();
                default: return String.Empty;
            }
        }

        internal int Sign
        {
            get
            {
                switch (this.integerMode)
                {
                    case IntegerMode.SmallValue:
                        return (this.smallValue == 0) ? 0 : ((this.smallValue < 0) ? -1 :
                            1);
                    case IntegerMode.LargeValue:
                        return this.largeValue.Sign;
                    default:
                        return 0;
                }
            }
        }

        internal bool IsValueZero
        {
            get
            {
                switch (this.integerMode)
                {
                    case IntegerMode.SmallValue:
                        return this.smallValue == 0;
                    case IntegerMode.LargeValue:
                        return this.largeValue.IsZero;
                    default:
                        return false;
                }
            }
        }

        internal bool CanFitInInt64()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return true;
                case IntegerMode.LargeValue:
                    return this.largeValue
                      .CanFitInInt64();
                default: throw new InvalidOperationException();
            }
        }

        internal long ToInt64()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return (long)this.smallValue;
                case IntegerMode.LargeValue:
                    return this.largeValue
                      .ToInt64Unchecked();
                default: throw new InvalidOperationException();
            }
        }

        internal int CompareToInt64(long valLong)
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return (valLong == this.smallValue) ? 0 : (this.smallValue <
          valLong ? -1 :
                        1);
                case IntegerMode.LargeValue:
                    return this.largeValue.CompareTo(valLong);
                default: return 0;
            }
        }

        internal int CompareToInt(int val)
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return (val == this.smallValue) ? 0 : (this.smallValue < val ? -1 :
                        1);
                case IntegerMode.LargeValue:
                    return this.largeValue.CompareTo((EInteger)val);
                default: return 0;
            }
        }

        internal EInteger ToEInteger()
        {
            switch (this.integerMode)
            {
                case IntegerMode.SmallValue:
                    return EInteger.FromInt32(this.smallValue);
                case IntegerMode.LargeValue:
                    return this.largeValue;
                default: throw new InvalidOperationException();
            }
        }
    }

    internal interface IRadixMath<T>
    {
        IRadixMathHelper<T> GetHelper();

        T DivideToIntegerNaturalScale(T thisValue, T divisor, EContext ctx);

        T DivideToIntegerZeroScale(T thisValue, T divisor, EContext ctx);

        T Abs(T value, EContext ctx);

        T Negate(T value, EContext ctx);

        T Remainder(T thisValue, T divisor, EContext ctx, bool roundAfterDivide);

        T RemainderNear(T thisValue, T divisor, EContext ctx);

        T Pi(EContext ctx);

        T Power(T thisValue, T pow, EContext ctx);

        T Ln(T thisValue, EContext ctx);

        T Exp(T thisValue, EContext ctx);

        T SquareRoot(T thisValue, EContext ctx);

        T NextMinus(T thisValue, EContext ctx);

        T NextToward(T thisValue, T otherValue, EContext ctx);

        T NextPlus(T thisValue, EContext ctx);

        T DivideToExponent(
          T thisValue,
          T divisor,
          EInteger desiredExponent,
          EContext ctx);

        T Divide(T thisValue, T divisor, EContext ctx);

        T MinMagnitude(T a, T b, EContext ctx);

        T MaxMagnitude(T a, T b, EContext ctx);

        T Max(T a, T b, EContext ctx);

        T Min(T a, T b, EContext ctx);

        T Multiply(T thisValue, T other, EContext ctx);

        T MultiplyAndAdd(
          T thisValue,
          T multiplicand,
          T augend,
          EContext ctx);

        T Plus(T thisValue, EContext ctx);

        T RoundToPrecision(T thisValue, EContext ctx);

        T RoundAfterConversion(T thisValue, EContext ctx);

        T SignalOverflow(EContext ctx, bool neg);

        T Quantize(T thisValue, T otherValue, EContext ctx);

        T RoundToExponentExact(
          T thisValue,
          EInteger expOther,
          EContext ctx);

        T RoundToExponentSimple(
          T thisValue,
          EInteger expOther,
          EContext ctx);

        T RoundToExponentNoRoundedFlag(
          T thisValue,
          EInteger exponent,
          EContext ctx);

        T Reduce(T thisValue, EContext ctx);

        T Add(T thisValue, T other, EContext ctx);

        T AddEx(
          T thisValue,
          T other,
          EContext ctx,
          bool roundToOperandPrecision);

        T CompareToWithContext(
          T thisValue,
          T otherValue,
          bool treatQuietNansAsSignaling,
          EContext ctx);

        int CompareTo(T thisValue, T otherValue);
    }

    internal interface IRadixMathHelper<T>
    {
        int GetRadix();

        int GetArithmeticSupport();

        int GetSign(T value);

        int GetFlags(T value);

        EInteger GetMantissa(T value);

        EInteger GetExponent(T value);

        FastIntegerFixed GetMantissaFastInt(T value);

        FastIntegerFixed GetExponentFastInt(T value);

        T ValueOf(int val);

        T CreateNewWithFlags(EInteger mantissa, EInteger exponent, int flags);

        T CreateNewWithFlagsFastInt(
          FastIntegerFixed mantissa,
          FastIntegerFixed exponent,
          int flags);

        IShiftAccumulator CreateShiftAccumulatorWithDigits(
          EInteger value,
          int lastDigit,
          int olderDigits);

        IShiftAccumulator CreateShiftAccumulatorWithDigitsFastInt(
          FastIntegerFixed value,
          int lastDigit,
          int olderDigits);

        FastInteger DivisionShift(EInteger num, EInteger den);

        FastInteger GetDigitLength(EInteger ei);

        EInteger MultiplyByRadixPower(EInteger value, FastInteger power);

        FastIntegerFixed MultiplyByRadixPowerFastInt(
          FastIntegerFixed value,
          FastIntegerFixed power);
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.IShiftAccumulator"]/*'/>
    internal interface IShiftAccumulator
    {
        EInteger ShiftedInt
        {
            get;
        }

        FastInteger GetDigitLength();

        FastInteger OverestimateDigitLength();

        int OlderDiscardedDigits
        {
            get;
        }

        int LastDiscardedDigit
        {
            get;
        }

        FastInteger ShiftedIntFast
        {
            get;
        }

        FastInteger DiscardedDigitCount
        {
            get;
        }

        void TruncateOrShiftRight(FastInteger bits, bool truncate);

        int ShiftedIntMod(int mod);

        void ShiftRightInt(int bits);

        void ShiftToDigits(FastInteger bits, FastInteger preShift, bool truncate);
    }

    internal static class NumberUtility
    {
        private static readonly EInteger[] ValueBigIntPowersOfTen = {
      EInteger.One, (EInteger)10, (EInteger)100, (EInteger)1000,
      (EInteger)10000, (EInteger)100000, (EInteger)1000000,
      (EInteger)10000000, (EInteger)100000000, (EInteger)1000000000,
      (EInteger)10000000000L, (EInteger)100000000000L,
      (EInteger)1000000000000L, (EInteger)10000000000000L,
      (EInteger)100000000000000L, (EInteger)1000000000000000L,
      (EInteger)10000000000000000L,
      (EInteger)100000000000000000L, (EInteger)1000000000000000000L,
    };

        private static readonly EInteger[] ValueBigIntPowersOfFive = {
      EInteger.One, (EInteger)5, (EInteger)25, (EInteger)125,
      (EInteger)625, (EInteger)3125, (EInteger)15625,
      (EInteger)78125, (EInteger)390625,
      (EInteger)1953125, (EInteger)9765625, (EInteger)48828125,
      (EInteger)244140625, (EInteger)1220703125,
      (EInteger)6103515625L, (EInteger)30517578125L,
      (EInteger)152587890625L, (EInteger)762939453125L,
      (EInteger)3814697265625L, (EInteger)19073486328125L,
      (EInteger)95367431640625L,
      (EInteger)476837158203125L, (EInteger)2384185791015625L,
      (EInteger)11920928955078125L,
      (EInteger)59604644775390625L, (EInteger)298023223876953125L,
      (EInteger)1490116119384765625L, (EInteger)7450580596923828125L,
    };

        internal static int ShiftLeftOne(int[] arr)
        {
            unchecked
            {
                var carry = 0;
                for (var i = 0; i < arr.Length; ++i)
                {
                    int item = arr[i];
                    arr[i] = (int)(arr[i] << 1) | (int)carry;
                    carry = ((item >> 31) != 0) ? 1 : 0;
                }
                return carry;
            }
        }

        private static int CountTrailingZeros(int numberValue)
        {
            if (numberValue == 0)
            {
                return 32;
            }
            var i = 0;
            unchecked
            {
                if ((numberValue << 16) == 0)
                {
                    numberValue >>= 16;
                    i += 16;
                }
                if ((numberValue << 24) == 0)
                {
                    numberValue >>= 8;
                    i += 8;
                }
                if ((numberValue << 28) == 0)
                {
                    numberValue >>= 4;
                    i += 4;
                }
                if ((numberValue << 30) == 0)
                {
                    numberValue >>= 2;
                    i += 2;
                }
                if ((numberValue << 31) == 0)
                {
                    ++i;
                }
            }
            return i;
        }

        internal static int BitLength(int numberValue)
        {
            if (numberValue == 0)
            {
                return 0;
            }
            var i = 32;
            unchecked
            {
                if ((numberValue >> 16) == 0)
                {
                    numberValue <<= 16;
                    i -= 16;
                }
                if ((numberValue >> 24) == 0)
                {
                    numberValue <<= 8;
                    i -= 8;
                }
                if ((numberValue >> 28) == 0)
                {
                    numberValue <<= 4;
                    i -= 4;
                }
                if ((numberValue >> 30) == 0)
                {
                    numberValue <<= 2;
                    i -= 2;
                }
                if ((numberValue >> 31) == 0)
                {
                    --i;
                }
            }
            return i;
        }

        internal static int ShiftAwayTrailingZerosTwoElements(int[] arr)
        {
            int a0 = arr[0];
            int a1 = arr[1];
            int tz = CountTrailingZeros(a0);
            if (tz == 0)
            {
                return 0;
            }
            unchecked
            {
                if (tz < 32)
                {
                    int carry = a1 << (32 - tz);
                    arr[0] = (int)((a0 >> tz) & (0x7fffffff >> (tz - 1))) | (int)carry;
                    arr[1] = (a1 >> tz) & (0x7fffffff >> (tz - 1));
                    return tz;
                }
                tz = CountTrailingZeros(a1);
                if (tz == 32)
                {
                    arr[0] = 0;
                }
                else if (tz > 0)
                {
                    arr[0] = (a1 >> tz) & (0x7fffffff >> (tz - 1));
                }
                else
                {
                    arr[0] = a1;
                }
                arr[1] = 0;
                return 32 + tz;
            }
        }

        internal static bool HasBitSet(int[] arr, int bit)
        {
            return (bit >> 5) < arr.Length && (arr[bit >> 5] & (1 << (bit & 31))) !=
              0;
        }

        private sealed class PowerCache
        {
            private const int MaxSize = 128;
            private readonly EInteger[] outputs;
            private readonly EInteger[] inputs;
            private readonly int[] inputsInts;

            public PowerCache()
            {
                this.outputs = new EInteger[MaxSize];
                this.inputs = new EInteger[MaxSize];
                this.inputsInts = new int[MaxSize];
            }

            private int size;

            public EInteger[] FindCachedPowerOrSmaller(EInteger bi)
            {
                EInteger[] ret = null;
                EInteger minValue = null;
                if (bi.CanFitInInt32())
                {
                    return this.FindCachedPowerIntOrSmaller(bi.ToInt32Checked());
                }
                lock (this.outputs)
                {
                    for (var i = 0; i < this.size; ++i)
                    {
                        if (this.inputs[i].CompareTo(bi) <= 0 && (minValue == null ||
                            this.inputs[i].CompareTo(minValue) >= 0))
                        {
                            // DebugUtility.Log("Have cached power (" + inputs[i] + "," + bi + ") ");
                            ret = new EInteger[2];
                            ret[0] = this.inputs[i];
                            ret[1] = this.outputs[i];
                            minValue = this.inputs[i];
                        }
                    }
                }
                return ret;
            }

            public EInteger[] FindCachedPowerIntOrSmaller(int precision)
            {
                EInteger[] ret = null;
                var integerMinValue = -1;
                lock (this.outputs)
                {
                    for (var i = 0; i < this.size; ++i)
                    {
                        if (this.inputsInts[i] >= 0 &&
                          this.inputsInts[i] <= precision && (integerMinValue == -1 ||
                            this.inputsInts[i] >= integerMinValue))
                        {
                            // DebugUtility.Log("Have cached power (" + inputs[i] + "," + bi + ") ");
                            ret = new EInteger[2];
                            ret[0] = this.inputs[i];
                            ret[1] = this.outputs[i];
                            integerMinValue = this.inputsInts[i];
                        }
                    }
                }
                return ret;
            }

            public EInteger GetCachedPower(EInteger bi)
            {
                if (bi.CanFitInInt32())
                {
                    return this.GetCachedPowerInt(bi.ToInt32Checked());
                }
                lock (this.outputs)
                {
                    for (var i = 0; i < this.size; ++i)
                    {
                        if (bi.Equals(this.inputs[i]))
                        {
                            if (i != 0)
                            {
                                EInteger tmp;
                                // Move to head of cache if it isn't already
                                tmp = this.inputs[i];
                                this.inputs[i] = this.inputs[0];
                                this.inputs[0] = tmp;
                                int tmpi = this.inputsInts[i];
                                this.inputsInts[i] = this.inputsInts[0];
                                this.inputsInts[0] = tmpi;
                                tmp = this.outputs[i];
                                this.outputs[i] = this.outputs[0];
                                this.outputs[0] = tmp;
                                // Move formerly newest to next newest
                                if (i != 1)
                                {
                                    tmp = this.inputs[i];
                                    this.inputs[i] = this.inputs[1];
                                    this.inputs[1] = tmp;
                                    tmpi = this.inputsInts[i];
                                    this.inputsInts[i] =
                                      this.inputsInts[1];
                                    this.inputsInts[1] = tmpi;
                                    tmp = this.outputs[i];
                                    this.outputs[i] = this.outputs[1];
                                    this.outputs[1] = tmp;
                                }
                            }
                            return this.outputs[0];
                        }
                    }
                }
                return null;
            }

            public EInteger GetCachedPowerInt(int ibi)
            {
                lock (this.outputs)
                {
                    if (ibi > 0 && this.size < 64)
                    {
                        for (var i = 0; i < this.size; ++i)
                        {
                            if (this.inputsInts[i] == ibi)
                            {
                                return this.outputs[i];
                            }
                        }
                        return null;
                    }
                    for (var i = 0; i < this.size; ++i)
                    {
                        if (this.inputsInts[i] >= 0 && this.inputsInts[i] == ibi)
                        {
                            if (i != 0)
                            {
                                EInteger tmp;
                                // Move to head of cache if it isn't already
                                tmp = this.inputs[i];
                                this.inputs[i] = this.inputs[0];
                                this.inputs[0] = tmp;
                                int tmpi = this.inputsInts[i];
                                this.inputsInts[i] = this.inputsInts[0];
                                this.inputsInts[0] = tmpi;
                                tmp = this.outputs[i];
                                this.outputs[i] = this.outputs[0];
                                this.outputs[0] = tmp;
                                // Move formerly newest to next newest
                                if (i != 1)
                                {
                                    tmp = this.inputs[i];
                                    this.inputs[i] = this.inputs[1];
                                    this.inputs[1] = tmp;
                                    tmpi = this.inputsInts[i];
                                    this.inputsInts[i] =
                                      this.inputsInts[1];
                                    this.inputsInts[1] = tmpi;
                                    tmp = this.outputs[i];
                                    this.outputs[i] = this.outputs[1];
                                    this.outputs[1] = tmp;
                                }
                            }
                            return this.outputs[0];
                        }
                    }
                }
                return null;
            }

            public void AddPower(int input, EInteger output)
            {
                this.AddPower(EInteger.FromInt32(input), output);
            }
            public void AddPower(EInteger input, EInteger output)
            {
                lock (this.outputs)
                {
                    if (this.size < MaxSize)
                    {
                        // Shift newer entries down
                        for (int i = this.size; i > 0; --i)
                        {
                            this.inputs[i] = this.inputs[i - 1];
                            this.inputsInts[i] = this.inputsInts[i - 1];
                            this.outputs[i] = this.outputs[i - 1];
                        }
                        this.inputs[0] = input;
                        this.inputsInts[0] = input.CanFitInInt32() ?
                          input.ToInt32Checked() : -1;
                        this.outputs[0] = output;
                        ++this.size;
                    }
                    else
                    {
                        // Shift newer entries down
                        for (int i = MaxSize - 1; i > 0; --i)
                        {
                            this.inputs[i] = this.inputs[i - 1];
                            this.inputsInts[i] = this.inputsInts[i - 1];
                            this.outputs[i] = this.outputs[i - 1];
                        }
                        this.inputs[0] = input;
                        this.inputsInts[0] = input.CanFitInInt32() ?
                          input.ToInt32Checked() : -1;
                        this.outputs[0] = output;
                    }
                }
            }
        }

        private static readonly PowerCache ValuePowerOfFiveCache = new
        NumberUtility.PowerCache();

        private static readonly PowerCache ValuePowerOfTenCache = new
        NumberUtility.PowerCache();

        public static EInteger FindPowerOfTen(long diffLong)
        {
            if (diffLong < 0)
            {
                return EInteger.Zero;
            }
            if (diffLong == 0)
            {
                return EInteger.One;
            }
            return (diffLong <= Int32.MaxValue) ? FindPowerOfTen((int)diffLong) :
              FindPowerOfTenFromBig(EInteger.FromInt64(diffLong));
        }

        internal static EInteger MultiplyByPowerOfTen(EInteger v, int precision)
        {
            if (precision < 0 || v.IsZero)
            {
                return EInteger.Zero;
            }
            if (precision < ValueBigIntPowersOfTen.Length)
            {
                return v.Multiply(ValueBigIntPowersOfTen[precision]);
            }
            return (precision <= 94) ?
      v.Multiply(FindPowerOfFive(precision)).ShiftLeft(precision) :
      MultiplyByPowerOfFive(v, precision).ShiftLeft(precision);
        }

        internal static EInteger MultiplyByPowerOfTen(EInteger v, EInteger
    eprecision)
        {
            return (eprecision.Sign < 0 || v.IsZero) ? EInteger.Zero :
      MultiplyByPowerOfFive(v, eprecision).ShiftLeft(eprecision);
        }

        internal static EInteger MultiplyByPowerOfFive(EInteger v, int precision)
        {
            if (precision < 0 || v.IsZero)
            {
                return EInteger.Zero;
            }
            if (precision <= 94)
            {
                return v.Multiply(FindPowerOfFive(precision));
            }
            EInteger otherPower = ValuePowerOfFiveCache.GetCachedPowerInt(precision);
            if (otherPower != null)
            {
                return v.Multiply(otherPower);
            }
            var powprec = 64;
            v = v.Multiply(FindPowerOfFive(precision & 63));
            precision >>= 6;
            while (precision > 0)
            {
                if ((precision & 1) == 1)
                {
                    otherPower = ValuePowerOfFiveCache.GetCachedPowerInt(powprec);
                    if (otherPower == null)
                    {
                        // NOTE: Assumes powprec is 2 or greater and is a power of 2
                        EInteger prevPower = FindPowerOfFive(powprec >> 1);
                        otherPower = prevPower.Multiply(prevPower);
                        ValuePowerOfFiveCache.AddPower(powprec, otherPower);
                    }
                    v = v.Multiply(otherPower);
                }
                powprec = unchecked(powprec << 1);
                precision >>= 1;
            }
            return v;
        }

        internal static EInteger MultiplyByPowerOfFive(EInteger v, EInteger
          epower)
        {
            return epower.CanFitInInt32() ? MultiplyByPowerOfFive(v,
                epower.ToInt32Checked()) : v.Multiply(FindPowerOfFiveFromBig(
                  epower));
        }
        internal static EInteger FindPowerOfFiveFromBig(EInteger diff)
        {
            int sign = diff.Sign;
            if (sign < 0)
            {
                return EInteger.Zero;
            }
            if (sign == 0)
            {
                return EInteger.One;
            }
            if (diff.CanFitInInt32())
            {
                return FindPowerOfFive(diff.ToInt32Checked());
            }
            EInteger epowprec = EInteger.One;
            EInteger ret = EInteger.One;
            while (diff.Sign > 0)
            {
                if (!diff.IsEven)
                {
                    EInteger otherPower = ValuePowerOfFiveCache.GetCachedPower(epowprec);
                    if (otherPower == null)
                    {
                        // NOTE: Assumes powprec is 2 or greater and is a power of 2
                        EInteger prevPower = FindPowerOfFiveFromBig(epowprec.ShiftRight(
                              1));
                        otherPower = prevPower.Multiply(prevPower);
                        ValuePowerOfFiveCache.AddPower(epowprec, otherPower);
                    }
                    ret = ret.Multiply(otherPower);
                }
                epowprec = epowprec.ShiftLeft(1);
                diff = diff.ShiftRight(1);
            }
            return ret;
        }

        internal static EInteger FindPowerOfTenFromBig(EInteger
          bigintExponent)
        {
            int sign = bigintExponent.Sign;
            if (sign < 0)
            {
                return EInteger.Zero;
            }
            if (sign == 0)
            {
                return EInteger.One;
            }
            return bigintExponent.CanFitInInt32() ?
              FindPowerOfTen(bigintExponent.ToInt32Checked()) :
              FindPowerOfFiveFromBig(bigintExponent).ShiftLeft(bigintExponent);
        }

        private static readonly EInteger ValueFivePower40 =
          ((EInteger)95367431640625L) * (EInteger)95367431640625L;

        internal static EInteger FindPowerOfFive(int precision)
        {
            if (precision < 0)
            {
                return EInteger.Zero;
            }
            if (precision <= 27)
            {
                return ValueBigIntPowersOfFive[(int)precision];
            }
            EInteger bigpow;
            EInteger ret;
            if (precision == 40)
            {
                return ValueFivePower40;
            }
            int startPrecision = precision;
            bigpow = ValuePowerOfFiveCache.GetCachedPowerInt(precision);
            if (bigpow != null)
            {
                return bigpow;
            }
            var origPrecision = (EInteger)precision;
            // DebugUtility.Log("Getting power of five "+precision);
            if (precision <= 54)
            {
                if ((precision & 1) == 0)
                {
                    ret = ValueBigIntPowersOfFive[(int)(precision >> 1)];
                    ret *= (EInteger)ret;
                    ValuePowerOfFiveCache.AddPower(origPrecision, ret);
                    return ret;
                }
                ret = ValueBigIntPowersOfFive[27];
                bigpow = ValueBigIntPowersOfFive[((int)precision) - 27];
                ret *= (EInteger)bigpow;
                ValuePowerOfFiveCache.AddPower(origPrecision, ret);
                return ret;
            }
            else if (precision <= 94)
            {
                ret = ValueFivePower40;
                bigpow = FindPowerOfFive(precision - 40);
                ret *= (EInteger)bigpow;
                ValuePowerOfFiveCache.AddPower(origPrecision, ret);
                return ret;
            }
            var powprec = 64;
            // Console.WriteLine("pow="+(precision&63)+",precision="+precision);
            ret = FindPowerOfFive(precision & 63);
            precision >>= 6;
            while (precision > 0)
            {
                if ((precision & 1) == 1)
                {
                    EInteger otherPower =
                      ValuePowerOfFiveCache.GetCachedPowerInt(powprec);
                    // Console.WriteLine("pow="+powprec+",precision="+precision);
                    if (otherPower == null)
                    {
                        // NOTE: Assumes powprec is 2 or greater and is a power of 2
                        EInteger prevPower = FindPowerOfFive(powprec >> 1);
                        otherPower = prevPower.Multiply(prevPower);
                        ValuePowerOfFiveCache.AddPower(powprec, otherPower);
                    }
                    ret = ret.Multiply(otherPower);
                }
                powprec = unchecked(powprec << 1);
                precision >>= 1;
            }
            return ret;
        }

        internal static EInteger FindPowerOfTen(int precision)
        {
            if (precision < 0)
            {
                return EInteger.Zero;
            }
            if (precision <= 18)
            {
                return ValueBigIntPowersOfTen[(int)precision];
            }
            EInteger bigpow;
            EInteger ret;
            int startPrecision = precision;
            bigpow = ValuePowerOfTenCache.GetCachedPowerInt(precision);
            if (bigpow != null)
            {
                return bigpow;
            }
            // Console.WriteLine("power="+precision);
            if (precision <= 27)
            {
                ret = ValueBigIntPowersOfFive[precision];
                ret <<= precision;
                ValuePowerOfTenCache.AddPower(precision, ret);
                return ret;
            }
            else if (precision <= 36)
            {
                if ((precision & 1) == 0)
                {
                    ret = ValueBigIntPowersOfTen[(int)(precision >> 1)];
                    ret *= (EInteger)ret;
                    ValuePowerOfTenCache.AddPower(precision, ret);
                    return ret;
                }
                ret = ValueBigIntPowersOfTen[18];
                bigpow = ValueBigIntPowersOfTen[((int)precision) - 18];
                ret *= (EInteger)bigpow;
                ValuePowerOfTenCache.AddPower(precision, ret);
                return ret;
            }
            return FindPowerOfFive(precision).ShiftLeft(precision);
        }

        public static int BitLength(long mantlong)
        {
#if DEBUG
            if (mantlong < 0)
            {
                throw new ArgumentException("mantlong (" + mantlong +
                  ") is not greater or equal" + "\u0020to 0");
            }
#endif
            if (mantlong == 0)
            {
                return 1;
            }
            var wcextra = 64;
            if ((mantlong >> 32) == 0)
            {
                mantlong <<= 32;
                wcextra -= 32;
            }
            if ((mantlong >> 48) == 0)
            {
                mantlong <<= 16;
                wcextra -= 16;
            }
            if ((mantlong >> 56) == 0)
            {
                mantlong <<= 8;
                wcextra -= 8;
            }
            if ((mantlong >> 60) == 0)
            {
                mantlong <<= 4;
                wcextra -= 4;
            }
            if ((mantlong >> 62) == 0)
            {
                mantlong <<= 2;
                wcextra -= 2;
            }
            return ((mantlong >> 63) == 0) ? wcextra - 1 : wcextra;
        }

        public static THelper PreRound<THelper>(
          THelper val,
          EContext ctx,
          IRadixMath<THelper> wrapper)
        {
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return val;
            }
            IRadixMathHelper<THelper> helper = wrapper.GetHelper();
            int thisFlags = helper.GetFlags(val);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                // Infinity or NaN
                return val;
            }
            FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
            EInteger mant = helper.GetMantissa(val).Abs();
            // Rounding is only to be done if the digit count is
            // too big (distinguishing this case is material
            // if the value also has an exponent that's out of range)
            FastInteger[] digitBounds = NumberUtility.DigitLengthBounds(
                helper,
                mant);
            if (digitBounds[1].CompareTo(fastPrecision) <= 0)
            {
                // Upper bound is less than or equal to precision
                return val;
            }
            EContext ctx2 = ctx;
            if (digitBounds[0].CompareTo(fastPrecision) <= 0)
            {
                // Lower bound is less than or equal to precision, so
                // calculate digit length more precisely
                FastInteger digits = helper.GetDigitLength(mant);
                ctx2 = ctx.WithBlankFlags().WithTraps(0);
                if (digits.CompareTo(fastPrecision) <= 0)
                {
                    return val;
                }
            }
            val = wrapper.RoundToPrecision(val, ctx2);
            // the only time rounding can signal an invalid
            // operation is if an operand is a signaling NaN, but
            // this was already checked beforehand
#if DEBUG
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                throw new ArgumentException("doesn't" +
                  "\u0020satisfy(ctx2.Flags&FlagInvalid)==0");
            }
#endif
            if ((ctx2.Flags & EContext.FlagInexact) != 0)
            {
                if (ctx.HasFlags)
                {
                    ctx.Flags |= BigNumberFlags.LostDigitsFlags;
                }
            }
            if ((ctx2.Flags & EContext.FlagRounded) != 0)
            {
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagRounded;
                }
            }
            if ((ctx2.Flags & EContext.FlagOverflow) != 0)
            {
                bool neg = (thisFlags & BigNumberFlags.FlagNegative) != 0;
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagLostDigits;
                    ctx.Flags |= EContext.FlagOverflow |
                      EContext.FlagInexact | EContext.FlagRounded;
                }
            }
            return val;
        }

        public static int DecimalDigitLength(int v2)
        {
#if DEBUG
            if (!(v2 >= 0))
            {
                throw new ArgumentException("doesn't satisfy v2 >= 0");
            }
#endif
            if (v2 < 100000)
            {
                return (v2 >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ?
                      3 : ((v2 >= 10) ? 2 : 1)));
            }
            else
            {
                return (v2 >= 1000000000) ? 10 : ((v2 >= 100000000) ? 9 : ((v2 >=
                        10000000) ? 8 : ((v2 >= 1000000) ? 7 : 6)));
            }
        }

        public static int DecimalDigitLength(long value)
        {
#if DEBUG
            if (!(value >= 0))
            {
                throw new ArgumentException("doesn't satisfy value>= 0");
            }
#endif
            if (value >= 1000000000L)
            {
                return (value >= 1000000000000000000L) ? 19 : ((value >=
                      100000000000000000L) ? 18 : ((value >= 10000000000000000L) ?
                      17 : ((value >= 1000000000000000L) ? 16 :
                        ((value >= 100000000000000L) ? 15 : ((value
                              >= 10000000000000L) ?
                            14 : ((value >= 1000000000000L) ? 13 : ((value
                                  >= 100000000000L) ? 12 : ((value >= 10000000000L) ?
                                  11 : ((value >= 1000000000L) ? 10 : 9)))))))));
            }
            else
            {
                var v2 = (int)value;
                return (v2 >= 100000000) ? 9 : ((v2 >= 10000000) ? 8 : ((v2 >=
                        1000000) ? 7 : ((v2 >= 100000) ? 6 : ((v2
                            >= 10000) ? 5 : ((v2 >= 1000) ? 4 : ((v2 >= 100) ?
                              3 : ((v2 >= 10) ? 2 : 1)))))));
            }
        }

        public static EInteger[] DecimalDigitLengthBoundsAsEI(EInteger ei)
        {
            long longBitLength = ei.GetUnsignedBitLengthAsInt64();
            if (longBitLength < 33)
            {
                // Can easily be calculated without estimation
                EInteger eintcnt = EInteger.FromInt32((int)ei.GetDigitCountAsInt64());
                return new EInteger[] { eintcnt, eintcnt };
            }
            else if (longBitLength <= 2135)
            {
                var bitlen = (int)longBitLength;
                // Approximation of ln(2)/ln(10)
                int minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                int maxDigits = 1 + ((bitlen * 631305) >> 21);
                if (minDigits == maxDigits)
                {
                    EInteger eintcnt = EInteger.FromInt32(minDigits);
                    return new EInteger[] { eintcnt, eintcnt };
                }
                else
                {
                    return new EInteger[] {
              EInteger.FromInt32(minDigits), // lower bound
              EInteger.FromInt32(maxDigits), // upper bound
            };
                }
            }
            else if (longBitLength <= 6432162)
            {
                var bitlen = (int)longBitLength;
                // Approximation of ln(2)/ln(10)
                int minDigits = 1 + (int)(((long)(bitlen - 1) * 661971961083L) >> 41);
                int maxDigits = 1 + (int)(((long)bitlen * 661971961083L) >> 41);
                if (minDigits == maxDigits)
                {
                    EInteger eintcnt = EInteger.FromInt32(minDigits);
                    return new EInteger[] { eintcnt, eintcnt };
                }
                else
                {
                    return new EInteger[] {
              EInteger.FromInt32(minDigits), // lower bound
              EInteger.FromInt32(maxDigits), // upper bound
            };
                }
            }
            else
            {
                FastInteger[] fis = DecimalDigitLengthBounds(ei);
                return new EInteger[] { fis[0].ToEInteger(), fis[1].ToEInteger() };
            }
        }

        public static FastInteger[] DecimalDigitLengthBounds(EInteger ei)
        {
            long longBitLength = ei.GetUnsignedBitLengthAsInt64();
            if (longBitLength < 33)
            {
                // Can easily be calculated without estimation
                var fi = new FastInteger((int)ei.GetDigitCountAsInt64());
                return new FastInteger[] { fi, fi };
            }
            else if (longBitLength <= 2135)
            {
                var bitlen = (int)longBitLength;
                int minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                int maxDigits = 1 + ((bitlen * 631305) >> 21);
                if (minDigits == maxDigits)
                {
                    var fi = new FastInteger(minDigits);
                    return new FastInteger[] { fi, fi };
                }
                else
                {
                    return new FastInteger[] {
              new FastInteger(minDigits), // lower bound
              new FastInteger(maxDigits), // upper bound
            };
                }
            }
            else if (longBitLength <= 6432162)
            {
                var bitlen = (int)longBitLength;
                // Approximation of ln(2)/ln(10)
                int minDigits = 1 + (int)(((long)(bitlen - 1) * 661971961083L) >> 41);
                int maxDigits = 1 + (int)(((long)bitlen * 661971961083L) >> 41);
                if (minDigits == maxDigits)
                {
                    var fi = new FastInteger(minDigits);
                    return new FastInteger[] { fi, fi };
                }
                else
                {
                    return new FastInteger[] {
              new FastInteger(minDigits), // lower bound
              new FastInteger(maxDigits), // upper bound
            };
                }
            }
            else
            {
                // Bit length is big enough that these bounds will
                // overestimate or underestimate the true base-10 digit length
                // as appropriate.
                EInteger bigBitLength = ei.GetUnsignedBitLengthAsEInteger();
                EInteger lowerBound = bigBitLength.Multiply(100).Divide(335);
                EInteger upperBound = bigBitLength.Divide(3);
                return new FastInteger[] {
            FastInteger.FromBig(lowerBound), // lower bound
            FastInteger.FromBig(upperBound), // upper bound
          };
            }
        }

        public static FastInteger[] DigitLengthBounds<THelper>(
          IRadixMathHelper<THelper> helper,
          EInteger ei)
        {
            int radix = helper.GetRadix();
            if (radix == 2)
            {
                FastInteger fi =
                  FastInteger.FromBig(ei.GetUnsignedBitLengthAsEInteger());
                return new FastInteger[] { fi, fi };
            }
            else if (radix == 10)
            {
                return DecimalDigitLengthBounds(ei);
            }
            else
            {
                FastInteger fi = helper.GetDigitLength(ei);
                return new FastInteger[] { fi, fi };
            }
        }

        private static FastIntegerFixed FastPathDigitLength(
          FastIntegerFixed fei,
          int radix)
        {
            if (fei.CanFitInInt32())
            {
                int ifei = fei.ToInt32();
                if (ifei != Int32.MinValue)
                {
                    if (radix == 2)
                    {
                        return FastIntegerFixed.FromInt32((int)BitLength(Math.Abs(ifei)));
                    }
                    else if (radix == 10)
                    {
                        return FastIntegerFixed.FromInt32(
                           (int)DecimalDigitLength(Math.Abs(ifei)));
                    }
                }
            }
            else
            {
                if (radix == 2)
                {
                    long i64 = fei.ToEInteger().GetUnsignedBitLengthAsInt64();
                    if (i64 != Int64.MaxValue)
                    {
                        return FastIntegerFixed.FromInt64(i64);
                    }
                }
                else if (radix == 10)
                {
                    EInteger ei = fei.ToEInteger();
                    long i64 = ei.GetUnsignedBitLengthAsInt64();
                    if (i64 < 33)
                    {
                        // Can easily be calculated without estimation
                        return FastIntegerFixed.FromInt32(
                          (int)ei.GetDigitCountAsInt64());
                    }
                    else if (i64 <= 2135)
                    {
                        var bitlen = (int)i64;
                        // Approximation of ln(2)/ln(10)
                        int minDigits = 1 + (((bitlen - 1) * 631305) >> 21);
                        int maxDigits = 1 + ((bitlen * 631305) >> 21);
                        if (minDigits == maxDigits)
                        {
                            return FastIntegerFixed.FromInt32(minDigits);
                        }
                    }
                    else if (i64 <= 6432162)
                    {
                        var bitlen = (int)i64;
                        // Approximation of ln(2)/ln(10)
                        int minDigits = 1 + (int)(((long)(bitlen - 1) * 661971961083L) >>
            41);
                        int maxDigits = 1 + (int)(((long)bitlen * 661971961083L) >> 41);
                        if (minDigits == maxDigits)
                        {
                            return FastIntegerFixed.FromInt32(minDigits);
                        }
                    }
                }
            }
            return null;
        }

        public static FastIntegerFixed[] DigitLengthBoundsFixed<THelper>(
          IRadixMathHelper<THelper> helper,
          FastIntegerFixed fei)
        {
            int radix = helper.GetRadix();
            FastIntegerFixed fastpath = FastPathDigitLength(fei, radix);
            if (fastpath != null)
            {
                return new FastIntegerFixed[] { fastpath, fastpath };
            }
            if (radix == 10)
            {
                EInteger[] fi = DecimalDigitLengthBoundsAsEI(fei.ToEInteger());
                return new FastIntegerFixed[] {
          FastIntegerFixed.FromBig(fi[0]),
          FastIntegerFixed.FromBig(fi[1]),
        };
            }
            else
            {
                FastInteger fi = helper.GetDigitLength(fei.ToEInteger());
                FastIntegerFixed fif = FastIntegerFixed.FromFastInteger(fi);
                return new FastIntegerFixed[] { fif, fif };
            }
        }

        public static FastIntegerFixed DigitLengthFixed<THelper>(
          IRadixMathHelper<THelper> helper,
          FastIntegerFixed fei)
        {
            FastIntegerFixed fastpath = FastPathDigitLength(fei, helper.GetRadix());
            if (fastpath != null)
            {
                return fastpath;
            }
            FastInteger fi = helper.GetDigitLength(fei.ToEInteger());
            FastIntegerFixed fif = FastIntegerFixed.FromFastInteger(fi);
            return fif;
        }

        public static FastInteger DigitLengthUpperBound<THelper>(
          IRadixMathHelper<THelper> helper,
          EInteger ei)
        {
            return DigitLengthBounds(helper, ei)[1];
        }

        public static EInteger ReduceTrailingZeros(
          EInteger bigmant,
          FastInteger exponentMutable,
          int radix,
          FastInteger digits,
          FastInteger precision,
          FastInteger idealExp)
        {
#if DEBUG
            if (precision != null && digits == null)
            {
                throw new ArgumentException("doesn't satisfy precision==null ||" +
                  "\u0020digits!=null");
            }
            if (!(bigmant.Sign >= 0))
            {
                throw new ArgumentException("doesn't satisfy bigmant.Sign >= 0");
            }
#endif
            if (bigmant.IsZero)
            {
                exponentMutable.SetInt(0);
                return bigmant;
            }
            if (radix == 2)
            {
                if (!bigmant.IsEven)
                {
                    return bigmant;
                }
                long lowbit = bigmant.GetLowBitAsInt64();
                if (lowbit != Int64.MaxValue)
                {
                    if (precision != null && digits.CompareTo(precision) >= 0)
                    {
                        // Limit by digits minus precision
                        EInteger tmp = digits.ToEInteger().Subtract(precision.ToEInteger());
                        if (tmp.CompareTo(EInteger.FromInt64(lowbit)) < 0)
                        {
                            lowbit = tmp.ToInt64Checked();
                        }
                    }
                    if (idealExp != null && exponentMutable.CompareTo(idealExp) <= 0)
                    {
                        // Limit by idealExp minus exponentMutable
                        EInteger tmp =
                          idealExp.ToEInteger().Subtract(exponentMutable.ToEInteger());
                        if (tmp.CompareTo(EInteger.FromInt64(lowbit)) < 0)
                        {
                            lowbit = tmp.ToInt64Checked();
                        }
                    }
                    bigmant = (lowbit <= Int32.MaxValue) ?
                      bigmant.ShiftRight((int)lowbit) :
                      bigmant.ShiftRight(EInteger.FromInt64(lowbit));
                    if (digits != null)
                    {
                        digits.SubtractInt64(lowbit);
                    }
                    if (exponentMutable != null)
                    {
                        exponentMutable.AddInt64(lowbit);
                    }
                    return bigmant;
                }
            }
            var bigradix = (EInteger)radix;
            var bitsToShift = new FastInteger(0);
            while (!bigmant.IsZero)
            {
                if (precision != null && digits.CompareTo(precision) == 0)
                {
                    break;
                }
                if (idealExp != null && exponentMutable.CompareTo(idealExp) == 0)
                {
                    break;
                }
                EInteger bigrem;
                EInteger bigquo;
                EInteger[] divrem = bigmant.DivRem(bigradix);
                bigquo = divrem[0];
                bigrem = divrem[1];
                if (!bigrem.IsZero)
                {
                    break;
                }
                bigmant = bigquo;
                exponentMutable.Increment();
                if (digits != null)
                {
                    digits.Decrement();
                }
            }
            return bigmant;
        }
    }

    /// <include file='../../docs.xml'
    /// path='docs/doc[@name="T:PeterO.Numbers.RadixMath`1"]/*'/>
    #pragma warning disable CS0618 // certain ERounding values are obsolete
    internal class RadixMath<T> : IRadixMath<T>
    {
        // Use given exponent
        private const int IntegerModeFixedScale = 1;
        // Use flexible exponent
        private const int IntegerModeRegular = 0;

        private const int SafeMin32 = -0x3ffffffe;
        private const int SafeMax32 = 0x3ffffffe;
        private const long SafeMin64 = -0x3ffffffffffffffeL;
        private const long SafeMax64 = 0x3ffffffffffffffeL;

        private static readonly int[] BitMasks = {
      0x7fffffff, 0x3fffffff, 0x1fffffff,
      0xfffffff, 0x7ffffff, 0x3ffffff, 0x1ffffff,
      0xffffff, 0x7fffff, 0x3fffff, 0x1fffff,
      0xfffff, 0x7ffff, 0x3ffff, 0x1ffff,
      0xffff, 0x7fff, 0x3fff, 0x1fff,
      0xfff, 0x7ff, 0x3ff, 0x1ff,
      0xff, 0x7f, 0x3f, 0x1f,
      0xf, 0x7, 0x3, 0x1,
    };

        private static readonly long[] BitMasks64 = {
      0x7fffffffffffffffL, 0x3fffffffffffffffL, 0x1fffffffffffffffL,
      0xfffffffffffffffL, 0x7ffffffffffffffL, 0x3ffffffffffffffL,
      0x1ffffffffffffffL,
      0xffffffffffffffL, 0x7fffffffffffffL, 0x3fffffffffffffL,
      0x1fffffffffffffL,
      0xfffffffffffffL, 0x7ffffffffffffL, 0x3ffffffffffffL, 0x1ffffffffffffL,
      0xffffffffffffL, 0x7fffffffffffL, 0x3fffffffffffL, 0x1fffffffffffL,
      0xfffffffffffL, 0x7ffffffffffL, 0x3ffffffffffL, 0x1ffffffffffL,
      0xffffffffffL, 0x7fffffffffL, 0x3fffffffffL, 0x1fffffffffL,
      0xfffffffffL, 0x7ffffffffL, 0x3ffffffffL, 0x1ffffffffL,
      0xffffffffL, 0x7fffffff, 0x3fffffff, 0x1fffffff,
      0xfffffff, 0x7ffffff, 0x3ffffff, 0x1ffffff,
      0xffffff, 0x7fffff, 0x3fffff, 0x1fffff,
      0xfffff, 0x7ffff, 0x3ffff, 0x1ffff,
      0xffff, 0x7fff, 0x3fff, 0x1fff,
      0xfff, 0x7ff, 0x3ff, 0x1ff,
      0xff, 0x7f, 0x3f, 0x1f,
      0xf, 0x7, 0x3, 0x1,
    };

        private static readonly int[] OverflowMaxes = {
      2147483647, 214748364, 21474836,
      2147483, 214748, 21474, 2147, 214, 21, 2,
    };

        private static readonly EInteger ValueMinusOne = EInteger.Zero -
          EInteger.One;

        private static readonly int[] ValueTenPowers = {
      1, 10, 100, 1000, 10000, 100000,
      1000000, 10000000, 100000000,
      1000000000,
    };

        private static readonly long[] OverflowMaxes64 = {
      9223372036854775807L, 922337203685477580L,
      92233720368547758L, 9223372036854775L,
      922337203685477L, 92233720368547L,
      9223372036854L, 922337203685L,
      92233720368L, 9223372036L,
      922337203L, 92233720, 9223372,
      922337, 92233, 9223, 922, 92, 9,
    };

        private static readonly long[] ValueTenPowers64 = {
      1, 10, 100, 1000,
      10000, 100000, 1000000,
      10000000, 100000000, 1000000000,
      10000000000L, 100000000000L,
      1000000000000L, 10000000000000L,
      100000000000000L, 1000000000000000L,
      10000000000000000L, 100000000000000000L,
      1000000000000000000L,
    };

        private readonly IRadixMathHelper<T> helper;
        private readonly int support;
        private readonly int thisRadix;

        // Conservative maximum base-10 radix power for
        // TryMultiplyByRadixPower; derived from
        // Int32.MaxValue*8/3 (8 is the number of bits in a byte;
        // 3 is a conservative estimate of log(10)/log(2).)
        private static EInteger valueMaxDigits = (EInteger)5726623058L;

        public RadixMath(IRadixMathHelper<T> helper)
        {
            this.helper = helper;
            this.support = helper.GetArithmeticSupport();
            this.thisRadix = helper.GetRadix();
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            if ((object)thisValue == null)
            {
                throw new ArgumentNullException(nameof(thisValue));
            }
            if ((object)other == null)
            {
                throw new ArgumentNullException(nameof(other));
            }
            return this.AddEx(thisValue, other, ctx, false);
        }
        private FastInteger DigitLengthUpperBoundForBitPrecision(FastInteger prec)
        {
            FastInteger result;
            if (this.thisRadix == 2)
            {
                result = prec;
            }
            else
            {
                if (this.thisRadix == 10 && prec.CompareToInt(2135) <= 0)
                {
                    int value = checked(1 + ((prec.ToInt32() * 631305) >> 21));
                    result = new FastInteger(value);
                }
                else if (this.thisRadix == 10 && prec.CompareToInt(6432162) <= 0)
                {
                    // Approximation of ln(2)/ln(10)
                    int value = 1 + (int)(((long)prec.ToInt32() * 661971961083L) >> 41);
                    result = new FastInteger(value);
                }
                else
                {
                    return this.helper.GetDigitLength(
                        EInteger.One.ShiftLeft(prec.ToEInteger()).Subtract(1));
                }
            }
            return result;
        }
        private T AddEx32Bit(
          int expcmp,
          FastIntegerFixed op1Exponent,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Exponent,
          FastIntegerFixed op2Mantissa,
          FastIntegerFixed resultExponent,
          int thisFlags,
          int otherFlags,
          EContext ctx)
        {
            T retval = default(T);
            if ((expcmp == 0 || (op1Exponent.CanFitInInt32() &&
                  op2Exponent.CanFitInInt32())) &&
              op1Mantissa.CanFitInInt32() && op2Mantissa.CanFitInInt32() &&
              (thisFlags & BigNumberFlags.FlagNegative) == (otherFlags &
                BigNumberFlags.FlagNegative))
            {
                int negflag = thisFlags & BigNumberFlags.FlagNegative;
                var e1int = 0;
                var e2int = 0;
                if (expcmp != 0)
                {
                    e1int = op1Exponent.ToInt32();
                    e2int = op2Exponent.ToInt32();
                }
                int m1, m2;
                var haveRetval = false;
                if (expcmp == 0 || (e1int >= SafeMin32 && e1int <= SafeMax32 &&
                    e2int >= SafeMin32 && e2int <= SafeMax32))
                {
                    int ediff = (expcmp == 0) ? 0 : ((e1int > e2int) ? (e1int - e2int) :
                        (e2int - e1int));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        if (m2 <= Int32.MaxValue - m1)
                        {
                            m1 += m2;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.FromInt32(m1),
                                resultExponent,
                                negflag);
                            haveRetval = true;
                        }
                    }
                    else if (ediff <= 9 && radix == 10)
                    {
                        int power = ValueTenPowers[ediff];
                        int maxoverflow = OverflowMaxes[ediff];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.ToInt32();
                            m2 = op2Mantissa.ToInt32();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op2Mantissa,
                                    op2Exponent,
                                    otherFlags);
                            }
                            else if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                if (m2 <= Int32.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt32(m1),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.ToInt32();
                            m2 = op2Mantissa.ToInt32();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op1Mantissa,
                                    op1Exponent,
                                    thisFlags);
                            }
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                if (m1 <= Int32.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt32(m2),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                    else if (ediff <= 30 && radix == 2)
                    {
                        int mask = BitMasks[ediff];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.ToInt32();
                            m2 = op2Mantissa.ToInt32();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op2Mantissa,
                                    op2Exponent,
                                    otherFlags);
                            }
                            else if ((m1 & mask) == m1)
                            {
                                m1 <<= ediff;
                                if (m2 <= Int32.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt32(m1),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.ToInt32();
                            m2 = op2Mantissa.ToInt32();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op1Mantissa,
                                    op1Exponent,
                                    thisFlags);
                            }
                            else if ((m2 & mask) == m2)
                            {
                                m2 <<= ediff;
                                if (m1 <= Int32.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt32(m2),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                }
                if (haveRetval)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        if (resultExponent.IsValueZero &&
                          this.IsNullOrInt32FriendlyContext(ctx))
                        {
                            return retval;
                        }
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            if ((thisFlags & BigNumberFlags.FlagNegative) != 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) == 0)
            {
                FastIntegerFixed fftmp;
                fftmp = op1Exponent;
                op1Exponent = op2Exponent;
                op2Exponent = fftmp;
                fftmp = op1Mantissa;
                op1Mantissa = op2Mantissa;
                op2Mantissa = fftmp;
                int tmp;
                tmp = thisFlags;
                thisFlags = otherFlags;
                otherFlags = tmp;
                expcmp = -expcmp;
                resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            }
            if ((expcmp == 0 || (op1Exponent.CanFitInInt32() &&
                  op2Exponent.CanFitInInt32())) &&
              op1Mantissa.CanFitInInt32() && op2Mantissa.CanFitInInt32() &&
              (thisFlags & BigNumberFlags.FlagNegative) == 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) != 0 &&
              !op2Mantissa.IsValueZero && !op1Mantissa.IsValueZero)
            {
                var e1int = 0;
                var e2int = 0;
                var result = 0;
                if (expcmp != 0)
                {
                    e1int = op1Exponent.ToInt32();
                    e2int = op2Exponent.ToInt32();
                }
                int m1, m2;
                var haveRetval = false;
                if (expcmp == 0 || (e1int >= SafeMin32 && e1int <= SafeMax32 &&
                    e2int >= SafeMin32 && e2int <= SafeMax32))
                {
                    int ediff = (expcmp == 0) ? 0 : ((e1int > e2int) ? (e1int - e2int) :
                        (e2int - e1int));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        if (Int32.MinValue + m2 <= m1 && m1 >= m2)
                        {
                            m1 -= m2;
                            result = m1;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.FromInt32(m1),
                                resultExponent,
                                0);
                            haveRetval = true;
                        }
                    }
                    else if (radix == 10 && ediff <= 9)
                    {
                        int power = ValueTenPowers[ediff];
                        int maxoverflow = OverflowMaxes[ediff];
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        var negbit = false;
                        var multed = false;
                        if (expcmp < 0)
                        {
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                multed = true;
                            }
                        }
                        else
                        {
                            if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                multed = true;
                            }
                        }
                        if (multed && Int32.MinValue + m2 <= m1)
                        {
                            m1 -= m2;
                            if (m1 != Int32.MinValue)
                            {
                                negbit = m1 < 0;
                                result = Math.Abs(m1);
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    FastIntegerFixed.FromInt32(result),
                                    resultExponent,
                                    negbit ? BigNumberFlags.FlagNegative : 0);
                                haveRetval = true;
                            }
                        }
                    }
                }
                if (haveRetval && result != 0)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        if (resultExponent.IsValueZero &&
                          this.IsNullOrInt32FriendlyContext(ctx))
                        {
                            return retval;
                        }
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
                if (haveRetval && result == 0)
                {
                    if (resultExponent.IsValueZero &&
                      this.IsNullOrInt32FriendlyContext(ctx))
                    {
                        return retval;
                    }
                    // DebugUtility.Log("haveRetval, result=0, [" + thisFlags + "," +
                    // op1Mantissa + "," + op1Exponent + "] + [" + otherFlags + "," +
                    // op2Mantissa + "," + op2Exponent + "], retval="+retval);
                }
            }
            return default(T);
        }

        private T AddEx64Bit(
          long expcmp,
          FastIntegerFixed op1Exponent,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Exponent,
          FastIntegerFixed op2Mantissa,
          FastIntegerFixed resultExponent,
          int thisFlags,
          int otherFlags,
          EContext ctx)
        {
            T retval = default(T);
            if ((expcmp == 0 || (op1Exponent.CanFitInInt64() &&
                  op2Exponent.CanFitInInt64())) &&
              op1Mantissa.CanFitInInt64() && op2Mantissa.CanFitInInt64() &&
              (thisFlags & BigNumberFlags.FlagNegative) == (otherFlags &
                BigNumberFlags.FlagNegative))
            {
                int negflag = thisFlags & BigNumberFlags.FlagNegative;
                long e1long = 0;
                long e2long = 0;
                if (expcmp != 0)
                {
                    e1long = op1Exponent.ToInt64();
                    e2long = op2Exponent.ToInt64();
                }
                long m1, m2;
                var haveRetval = false;
                if (expcmp == 0 || (e1long >= SafeMin64 && e1long <= SafeMax64 &&
                    e2long >= SafeMin64 && e2long <= SafeMax64))
                {
                    long ediffLong = (expcmp == 0) ? 0 : ((e1long > e2long) ?
                        (e1long - e2long) : (e2long - e1long));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        if (m2 <= Int64.MaxValue - m1)
                        {
                            m1 += m2;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.FromInt64(m1),
                                resultExponent,
                                negflag);
                            haveRetval = true;
                        }
                    }
                    else if (ediffLong < ValueTenPowers64.Length && radix == 10)
                    {
                        long power = ValueTenPowers64[(int)ediffLong];
                        long maxoverflow = OverflowMaxes64[(int)ediffLong];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.ToInt64();
                            m2 = op2Mantissa.ToInt64();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op2Mantissa,
                                    op2Exponent,
                                    otherFlags);
                            }
                            else if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                if (m2 <= Int64.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt64(m1),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.ToInt64();
                            m2 = op2Mantissa.ToInt64();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op1Mantissa,
                                    op1Exponent,
                                    thisFlags);
                            }
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                if (m1 <= Int64.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt64(m2),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                    else if (ediffLong < BitMasks64.Length && radix == 2)
                    {
                        long mask = BitMasks64[(int)ediffLong];
                        if (expcmp > 0)
                        {
                            m1 = op1Mantissa.ToInt64();
                            m2 = op2Mantissa.ToInt64();
                            if (m1 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op2Mantissa,
                                    op2Exponent,
                                    otherFlags);
                            }
                            else if ((m1 & mask) == m1)
                            {
                                m1 <<= (int)ediffLong;
                                if (m2 <= Int64.MaxValue - m1)
                                {
                                    m1 += m2;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt64(m1),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                        else
                        {
                            m1 = op1Mantissa.ToInt64();
                            m2 = op2Mantissa.ToInt64();
                            if (m2 == 0)
                            {
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    op1Mantissa,
                                    op1Exponent,
                                    thisFlags);
                            }
                            else if ((m2 & mask) == m2)
                            {
                                m2 <<= (int)ediffLong;
                                if (m1 <= Int64.MaxValue - m2)
                                {
                                    m2 += m1;
                                    retval = this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt64(m2),
                                        resultExponent,
                                        negflag);
                                    haveRetval = true;
                                }
                            }
                        }
                    }
                }
                if (haveRetval)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            if ((thisFlags & BigNumberFlags.FlagNegative) != 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) == 0)
            {
                FastIntegerFixed fftmp;
                fftmp = op1Exponent;
                op1Exponent = op2Exponent;
                op2Exponent = fftmp;
                fftmp = op1Mantissa;
                op1Mantissa = op2Mantissa;
                op2Mantissa = fftmp;
                int tmp;
                tmp = thisFlags;
                thisFlags = otherFlags;
                otherFlags = tmp;
                expcmp = -expcmp;
                resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            }
            if ((expcmp == 0 || (op1Exponent.CanFitInInt64() &&
                  op2Exponent.CanFitInInt64())) &&
              op1Mantissa.CanFitInInt64() && op2Mantissa.CanFitInInt64() &&
              (thisFlags & BigNumberFlags.FlagNegative) == 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) != 0 &&
              !op2Mantissa.IsValueZero && !op1Mantissa.IsValueZero)
            {
                long e1long = 0;
                long e2long = 0;
                long result = 0;
                if (expcmp != 0)
                {
                    e1long = op1Exponent.ToInt64();
                    e2long = op2Exponent.ToInt64();
                }
                long m1, m2;
                var haveRetval = false;
                if (expcmp == 0 || (e1long >= SafeMin64 && e1long <= SafeMax64 &&
                    e2long >= SafeMin64 && e2long <= SafeMax64))
                {
                    long ediffLong = (expcmp == 0) ? 0 : ((e1long > e2long) ?
                        (e1long - e2long) : (e2long - e1long));
                    int radix = this.thisRadix;
                    if (expcmp == 0)
                    {
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        if (Int64.MinValue + m2 <= m1 && m1 >= m2)
                        {
                            m1 -= m2;
                            result = m1;
                            retval = this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.FromInt64(m1),
                                resultExponent,
                                0);
                            haveRetval = true;
                        }
                    }
                    else if (radix == 10 && ediffLong < ValueTenPowers64.Length)
                    {
                        long power = ValueTenPowers64[(int)ediffLong];
                        long maxoverflow = OverflowMaxes64[(int)ediffLong];
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        var negbit = false;
                        var multed = false;
                        if (expcmp < 0)
                        {
                            if (m2 <= maxoverflow)
                            {
                                m2 *= power;
                                multed = true;
                            }
                        }
                        else
                        {
                            if (m1 <= maxoverflow)
                            {
                                m1 *= power;
                                multed = true;
                            }
                        }
                        if (multed && Int64.MinValue + m2 <= m1)
                        {
                            m1 -= m2;
                            if (m1 != Int64.MinValue)
                            {
                                negbit = m1 < 0;
                                result = Math.Abs(m1);
                                retval = this.helper.CreateNewWithFlagsFastInt(
                                    FastIntegerFixed.FromInt64(result),
                                    resultExponent,
                                    negbit ? BigNumberFlags.FlagNegative : 0);
                                haveRetval = true;
                            }
                        }
                    }
                }
                if (haveRetval && result != 0)
                {
                    if (!IsNullOrSimpleContext(ctx))
                    {
                        retval = this.RoundToPrecision(retval, ctx);
                    }
                    return retval;
                }
            }
            return default(T);
        }

        public T AddEx(
          T thisValue,
          T other,
          EContext ctx,
          bool roundToOperandPrecision)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                    {
                        if ((thisFlags & BigNumberFlags.FlagNegative) != (otherFlags &
                            BigNumberFlags.FlagNegative))
                        {
                            return this.SignalInvalid(ctx);
                        }
                    }
                    return thisValue;
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return other;
                }
            }
            FastIntegerFixed op1Exponent = this.helper.GetExponentFastInt(thisValue);
            FastIntegerFixed op2Exponent = this.helper.GetExponentFastInt(other);
            FastIntegerFixed op1Mantissa = this.helper.GetMantissaFastInt(thisValue);
            FastIntegerFixed op2Mantissa = this.helper.GetMantissaFastInt(other);
            int expcmp = op1Exponent.CompareTo(op2Exponent);
            FastIntegerFixed resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
            T retval = default(T);
            if ((thisFlags & BigNumberFlags.FlagNegative) == 0 &&
              (otherFlags & BigNumberFlags.FlagNegative) == 0)
            {
                if (expcmp < 0 && op2Mantissa.IsValueZero)
                {
                    return IsNullOrSimpleContext(ctx) ?
                      thisValue : this.RoundToPrecision(thisValue, ctx);
                }
                else if (expcmp >= 0 && op1Mantissa.IsValueZero)
                {
                    return IsNullOrSimpleContext(ctx) ?
                      other : this.RoundToPrecision(other, ctx);
                }
            }
            if (!roundToOperandPrecision)
            {
                retval = this.AddEx32Bit(
                    expcmp,
                    op1Exponent,
                    op1Mantissa,
                    op2Exponent,
                    op2Mantissa,
                    resultExponent,
                    thisFlags,
                    otherFlags,
                    ctx);
                if ((object)retval != (object)default(T))
                {
                    return retval;
                }
                retval = this.AddEx64Bit(
                    expcmp,
                    op1Exponent,
                    op1Mantissa,
                    op2Exponent,
                    op2Mantissa,
                    resultExponent,
                    thisFlags,
                    otherFlags,
                    ctx);
                if ((object)retval != (object)default(T))
                {
                    return retval;
                }
            }
            if (expcmp == 0)
            {
                retval = this.AddCore2(
                    op1Mantissa,
                    op2Mantissa,
                    op1Exponent,
                    thisFlags,
                    otherFlags,
                    ctx);
                if (!IsNullOrSimpleContext(ctx))
                {
                    retval = this.RoundToPrecision(retval, ctx);
                }
            }
            else
            {
                retval = this.AddExDiffExp(
                    op1Exponent,
                    op1Mantissa,
                    op2Exponent,
                    op2Mantissa,
                    thisFlags,
                    otherFlags,
                    ctx,
                    expcmp,
                    roundToOperandPrecision);
            }
            return retval;
        }

        public int CompareTo(T thisValue, T otherValue)
        {
            if (otherValue == null)
            {
                return 1;
            }
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                return CompareToHandleSpecial2(
                    thisFlags,
                    otherFlags);
            }
            return CompareToInternal(thisValue, otherValue, true, this.helper);
        }

        public T CompareToWithContext(
          T thisValue,
          T otherValue,
          bool treatQuietNansAsSignaling,
          EContext ctx)
        {
            if (otherValue == null)
            {
                return this.SignalInvalid(ctx);
            }
            T result = this.CompareToHandleSpecial(
                thisValue,
                otherValue,
                treatQuietNansAsSignaling,
                ctx);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = CompareToInternal(thisValue, otherValue, false, this.helper);
            return (cmp == -2) ? this.SignalInvalidWithMessage(
                ctx,
                "Out of memory ") :
              this.ValueOf(this.CompareTo(thisValue, otherValue), null);
        }

        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            return this.DivideInternal(
                thisValue,
                divisor,
                ctx,
                IntegerModeRegular,
                EInteger.Zero);
        }

        public T DivideToExponent(
          T thisValue,
          T divisor,
          EInteger desiredExponent,
          EContext ctx)
        {
            if (ctx != null && !ctx.ExponentWithinRange(desiredExponent))
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "Exponent not within exponent range: " + desiredExponent);
            }
            EContext ctx2 = (ctx == null) ?
              EContext.ForRounding(ERounding.HalfDown) :
              ctx.WithUnlimitedExponents().WithPrecision(0);
            T ret = this.DivideInternal(
                thisValue,
                divisor,
                ctx2,
                IntegerModeFixedScale,
                desiredExponent);
            if (!ctx2.HasMaxPrecision && this.IsFinite(ret))
            {
                // If a precision is given, call Quantize to ensure
                // that the value fits the precision
                ret = this.Quantize(ret, ret, ctx2);
                if ((ctx2.Flags & EContext.FlagInvalid) != 0)
                {
                    ctx2.Flags = EContext.FlagInvalid;
                }
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= ctx2.Flags;
            }
            return ret;
        }

        public T DivideToIntegerNaturalScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            FastInteger desiredScale =
              FastInteger.FromBig(this.helper.GetExponent(thisValue))
              .SubtractBig(this.helper.GetExponent(divisor));
            EContext ctx2 =
              EContext.ForRounding(ERounding.Down).WithBigPrecision(ctx == null ?
                EInteger.Zero : ctx.Precision).WithBlankFlags();
            T ret = this.DivideInternal(
                thisValue,
                divisor,
                ctx2,
                IntegerModeFixedScale,
                EInteger.Zero);
            if ((ctx2.Flags & (EContext.FlagInvalid |
                  EContext.FlagDivideByZero)) != 0)
            {
                if (ctx != null && ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInvalid | EContext.FlagDivideByZero;
                }
                return ret;
            }
            bool neg = (this.helper.GetSign(thisValue) < 0) ^
              (this.helper.GetSign(divisor) < 0);

            // Now the exponent's sign can only be 0 or positive
            if (this.helper.GetMantissa(ret).IsZero)
            {
                // Value is 0, so just change the exponent
                // to the preferred one
                EInteger dividendExp = this.helper.GetExponent(thisValue);
                EInteger divisorExp = this.helper.GetExponent(divisor);
                ret = this.helper.CreateNewWithFlags(
                    EInteger.Zero,
                    dividendExp - (EInteger)divisorExp,
                    this.helper.GetFlags(ret));
            }
            else
            {
                if (desiredScale.Sign < 0)
                {
                    // Desired scale is negative, shift left
                    desiredScale.Negate();
                    EInteger bigmantissa = this.helper.GetMantissa(ret);
                    bigmantissa = this.TryMultiplyByRadixPower(bigmantissa,
                        desiredScale);
                    if (bigmantissa == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }
                    EInteger exponentDivisor = this.helper.GetExponent(divisor);
                    ret = this.helper.CreateNewWithFlags(
                        bigmantissa,
                        this.helper.GetExponent(thisValue) - (EInteger)exponentDivisor,
                        this.helper.GetFlags(ret));
                }
                else if (desiredScale.Sign > 0)
                {
                    // Desired scale is positive, shift away zeros
                    // but not after scale is reached
                    EInteger bigmantissa = this.helper.GetMantissa(ret);
                    FastInteger fastexponent =
                      FastInteger.FromBig(this.helper.GetExponent(ret));
                    var bigradix = (EInteger)this.thisRadix;
                    while (true)
                    {
                        if (desiredScale.CompareTo(fastexponent) == 0)
                        {
                            break;
                        }
                        EInteger bigrem;
                        EInteger bigquo;
                        {
                            EInteger[] divrem = bigmantissa.DivRem(bigradix);
                            bigquo = divrem[0];
                            bigrem = divrem[1];
                        }
                        if (!bigrem.IsZero)
                        {
                            break;
                        }
                        bigmantissa = bigquo;
                        fastexponent.Increment();
                    }
                    ret = this.helper.CreateNewWithFlags(
                        bigmantissa,
                        fastexponent.ToEInteger(),
                        this.helper.GetFlags(ret));
                }
            }
            if (ctx != null)
            {
                ret = this.RoundToPrecision(ret, ctx);
            }
            ret = this.EnsureSign(ret, neg);
            return ret;
        }

        private T SignalUnderflow(EContext ec, bool negative, bool
          zeroSignificand)
        {
            EInteger eTiny = ec.EMin.Subtract(ec.Precision.Subtract(1));
            eTiny = eTiny.Subtract(2); // subtract 2 from proper eTiny to
                                       // trigger underflow (2, rather than 1, because of HalfUp mode)
            T ret = this.helper.CreateNewWithFlags(
                zeroSignificand ? EInteger.Zero : EInteger.One,
                eTiny,
                negative ? BigNumberFlags.FlagNegative : 0);
            // DebugUtility.Log(ret+" underflow "+ec);
            return this.RoundToPrecision(ret, ec);
        }

        public T DivideToIntegerZeroScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            EContext ctx2 = EContext.ForRounding(ERounding.Down)
              .WithBigPrecision(ctx == null ? EInteger.Zero :
                ctx.Precision).WithBlankFlags();
            T ret = this.DivideInternal(
                thisValue,
                divisor,
                ctx2,
                IntegerModeFixedScale,
                EInteger.Zero);
            if ((ctx2.Flags & (EContext.FlagInvalid |
                  EContext.FlagDivideByZero)) != 0)
            {
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctx2.Flags & (EContext.FlagInvalid |
                        EContext.FlagDivideByZero);
                }
                return ret;
            }
            if (ctx != null)
            {
                ctx2 = ctx.WithBlankFlags().WithUnlimitedExponents();
                ret = this.RoundToPrecision(ret, ctx2);
                if ((ctx2.Flags & EContext.FlagRounded) != 0)
                {
                    return this.SignalInvalid(ctx);
                }
            }
            return ret;
        }

        private EInteger WorkingDigits(EInteger workingBits)
        {
            int radix = this.thisRadix;
            if (radix <= 2)
            {
                {
                    return workingBits;
                }
            }
            int ibits = NumberUtility.BitLength(radix) - 1;
            return workingBits.Divide(ibits).Add(1);
        }

        public T Exp(T thisValue, EContext ctx)
        {
            return this.Exp(thisValue, ctx, ctx == null ? null : ctx.Precision);
        }

        private T Exp(T thisValue, EContext ctx, EInteger workingPrecision)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                // NOTE: Returning a signaling NaN is independent of
                // rounding mode
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                // NOTE: Returning a quiet NaN is independent of
                // rounding mode
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            EContext ctxCopy = ctx.WithBlankFlags();
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                if ((flags & BigNumberFlags.FlagNegative) != 0)
                {
                    T retval = this.helper.CreateNewWithFlags(
                        EInteger.Zero,
                        EInteger.Zero,
                        0);
                    retval = this.RoundToPrecision(
                        retval,
                        ctxCopy);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxCopy.Flags;
                    }
                    return retval;
                }
                return thisValue;
            }
            int sign = this.helper.GetSign(thisValue);
            T one = this.helper.ValueOf(1);
            EInteger guardDigits = this.thisRadix == 2 ?
              workingPrecision.Add(10) : (EInteger)10;
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                workingPrecision + guardDigits)
              .WithRounding(ERounding.HalfEven).WithBlankFlags();
            if (sign == 0)
            {
                thisValue = this.RoundToPrecision(one, ctxCopy);
            }
            else if (sign > 0 && this.CompareTo(thisValue, one) <= 0)
            {
                T closeToZero = this.Divide(
                    this.helper.ValueOf(1),
                    this.helper.ValueOf(0x800),
                    null);
                if (this.IsFinite(closeToZero) &&
                  this.CompareTo(thisValue, closeToZero) <= 0)
                {
                    // Call ExpInternal for magnitudes close to 0, to avoid
                    // issues when thisValue's magnitude is extremely
                    // close to 0
                    thisValue = this.ExpInternalVeryCloseToZero(
                        thisValue,
                        ctxdiv.Precision,
                        ctxCopy);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= EContext.FlagInexact |
                          EContext.FlagRounded | ctxCopy.Flags;
                    }
                    return thisValue;
                }
                thisValue = this.ExpInternal(
                    thisValue,
                    ctxdiv.Precision,
                    ctxCopy);
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInexact | EContext.FlagRounded;
                }
            }
            else if (sign < 0)
            {
                T closeToZero = this.Divide(
                    this.helper.ValueOf(-1),
                    this.helper.ValueOf(0x800),
                    null);
                // DebugUtility.Log("ctz="+closeToZero+", wp="+
                // workingPrecision+
                // " ctxp="+ctx.Precision);
                if (this.IsFinite(closeToZero) &&
                  this.CompareTo(thisValue, closeToZero) >= 0)
                {
                    // Call ExpInternal for magnitudes close to 0, to avoid
                    // issues when thisValue's magnitude is extremely
                    // close to 0
                    // DebugUtility.Log("very ctx: thisValue="+thisValue);
                    thisValue = this.ExpInternalVeryCloseToZero(
                        thisValue,
                        ctxdiv.Precision,
                        ctxCopy);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= EContext.FlagInexact |
                          EContext.FlagRounded | ctxCopy.Flags;
                    }
                    return thisValue;
                }
                // DebugUtility.Log("ordinary: thisValue="+thisValue);
                // exp(x) = 1/exp(-x) where x<0
                T val = this.Exp(this.NegateRaw(thisValue), ctxdiv);
                if ((ctxdiv.Flags & EContext.FlagOverflow) != 0 ||
                  !this.IsFinite(val))
                {
                    // Overflow, try again with expanded exponent range
                    EInteger newMax;
                    ctxdiv.Flags = 0;
                    newMax = ctx.EMax;
                    EInteger eintExpdiff = ctx.EMin;
                    eintExpdiff = newMax - (EInteger)eintExpdiff;
                    newMax += (EInteger)eintExpdiff;
                    ctxdiv = ctxdiv.WithBigExponentRange(ctxdiv.EMin, newMax);
                    thisValue = this.Exp(this.NegateRaw(thisValue), ctxdiv);
                    if ((ctxdiv.Flags & EContext.FlagOverflow) != 0)
                    {
                        // Still overflowed, so trigger underflow
                        return this.SignalUnderflow(ctx, false, false);
                    }
                }
                else
                {
                    thisValue = val;
                }
                thisValue = this.Divide(one, thisValue, ctxCopy);
                // DebugUtility.Log("end= " + thisValue);
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInexact |
                      EContext.FlagRounded;
                }
            }
            else
            {
                T intpart = default(T);
                var haveIntPart = false;
                if (ctx.HasExponentRange && this.thisRadix >= 2 &&
                  this.thisRadix <= 12 &&
                  this.CompareTo(thisValue, this.helper.ValueOf(10)) > 0)
                {
                    // Calculated with ceil(ln(radix))+1 (radixes 0 and 1 are
                    // not used and have entries of 1)
                    int[] upperDivisors = {
            1, 1, 71, 111, 140, 162, 181, 196, 209, 221, 232, 241, 250,
          };
                    // Calculate an upper bound on the overflow threshold
                    // for exp
                    EInteger maxexp = ctx.EMax.Add(ctx.Precision);
                    maxexp = maxexp.Multiply(upperDivisors[this.thisRadix])
                      .Divide(100).Add(2);
                    maxexp = EInteger.Max(EInteger.FromInt32(10), maxexp);
                    T mxe = this.helper.CreateNewWithFlags(
                        maxexp,
                        EInteger.Zero,
                        0);
                    if (this.CompareTo(thisValue, mxe) > 0)
                    {
                        // Greater than overflow bound, so this is an overflow
                        // DebugUtility.Log("thisValue > mxe: " + thisValue + " " + mxe);
                        return this.SignalOverflow(ctx, false);
                    }
                }
                if (ctx.HasExponentRange &&
                  this.CompareTo(thisValue, this.helper.ValueOf(50000)) > 0)
                {
                    // Try to check for overflow quickly
                    // Do a trial powering using a lower number than e,
                    // and a power of 50000
                    this.PowerIntegral(
                      this.helper.ValueOf(2),
                      (EInteger)50000,
                      ctxCopy);
                    if ((ctxCopy.Flags & EContext.FlagOverflow) != 0)
                    {
                        // The trial powering caused overflow, so exp will
                        // cause overflow as well
                        return this.SignalOverflow(ctx, false);
                    }
                    intpart = this.Quantize(
                        thisValue,
                        one,
                        EContext.ForRounding(ERounding.Down));
                    if (!this.GetHelper().GetExponent(intpart).IsZero)
                    {
                        throw new ArgumentException("integer part not zero, as expected");
                    }
                    haveIntPart = true;
                    ctxCopy.Flags = 0;
                    // Now do the same using the integer part of the operand
                    // as the power
                    this.PowerIntegral(
                      this.helper.ValueOf(2),
                      this.helper.GetMantissa(intpart),
                      ctxCopy);
                    if ((ctxCopy.Flags & EContext.FlagOverflow) != 0)
                    {
                        // The trial powering caused overflow, so exp will
                        // cause overflow as well
                        return this.SignalOverflow(ctx, false);
                    }
                    ctxCopy.Flags = 0;
                }
                if (!haveIntPart)
                {
                    intpart = this.Quantize(
                        thisValue,
                        one,
                        EContext.ForRounding(ERounding.Down));
                    if (!this.GetHelper().GetExponent(intpart).IsZero)
                    {
                        throw new ArgumentException("integer part not zero, as expected");
                    }
                }
                T fracpart = this.Add(thisValue, this.NegateRaw(intpart), null);
                // DebugUtility.Log("fracpart0=" + fracpart);
                ctxdiv = SetPrecisionIfLimited(ctxdiv, ctxdiv.Precision + guardDigits)
                  .WithBlankFlags();
                fracpart = this.Add(
                    one,
                    this.Divide(fracpart, intpart, ctxdiv),
                    null);
                ctxdiv.Flags = 0;
                // DebugUtility.Log("fracpart1=" + fracpart);
                EInteger workingPrec = ctxdiv.Precision;
                workingPrec = workingPrec.Add(
                    this.WorkingDigits(EInteger.FromInt32(40)));
                // DebugUtility.Log("intpart=" + intpart + " wp=" + workingPrec);
                thisValue = this.ExpInternal(fracpart, workingPrec, ctxdiv);
                // DebugUtility.Log("thisValue=" + thisValue);
                if ((ctxdiv.Flags & EContext.FlagUnderflow) != 0)
                {
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxdiv.Flags;
                    }
                }
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagInexact |
                      EContext.FlagRounded;
                }
                thisValue = this.PowerIntegral(
                    thisValue,
                    this.helper.GetMantissa(intpart),
                    ctxCopy);
                // DebugUtility.Log(" -->" + thisValue);
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxCopy.Flags;
            }
            return thisValue;
        }

        public IRadixMathHelper<T> GetHelper()
        {
            return this.helper;
        }

        public static EFloat FastLn(EFloat x, EContext ctx)
        {
            /*
           #if DEBUG
              if ((ef) == null) {
                throw new ArgumentNullException(nameof(ef));
              }
              if ((ctx) == null) {
                throw new ArgumentNullException(nameof(ctx));
              }
           #endif

            */
            // Fast log for contexts of precision 53 bits or less
            if (x.CompareTo(EFloat.Create(32, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(36, -6)) < 0)
            {
                return EFloat.Create(-7918475170148451L, -47)
                  .MultiplyAndAdd(x, EFloat.Create(5842854079153127L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-7855987447712801L, -43), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(3178826684731201L, -41), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-3446209805793071L, -41), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(5269250416501899L, -42), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-1456756048094669L, -41), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(589048828844673L, -41), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-5626160540257247L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(5306429958415307L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-8023390364436687L, -51), ctx);
            }
            if (x.CompareTo(EFloat.Create(36, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(40, -6)) < 0)
            {
                return EFloat.Create(-649418159759275L, -45)
                  .MultiplyAndAdd(x, EFloat.Create(8569695812135613L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-3219836323271541L, -43), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(1456356315564023L, -41), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-7059686721514865L, -43), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(6033379619755303L, -43), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-7458850461699891L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(6743646686636803L, -45), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-281293242157611L, -42), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(4746007495118267L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-7772015102064253L, -51), ctx);
            }
            if (x.CompareTo(EFloat.Create(40, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(44, -6)) < 0)
            {
                return EFloat.Create(5559026033201687L, -50)
                  .MultiplyAndAdd(x, EFloat.Create(-4617856151292203L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(54117074379353L, -39), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-6186785536082459L, -45), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(7306510509645715L, -45), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-2995764726321697L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(6986795845479189L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-5891564005530805L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(15091899246223L, -40), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-7320823715054069L, -51), ctx);
            }
            if (x.CompareTo(EFloat.Create(44, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(48, -6)) < 0)
            {
                return EFloat.Create(612197579983455L, -48)
                  .MultiplyAndAdd(x, EFloat.Create(-1114006258063177L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(457577809503393L, -43), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-1790557502154387L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(4632494137994963L, -45), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-4161053891636247L, -45), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(2657563185521199L, -45), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-4909589327505907L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(7053693369648581L, -49), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-3557744849045649L, -50), ctx);
            }
            if (x.CompareTo(EFloat.Create(48, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(52, -6)) < 0)
            {
                return EFloat.Create(577499201531193L, -49)
                  .MultiplyAndAdd(x, EFloat.Create(-1142306702241897L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(8160604872283537L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-4339153427527017L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(6101799781923291L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-5958127120148891L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(8273521206806363L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-4154027270256105L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(3244106922381301L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-13529886537447L, -42), ctx);
            }
            if (x.CompareTo(EFloat.Create(52, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(56, -6)) < 0)
            {
                return EFloat.Create(1154075304800921L, -51)
                  .MultiplyAndAdd(x, EFloat.Create(-2465640916317121L, -49), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(74318910129327L, -42), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-85366471369779L, -41), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(259329022146413L, -42), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-4376322035869763L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(3282099616186431L, -46), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-3560066267427385L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(1501608713011209L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-26381046771207L, -43), ctx);
            }
            if (x.CompareTo(EFloat.Create(56, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(60, -6)) < 0)
            {
                return EFloat.Create(37824989738239L, -47)
                  .MultiplyAndAdd(x, EFloat.Create(-43408559199581L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(2878790570900291L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-7105058961533699L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(5797162642745407L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-6569041813188869L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(661617942907567L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-6168232135736261L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(43675806283161L, -42), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-6591942829339363L, -51), ctx);
            }
            if (x.CompareTo(EFloat.Create(60, -6)) >= 0 &&
               x.CompareTo(EFloat.Create(63, -6)) < 0)
            {
                return EFloat.Create(-6156921697102261L, -55)
                  .MultiplyAndAdd(x, EFloat.Create(211488681190339L, -47), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-6644421976470021L, -50), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(7668093965389463L, -49), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-5761162710156971L, -48), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(369347589996043L, -44), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-8524061902531777L, -49), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(4683735041389899L, -49), ctx)
                  .MultiplyAndAdd(x, EFloat.Create(-6208425595264589L, -51), ctx);
            }
            return null;
        }

        public T Ln(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                // NOTE: Returning a signaling NaN is independent of
                // rounding mode
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                // NOTE: Returning a quiet NaN is independent of
                // rounding mode
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            int sign = this.helper.GetSign(thisValue);
            if (sign < 0)
            {
                return this.SignalInvalid(ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                return thisValue;
            }
            EContext ctxCopy = ctx.WithBlankFlags();
            T one = this.helper.ValueOf(1);
            ERounding intermedRounding = ERounding.HalfEven;
            if (sign == 0)
            {
                return this.helper.CreateNewWithFlags(
                    EInteger.Zero,
                    EInteger.Zero,
                    BigNumberFlags.FlagNegative | BigNumberFlags.FlagInfinity);
            }
            else
            {
                int cmpOne = this.CompareTo(thisValue, one);
                EContext ctxdiv = null;
                if (cmpOne == 0)
                {
                    // Equal to 1
                    thisValue = this.RoundToPrecision(
                        this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                        ctxCopy);
                }
                else if (cmpOne < 0)
                {
                    // Less than 1
                    T half = this.Divide(one, this.helper.ValueOf(2), ctxCopy);
                    if (this.CompareTo(thisValue, half) >= 0 &&
                        this.helper.GetRadix() == 2 && ctx.Precision.CompareTo(53) <= 0)
                    {
                        if (thisValue is EFloat)
                        {
                            var ef = thisValue as EFloat;
                            ef = FastLn(ef, ctxCopy);
                            if (ef != null)
                            {
                                //thisValue = (T)ef;
                                if (ctx.HasFlags)
                                {
                                    ctx.Flags |= EContext.FlagInexact;
                                    ctx.Flags |= EContext.FlagRounded;
                                }
                                return thisValue;
                            }
                        }
                    }
                    T quarter = this.Divide(one, this.helper.ValueOf(4), ctxCopy);
                    FastInteger error;
                    error = (this.CompareTo(thisValue, quarter) < 0) ?
                      new FastInteger(20) : new FastInteger(10);
                    EInteger bigError = error.ToEInteger();
                    ctxdiv = SetPrecisionIfLimited(ctx, ctx.Precision + bigError)
                      .WithRounding(intermedRounding).WithBlankFlags();
                    T threeQuarters = this.Multiply(
                        quarter,
                        this.helper.ValueOf(3),
                        null);
                    if (this.CompareTo(thisValue, threeQuarters) <= 0)
                    {
                        // Three quarters or less
                        var roots = new FastInteger(0);
                        // Take square root until this value
                        // is 3/4 or more
                        while (this.CompareTo(thisValue, threeQuarters) < 0)
                        {
                            thisValue = this.SquareRoot(
                                thisValue,
                                ctxdiv.WithUnlimitedExponents());
                            // DebugUtility.Log("--> " +thisValue);
                            roots.Increment();
                        }
                        for (var i = 0; i < 6; ++i)
                        {
                            thisValue = this.SquareRoot(
                                thisValue,
                                ctxdiv.WithUnlimitedExponents());
                            // DebugUtility.Log("--> " +thisValue);
                            roots.Increment();
                        }
                        // DebugUtility.Log("LnInternal AA " +(thisValue as
                        // EDecimal)?.ToDouble());
                        thisValue = this.LnInternal(thisValue, ctxdiv.Precision, ctxdiv);
                        EInteger bigintRoots = PowerOfTwo(roots);
                        // Multiply back 2^X, where X is the number
                        // of square root calls
                        thisValue = this.Multiply(
                            thisValue,
                            this.helper.CreateNewWithFlags(bigintRoots, EInteger.Zero, 0),
                            ctxCopy);
                    }
                    else
                    {
                        T smallfrac = this.Divide(one, this.helper.ValueOf(16), ctxdiv);
                        T closeToOne = this.Add(one, this.NegateRaw(smallfrac), null);
                        if (this.CompareTo(thisValue, closeToOne) >= 0)
                        {
                            // This value is close to 1, so use a higher working precision
                            error = this.helper.GetDigitLength(this.helper.GetMantissa(
                                  thisValue));
                            error = error.Copy();
                            error.AddInt(6);
                            error.AddBig(ctx.Precision);
                            bigError = error.ToEInteger();
                            // DebugUtility.Log("LnInternalCloseToOne B " +(thisValue as
                            // EDecimal)?.ToDouble());
                            thisValue = this.LnInternalCloseToOne2(
                                thisValue,
                                error.ToEInteger(),
                                ctxCopy);
                        }
                        else
                        {
                            // DebugUtility.Log("LnInternal A " +(thisValue as
                            // EDecimal)?.ToDouble());
                            thisValue = this.LnInternal(
                                thisValue,
                                ctxdiv.Precision,
                                ctxCopy);
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctxCopy.Flags |= EContext.FlagInexact;
                        ctxCopy.Flags |= EContext.FlagRounded;
                    }
                }
                else
                {
                    // Greater than 1
                    // T hundred = this.helper.ValueOf(100);
                    T two = this.helper.ValueOf(2);
                    // DebugUtility.Log("thisValue=" + thisValue +
                    // " hundredcmp=" + this.CompareTo(thisValue, hundred) +
                    // " twocmp=" + this.CompareTo(thisValue, two));
                    if (this.CompareTo(thisValue, two) > 0 &&
                      this.helper.GetRadix() == 2)
                    {
                        T half = this.Divide(this.helper.ValueOf(1),
                            this.helper.ValueOf(2),
                          EContext.Unlimited);
                        FastIntegerFixed fmant = this.helper.GetMantissaFastInt(thisValue);
                        EInteger fexp =
                          this.helper.GetExponentFastInt(thisValue).ToEInteger();
                        EInteger fbits =
                          fmant.ToEInteger().GetUnsignedBitLengthAsEInteger();
                        EInteger adjval = EInteger.One;
                        adjval = fbits.Negate(); // fexp.Subtract(fbits.Add(fexp));
                        EInteger adjbits = EInteger.Zero;
                        T reduced = default(T);
                        if (fexp.Sign > 0)
                        {
                            reduced = this.helper.CreateNewWithFlags(fmant.ToEInteger(),
                                adjval,
                                0);
                            adjbits = fexp.Add(fbits);
                        }
                        else
                        {
                            reduced = this.helper.CreateNewWithFlags(fmant.ToEInteger(),
                                adjval,
                                0);
                            adjbits = fexp.Add(fbits);
                        }
                        T addval = adjbits.Sign < 0 ? this.helper.CreateNewWithFlags(
                            adjbits.Abs(),
                            EInteger.Zero,
                            BigNumberFlags.FlagNegative) : this.helper.CreateNewWithFlags(
                            adjbits.Abs(),
                            EInteger.Zero,
                            0);
                        EInteger cprec = ctx.Precision.Add(10);
                        ctxdiv = SetPrecisionIfLimited(ctx, cprec)
                          .WithRounding(intermedRounding).WithBlankFlags();
#if DEBUG
                        if (this.CompareTo(reduced, one) >= 0 ||
                          this.CompareTo(reduced, half) < 0)
                        {
                            throw new InvalidOperationException(
                              "thisValue = " + thisValue + "\n" +
                              "fexp = " + fexp + "\n" + "fbits = " + fbits + "\n" +
                              "adjval = " + adjval + "\n" + "reduced = " + reduced + "\n");
                        }
#endif
                        // DebugUtility.Log("thisValue = " + thisValue + "\n" +
                        // "fexp = " + fexp + "\n" + "fbits = " + fbits + "\n" +
                        // "adjval = " + adjval + "\n" + "reduced = " + reduced + "\n");
                        reduced = this.Ln(reduced, ctxdiv);
                        thisValue = this.MultiplyAndAdd(
                            this.Ln(two, ctxdiv),
                            addval,
                            reduced,
                            ctxCopy);
                    }
                    else if (this.CompareTo(thisValue, two) >= 0)
                    {
                        // 2 or greater
                        var roots = new FastInteger(0);
                        FastInteger error;
                        EInteger bigError;
                        FastIntegerFixed fmant = this.helper.GetMantissaFastInt(thisValue);
                        FastIntegerFixed[] bounds = NumberUtility.DigitLengthBoundsFixed(
                            this.helper,
                            fmant);
                        // DebugUtility.Log("thisValue "+thisValue);
                        // DebugUtility.Log("bounds "+bounds[1]+" ctxprec="+ctx.Precision);
                        error = new FastInteger(10);
                        if (this.CompareTo(thisValue,
                            this.helper.ValueOf(10000000)) >= 0)
                        {
                            if (this.helper.GetRadix() == 2)
                            {
                                error = new FastInteger(32);
                            }
                            error = new FastInteger(16);
                        }
                        bigError = error.ToEInteger();
                        EInteger cprec = EInteger.Max(bounds[1].ToEInteger(), ctx.Precision)
                          .Add(bigError);
                        ctxdiv = SetPrecisionIfLimited(ctx, cprec)
                          .WithRounding(intermedRounding).WithBlankFlags();
                        T smallfrac = (ctxdiv.Precision.CompareTo(400) > 0) ?
                          this.Divide(one, this.helper.ValueOf(1000000), ctxdiv) :
                          this.Divide(one, this.helper.ValueOf(200), ctxdiv);
                        T closeToOne = this.Add(one, smallfrac, null);
                        // DebugUtility.Log("Before Ln " +thisValue);
                        T oldThisValue = thisValue;
                        // Take square root until this value
                        // is close to 1
                        while (this.CompareTo(thisValue, two) >= 0)
                        {
                            thisValue = this.SquareRoot(
                                thisValue,
                                ctxdiv.WithUnlimitedExponents());
                            // DebugUtility.Log("--> " +thisValue);
                            roots.Increment();
                        }
                        for (int i = 0; i < 8; ++i)
                        {
                            thisValue = this.SquareRoot(
                                thisValue,
                                ctxdiv.WithUnlimitedExponents());
                            // DebugUtility.Log("--> " +thisValue);
                            roots.Increment();
                        }
                        // DebugUtility.Log("rootcount="+roots);
                        // Find -Ln(1/thisValue)
                        // DebugUtility.Log("LnInternalCloseToOne C " + thisValue);
                        thisValue = this.Divide(one, thisValue, ctxdiv);
                        // DebugUtility.Log("LnInternalCloseToOne C " + thisValue);
                        thisValue = this.LnInternalCloseToOne2(
                            thisValue,
                            ctxdiv.Precision,
                            ctxdiv);
                        thisValue = this.NegateRaw(thisValue);
                        // DebugUtility.Log("After LnInternal " +thisValue +
                        // " roots="+roots);
                        EInteger bigintRoots = PowerOfTwo(roots);
                        // Multiply back 2^X, where X is the number
                        // of square root calls
                        /* DebugUtility.Log("After LnInternal Mult<ctxdiv> " +this.Multiply(
                            thisValue,
                            this.helper.CreateNewWithFlags(bigintRoots, EInteger.Zero, 0),
                            ctxdiv));
                         DebugUtility.Log("After LnInternal Mult<ei3> " +this.Multiply(
                            thisValue,
                            this.helper.CreateNewWithFlags(bigintRoots, EInteger.Zero, 0),
                            ctxCopy.WithRounding(intermedRounding)));
                        */
                        thisValue = this.Multiply(
                         thisValue,
                         this.helper.CreateNewWithFlags(bigintRoots, EInteger.Zero, 0),
                         ctxCopy);
                        // DebugUtility.Log("After LnInternal Mult " +(thisValue as
                        // EDecimal)?.ToDouble());
                        // DebugUtility.Log("ctx=" + ctxCopy + " ");
                    }
                    else
                    {
                        FastInteger error;
                        EInteger bigError;
                        error = new FastInteger(10);
                        bigError = error.ToEInteger();
                        ctxdiv = SetPrecisionIfLimited(ctx, ctx.Precision + bigError)
                          .WithRounding(intermedRounding).WithBlankFlags();
                        T smallfrac = this.Divide(one, this.helper.ValueOf(16), ctxdiv);
                        T closeToOne = this.Add(one, smallfrac, null);
                        if (this.CompareTo(thisValue, closeToOne) < 0)
                        {
                            error = this.helper.GetDigitLength(this.helper.GetMantissa(
                                  thisValue));
                            error = error.Copy();
                            error.AddInt(6);
                            error.AddBig(ctx.Precision);
                            // DebugUtility.Log("using error precision: " + error + ", " +
                            // thisValue);
                            bigError = error.ToEInteger();
                            // Greater than 1 and close to 1, will require a higher working
                            // precision
                            // DebugUtility.Log("LnInternalCloseToOne D " +(thisValue as
                            // EDecimal)?.ToDouble());
                            thisValue = this.LnInternalCloseToOne2(
                                thisValue,
                                error.ToEInteger(),
                                ctxCopy);
                        }
                        else
                        {
                            // Find -Ln(1/thisValue)
                            thisValue = this.Divide(one, thisValue, ctxdiv);
                            // DebugUtility.Log("LnInternal B " +(thisValue as
                            // EDecimal)?.ToDouble());
                            /* // thisValue = this.LnInternal(
                              // thisValue, // ctxdiv.getPrecision()
                              //,
                              ctxCopy); */
                            thisValue = this.Ln(thisValue, ctxCopy);
                            thisValue = this.NegateRaw(thisValue);
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctxCopy.Flags |= EContext.FlagInexact;
                        ctxCopy.Flags |= EContext.FlagRounded;
                    }
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxCopy.Flags;
            }
            return thisValue;
        }

        public T Max(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, false, false);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(a, b);
            if (cmp != 0)
            {
                return cmp < 0 ? this.RoundToPrecision(b, ctx) :
                  this.RoundToPrecision(a, ctx);
            }
            int flagNegA = this.helper.GetFlags(a) & BigNumberFlags.FlagNegative;
            return (flagNegA != (this.helper.GetFlags(b) &
                  BigNumberFlags.FlagNegative)) ? ((flagNegA != 0) ?
                this.RoundToPrecision(b, ctx) : this.RoundToPrecision(a, ctx)) :
              ((flagNegA == 0) ? (this.helper.GetExponent(a).CompareTo(
                    this.helper.GetExponent(
                      b)) > 0 ? this.RoundToPrecision(a, ctx) :
                  this.RoundToPrecision(b, ctx)) : (this.helper.GetExponent(
                    a).CompareTo(
                    this.helper.GetExponent(
                      b)) > 0 ? this.RoundToPrecision(b, ctx) :
                  this.RoundToPrecision(a, ctx)));
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, false, true);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(this.AbsRaw(a), this.AbsRaw(b));
            return (cmp == 0) ? this.Max(a, b, ctx) : ((cmp > 0) ?
                this.RoundToPrecision(
                  a,
                  ctx) : this.RoundToPrecision(
                  b,
                  ctx));
        }

        public T Min(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, true, false);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(a, b);
            if (cmp != 0)
            {
                return cmp > 0 ? this.RoundToPrecision(b, ctx) :
                  this.RoundToPrecision(a, ctx);
            }
            int signANeg = this.helper.GetFlags(a) & BigNumberFlags.FlagNegative;
            return (signANeg != (this.helper.GetFlags(b) &
                  BigNumberFlags.FlagNegative)) ? ((signANeg != 0) ?
                this.RoundToPrecision(a, ctx) : this.RoundToPrecision(b, ctx)) :
              ((signANeg == 0) ? (this.helper.GetExponent(a).CompareTo(
                    this.helper.GetExponent(
                      b)) > 0 ? this.RoundToPrecision(b, ctx) :
                  this.RoundToPrecision(a, ctx)) : (this.helper.GetExponent(
                    a).CompareTo(
                    this.helper.GetExponent(
                      b)) > 0 ? this.RoundToPrecision(a, ctx) :
                  this.RoundToPrecision(b, ctx)));
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            if (a == null)
            {
                throw new ArgumentNullException(nameof(a));
            }
            if (b == null)
            {
                throw new ArgumentNullException(nameof(b));
            }
            // Handle infinity and NaN
            T result = this.MinMaxHandleSpecial(a, b, ctx, true, true);
            if ((object)result != (object)default(T))
            {
                return result;
            }
            int cmp = this.CompareTo(this.AbsRaw(a), this.AbsRaw(b));
            return (cmp == 0) ? this.Min(a, b, ctx) : ((cmp < 0) ?
                this.RoundToPrecision(
                  a,
                  ctx) : this.RoundToPrecision(
                  b,
                  ctx));
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Attempt to multiply infinity by 0
                    bool negflag = ((thisFlags & BigNumberFlags.FlagNegative) != 0) ^
                      ((otherFlags & BigNumberFlags.FlagNegative) != 0);
                    return ((otherFlags & BigNumberFlags.FlagSpecial) == 0 &&
                        this.helper.GetMantissa(other).IsZero) ? this.SignalInvalid(
                        ctx) : this.EnsureSign(
                        thisValue,
                        negflag);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Attempt to multiply infinity by 0
                    bool negflag = ((thisFlags & BigNumberFlags.FlagNegative) != 0) ^
                      ((otherFlags & BigNumberFlags.FlagNegative) != 0);
                    return ((thisFlags & BigNumberFlags.FlagSpecial) == 0 &&
                        this.helper.GetMantissa(thisValue).IsZero) ?
                      this.SignalInvalid(ctx) : this.EnsureSign(other, negflag);
                }
            }
            EInteger bigintOp2 = this.helper.GetExponent(other);
            EInteger newexp = this.helper.GetExponent(thisValue) +
              (EInteger)bigintOp2;
            EInteger mantissaOp2 = this.helper.GetMantissa(other);
            // DebugUtility.Log("" + (this.helper.GetMantissa(thisValue)) + "," +
            // (this.helper.GetExponent(thisValue)) + " -> " + mantissaOp2 +", " +
            // (bigintOp2));
            thisFlags = (thisFlags & BigNumberFlags.FlagNegative) ^ (otherFlags &
                BigNumberFlags.FlagNegative);
            T ret =
              this.helper.CreateNewWithFlags(
                this.helper.GetMantissa(thisValue) * (EInteger)mantissaOp2,
                newexp,
                thisFlags);
            if (ctx != null && ctx != EContext.UnlimitedHalfEven)
            {
                ret = this.RoundToPrecision(ret, ctx);
            }
            return ret;
        }

        public T MultiplyAndAdd(
          T thisValue,
          T multiplicand,
          T augend,
          EContext ctx)
        {
            if (multiplicand == null)
            {
                throw new ArgumentNullException(nameof(multiplicand));
            }
            if (augend == null)
            {
                throw new ArgumentNullException(nameof(augend));
            }
            EContext ctx2 = EContext.UnlimitedHalfEven.WithBlankFlags();
            T ret = this.MultiplyAddHandleSpecial(
                thisValue,
                multiplicand,
                augend,
                ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            T product = this.Multiply(thisValue, multiplicand, ctx2);
            ret = this.Add(product, augend, ctx);
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= ctx2.Flags;
            }
            return ret;
        }

        public T Negate(T value, EContext ctx)
        {
            int flags = this.helper.GetFlags(value);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(value, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(value, ctx);
            }
            EInteger mant = this.helper.GetMantissa(value);
            T zero;
            if ((flags & BigNumberFlags.FlagInfinity) == 0 && mant.IsZero)
            {
                // Negate(-0) is treated as subtract(0, -0), which in turn is treated
                // as add (0, 0), so that the result is positive 0 since both
                // operands to add are positive
                // Negate(0) is treated as subtract(0, 0), which in turn is treated
                // as add(0, -0), so that the result is positive 0 since both
                // operands to add are positive
                bool nonnegative, floor;
                nonnegative = (flags & BigNumberFlags.FlagNegative) == 0;
                floor = ctx != null && ctx.Rounding == ERounding.Floor;
                if (floor && nonnegative)
                {
                    zero = this.helper.CreateNewWithFlags(
                        mant,
                        this.helper.GetExponent(value),
                        flags | BigNumberFlags.FlagNegative);
                }
                else
                {
                    zero = this.helper.CreateNewWithFlags(
                        mant,
                        this.helper.GetExponent(value),
                        flags & ~BigNumberFlags.FlagNegative);
                }
                // DebugUtility.Log("" + (// value) + " -> " + zero + " (nonneg=" +
                // nonnegative + ", floor=" + floor + ")");
                return this.RoundToPrecision(zero, ctx);
            }
            flags ^= BigNumberFlags.FlagNegative;
            T ret = this.helper.CreateNewWithFlags(
                mant,
                this.helper.GetExponent(value),
                flags);
            return this.RoundToPrecision(ret, ctx);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            if (!ctx.HasExponentRange)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "doesn't satisfy ctx.HasExponentRange");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                if ((flags & BigNumberFlags.FlagNegative) != 0)
                {
                    return thisValue;
                }
                else
                {
                    EInteger bigexp2 = ctx.EMax;
                    EInteger bigprec = ctx.Precision;
                    if (ctx.AdjustExponent)
                    {
                        bigexp2 += EInteger.One;
                        bigexp2 -= (EInteger)bigprec;
                    }
                    EInteger overflowMant = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        FastInteger.FromBig(ctx.Precision));
                    if (overflowMant == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }
                    overflowMant -= EInteger.One;
                    return this.helper.CreateNewWithFlags(overflowMant, bigexp2, 0);
                }
            }
            FastInteger minexp = FastInteger.FromBig(ctx.EMin);
            if (ctx.AdjustExponent)
            {
                minexp.SubtractBig(ctx.Precision).Increment();
            }
            FastInteger bigexp =
              FastInteger.FromBig(this.helper.GetExponent(thisValue));
            if (bigexp.CompareTo(minexp) <= 0)
            {
                // Use a smaller exponent if the input exponent is already
                // very small
                minexp = bigexp.Copy().SubtractInt(2);
            }
            T quantum = this.helper.CreateNewWithFlags(
                EInteger.One,
                minexp.ToEInteger(),
                BigNumberFlags.FlagNegative);
            EContext ctx2;
            ctx2 = ctx.WithRounding(ERounding.Floor);
            return this.Add(thisValue, quantum, ctx2);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            if (!ctx.HasExponentRange)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "doesn't satisfy ctx.HasExponentRange");
            }
            int flags = this.helper.GetFlags(thisValue);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(thisValue, ctx);
            }
            if ((flags & BigNumberFlags.FlagInfinity) != 0)
            {
                if ((flags & BigNumberFlags.FlagNegative) != 0)
                {
                    EInteger bigexp2 = ctx.EMax;
                    EInteger bigprec = ctx.Precision;
                    if (ctx.AdjustExponent)
                    {
                        bigexp2 += EInteger.One;
                        bigexp2 -= (EInteger)bigprec;
                    }
                    EInteger overflowMant = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        FastInteger.FromBig(ctx.Precision));
                    if (overflowMant == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }
                    overflowMant -= EInteger.One;
                    return this.helper.CreateNewWithFlags(
                        overflowMant,
                        bigexp2,
                        BigNumberFlags.FlagNegative);
                }
                return thisValue;
            }
            FastInteger minexp = FastInteger.FromBig(ctx.EMin);
            if (ctx.AdjustExponent)
            {
                minexp.SubtractBig(ctx.Precision).Increment();
            }
            FastInteger bigexp =
              FastInteger.FromBig(this.helper.GetExponent(thisValue));
            if (bigexp.CompareTo(minexp) <= 0)
            {
                // Use a smaller exponent if the input exponent is already
                // very small
                minexp = bigexp.Copy().SubtractInt(2);
            }
            T quantum = this.helper.CreateNewWithFlags(
                EInteger.One,
                minexp.ToEInteger(),
                0);
            EContext ctx2;
            T val = thisValue;
            ctx2 = ctx.WithRounding(ERounding.Ceiling);
            return this.Add(val, quantum, ctx2);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            if (!ctx.HasExponentRange)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "doesn't satisfy ctx.HasExponentRange");
            }
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, otherValue, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
            }
            EContext ctx2;
            int cmp = this.CompareTo(thisValue, otherValue);
            if (cmp == 0)
            {
                return this.RoundToPrecision(
                    this.EnsureSign(
                      thisValue,
                      (otherFlags & BigNumberFlags.FlagNegative) != 0),
                    ctx.WithNoFlags());
            }
            else
            {
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if ((thisFlags & (BigNumberFlags.FlagInfinity |
                          BigNumberFlags.FlagNegative)) == (otherFlags &
                        (BigNumberFlags.FlagInfinity | BigNumberFlags.FlagNegative)))
                    {
                        // both values are the same infinity
                        return thisValue;
                    }
                    else
                    {
                        EInteger bigexp2 = ctx.EMax;
                        EInteger bigprec = ctx.Precision;
                        if (ctx.AdjustExponent)
                        {
                            bigexp2 += EInteger.One;
                            bigexp2 -= (EInteger)bigprec;
                        }
                        EInteger overflowMant = this.TryMultiplyByRadixPower(
                            EInteger.One,
                            FastInteger.FromBig(ctx.Precision));
                        if (overflowMant == null)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Result requires too much memory");
                        }
                        overflowMant -= EInteger.One;
                        return this.helper.CreateNewWithFlags(
                            overflowMant,
                            bigexp2,
                            thisFlags & BigNumberFlags.FlagNegative);
                    }
                }
                FastInteger minexp = FastInteger.FromBig(ctx.EMin);
                if (ctx.AdjustExponent)
                {
                    minexp.SubtractBig(ctx.Precision).Increment();
                }
                FastInteger bigexp =
                  FastInteger.FromBig(this.helper.GetExponent(thisValue));
                if (bigexp.CompareTo(minexp) < 0)
                {
                    // Use a smaller exponent if the input exponent is already
                    // very small
                    minexp = bigexp.Copy().SubtractInt(2);
                }
                else
                {
                    // Ensure the exponent is lower than the exponent range
                    // (necessary to flag underflow correctly)
                    minexp.SubtractInt(2);
                }
                T quantum = this.helper.CreateNewWithFlags(
                    EInteger.One,
                    minexp.ToEInteger(),
                    (cmp > 0) ? BigNumberFlags.FlagNegative : 0);
                T val = thisValue;
                ctx2 = ctx.WithRounding((cmp > 0) ? ERounding.Floor :
                    ERounding.Ceiling).WithBlankFlags();
                val = this.Add(val, quantum, ctx2);
                if ((ctx2.Flags & (EContext.FlagOverflow |
                      EContext.FlagUnderflow)) == 0)
                {
                    // Don't set flags except on overflow or underflow,
                    // in accordance with the DecTest test cases
                    ctx2.Flags = 0;
                }
                if ((ctx2.Flags & EContext.FlagUnderflow) != 0)
                {
                    EInteger bigmant = this.helper.GetMantissa(val);
                    EInteger maxmant = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        FastInteger.FromBig(ctx.Precision).Decrement());
                    if (maxmant == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }
                    if (bigmant.CompareTo(maxmant) >= 0 ||
                      ctx.Precision.CompareTo(EInteger.One) == 0)
                    {
                        // don't treat max-precision results as having underflowed
                        ctx2.Flags = 0;
                    }
                }
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctx2.Flags;
                }
                return val;
            }
        }

        public T Pi(EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            // Gauss-Legendre algorithm
            T a = this.helper.ValueOf(1);
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                ctx.Precision + (EInteger)10)
              .WithRounding(ERounding.HalfEven);
            T two = this.helper.ValueOf(2);
            T b = this.Divide(a, this.SquareRoot(two, ctxdiv), ctxdiv);
            T four = this.helper.ValueOf(4);
            T half = ((this.thisRadix & 1) == 0) ?
              this.helper.CreateNewWithFlags(
                (EInteger)(this.thisRadix / 2),
                ValueMinusOne,
                0) : default(T);
            T t = this.Divide(a, four, ctxdiv);
            var more = true;
            var lastCompare = 0;
            var vacillations = 0;
            T lastGuess = default(T);
            T guess = default(T);
            EInteger powerTwo = EInteger.One;
            while (more)
            {
                lastGuess = guess;
                T aplusB = this.Add(a, b, null);
                T newA = (half == null) ? this.Divide(aplusB, two, ctxdiv) :
                  this.Multiply(aplusB, half, null);
                T valueAMinusNewA = this.Add(a, this.NegateRaw(newA), null);
                if (!a.Equals(b))
                {
                    T atimesB = this.Multiply(a, b, ctxdiv);
                    b = this.SquareRoot(atimesB, ctxdiv);
                }
                a = newA;
                guess = this.Multiply(aplusB, aplusB, null);
                guess = this.Divide(guess, this.Multiply(t, four, null), ctxdiv);
                T newGuess = guess;
                if ((object)lastGuess != (object)default(T))
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                      guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= 3;
                    }
                    lastCompare = guessCmp;
                }
                if (more)
                {
                    T tmpT = this.Multiply(valueAMinusNewA, valueAMinusNewA, null);
                    tmpT = this.Multiply(
                        tmpT,
                        this.helper.CreateNewWithFlags(powerTwo, EInteger.Zero, 0),
                        null);
                    t = this.Add(t, this.NegateRaw(tmpT), ctxdiv);
                    powerTwo <<= 1;
                }
                guess = newGuess;
            }
            return this.RoundToPrecision(guess, ctx);
        }

        public T Plus(T thisValue, EContext context)
        {
            return this.RoundToPrecisionInternal(
                thisValue,
                0,
                0,
                null,
                true,
                context);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            T ret = this.HandleNotANumber(thisValue, pow, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            int thisSign = this.helper.GetSign(thisValue);
            int powSign = this.helper.GetSign(pow);
            int thisFlags = this.helper.GetFlags(thisValue);
            int powFlags = this.helper.GetFlags(pow);
            if (thisSign == 0 && powSign == 0)
            {
                // Both operands are zero: invalid
                return this.SignalInvalid(ctx);
            }
            if (thisSign < 0 && (powFlags & BigNumberFlags.FlagInfinity) != 0)
            {
                // This value is negative and power is infinity: invalid
                return this.SignalInvalid(ctx);
            }
            if (thisSign > 0 && (thisFlags & BigNumberFlags.FlagInfinity) == 0 &&
              (powFlags & BigNumberFlags.FlagInfinity) != 0)
            {
                // Power is infinity and this value is greater than
                // zero and not infinity
                int cmp = this.CompareTo(thisValue, this.helper.ValueOf(1));
                if (cmp < 0)
                {
                    // Value is less than 1
                    if (powSign < 0)
                    {
                        // Power is negative infinity, return positive infinity
                        return this.helper.CreateNewWithFlags(
                            EInteger.Zero,
                            EInteger.Zero,
                            BigNumberFlags.FlagInfinity);
                    }
                    // Power is positive infinity, return 0
                    return this.RoundToPrecision(
                        this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                        ctx);
                }
                if (cmp == 0)
                {
                    // Extend the precision of the mantissa as much as possible,
                    // in the special case that this value is 1
                    return this.ExtendPrecision(this.helper.ValueOf(1), ctx);
                }
                // Value is greater than 1
                if (powSign > 0)
                {
                    // Power is positive infinity, return positive infinity
                    return pow;
                }
                // Power is negative infinity, return 0
                return this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                    ctx);
            }
            EInteger powExponent = this.helper.GetExponent(pow);
            bool isPowIntegral = powExponent.Sign > 0;
            var isPowOdd = false;
            T powInt = default(T);
            if (!isPowIntegral)
            {
                powInt = this.Quantize(
                    pow,
                    this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                    EContext.ForRounding(ERounding.Down));
                isPowIntegral = this.CompareTo(powInt, pow) == 0;
                isPowOdd = !this.helper.GetMantissa(powInt).IsEven;
            }
            else
            {
                if (powExponent.Equals(EInteger.Zero))
                {
                    isPowOdd = !this.helper.GetMantissa(powInt).IsEven;
                }
                else if (this.thisRadix % 2 == 0)
                {
                    // Never odd for even radixes
                    isPowOdd = false;
                }
                else
                {
                    // DebugUtility.Log("trying to quantize " + pow);
                    powInt = this.Quantize(
                        pow,
                        this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                        EContext.ForRounding(ERounding.Down));
                    isPowOdd = !this.helper.GetMantissa(powInt).IsEven;
                }
            }
            // DebugUtility.Log("pow=" + pow + " powint=" + powInt);
            bool isResultNegative = (thisFlags & BigNumberFlags.FlagNegative) != 0 &&
              (powFlags & BigNumberFlags.FlagInfinity) == 0 && isPowIntegral &&
              isPowOdd;
            if (thisSign == 0 && powSign != 0)
            {
                int infinityFlags = (powSign < 0) ? BigNumberFlags.FlagInfinity : 0;
                if (isResultNegative)
                {
                    infinityFlags |= BigNumberFlags.FlagNegative;
                }
                thisValue = this.helper.CreateNewWithFlags(
                    EInteger.Zero,
                    EInteger.Zero,
                    infinityFlags);
                if ((infinityFlags & BigNumberFlags.FlagInfinity) == 0)
                {
                    thisValue = this.RoundToPrecision(thisValue, ctx);
                }
                return thisValue;
            }
            if ((!isPowIntegral || powSign < 0) && (ctx == null ||
                !ctx.HasMaxPrecision))
            {
                // TODO: In next major version, support the case when:
                // - ctx is null or has unlimited precision, and
                // - thisValue is greater than 0.
                // This case is trivial: divide 1 by thisValue^abs(pow).
                const string ValueOutputMessage =
                  "ctx is null or has unlimited precision, " +
                  "and pow's exponent is not an integer or is negative";
                return this.SignalInvalidWithMessage(
                    ctx,
                    ValueOutputMessage);
            }
            if (thisSign < 0 && !isPowIntegral)
            {
                return this.SignalInvalid(ctx);
            }
            if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
            {
                // This value is infinity
                int negflag = isResultNegative ? BigNumberFlags.FlagNegative : 0;
                return (powSign > 0) ? this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(
                      EInteger.Zero,
                      EInteger.Zero,
                      negflag | BigNumberFlags.FlagInfinity),
                    ctx) : ((powSign < 0) ? this.RoundToPrecision(
                      this.helper.CreateNewWithFlags(
                        EInteger.Zero,
                        EInteger.Zero,
                        negflag),
                      ctx) : this.RoundToPrecision(
                      this.helper.CreateNewWithFlags(EInteger.One, EInteger.Zero, 0),
                      ctx));
            }
            if (powSign == 0)
            {
                return
                  this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(EInteger.One, EInteger.Zero, 0),
                    ctx);
            }
            if (isPowIntegral)
            {
                EInteger signedMant;
                // Special case for 1 in certain cases
                if (this.CompareTo(thisValue, this.helper.ValueOf(1)) == 0 &&
                  isPowIntegral)
                {
                    EInteger thisExponent = this.helper.GetExponent(thisValue);
                    if (thisExponent.Sign == 0)
                    {
                        return (!this.IsWithinExponentRangeForPow(pow, ctx)) ?
                          this.SignalInvalid(ctx) : this.helper.ValueOf(1);
                    }
                    else if (powExponent.Sign == 0)
                    {
                        if (!this.IsWithinExponentRangeForPow(pow, ctx))
                        {
                            return this.SignalInvalid(ctx);
                        }
                        signedMant = this.helper.GetMantissa(powInt).Abs();
                        return this.PowerIntegral(thisValue, signedMant, ctx);
                    }
                }
                // Very high values of pow and a very high exponent
                if (powExponent.CompareTo(10) > 0 &&
                  this.CompareTo(pow, this.helper.ValueOf(99999999)) > 0)
                {
                    EContext ctxCopy = ctx.WithBlankFlags().WithTraps(0);
                    // DebugUtility.Log("changing pow to 9999999*, ctx="+ctxCopy);
                    // Try doing Power with a smaller value for pow
                    T result = this.Power(
                        thisValue,
                        this.helper.ValueOf(isPowOdd ? 99999999 : 99999998),
                        ctxCopy);
                    if ((ctxCopy.Flags & EContext.FlagOverflow) != 0)
                    {
                        // Caused overflow
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= ctxCopy.Flags;
                        }
                        return result;
                    }
                }
                if ((object)powInt == (object)default(T))
                {
                    // DebugUtility.Log("no powInt, quantizing "+pow);
                    powInt = this.Quantize(
                        pow,
                        this.helper.CreateNewWithFlags(EInteger.Zero, EInteger.Zero, 0),
                        EContext.ForRounding(ERounding.Down));
                }
                signedMant = this.helper.GetMantissa(powInt);
                if (powSign < 0)
                {
                    signedMant = -signedMant;
                }
                // DebugUtility.Log("tv=" + thisValue + " mant=" + signedMant);
                return this.PowerIntegral(thisValue, signedMant, ctx);
            }
            // Special case for 1
            if (this.CompareTo(thisValue, this.helper.ValueOf(1)) == 0
      // && powSign > 0
      )
            {
                // DebugUtility.Log("Special case 1B");
                return (!this.IsWithinExponentRangeForPow(pow, ctx)) ?
                  this.SignalInvalid(ctx) :
                  this.ExtendPrecision(this.helper.ValueOf(1), ctx);
            }
#if DEBUG
            if (ctx == null)
            {
                throw new ArgumentNullException(nameof(ctx));
            }
#endif
            // Special case for 0.5
            if (this.thisRadix == 10 || this.thisRadix == 2)
            {
                T half = (this.thisRadix == 10) ? this.helper.CreateNewWithFlags(
                    (EInteger)5,
                    ValueMinusOne,
                    0) : this.helper.CreateNewWithFlags(
                      EInteger.One,
                      ValueMinusOne,
                      0);
                if (this.CompareTo(pow, half) == 0 &&
                  this.IsWithinExponentRangeForPow(pow, ctx) &&
                  this.IsWithinExponentRangeForPow(thisValue, ctx))
                {
                    EContext ctxCopy = ctx.WithBlankFlags();
                    thisValue = this.SquareRoot(thisValue, ctxCopy);
                    ctxCopy.Flags |= EContext.FlagInexact;
                    ctxCopy.Flags |= EContext.FlagRounded;
                    if ((ctxCopy.Flags & EContext.FlagSubnormal) != 0)
                    {
                        ctxCopy.Flags |= EContext.FlagUnderflow;
                    }
                    thisValue = this.ExtendPrecision(thisValue, ctxCopy);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxCopy.Flags;
                    }
                    return thisValue;
                }
            }
            EInteger guardDigits = this.WorkingDigits(EInteger.FromInt32(17));
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                ctx.Precision + guardDigits);
            if (ctx.Rounding != ERounding.Ceiling &&
              ctx.Rounding != ERounding.Floor)
            {
                ctxdiv = ctxdiv.WithRounding(ctx.Rounding)
                  .WithBlankFlags();
            }
            else
            {
                ctxdiv = ctxdiv.WithRounding(ERounding.Up)
                  .WithBlankFlags();
            }
            T lnresult = this.Ln(thisValue, ctxdiv);
            // DebugUtility.Log("rounding="+ctxdiv.Rounding);
            // DebugUtility.Log("before mul="+lnresult);
            lnresult = this.Multiply(lnresult, pow, ctxdiv);
            EInteger workingPrecision = ctxdiv.Precision;
            // Now use original precision and rounding mode
            ctxdiv = ctx.WithBlankFlags();
            // DebugUtility.Log("before exp="+lnresult);
            lnresult = this.Exp(lnresult, ctxdiv);
            // DebugUtility.Log("after exp.="+lnresult);
            if ((ctxdiv.Flags & (EContext.FlagClamped |
                  EContext.FlagOverflow)) != 0)
            {
                if (!this.IsWithinExponentRangeForPow(thisValue, ctx))
                {
                    return this.SignalInvalid(ctx);
                }
                if (!this.IsWithinExponentRangeForPow(pow, ctx))
                {
                    return this.SignalInvalid(ctx);
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= ctxdiv.Flags;
            }
            return lnresult;
        }

        private bool IsSubnormal(T value, EContext ctx)
        {
            bool flag = ctx == null || !ctx.HasMaxPrecision;
            bool result;
            if (flag)
            {
                result = false;
            }
            else
            {
                FastInteger fastInteger = FastInteger.FromBig(
                    this.helper.GetExponent(value));
                FastInteger val = FastInteger.FromBig(ctx.EMin);
                bool adjustExponent = ctx.AdjustExponent;
                if (adjustExponent)
                {
                    FastInteger digitLength =
                      this.helper.GetDigitLength(this.helper.GetMantissa(value));
                    fastInteger.Add(digitLength).SubtractInt(1);
                }
                result = fastInteger.CompareTo(val) < 0;
            }
            return result;
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, otherValue, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if (((thisFlags & otherFlags) & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.RoundToPrecision(thisValue, ctx);
                }
                // At this point, it's only the case that either value
                // is infinity
                return this.SignalInvalid(ctx);
            }
            EInteger expOther = this.helper.GetExponent(otherValue);
            if (ctx != null && !ctx.ExponentWithinRange(expOther))
            {
                // DebugUtility.Log("exp not within range");
                return this.SignalInvalidWithMessage(
                    ctx,
                    "Exponent not within exponent range: " + expOther);
            }
            EContext tmpctx = (ctx == null ?
                EContext.ForRounding(ERounding.HalfEven) :
                ctx.Copy()).WithBlankFlags();
            EInteger mantThis = this.helper.GetMantissa(thisValue);
            EInteger expThis = this.helper.GetExponent(thisValue);
            int expcmp = expThis.CompareTo(expOther);
            int negativeFlag = this.helper.GetFlags(thisValue) &
              BigNumberFlags.FlagNegative;
            T ret = default(T);
            if (expcmp == 0)
            {
                // DebugUtility.Log("exp same");
                ret = this.RoundToPrecision(thisValue, tmpctx);
            }
            else if (mantThis.IsZero)
            {
                // DebugUtility.Log("mant is 0");
                ret = this.helper.CreateNewWithFlags(
                    EInteger.Zero,
                    expOther,
                    negativeFlag);
                ret = this.RoundToPrecision(ret, tmpctx);
            }
            else if (expcmp > 0)
            {
                // Other exponent is less
                // DebugUtility.Log("other exp less");
                FastInteger radixPower =
                  FastInteger.FromBig(expThis).SubtractBig(expOther);
                if (tmpctx.Precision.Sign > 0 &&
                  radixPower.CompareTo(FastInteger.FromBig(tmpctx.Precision)
                    .AddInt(10)) > 0)
                {
                    // Radix power is much too high for the current precision
                    // DebugUtility.Log("result too high for prec:" +
                    // tmpctx.Precision + " radixPower= " + radixPower);
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result too high for current precision");
                }
                mantThis = this.TryMultiplyByRadixPower(mantThis, radixPower);
                if (mantThis == null)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result requires too much memory");
                }
                ret = this.helper.CreateNewWithFlags(mantThis, expOther, negativeFlag);
                ret = this.RoundToPrecision(ret, tmpctx);
            }
            else
            {
                // Other exponent is greater
                // DebugUtility.Log("other exp greater");
                FastInteger shift = FastInteger.FromBig(expOther).SubtractBig(
                    expThis);
                ret = this.RoundToPrecisionInternal(
                    thisValue,
                    0,
                    0,
                    shift,
                    false,
                    tmpctx);
            }
            if ((tmpctx.Flags & EContext.FlagOverflow) != 0)
            {
                // DebugUtility.Log("overflow occurred");
                return this.SignalInvalid(ctx);
            }
            if (ret == null || !this.helper.GetExponent(ret).Equals(expOther))
            {
                // DebugUtility.Log("exp not same "+ret);
                return this.SignalInvalid(ctx);
            }
            ret = this.EnsureSign(ret, negativeFlag != 0);
            if (ctx != null && ctx.HasFlags)
            {
                int flags = tmpctx.Flags;
                flags &= ~EContext.FlagUnderflow;
                bool flag12 = expcmp < 0 && !this.helper.GetMantissa(ret).IsZero &&
                  this.IsSubnormal(ret, ctx);
                if (flag12)
                {
                    flags |= EContext.FlagSubnormal;
                }
                ctx.Flags |= flags;
            }
            return ret;
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            return this.ReduceToPrecisionAndIdealExponent(
                thisValue,
                ctx,
                null,
                null);
        }

        public T Remainder(
          T thisValue,
          T divisor,
          EContext ctx,
          bool roundAfterDivide)
        {
            EContext ctx2 = ctx == null ? null : ctx.WithBlankFlags();
            T ret = this.RemainderHandleSpecial(thisValue, divisor, ctx2);
            if ((object)ret != (object)default(T))
            {
                TransferFlags(ctx, ctx2);
                return ret;
            }
            ret = this.DivideToIntegerZeroScale(
                thisValue,
                divisor,
                roundAfterDivide ? ctx2 : null);
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            ret = this.Add(
                thisValue,
                this.NegateRaw(this.Multiply(ret, divisor, null)),
                ctx2);
            ret = this.EnsureSign(
                ret,
                (this.helper.GetFlags(thisValue) & BigNumberFlags.FlagNegative) != 0);

            TransferFlags(
              ctx,
              ctx2);
            return ret;
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            EContext ctx2 = ctx == null ?
              EContext.ForRounding(ERounding.HalfEven).WithBlankFlags() :
              ctx.WithRounding(ERounding.HalfEven).WithBlankFlags();
            T ret = this.RemainderHandleSpecial(thisValue, divisor, ctx2);
            if ((object)ret != (object)default(T))
            {
                TransferFlags(ctx, ctx2);
                return ret;
            }
            ret = this.DivideInternal(
                thisValue,
                divisor,
                ctx2,
                IntegerModeFixedScale,
                EInteger.Zero);
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            ctx2 = ctx2.WithBlankFlags();
            ret = this.RoundToPrecision(ret, ctx2);
            if ((ctx2.Flags & (EContext.FlagRounded |
                  EContext.FlagInvalid)) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            ctx2 = ctx == null ? EContext.UnlimitedHalfEven.WithBlankFlags() :
              ctx.WithBlankFlags();
            T ret2 = this.Add(
                thisValue,
                this.NegateRaw(this.Multiply(ret, divisor, null)),
                ctx2);
            if ((ctx2.Flags & EContext.FlagInvalid) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            if (this.helper.GetFlags(ret2) == 0 &&
              this.helper.GetMantissa(ret2).IsZero)
            {
                ret2 = this.EnsureSign(
                  ret2,
                  (this.helper.GetFlags(thisValue) & BigNumberFlags.FlagNegative) != 0);
            }
            TransferFlags(
              ctx,
              ctx2);
            return ret2;
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            // DebugUtility.Log("RM RoundAfterConversion");
            return this.RoundToPrecision(thisValue, ctx);
        }

        public T RoundToExponentExact(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            if (this.helper.GetExponent(thisValue).CompareTo(expOther) >= 0)
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            else
            {
                EContext pctx = (ctx == null) ? null :
                  ctx.WithPrecision(0).WithBlankFlags();
                T ret = this.Quantize(
                    thisValue,
                    this.helper.CreateNewWithFlags(EInteger.One, expOther, 0),
                    pctx);
                if (ctx != null && ctx.HasFlags)
                {
                    ctx.Flags |= pctx.Flags;
                }
                return ret;
            }
        }

        public T RoundToExponentNoRoundedFlag(
          T thisValue,
          EInteger exponent,
          EContext ctx)
        {
            EContext pctx = (ctx == null) ? null : ctx.WithBlankFlags();
            T ret = this.RoundToExponentExact(thisValue, exponent, pctx);
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= pctx.Flags & ~(EContext.FlagInexact |
                    EContext.FlagRounded);
            }
            return ret;
        }

        public T RoundToExponentSimple(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, thisValue, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return thisValue;
                }
            }
            if (this.helper.GetExponent(thisValue).CompareTo(expOther) >= 0)
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            else
            {
                if (ctx != null && !ctx.ExponentWithinRange(expOther))
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Exponent not within exponent range: " + expOther);
                }
                FastInteger shift = FastInteger.FromBig(expOther)
                  .SubtractBig(this.helper.GetExponent(thisValue));
                if (shift.Sign == 0 && IsSimpleContext(ctx))
                {
                    return thisValue;
                }
                EInteger bigmantissa = this.helper.GetMantissa(thisValue);
                if (IsSimpleContext(ctx) && ctx.Rounding == ERounding.Down)
                {
                    EInteger shiftedmant = shift.CanFitInInt32() ?
                      bigmantissa.ShiftRight((int)shift.ToInt32()) :
                      bigmantissa.ShiftRight(shift.ToEInteger());
                    return this.helper.CreateNewWithFlags(
                        shiftedmant,
                        expOther,
                        thisFlags);
                }
                else
                {
                    IShiftAccumulator accum =
                      this.helper.CreateShiftAccumulatorWithDigits(bigmantissa, 0, 0);
                    accum.TruncateOrShiftRight(
                      shift,
                      false);
                    bigmantissa = accum.ShiftedInt;
                    thisValue = this.helper.CreateNewWithFlags(
                        bigmantissa,
                        expOther,
                        thisFlags);
                    return this.RoundToPrecisionInternal(
                        thisValue,
                        accum.LastDiscardedDigit,
                        accum.OlderDiscardedDigits,
                        null,
                        false,
                        ctx);
                }
            }
        }

        public T RoundToPrecision(T thisValue, EContext context)
        {
            return this.RoundToPrecisionInternal(
                thisValue,
                0,
                0,
                null,
                false,
                context);
        }

        private T Root(T thisValue, int root, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            T ret = this.SquareRootHandleSpecial(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctxtmp = ctx.WithBlankFlags();
            EInteger currentExp = this.helper.GetExponent(thisValue);
            EInteger origExp = currentExp;
            EInteger idealExp;
            idealExp = currentExp;
            idealExp /= EInteger.FromInt32(root);
            if (currentExp.Sign < 0 && !currentExp.IsEven)
            {
                // Round towards negative infinity; BigInteger's
                // division operation rounds towards zero
                idealExp -= EInteger.One;
            }
            // DebugUtility.Log("curr=" + currentExp + " ideal=" + idealExp);
            if (this.helper.GetSign(thisValue) == 0)
            {
                ret = this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(
                      EInteger.Zero,
                      idealExp,
                      this.helper.GetFlags(thisValue)),
                    ctxtmp);
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctxtmp.Flags;
                }
                return ret;
            }
            EInteger mantissa = this.helper.GetMantissa(thisValue);
            FastInteger digitCount = this.helper.GetDigitLength(mantissa);
            FastInteger targetPrecision = FastInteger.FromBig(ctx.Precision);
            FastInteger precision = targetPrecision.Copy().Multiply(root).AddInt(2);
            var rounded = false;
            var inexact = false;
            if (digitCount.CompareTo(precision) < 0)
            {
                FastInteger diff = precision.Copy().Subtract(digitCount);
                // DebugUtility.Log(diff);
                if ((!diff.IsEvenNumber) ^ (!origExp.IsEven))
                {
                    diff.Increment();
                }
                EInteger bigdiff = diff.ToEInteger();
                currentExp -= (EInteger)bigdiff;
                mantissa = this.TryMultiplyByRadixPower(mantissa, diff);
                if (mantissa == null)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result requires too much memory");
                }
            }
            EInteger[] sr = mantissa.RootRem(root);
            digitCount = this.helper.GetDigitLength(sr[0]);
            EInteger rootRemainder = sr[1];
            // DebugUtility.Log("I " + mantissa + " -> " + sr[0] + " [target="+
            // targetPrecision + "], (zero= " + rootRemainder.IsZero +") "
            mantissa = sr[0];
            if (!rootRemainder.IsZero)
            {
                rounded = true;
                inexact = true;
            }
            EInteger oldexp = currentExp;
            currentExp = currentExp.ShiftRight(1);
            if (oldexp.Sign < 0 && !oldexp.IsEven)
            {
                // Round towards negative infinity; BigInteger's
                // division operation rounds towards zero
                currentExp -= EInteger.One;
            }
            T retval = this.helper.CreateNewWithFlags(mantissa, currentExp, 0);
            // DebugUtility.Log("idealExp= " + idealExp + ", curr" + currentExp
            // +" guess= " + mantissa);
            retval = this.RoundToPrecisionInternal(
                retval,
                0,
                inexact ? 1 : 0,
                null,
                false,
                ctxtmp);
            currentExp = this.helper.GetExponent(retval);
            // DebugUtility.Log("guess I " + guess + " idealExp=" + idealExp
            // +", curr " + currentExp + " clamped= " +
            // (ctxtmp.Flags&PrecisionContext.FlagClamped));
            if ((ctxtmp.Flags & EContext.FlagUnderflow) == 0)
            {
                int expcmp = currentExp.CompareTo(idealExp);
                if (expcmp <= 0 || !this.IsFinite(retval))
                {
                    retval = this.ReduceToPrecisionAndIdealExponent(
                        retval,
                        ctx.HasExponentRange ? ctxtmp : null,
                        inexact ? targetPrecision : null,
                        FastInteger.FromBig(idealExp));
                }
            }
            if (ctx.HasFlags)
            {
                if (ctx.ClampNormalExponents &&
                  !this.helper.GetExponent(retval).Equals(idealExp) && (ctxtmp.Flags &
                    EContext.FlagInexact) == 0)
                {
                    ctx.Flags |= EContext.FlagClamped;
                }
                rounded |= (ctxtmp.Flags & EContext.FlagOverflow) != 0;
                // DebugUtility.Log("guess II " + guess);
                currentExp = this.helper.GetExponent(retval);
                if (rounded)
                {
                    ctxtmp.Flags |= EContext.FlagRounded;
                }
                else
                {
                    if (currentExp.CompareTo(idealExp) > 0)
                    {
                        // Greater than the ideal, treat as rounded anyway
                        ctxtmp.Flags |= EContext.FlagRounded;
                    }
                    else
                    {
                        // DebugUtility.Log("idealExp= " + idealExp + ", curr" +
                        // currentExp + " (II)");
                        ctxtmp.Flags &= ~EContext.FlagRounded;
                    }
                }
                if (inexact)
                {
                    ctxtmp.Flags |= EContext.FlagRounded;
                    ctxtmp.Flags |= EContext.FlagInexact;
                }
                ctx.Flags |= ctxtmp.Flags;
            }
            return retval;
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            if (ctx == null)
            {
                return this.SignalInvalidWithMessage(ctx, "ctx is null");
            }
            if (!ctx.HasMaxPrecision)
            {
                return this.SignalInvalidWithMessage(
                    ctx,
                    "ctx has unlimited precision");
            }
            T ret = this.SquareRootHandleSpecial(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctxtmp = ctx.WithBlankFlags();
            EInteger currentExp = this.helper.GetExponent(thisValue);
            EInteger origExp = currentExp;
            EInteger idealExp;
            idealExp = currentExp;
            idealExp /= (EInteger)2;
            if (currentExp.Sign < 0 && !currentExp.IsEven)
            {
                // Round towards negative infinity; BigInteger's
                // division operation rounds towards zero
                idealExp -= EInteger.One;
            }
            // DebugUtility.Log("curr=" + currentExp + " ideal=" + idealExp);
            if (this.helper.GetSign(thisValue) == 0)
            {
                ret = this.RoundToPrecision(
                    this.helper.CreateNewWithFlags(
                      EInteger.Zero,
                      idealExp,
                      this.helper.GetFlags(thisValue)),
                    ctxtmp);
                if (ctx.HasFlags)
                {
                    ctx.Flags |= ctxtmp.Flags;
                }
                return ret;
            }
            EInteger mantissa = this.helper.GetMantissa(thisValue);
            FastInteger digitCount = this.helper.GetDigitLength(mantissa);
            FastInteger targetPrecision = FastInteger.FromBig(ctx.Precision);
            FastInteger precision = targetPrecision.Copy().Multiply(2).AddInt(2);
            var rounded = false;
            var inexact = false;
            if (digitCount.CompareTo(precision) < 0)
            {
                FastInteger diff = precision.Copy().Subtract(digitCount);
                // DebugUtility.Log("precisiondiff=" + diff);
                if ((!diff.IsEvenNumber) ^ (!origExp.IsEven))
                {
                    diff.Increment();
                }
                EInteger bigdiff = diff.ToEInteger();
                currentExp -= (EInteger)bigdiff;
                mantissa = this.TryMultiplyByRadixPower(mantissa, diff);
                if (mantissa == null)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result requires too much memory");
                }
            }
            EInteger[] sr = mantissa.SqrtRem();
            digitCount = this.helper.GetDigitLength(sr[0]);
            EInteger squareRootRemainder = sr[1];
            // DebugUtility.Log("I " + mantissa + " -> " + sr[0] +
            // " [target="+
            // targetPrecision + "], (zero= " +
            // squareRootRemainder.IsZero +") ");
            mantissa = sr[0];
            if (!squareRootRemainder.IsZero)
            {
                rounded = true;
                inexact = true;
            }
            EInteger oldexp = currentExp;
            currentExp = currentExp.ShiftRight(1);
            if (oldexp.Sign < 0 && !oldexp.IsEven)
            {
                // Round towards negative infinity; BigInteger's
                // division operation rounds towards zero
                currentExp -= EInteger.One;
            }
            T retval = this.helper.CreateNewWithFlags(mantissa, currentExp, 0);
            // DebugUtility.Log("idealExp= " + idealExp + ", curr" + currentExp
            // +" guess= " + mantissa);
            retval = this.RoundToPrecisionInternal(
                retval,
                0,
                inexact ? 1 : 0,
                null,
                false,
                ctxtmp);
            currentExp = this.helper.GetExponent(retval);
            // DebugUtility.Log("guess I " + guess + " idealExp=" + idealExp
            // +", curr " + currentExp + " clamped= " +
            // (ctxtmp.Flags&PrecisionContext.FlagClamped));
            if ((ctxtmp.Flags & EContext.FlagUnderflow) == 0)
            {
                int expcmp = currentExp.CompareTo(idealExp);
                if (expcmp <= 0 || !this.IsFinite(retval))
                {
                    retval = this.ReduceToPrecisionAndIdealExponent(
                        retval,
                        ctx.HasExponentRange ? ctxtmp : null,
                        inexact ? targetPrecision : null,
                        FastInteger.FromBig(idealExp));
                }
            }
            if (ctx.HasFlags)
            {
                if (ctx.ClampNormalExponents &&
                  !this.helper.GetExponent(retval).Equals(idealExp) && (ctxtmp.Flags &
                    EContext.FlagInexact) == 0)
                {
                    ctx.Flags |= EContext.FlagClamped;
                }
                rounded |= (ctxtmp.Flags & EContext.FlagOverflow) != 0;
                // DebugUtility.Log("guess II " + guess);
                currentExp = this.helper.GetExponent(retval);
                if (rounded)
                {
                    ctxtmp.Flags |= EContext.FlagRounded;
                }
                else
                {
                    if (currentExp.CompareTo(idealExp) > 0)
                    {
                        // Greater than the ideal, treat as rounded anyway
                        ctxtmp.Flags |= EContext.FlagRounded;
                    }
                    else
                    {
                        // DebugUtility.Log("idealExp= " + idealExp + ", curr" +
                        // currentExp + " (II)");
                        ctxtmp.Flags &= ~EContext.FlagRounded;
                    }
                }
                if (inexact)
                {
                    ctxtmp.Flags |= EContext.FlagRounded;
                    ctxtmp.Flags |= EContext.FlagInexact;
                }
                ctx.Flags |= ctxtmp.Flags;
            }
            return retval;
        }

        private static int CompareToFast(
          int e1int,
          int e2int,
          int expcmp,
          int signA,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Mantissa,
          int radix)
        {
            int m1, m2;
            // DebugUtility.Log("" + (// e1int) + " " + e2int + ", expcmp=" +
            // expcmp + ", signA=" + signA + ", om=" + op1Mantissa + ", " +
            // op2Mantissa);
            if (e1int >= SafeMin32 && e1int <= SafeMax32 &&
              e2int >= SafeMin32 && e2int <= SafeMax32)
            {
                int ediff = (e1int > e2int) ? (e1int - e2int) : (e2int - e1int);
                if (ediff <= 9 && radix == 10)
                {
                    int power = ValueTenPowers[ediff];
                    int maxoverflow = OverflowMaxes[ediff];
                    if (expcmp > 0)
                    {
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        if (m1 <= maxoverflow)
                        {
                            m1 *= power;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                    else
                    {
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        if (m2 <= maxoverflow)
                        {
                            m2 *= power;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                }
                else if (ediff <= 30 && radix == 2)
                {
                    int mask = BitMasks[ediff];
                    if (expcmp > 0)
                    {
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        if ((m1 & mask) == m1)
                        {
                            m1 <<= ediff;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                    else
                    {
                        m1 = op1Mantissa.ToInt32();
                        m2 = op2Mantissa.ToInt32();
                        if ((m2 & mask) == m2)
                        {
                            m2 <<= ediff;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                }
            }
            return 2;
        }

        private static int CompareToFast64(
          int e1int,
          int e2int,
          int expcmp,
          int signA,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Mantissa,
          int radix)
        {
            long m1, m2;
            // DebugUtility.Log("" + (// e1int) + " " + e2int + ", expcmp=" +
            // expcmp + ", signA=" + signA + ", om=" + op1Mantissa + ", " +
            // op2Mantissa);
            if (e1int >= SafeMin32 && e1int <= SafeMax32 &&
              e2int >= SafeMin32 && e2int <= SafeMax32)
            {
                long ediffLong = (e1int > e2int) ? (e1int - e2int) : (e2int - e1int);
                if (ediffLong <= 18 && radix == 10)
                {
                    long power = ValueTenPowers64[(int)ediffLong];
                    long maxoverflow = OverflowMaxes64[(int)ediffLong];
                    if (expcmp > 0)
                    {
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        // DebugUtility.Log("overflowmax " + maxoverflow + " for " + m1);
                        if (m1 <= maxoverflow)
                        {
                            m1 *= power;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                    else
                    {
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        // DebugUtility.Log("overflowmax " + maxoverflow + " for " + m2);
                        if (m2 <= maxoverflow)
                        {
                            m2 *= power;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                }
                else if (ediffLong <= 62 && radix == 2)
                {
                    long mask = BitMasks64[(int)ediffLong];
                    if (expcmp > 0)
                    {
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        if ((m1 & mask) == m1)
                        {
                            m1 <<= (int)ediffLong;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                    else
                    {
                        m1 = op1Mantissa.ToInt64();
                        m2 = op2Mantissa.ToInt64();
                        if ((m2 & mask) == m2)
                        {
                            m2 <<= (int)ediffLong;
                            return (m1 == m2) ? 0 : ((m1 < m2) ? -signA : signA);
                        }
                    }
                }
            }
            return 2;
        }

        private static int CompareToSlow<TMath>(
          EInteger op1Exponent,
          EInteger op2Exponent,
          int expcmp,
          int signA,
          EInteger op1Mantissa,
          EInteger op2Mantissa,
          IRadixMathHelper<TMath> helper,
          bool reportOOM)
        {
#if DEBUG
            if (op1Mantissa.IsZero)
            {
                throw new InvalidOperationException();
            }
            if (op2Mantissa.IsZero)
            {
                throw new InvalidOperationException();
            }
#endif
            long bitExp1 = op1Exponent.GetUnsignedBitLengthAsInt64();
            long bitExp2 = op2Exponent.GetUnsignedBitLengthAsInt64();
            if (bitExp1 < Int64.MaxValue && bitExp2 < Int64.MaxValue &&
              helper.GetRadix() <= 10 && op1Exponent.Sign == op2Exponent.Sign && (
                (bitExp2 > bitExp1 && (bitExp2 - bitExp1) > 128) ||
                (bitExp1 > bitExp2 && (bitExp1 - bitExp2) > 128)))
            {
                // Bit difference in two exponents means exponent difference
                // is so big that the digit counts of the two significands
                // can't keep up (that is, exponent difference is greater than 2^128,
                // which is more than the maximum number of bits that
                // a significand can currently have).
                bool op2bigger = op1Exponent.Sign < 0 ? (bitExp2 < bitExp1) :
                  (bitExp2 > bitExp1);
                if (op2bigger)
                {
                    // operand 2 has greater magnitude
                    return signA < 0 ? 1 : -1;
                }
                else
                {
                    // operand 1 has greater magnitude
                    return signA < 0 ? -1 : 1;
                }
            }
            FastInteger fastOp1Exp = FastInteger.FromBig(op1Exponent);
            FastInteger fastOp2Exp = FastInteger.FromBig(op2Exponent);
            FastInteger expdiff = fastOp1Exp.Copy().Subtract(fastOp2Exp).Abs();
            // Check if exponent difference is too big for
            // radix-power calculation to work quickly
            if (expdiff.CompareToInt(200) >= 0)
            {
                EInteger op1MantAbs = op1Mantissa;
                EInteger op2MantAbs = op2Mantissa;
                FastInteger[] op1DigitBounds =
                  NumberUtility.DigitLengthBounds(helper, op1MantAbs);
                FastInteger[] op2DigitBounds =
                  NumberUtility.DigitLengthBounds(helper, op2MantAbs);
                FastInteger op2ExpUpperBound = fastOp2Exp.Copy().Add(
                    op2DigitBounds[1]);
                FastInteger op1ExpLowerBound = fastOp1Exp.Copy().Add(
                    op1DigitBounds[0]);
                if (op2ExpUpperBound.CompareTo(op1ExpLowerBound) < 0)
                {
                    // Operand 2's magnitude can't reach highest digit of operand 1,
                    // meaning operand 1 has a greater magnitude
                    return signA < 0 ? -1 : 1;
                }
                FastInteger op1ExpUpperBound = fastOp1Exp.Copy().Add(
                    op1DigitBounds[1]);
                FastInteger op2ExpLowerBound = fastOp2Exp.Copy().Add(
                    op2DigitBounds[0]);
                // DebugUtility.Log("1ub="+op1ExpUpperBound +
                // " 2lb="+op2ExpLowerBound);
                if (op1ExpUpperBound.CompareTo(op2ExpLowerBound) < 0)
                {
                    // Operand 1's magnitude can't reach highest digit of operand 2,
                    // meaning operand 2 has a greater magnitude
                    return signA < 0 ? 1 : -1;
                }
                FastInteger precision1 =
                  op1DigitBounds[0].CompareTo(op1DigitBounds[1]) == 0 ?
                  op1DigitBounds[0] : helper.GetDigitLength(op1MantAbs);
                FastInteger precision2 =
                  op2DigitBounds[0].CompareTo(op2DigitBounds[1]) == 0 ?
                  op2DigitBounds[0] : helper.GetDigitLength(op2MantAbs);
                FastInteger exp1 = fastOp1Exp.Copy().Add(precision1).Decrement();
                FastInteger exp2 = fastOp2Exp.Copy().Add(precision2).Decrement();
                int adjcmp = exp1.CompareTo(exp2);
                if (adjcmp != 0)
                {
                    // DebugUtility.Log("cmp=" + ((signA < 0) ? -adjcmp : adjcmp));
                    return (signA < 0) ? -adjcmp : adjcmp;
                }
                FastInteger maxPrecision = null;
                maxPrecision = (precision1.CompareTo(precision2) > 0) ? precision1 :
                  precision2;
                // If exponent difference is greater than the
                // maximum precision of the two operands
                if (expdiff.Copy().CompareTo(maxPrecision) > 0)
                {
                    int expcmp2 = fastOp1Exp.CompareTo(fastOp2Exp);
                    if (expcmp2 < 0)
                    {
                        if (!op2MantAbs.IsZero)
                        {
                            // first operand's exponent is less
                            // and second operand isn't zero
                            // second mantissa will be shifted by the exponent
                            // difference
                            FastInteger digitLength1 = helper.GetDigitLength(
                                op1MantAbs);
                            if (fastOp1Exp.Copy().Add(digitLength1).AddInt(2)
                              .CompareTo(fastOp2Exp) < 0)
                            {
                                // first operand's mantissa can't reach the
                                // second operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastInteger tmp = fastOp2Exp.Copy()
                                  .SubtractInt(8).Subtract(digitLength1).Subtract(
                                    maxPrecision);
                                FastInteger newDiff = tmp.Copy().Subtract(fastOp2Exp).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // At this point, both operands have the same sign
                                    // DebugUtility.Log("cmp case 1=" + ((signA < 0) ? 1 : -1));
                                    return (signA < 0) ? 1 : -1;
                                }
                            }
                        }
                    }
                    else if (expcmp2 > 0)
                    {
                        if (!op1MantAbs.IsZero)
                        {
                            // first operand's exponent is greater
                            // and second operand isn't zero
                            // first mantissa will be shifted by the exponent
                            // difference
                            FastInteger digitLength2 = helper.GetDigitLength(
                                op2MantAbs);
                            if (fastOp2Exp.Copy()
                              .Add(digitLength2).AddInt(2).CompareTo(fastOp1Exp) <
                              0)
                            {
                                // second operand's mantissa can't reach the
                                // first operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastInteger tmp = fastOp1Exp.Copy()
                                  .SubtractInt(8).Subtract(digitLength2).Subtract(
                                    maxPrecision);
                                FastInteger newDiff = tmp.Copy().Subtract(fastOp1Exp).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // At this point, both operands have the same sign
                                    // DebugUtility.Log("cmp case 2=" + ((signA < 0) ? -1 : 1));
                                    return (signA < 0) ? -1 : 1;
                                }
                            }
                        }
                    }
                    expcmp = op1Exponent.CompareTo((EInteger)op2Exponent);
                }
                // DebugUtility.Log("must rescale, expcmp=" + (expcmp));
            }
            if (expcmp > 0)
            {
                // if ((op1Exponent-op2Exponent).Abs() > 10) {
                // DebugUtility.Log("" + op1Mantissa + " " + op2Mantissa + " [exp="
                // + op1Exponent + " " + op2Exponent + "]");
                // }
                EInteger newmant = RescaleByExponentDiff(
                    op1Mantissa,
                    op1Exponent,
                    op2Exponent,
                    helper);
                if (newmant == null)
                {
                    if (reportOOM)
                    {
                        throw new OutOfMemoryException("Result requires too much memory");
                    }
                    return -2;
                }
                int mantcmp = newmant.CompareTo(op2Mantissa);
                return (signA < 0) ? -mantcmp : mantcmp;
            }
            else
            {
                // if ((op1Exponent-op2Exponent).Abs() > 10) {
                // DebugUtility.Log("" + op1Mantissa + " " + op2Mantissa + " [exp="
                // + op1Exponent + " " + op2Exponent + "]");
                // }
                EInteger newmant = RescaleByExponentDiff(
                    op2Mantissa,
                    op1Exponent,
                    op2Exponent,
                    helper);
                if (newmant == null)
                {
                    if (reportOOM)
                    {
                        throw new OutOfMemoryException("Result requires too much memory");
                    }
                    return -2;
                }
                int mantcmp = op1Mantissa.CompareTo(newmant);
                return (signA < 0) ? -mantcmp : mantcmp;
            }
        }

        private static bool IsNullOrSimpleContext(EContext ctx)
        {
            return ctx == null || ctx == EContext.UnlimitedHalfEven ||
              (!ctx.HasExponentRange && !ctx.HasMaxPrecision && ctx.Traps == 0 &&
                !ctx.HasFlags);
        }

        private static bool IsSimpleContext(EContext ctx)
        {
            return ctx != null && (ctx == EContext.UnlimitedHalfEven ||
                (!ctx.HasExponentRange && !ctx.HasMaxPrecision && ctx.Traps == 0 &&
                  !ctx.HasFlags));
        }

        private static EInteger PowerOfTwo(FastInteger fi)
        {
            if (fi.Sign <= 0)
            {
                return EInteger.One;
            }
            if (fi.CanFitInInt32())
            {
                return EInteger.One.ShiftLeft(fi.ToInt32());
            }
            else
            {
                return EInteger.One.ShiftLeft(fi.ToEInteger());
            }
        }

        // Calculated as floor(ln(i)*100/ln(2)), except the
        // entry at i is 0.
        private static readonly int[] BitsPerDigit = {
      0, 0, 100, 158, 200, 232, 258, 280, 300, 316, 332,
    };

        private static FastIntegerFixed RescaleByExponentDiff<TMath>(
          FastIntegerFixed mantissa,
          FastIntegerFixed fe1,
          FastIntegerFixed fe2,
          IRadixMathHelper<TMath> helper)
        {
            if (mantissa.Sign == 0)
            {
                return FastIntegerFixed.FromInt32(0);
            }
            // DebugUtility.Log("RescaleByExponentDiff "+fe1+" "+fe2);
            FastIntegerFixed eidiff = fe1.Subtract(fe2).Abs();
            EInteger eiBitCount =
              mantissa.ToEInteger().GetUnsignedBitLengthAsEInteger();
            EInteger eidiffBigInt = eidiff.ToEInteger();
            // NOTE: For radix 10, each digit fits less than 1 byte; the
            // supported byte length is thus less than the maximum value
            // of a 32-bit integer (2GB).
            if (helper.GetRadix() <= 10)
            {
                int radix = helper.GetRadix();
                eiBitCount = eiBitCount.Add(eidiffBigInt.Multiply(BitsPerDigit[radix])
                    .Divide(100));
                // DebugUtility.Log(""+eiBitCount);
                if (eiBitCount.CompareTo(Int32.MaxValue) > 0)
                {
                    return null;
                }
            }
            return helper.MultiplyByRadixPowerFastInt(mantissa, eidiff);
        }

        private static EInteger RescaleByExponentDiff<TMath>(
          EInteger mantissa,
          EInteger e1,
          EInteger e2,
          IRadixMathHelper<TMath> helper)
        {
            if (mantissa.Sign == 0)
            {
                return EInteger.Zero;
            }
            // DebugUtility.Log("RescaleByExponentDiff "+e1+" "+e2);
            FastInteger diff = FastInteger.FromBig(e1).SubtractBig(e2).Abs();
            EInteger eiBitCount = mantissa.GetUnsignedBitLengthAsEInteger();
            EInteger eidiffBigInt = diff.ToEInteger();
            // NOTE: For radix 10, each digit fits less than 1 byte; the
            // supported byte length is thus less than the maximum value
            // of a 32-bit integer (2GB).
            if (helper.GetRadix() <= 10)
            {
                int radix = helper.GetRadix();
                eiBitCount = eiBitCount.Add(eidiffBigInt.Multiply(BitsPerDigit[radix])
                    .Divide(100));
                // DebugUtility.Log(""+eiBitCount);
                if (eiBitCount.CompareTo(Int32.MaxValue) > 0)
                {
                    return null;
                }
            }
            return helper.MultiplyByRadixPower(mantissa, diff);
        }

        private static EContext SetPrecisionIfLimited(
          EContext ctx,
          EInteger bigPrecision)
        {
            return (ctx == null || !ctx.HasMaxPrecision) ? ctx :
              ctx.WithBigPrecision(bigPrecision);
        }

        private static void TransferFlags(
          EContext ctxDst,
          EContext ctxSrc)
        {
            if (ctxDst != null && ctxDst.HasFlags)
            {
                if ((ctxSrc.Flags & (EContext.FlagInvalid |
                      EContext.FlagDivideByZero)) != 0)
                {
                    ctxDst.Flags |= ctxSrc.Flags & (EContext.FlagInvalid |
                        EContext.FlagDivideByZero);
                }
                else
                {
                    ctxDst.Flags |= ctxSrc.Flags;
                }
            }
        }

        public T Abs(T value, EContext ctx)
        {
            int flags = this.helper.GetFlags(value);
            if ((flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(value, ctx);
            }
            else if ((flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return this.ReturnQuietNaN(
                    value,
                    ctx);
            }
            T ret = ((flags & BigNumberFlags.FlagNegative) != 0) ?
              this.helper.CreateNewWithFlags(
                this.helper.GetMantissa(value),
                this.helper.GetExponent(value),
                flags & ~BigNumberFlags.FlagNegative) :
              value;
            return this.RoundToPrecision(ret, ctx);
        }

        private T AbsRaw(T value)
        {
            return this.EnsureSign(value, false);
        }

        // mant1 and mant2 are assumed to be nonnegative
        private T AddCore2(
          FastIntegerFixed mant1,
          FastIntegerFixed mant2,
          FastIntegerFixed exponent,
          int flags1,
          int flags2,
          EContext ctx)
        {
#if DEBUG
            if (mant1.Sign < 0)
            {
                throw new InvalidOperationException();
            }
            if (mant2.Sign < 0)
            {
                throw new InvalidOperationException();
            }
#endif
            bool neg1 = (flags1 & BigNumberFlags.FlagNegative) != 0;
            bool neg2 = (flags2 & BigNumberFlags.FlagNegative) != 0;
            var negResult = false;
            // DebugUtility.Log("neg1=" + neg1 + " neg2=" + neg2);
            if (neg1 != neg2)
            {
                // Signs are different, treat as a subtraction
                mant1 = FastIntegerFixed.Subtract(mant1, mant2);
                int mant1Sign = mant1.Sign;
                if (mant1Sign < 0)
                {
                    negResult = !neg1;
                    mant1 = mant1.Negate();
                }
                else if (mant1Sign == 0)
                {
                    // Result is negative zero
                    negResult = neg1 ^ neg2;
                    if (negResult)
                    {
                        negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                            ctx.Rounding == ERounding.Floor);
                    }
                }
                else
                {
                    negResult = neg1;
                }
            }
            else
            {
                // Signs are same, treat as an addition
                mant1 = FastIntegerFixed.Add(mant1, mant2);
                negResult = neg1;
                if (negResult && mant1.IsValueZero)
                {
                    // Result is negative zero
                    negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                        ctx.Rounding == ERounding.Floor);
                }
            }
            // DebugUtility.Log("mant1= " + mant1 + " exp= " + exponent +" neg= "+
            // (negResult));
            return this.helper.CreateNewWithFlagsFastInt(
                mant1,
                exponent,
                negResult ? BigNumberFlags.FlagNegative : 0);
        }

        // mant1 and mant2 are assumed to be nonnegative
        private T AddCore(
          EInteger mant1,
          EInteger mant2,
          EInteger exponent,
          int flags1,
          int flags2,
          EContext ctx)
        {
#if DEBUG
            if (mant1.Sign < 0)
            {
                throw new InvalidOperationException();
            }
            if (mant2.Sign < 0)
            {
                throw new InvalidOperationException();
            }
#endif
            bool neg1 = (flags1 & BigNumberFlags.FlagNegative) != 0;
            bool neg2 = (flags2 & BigNumberFlags.FlagNegative) != 0;
            var negResult = false;
            // DebugUtility.Log("neg1=" + neg1 + " neg2=" + neg2);
            if (neg1 != neg2)
            {
                // Signs are different, treat as a subtraction
                // DebugUtility.Log("sub " + mant1 + " " + mant2);
                mant1 = mant1.Subtract(mant2);
                int mant1Sign = mant1.Sign;
                negResult = neg1 ^ (mant1Sign == 0 ? neg2 : (mant1Sign < 0));
                if (mant1Sign < 0)
                {
                    mant1 = mant1.Negate();
                }
            }
            else
            {
                // Signs are same, treat as an addition
                // DebugUtility.Log("add " + mant1 + " " + mant2);
                mant1 = mant1.Add(mant2);
                negResult = neg1;
            }
            if (negResult && mant1.IsZero)
            {
                // Result is negative zero
                negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                    ctx.Rounding == ERounding.Floor);
            }
            // DebugUtility.Log("mant1= " + mant1 + " exp= " + exponent +" neg= "+
            // (negResult));
            return this.helper.CreateNewWithFlags(
                mant1,
                exponent,
                negResult ? BigNumberFlags.FlagNegative : 0);
        }

        // mant1 and mant2 are assumed to be nonnegative
        private T AddCore(
          FastIntegerFixed fmant1,
          FastIntegerFixed fmant2,
          FastIntegerFixed exponent,
          int flags1,
          int flags2,
          EContext ctx)
        {
#if DEBUG
            if (fmant1.Sign < 0)
            {
                throw new InvalidOperationException();
            }
            if (fmant2.Sign < 0)
            {
                throw new InvalidOperationException();
            }
#endif
            bool neg1 = (flags1 & BigNumberFlags.FlagNegative) != 0;
            bool neg2 = (flags2 & BigNumberFlags.FlagNegative) != 0;
            var negResult = false;
            // DebugUtility.Log("neg1=" + neg1 + " neg2=" + neg2);
            if (neg1 != neg2)
            {
                // Signs are different, treat as a subtraction
                fmant1 = fmant1.Subtract(fmant2);
                int mant1Sign = fmant1.Sign;
                negResult = neg1 ^ (mant1Sign == 0 ? neg2 : (mant1Sign < 0));
                if (mant1Sign < 0)
                {
                    fmant1 = fmant1.Negate();
                }
            }
            else
            {
                // Signs are same, treat as an addition
                fmant1 = fmant1.Add(fmant2);
                negResult = neg1;
            }
            if (negResult && fmant1.IsValueZero)
            {
                // Result is negative zero
                negResult &= (neg1 && neg2) || ((neg1 ^ neg2) && ctx != null &&
                    ctx.Rounding == ERounding.Floor);
            }
            return this.helper.CreateNewWithFlagsFastInt(
                fmant1,
                exponent,
                negResult ? BigNumberFlags.FlagNegative : 0);
        }

        private static FastInteger ToFastInteger(FastIntegerFixed fif)
        {
            if (fif.CanFitInInt32())
            {
                return new FastInteger(fif.ToInt32());
            }
            else
            {
                return FastInteger.FromBig(fif.ToEInteger());
            }
        }

        private T AddExDiffExp(
          FastIntegerFixed op1Exponent,
          FastIntegerFixed op1Mantissa,
          FastIntegerFixed op2Exponent,
          FastIntegerFixed op2Mantissa,
          int thisFlags,
          int otherFlags,
          EContext ctx,
          int expcmp,
          bool roundToOperandPrecision)
        {
            /* #if DEBUG (!(op1Mantissa.Sign >= 0)) {
              throw new ArgumentException("doesn't satisfy op1Mantissa.Sign >= 0");
            }
            if (!(op2Mantissa.Sign >= 0)) {
              throw new ArgumentException("doesn't satisfy op2Mantissa.Sign >= 0");
            }
            #endif

            */
            T retval = default(T);
            // choose the minimum exponent
            FastIntegerFixed resultExponent = expcmp < 0 ?
              op1Exponent : op2Exponent;
            // DebugUtility.Log("[" + op1Mantissa + "," + op1Exponent + "], [" +
            // op2Mantissa + ", " + op2Exponent + "] -> " + resultExponent);
            if (ctx != null && ctx.HasMaxPrecision && ctx.Precision.Sign > 0)
            {
                FastIntegerFixed expdiff = op1Exponent.Subtract(op2Exponent).Abs();
                // Check if exponent difference is too big for
                // radix-power calculation to work quickly
                bool op2IsZero = op2Mantissa.IsValueZero;
                bool op1IsZero = op1Mantissa.IsValueZero;
                int thisSign = op1IsZero ? 0 : (((thisFlags &
                        BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
                int otherSign = op2IsZero ? 0 : (((otherFlags &
                        BigNumberFlags.FlagNegative) != 0) ? -1 : 1);
                bool moreDistantThanPrecision = expdiff.CompareTo(ctx.Precision) > 0;
                // If exponent difference is greater than the precision
                if (moreDistantThanPrecision)
                {
                    int expcmp2 = op1Exponent.CompareTo(op2Exponent);
                    if (expcmp2 < 0)
                    {
                        if (!op2IsZero)
                        {
                            // first operand's exponent is less
                            // and second operand isn't zero
                            // second mantissa will be shifted by the exponent
                            // difference
                            // _________________________111111111111|_
                            // ___222222222222222|____________________
                            FastIntegerFixed digitLength1 =
                              NumberUtility.DigitLengthBoundsFixed(this.helper,
                                op1Mantissa)[1];
                            // DebugUtility.Log("dl1="+digitLength1);
                            if (op1Exponent.Add(digitLength1).Add(2)
                              .CompareTo(op2Exponent) < 0)
                            {
                                // first operand's mantissa can't reach the
                                // second operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastIntegerFixed tmp = op2Exponent.Subtract(4)
                                  .Subtract(digitLength1).Subtract(ctx.Precision);
                                // DebugUtility.Log("tmp="+tmp);
                                FastIntegerFixed newDiff = tmp.Subtract(op2Exponent).Abs();
                                // DebugUtility.Log("newdiff="+newDiff + " expdiff="+expdiff);
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // First operand can be treated as almost zero
                                    bool sameSign = thisSign == otherSign;
                                    FastIntegerFixed digitLength2 =
                                      NumberUtility.DigitLengthFixed(this.helper, op2Mantissa);
                                    // DebugUtility.Log("dl2="+digitLength2);
                                    if (digitLength2.CompareTo(ctx.Precision) < 0)
                                    {
                                        // Second operand's precision too short, extend
                                        // it to the full precision
                                        FastIntegerFixed precisionDiff =
                                          FastIntegerFixed.FromBig(ctx.Precision)
                                          .Subtract(digitLength2);
                                        if (!op1IsZero && !sameSign)
                                        {
                                            precisionDiff = precisionDiff.Add(2);
                                        }
                                        op2Mantissa = this.TryMultiplyByRadixPowerFastInt(
                                            op2Mantissa,
                                            precisionDiff);
                                        if (op2Mantissa == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                                ctx,
                                                "Result requires too much memory");
                                        }
                                        op2Exponent = op2Exponent.Subtract(precisionDiff);
                                        if (!op1IsZero && !sameSign)
                                        {
                                            op2Mantissa = op2Mantissa.Subtract(1);
                                        }
                                        int hoflags = otherFlags;
                                        T other = this.helper.CreateNewWithFlagsFastInt(
                                            op2Mantissa,
                                            op2Exponent,
                                            hoflags);
                                        FastIntegerFixed shift = digitLength2
                                          .Subtract(ctx.Precision);
                                        if (op1IsZero && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }
                                        // DebugUtility.Log("Second op's prec too short:
                                        // op2Mantissa=" + op2Mantissa + " precdiff= " +
                                        // (precisionDiff));
                                        return this.RoundToPrecisionInternal(
                                            other,
                                            (op1IsZero || sameSign) ? 0 : 1,
                                            (op1IsZero && !sameSign) ? 0 : 1,
                                            ToFastInteger(shift),
                                            false,
                                            ctx);
                                    }
                                    else if (!op1IsZero && !sameSign)
                                    {
                                        op2Mantissa = this.TryMultiplyByRadixPowerFastInt(
                                            op2Mantissa,
                                            FastIntegerFixed.FromInt32(2));
                                        if (op2Mantissa == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                                ctx,
                                                "Result requires too much memory");
                                        }
                                        op2Exponent = op2Exponent.Subtract(2);
                                        op2Mantissa = op2Mantissa.Subtract(1);
                                        T other = this.helper.CreateNewWithFlagsFastInt(
                                            op2Mantissa,
                                            op2Exponent,
                                            otherFlags);
                                        FastIntegerFixed shift =
                                          digitLength2.Subtract(ctx.Precision);
                                        return this.RoundToPrecisionInternal(
                                            other,
                                            0,
                                            0,
                                            ToFastInteger(shift),
                                            false,
                                            ctx);
                                    }
                                    else
                                    {
                                        FastIntegerFixed shift2 =
                                          digitLength2.Subtract(ctx.Precision);
                                        if (!sameSign && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }
                                        T other = this.helper.CreateNewWithFlagsFastInt(
                                            op2Mantissa,
                                            op2Exponent,
                                            otherFlags);
                                        return this.RoundToPrecisionInternal(
                                            other,
                                            0,
                                            sameSign ? 1 : 0,
                                            ToFastInteger(shift2),
                                            false,
                                            ctx);
                                    }
                                }
                            }
                        }
                    }
                    else if (expcmp2 > 0)
                    {
                        if (!op1IsZero)
                        {
                            // first operand's exponent is greater
                            // and first operand isn't zero
                            // first mantissa will be shifted by the exponent
                            // difference
                            // __111111111111|
                            // ____________________222222222222222|
                            FastIntegerFixed digitLength2 =
                              NumberUtility.DigitLengthBoundsFixed(
                                this.helper,
                                op2Mantissa)[1];
                            if (op2Exponent.Add(digitLength2).Add(2)
                              .CompareTo(op1Exponent) < 0)
                            {
                                // second operand's mantissa can't reach the
                                // first operand's mantissa, so the exponent can be
                                // raised without affecting the result
                                FastIntegerFixed tmp = op1Exponent.Subtract(4)
                                  .Subtract(digitLength2).Subtract(ctx.Precision);
                                FastIntegerFixed newDiff = tmp.Subtract(op1Exponent).Abs();
                                if (newDiff.CompareTo(expdiff) < 0)
                                {
                                    // Second operand can be treated as almost zero
                                    bool sameSign = thisSign == otherSign;
                                    digitLength2 = NumberUtility.DigitLengthFixed(this.helper,
                                        op1Mantissa);
                                    if (digitLength2.CompareTo(ctx.Precision) < 0)
                                    {
                                        // First operand's precision too short; extend it
                                        // to the full precision
                                        FastIntegerFixed precisionDiff =
                                          FastIntegerFixed.FromBig(ctx.Precision)
                                          .Subtract(digitLength2);
                                        if (!op2IsZero && !sameSign)
                                        {
                                            precisionDiff = precisionDiff.Add(2);
                                        }
                                        op1Mantissa = this.TryMultiplyByRadixPowerFastInt(
                                            op1Mantissa,
                                            precisionDiff);
                                        if (op1Mantissa == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                                ctx,
                                                "Result requires too much memory");
                                        }
                                        op1Exponent = op1Exponent.Subtract(precisionDiff);
                                        if (!op2IsZero && !sameSign)
                                        {
                                            op1Mantissa = op1Mantissa.Subtract(1);
                                        }
                                        T thisValue = this.helper.CreateNewWithFlagsFastInt(
                                            op1Mantissa,
                                            op1Exponent,
                                            thisFlags);
                                        FastIntegerFixed shift =
                                          digitLength2.Subtract(ctx.Precision);
                                        if (op2IsZero && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }
                                        // DebugUtility.Log("thisValue D"+thisValue);
                                        return this.RoundToPrecisionInternal(
                                            thisValue,
                                            (op2IsZero || sameSign) ? 0 : 1,
                                            (op2IsZero && !sameSign) ? 0 : 1,
                                            ToFastInteger(shift),
                                            false,
                                            ctx);
                                    }
                                    else if (!op2IsZero && !sameSign)
                                    {
                                        op1Mantissa = this.TryMultiplyByRadixPowerFastInt(
                                            op1Mantissa,
                                            FastIntegerFixed.FromInt32(2));
                                        if (op1Mantissa == null)
                                        {
                                            return this.SignalInvalidWithMessage(
                                                ctx,
                                                "Result requires too much memory");
                                        }
                                        op1Exponent = op1Exponent.Subtract(2);
                                        op1Mantissa = op1Mantissa.Subtract(1);
                                        T thisValue = this.helper.CreateNewWithFlagsFastInt(
                                            op1Mantissa,
                                            op1Exponent,
                                            thisFlags);
                                        FastIntegerFixed shift =
                                          digitLength2.Subtract(ctx.Precision);
                                        return this.RoundToPrecisionInternal(
                                            thisValue,
                                            0,
                                            0,
                                            ToFastInteger(shift),
                                            false,
                                            ctx);
                                    }
                                    else
                                    {
                                        FastIntegerFixed shift2 =
                                          digitLength2.Subtract(ctx.Precision);
                                        if (!sameSign && ctx != null && ctx.HasFlags)
                                        {
                                            ctx.Flags |= EContext.FlagRounded;
                                        }
                                        T thisValue = this.helper.CreateNewWithFlagsFastInt(
                                            op1Mantissa,
                                            op1Exponent,
                                            thisFlags);
                                        return this.RoundToPrecisionInternal(
                                            thisValue,
                                            0,
                                            sameSign ? 1 : 0,
                                            ToFastInteger(shift2),
                                            false,
                                            ctx);
                                    }
                                }
                            }
                        }
                    }
                    expcmp = op1Exponent.CompareTo(op2Exponent);
                    resultExponent = expcmp < 0 ? op1Exponent : op2Exponent;
                }
            }
            if (expcmp > 0)
            {
                // DebugUtility.Log("expcmp>0 op2m="+op2Mantissa+" exps="+
                // op1Exponent+"/"+op2Exponent);
                op1Mantissa = RescaleByExponentDiff(
                    op1Mantissa,
                    op1Exponent,
                    op2Exponent,
                    this.helper);
                if (op1Mantissa == null)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result requires too much memory");
                }
                retval = this.AddCore(
                    op1Mantissa,
                    op2Mantissa,
                    resultExponent,
                    thisFlags,
                    otherFlags,
                    ctx);
                // DebugUtility.Log("expcmp="+expcmp+" retval="+retval);
            }
            else
            {
                // DebugUtility.Log("expcmp<= 0 op2m="+op2Mantissa+" exps="+
                // op1Exponent+"/"+op2Exponent);
                op2Mantissa = RescaleByExponentDiff(
                    op2Mantissa,
                    op1Exponent,
                    op2Exponent,
                    this.helper);
                // DebugUtility.Log("op1m="+op1Mantissa+
                // " op2m="+op2Mantissa);
                if (op2Mantissa == null)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result requires too much memory");
                }
                retval = this.AddCore(
                    op1Mantissa,
                    op2Mantissa,
                    resultExponent,
                    thisFlags,
                    otherFlags,
                    ctx);
                // DebugUtility.Log("expcmp="+expcmp+" retval="+retval);
            }
            if (roundToOperandPrecision && ctx != null && ctx.HasMaxPrecision)
            {
                FastInteger digitLength1 = this.helper.GetDigitLength(
                    op1Mantissa.ToEInteger());
                FastInteger digitLength2 =
                  this.helper.GetDigitLength(op2Mantissa.ToEInteger());
                FastInteger maxDigitLength = (digitLength1.CompareTo(digitLength2) >
                    0) ? digitLength1 :

                  digitLength2;
                maxDigitLength.SubtractBig(ctx.Precision);
                // DebugUtility.Log("retval= " + retval + " maxdl=" +
                // maxDigitLength + " prec= " + (ctx.Precision));
                return (maxDigitLength.Sign > 0) ? this.RoundToPrecisionInternal(
                    retval,
                    0,
                    0,
                    maxDigitLength,
                    false,
                    ctx) : this.RoundToPrecision(retval, ctx);
                // DebugUtility.Log("retval now " + retval);
            }
            else
            {
                return IsNullOrSimpleContext(ctx) ? retval :
                  this.RoundToPrecision(retval, ctx);
            }
        }

        private T CompareToHandleSpecial(
          T thisValue,
          T other,
          bool treatQuietNansAsSignaling,
          EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                // Check this value then the other value for signaling NaN
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(thisValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(other, ctx);
                }
                if (treatQuietNansAsSignaling)
                {
                    if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.SignalingNaNInvalid(thisValue, ctx);
                    }
                    if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.SignalingNaNInvalid(other, ctx);
                    }
                }
                else
                {
                    // Check this value then the other value for quiet NaN
                    if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.ReturnQuietNaN(thisValue, ctx);
                    }
                    if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        return this.ReturnQuietNaN(other, ctx);
                    }
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // thisValue is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative)) == (otherFlags &
                          (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative))) ? this.ValueOf(0, null) :
                      (((thisFlags & BigNumberFlags.FlagNegative) == 0) ? this.ValueOf(
                          1,
                          null) : this.ValueOf(-1, null));
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // the other value is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative)) == (otherFlags &
                          (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative))) ? this.ValueOf(0, null) :
                      (((otherFlags & BigNumberFlags.FlagNegative) == 0) ?
                        this.ValueOf(-1, null) : this.ValueOf(1, null));
                }
            }
            return default(T);
        }

        private static int CompareToHandleSpecial2(
          int thisFlags,
          int otherFlags)
        {
            // Assumes either value is NaN and/or infinity
            {
                if ((thisFlags & BigNumberFlags.FlagNaN) != 0)
                {
                    if ((otherFlags & BigNumberFlags.FlagNaN) != 0)
                    {
                        return 0;
                    }
                    // Consider NaN to be greater
                    return 1;
                }
                if ((otherFlags & BigNumberFlags.FlagNaN) != 0)
                {
                    // Consider this to be less than NaN
                    return -1;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // thisValue is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative)) == (otherFlags &
                          (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative))) ? 0 :
                      (((thisFlags & BigNumberFlags.FlagNegative) == 0) ? 1 : -1);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // the other value is infinity
                    return ((thisFlags & (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative)) == (otherFlags &
                          (BigNumberFlags.FlagInfinity |
                            BigNumberFlags.FlagNegative))) ? 0 :
                      (((otherFlags & BigNumberFlags.FlagNegative) == 0) ? -1 : 1);
                }
            }
            return 2;
        }

        private static int CompareToInternal<TMath>(
          TMath thisValue,
          TMath otherValue,
          bool reportOOM,
          IRadixMathHelper<TMath> helper)
        {
            int signA = helper.GetSign(thisValue);
            int signB = helper.GetSign(otherValue);
            if (signA != signB)
            {
                return (signA < signB) ? -1 : 1;
            }
            if (signB == 0 || signA == 0)
            {
                // Special case: Either operand is zero
                return 0;
            }
            FastIntegerFixed op1Exponent = helper.GetExponentFastInt(thisValue);
            FastIntegerFixed op2Exponent = helper.GetExponentFastInt(otherValue);
            FastIntegerFixed op1Mantissa = helper.GetMantissaFastInt(thisValue);
            FastIntegerFixed op2Mantissa = helper.GetMantissaFastInt(otherValue);
            int expcmp = op1Exponent.CompareTo(op2Exponent);
            // At this point, the signs are equal so we can compare
            // their absolute values instead
            int mantcmp = op1Mantissa.CompareTo(op2Mantissa);
            if (mantcmp == 0)
            {
                // Special case: Mantissas are equal
                return signA < 0 ? -expcmp : expcmp;
            }
            if (expcmp == 0)
            {
                return signA < 0 ? -mantcmp : mantcmp;
            }
            if (op1Exponent.CanFitInInt32() && op2Exponent.CanFitInInt32())
            {
                if (op1Mantissa.CanFitInInt32() && op2Mantissa.CanFitInInt32())
                {
                    int e1int = op1Exponent.ToInt32();
                    int e2int = op2Exponent.ToInt32();
                    int c = CompareToFast(
                        e1int,
                        e2int,
                        expcmp,
                        signA,
                        op1Mantissa,
                        op2Mantissa,
                        helper.GetRadix());
                    if (c <= 1)
                    {
                        return c;
                    }
                }
                else if (op1Mantissa.CanFitInInt64() && op2Mantissa.CanFitInInt64())
                {
                    int e1int = op1Exponent.ToInt32();
                    int e2int = op2Exponent.ToInt32();
                    int c = CompareToFast64(
                        e1int,
                        e2int,
                        expcmp,
                        signA,
                        op1Mantissa,
                        op2Mantissa,
                        helper.GetRadix());
                    if (c <= 1)
                    {
                        return c;
                    }
                }
            }
            return CompareToSlow(
                op1Exponent.ToEInteger(),
                op2Exponent.ToEInteger(),
                expcmp,
                signA,
                op1Mantissa.ToEInteger(),
                op2Mantissa.ToEInteger(),
                helper,
                reportOOM);
        }

        private static string Chop(string str)
        {
            return (str.Length < 100) ? str : (str.Substring(0, 100) + "...");
        }

        private T DivideInternal(
          T thisValue,
          T divisor,
          EContext ctx,
          int integerMode,
          EInteger desiredExponent)
        {
            T ret = this.DivisionHandleSpecial(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            int signA = this.helper.GetSign(thisValue);
            int signB = this.helper.GetSign(divisor);
            if (signB == 0)
            {
                if (signA == 0)
                {
                    return this.SignalInvalid(ctx);
                }
                bool flagsNeg = ((this.helper.GetFlags(thisValue) &
                      BigNumberFlags.FlagNegative) != 0) ^
                  ((this.helper.GetFlags(divisor) &
                      BigNumberFlags.FlagNegative) != 0);
                return this.SignalDivideByZero(ctx, flagsNeg);
            }
            int radix = this.thisRadix;
            if (signA == 0)
            {
                T retval = default(T);
                if (integerMode == IntegerModeFixedScale)
                {
                    int newflags = (this.helper.GetFlags(thisValue) &
                        BigNumberFlags.FlagNegative) ^ (this.helper.GetFlags(divisor) &
                        BigNumberFlags.FlagNegative);
                    retval = this.helper.CreateNewWithFlags(
                        EInteger.Zero,
                        desiredExponent,
                        newflags);
                }
                else
                {
                    EInteger dividendExp = this.helper.GetExponent(thisValue);
                    EInteger divisorExp = this.helper.GetExponent(divisor);
                    int newflags = (this.helper.GetFlags(thisValue) &
                        BigNumberFlags.FlagNegative) ^ (this.helper.GetFlags(divisor) &
                        BigNumberFlags.FlagNegative);
                    retval = this.helper.CreateNewWithFlags(
                        EInteger.Zero,
                        dividendExp - (EInteger)divisorExp,
                        newflags);
                    retval = this.RoundToPrecision(retval, ctx);
                }
                return retval;
            }
            else
            {
                EInteger mantissaDividend = this.helper.GetMantissa(thisValue);
                EInteger mantissaDivisor = this.helper.GetMantissa(divisor);
                FastIntegerFixed expDividend =
                  this.helper.GetExponentFastInt(thisValue);
                FastIntegerFixed expDivisor = this.helper.GetExponentFastInt(divisor);
                bool resultNeg = (this.helper.GetFlags(thisValue) &
                    BigNumberFlags.FlagNegative) != (this.helper.GetFlags(divisor) &
                    BigNumberFlags.FlagNegative);
                FastInteger expdiff = FastIntegerFixed.Subtract(expDividend,
                    expDivisor).ToFastInteger();
                EInteger eintPrecision = (ctx == null || !ctx.HasMaxPrecision) ?
                  EInteger.Zero : ctx.Precision;
                if (integerMode == IntegerModeFixedScale)
                {
                    FastInteger shift;
                    EInteger rem;
                    FastInteger fastDesiredExponent =
                      FastInteger.FromBig(desiredExponent);
                    if (ctx != null && ctx.HasFlags &&
                      fastDesiredExponent.CompareTo(expdiff) > 0)
                    {
                        // Treat as rounded if the desired exponent is greater
                        // than the "ideal" exponent
                        ctx.Flags |= EContext.FlagRounded;
                    }
                    if (expdiff.CompareTo(fastDesiredExponent) <= 0)
                    {
                        shift = fastDesiredExponent.Copy().Subtract(expdiff);
                        EInteger quo;
                        {
                            EInteger[] divrem = mantissaDividend.DivRem(mantissaDivisor);
                            quo = divrem[0];
                            rem = divrem[1];
                        }
                        return this.RoundToScale(
                            quo,
                            rem,
                            mantissaDivisor,
                            desiredExponent,
                            shift,
                            resultNeg,
                            ctx);
                    }
                    if (ctx != null && ctx.Precision.Sign != 0 &&
                      expdiff.Copy().SubtractInt(8).CompareTo(eintPrecision) >
                      0)
                    {
                        // NOTE: 8 guard digits
                        // Result would require a too-high precision since
                        // exponent difference is much higher
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result can't fit the precision");
                    }
                    else
                    {
                        shift = expdiff.Copy().Subtract(fastDesiredExponent);
                        mantissaDividend =
                          this.TryMultiplyByRadixPower(mantissaDividend, shift);
                        if (mantissaDividend == null)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Result requires too much memory");
                        }
                        EInteger quo;
                        {
                            EInteger[] divrem = mantissaDividend.DivRem(mantissaDivisor);
                            quo = divrem[0];
                            rem = divrem[1];
                        }
                        return this.RoundToScale(
                            quo,
                            rem,
                            mantissaDivisor,
                            desiredExponent,
                            new FastInteger(0),
                            resultNeg,
                            ctx);
                    }
                }
                if (integerMode == IntegerModeRegular)
                {
                    EInteger rem = null;
                    EInteger quo = null;
                    FastInteger natexp = null;
                    bool binaryOpt = this.thisRadix == 2 &&
                      expDivisor.CompareToInt(0) == 0 && expDividend.CompareToInt(0) ==
                      0 &&
                      ctx != null && ctx.HasMaxPrecision && ctx.Precision.CompareTo(53)
                      <= 0 &&
                      mantissaDividend.CanFitInInt64() && mantissaDivisor.CanFitInInt64();
                    if (binaryOpt)
                    {
                        EInteger absdivd = mantissaDividend.Abs();
                        EInteger absdivs = mantissaDivisor.Abs();
                        int maxprec = ctx.Precision.ToInt32Checked();
                        var divdCount = (int)absdivd.GetUnsignedBitLengthAsInt64();
                        var divsCount = (int)mantissaDivisor.GetUnsignedBitLengthAsInt64();
                        int dividendShift = (divdCount <= divsCount) ? ((divsCount -
                              divdCount) + maxprec + 1) : Math.Max(0,
                            (maxprec + 1) - (divdCount - divsCount));
                        absdivd = absdivd.ShiftLeft(dividendShift);
                        EInteger[] divrem3 = absdivd.DivRem(absdivs);
                        quo = divrem3[0];
                        rem = divrem3[1];
                        if (ctx == EContext.Binary64 && quo.CanFitInInt64() &&
                          rem.CanFitInInt64())
                        {
                            long lquo = quo.ToInt64Checked();
                            long lrem = rem.ToInt64Checked();
                            int nexp = -dividendShift;
                            if (lquo >= (1L << 53))
                            {
                                while (lquo >= (1L << 54))
                                {
                                    lrem |= lquo & 1L;
                                    lquo >>= 1;
                                    ++nexp;
                                }
                                if ((lquo & 3L) == 3 && lrem == 0)
                                {
                                    lquo >>= 1;
                                    ++lquo;
                                    ++nexp;
                                }
                                else if ((lquo & 1L) != 0 && lrem != 0)
                                {
                                    lquo >>= 1;
                                    ++lquo;
                                    ++nexp;
                                }
                                else
                                {
                                    lquo >>= 1;
                                    ++nexp;
                                }
                                while (lquo >= (1L << 53))
                                {
                                    lquo >>= 1;
                                    ++nexp;
                                }
                                return this.helper.CreateNewWithFlags(
                                    EInteger.FromInt64(lquo),
                                    EInteger.FromInt64(nexp),
                                    resultNeg ? BigNumberFlags.FlagNegative : 0);
                            }
                        }
                        if (ctx == EContext.Binary32 && quo.CanFitInInt64() &&
                          rem.CanFitInInt64())
                        {
                            long lquo = quo.ToInt64Checked();
                            long lrem = rem.ToInt64Checked();
                            int nexp = -dividendShift;
                            if (lquo >= (1L << 24))
                            {
                                while (lquo >= (1L << 25))
                                {
                                    lrem |= lquo & 1L;
                                    lquo >>= 1;
                                    ++nexp;
                                }
                                if ((lquo & 3L) == 3 && lrem == 0)
                                {
                                    lquo >>= 1;
                                    ++lquo;
                                    ++nexp;
                                }
                                else if ((lquo & 1L) != 0 && lrem != 0)
                                {
                                    lquo >>= 1;
                                    ++lquo;
                                    ++nexp;
                                }
                                else
                                {
                                    lquo >>= 1;
                                    ++nexp;
                                }
                                while (lquo >= (1L << 24))
                                {
                                    lquo >>= 1;
                                    ++nexp;
                                }
                                return this.helper.CreateNewWithFlags(
                                    EInteger.FromInt64(lquo),
                                    EInteger.FromInt64(nexp),
                                    resultNeg ? BigNumberFlags.FlagNegative : 0);
                            }
                        }
                        natexp = new FastInteger(-dividendShift);
                        // Console.WriteLine(quo.GetUnsignedBitLengthAsInt64()+" "+
                        // rem.GetUnsignedBitLengthAsInt64()+" "+
                        // (ctx == EContext.Binary64));
                    }
                    if (!binaryOpt)
                    {
                        EInteger[] divrem = mantissaDividend.DivRem(mantissaDivisor);
                        quo = divrem[0];
                        rem = divrem[1];
                        if (rem.IsZero)
                        {
                            // Dividend is divisible by divisor
                            // Console.WriteLine("divisible dividend: quo length=" +
                            // quo.GetUnsignedBitLengthAsInt64());
                            quo = quo.Abs();
                            T fi = this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.FromBig(quo),
                                FastIntegerFixed.FromFastInteger(expdiff),
                                resultNeg ? BigNumberFlags.FlagNegative : 0);
                            return this.RoundToPrecision(fi, ctx);
                        }
                    }
                    if (ctx != null && ctx.HasMaxPrecision)
                    {
                        if (!binaryOpt)
                        {
                            EInteger divid = mantissaDividend;
                            FastInteger shift = FastInteger.FromBig(ctx.Precision);
                            FastInteger[] dividBounds =
                              NumberUtility.DigitLengthBounds(this.helper, mantissaDividend);
                            FastInteger[] divisBounds =
                              NumberUtility.DigitLengthBounds(this.helper, mantissaDivisor);
                            if (dividBounds[0].Copy().Subtract(divisBounds[1])
                              .CompareTo(shift) > 0)
                            {
                                // Dividend is already bigger than divisor by at least
                                // shift digits, so no need to shift
                                shift.SetInt(0);
                            }
                            else
                            {
                                FastInteger shiftCalc = divisBounds[0].Copy().Subtract(
                                    dividBounds[1]).AddInt(2).Add(shift);
                                if (shiftCalc.CompareToInt(0) <= 0)
                                {
                                    // No need to shift
                                    shift.SetInt(0);
                                }
                                else
                                {
                                    shift = shiftCalc;
                                    divid = this.TryMultiplyByRadixPower(divid, shift);
                                    if (divid == null)
                                    {
                                        return this.SignalInvalidWithMessage(
                                            ctx,
                                            "Result requires too much memory");
                                    }
                                }
                            }
                            if (shift.Sign != 0 || quo == null)
                            {
                                // if shift isn't zero, recalculate the quotient
                                // and remainder
                                EInteger[] divrem2 = divid.DivRem(mantissaDivisor);
                                quo = divrem2[0];
                                rem = divrem2[1];
                            }
                            natexp = expdiff.Copy().Subtract(shift);
                        }
                        // DebugUtility.Log(String.Format("" + divid + "" +
                        // mantissaDivisor + " -> quo= " + quo + " rem= " +
                        // (rem)));
                        int[] digitStatus = this.RoundToScaleStatus(
                            rem,
                            mantissaDivisor,
                            ctx);
                        if (digitStatus == null)
                        {
                            // NOTE: Can only happen for ERounding.None
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Rounding was required");
                        }
                        T retval2 = this.helper.CreateNewWithFlags(
                            quo,
                            natexp.ToEInteger(),
                            resultNeg ? BigNumberFlags.FlagNegative : 0);
                        if ((ctx == null || !ctx.HasFlagsOrTraps) &&
                          (digitStatus[0] | digitStatus[1]) != 0)
                        {
                            // Context doesn't care about flags, and
                            // we already know the result is inexact, so no
                            // need to create a blank flag context to find that out
                            return this.RoundToPrecisionInternal(
                                retval2,
                                digitStatus[0],
                                digitStatus[1],
                                null,
                                false,
                                ctx);
                        }
                        EContext ctxcopy = ctx.WithBlankFlags();
                        retval2 = this.RoundToPrecisionInternal(
                            retval2,
                            digitStatus[0],
                            digitStatus[1],
                            null,
                            false,
                            ctxcopy);
                        if ((ctxcopy.Flags & EContext.FlagInexact) != 0)
                        {
                            if (ctx.HasFlags)
                            {
                                ctx.Flags |= ctxcopy.Flags;
                            }
                            return retval2;
                        }
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= ctxcopy.Flags & ~EContext.FlagRounded;
                        }
                        retval2 = this.ReduceToPrecisionAndIdealExponent(
                            retval2,
                            ctx,
                            rem.IsZero ? null : FastInteger.FromBig(eintPrecision),
                            expdiff);
                        return retval2;
                    }
                }
                // Rest of method assumes unlimited precision
                // and IntegerModeRegular
                var adjust = new FastInteger(0);
                var result = new FastInteger(0);
                int mantcmp = mantissaDividend.CompareTo(mantissaDivisor);
                if (mantcmp == 0)
                {
                    result = new FastInteger(1);
                    mantissaDividend = EInteger.Zero;
                }
                else
                {
                    EInteger gcd = mantissaDividend.Gcd(mantissaDivisor);
                    // DebugUtility.Log("mgcd/den1=" + mantissaDividend + "/" + (//
                    // mantissaDivisor) + "/" + gcd);
                    if (gcd.CompareTo(EInteger.One) != 0)
                    {
                        mantissaDividend /= gcd;
                        mantissaDivisor /= gcd;
                    }
                    // DebugUtility.Log("mgcd/den2=" + mantissaDividend + "/" + (//
                    // mantissaDivisor) + "/" + gcd);
                    FastInteger divShift = this.helper.DivisionShift(
                        mantissaDividend,
                        mantissaDivisor);

                    if (divShift == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result would have a nonterminating expansion");
                    }
                    mantissaDividend = this.helper.MultiplyByRadixPower(
                        mantissaDividend,
                        divShift);
                    adjust = divShift.Copy();
                    // DebugUtility.Log("mant " + mantissaDividend + " " +
                    // (// mantissaDivisor));
                    EInteger[] quorem = mantissaDividend.DivRem(mantissaDivisor);
#if DEBUG
                    if (!quorem[1].IsZero)
                    {
                        throw new ArgumentException("doesn't satisfy quorem[1].IsZero");
                    }
#endif

                    mantissaDividend = quorem[1];
                    result = FastInteger.FromBig(quorem[0]);
                }
                // mantissaDividend now has the remainder
                FastInteger exp = expdiff.Copy().Subtract(adjust);
                ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
                var lastDiscarded = 0;
                var olderDiscarded = 0;
                if (!mantissaDividend.IsZero)
                {
                    if (rounding == ERounding.HalfDown || rounding ==
                      ERounding.HalfEven || rounding == ERounding.HalfUp)
                    {
                        int cmpHalf = CompareToHalf(mantissaDividend, mantissaDivisor);
                        if (cmpHalf == 0)
                        {
                            // remainder is exactly half
                            lastDiscarded = radix / 2;
                            olderDiscarded = 0;
                        }
                        else if (cmpHalf > 0)
                        {
                            // remainder is greater than half
                            lastDiscarded = radix / 2;
                            olderDiscarded = 1;
                        }
                        else
                        {
                            // remainder is less than half
                            lastDiscarded = 0;
                            olderDiscarded = 1;
                        }
                    }
                    else
                    {
                        if (rounding == ERounding.None)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Rounding was required");
                        }
                        lastDiscarded = 1;
                        olderDiscarded = 1;
                    }
                }
                EInteger bigResult = result.ToEInteger();
                if (ctx != null && ctx.HasFlags && exp.CompareTo(expdiff) > 0)
                {
                    // Treat as rounded if the true exponent is greater
                    // than the "ideal" exponent
                    ctx.Flags |= EContext.FlagRounded;
                }
                EInteger bigexp = exp.ToEInteger();
                T retval = this.helper.CreateNewWithFlags(
                    bigResult,
                    bigexp,
                    resultNeg ? BigNumberFlags.FlagNegative : 0);
                return this.RoundToPrecisionInternal(
                    retval,
                    lastDiscarded,
                    olderDiscarded,
                    null,
                    false,
                    ctx);
            }
        }

        private T DivisionHandleSpecial(
          T thisValue,
          T other,
          EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0 && (otherFlags &
                    BigNumberFlags.FlagInfinity) != 0)
                {
                    // Attempt to divide infinity by infinity
                    return this.SignalInvalid(ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.EnsureSign(
                        thisValue,
                        ((thisFlags ^ otherFlags) & BigNumberFlags.FlagNegative) != 0);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Divisor is infinity, so result will be epsilon
                    if (ctx != null && ctx.HasExponentRange && ctx.Precision.Sign > 0)
                    {
                        if (ctx.HasFlags)
                        {
                            ctx.Flags |= EContext.FlagClamped;
                        }
                        EInteger bigexp = ctx.EMin;
                        EInteger bigprec = ctx.Precision;
                        if (ctx.AdjustExponent)
                        {
                            bigexp -= (EInteger)bigprec;
                            bigexp += EInteger.One;
                        }
                        thisFlags = (thisFlags ^ otherFlags) & BigNumberFlags.FlagNegative;
                        return this.helper.CreateNewWithFlags(
                            EInteger.Zero,
                            bigexp,
                            thisFlags);
                    }
                    thisFlags = (thisFlags ^ otherFlags) & BigNumberFlags.FlagNegative;
                    result = this.helper.CreateNewWithFlags(
                        EInteger.Zero,
                        EInteger.Zero,
                        thisFlags);
                    return this.RoundToPrecision(
                        result,
                        ctx);
                }
            }
            return default(T);
        }

        private T EnsureSign(T val, bool negative)
        {
            if (val == null)
            {
                return val;
            }
            int flags = this.helper.GetFlags(val);
            if ((negative && (flags & BigNumberFlags.FlagNegative) == 0) ||
              (!negative && (flags & BigNumberFlags.FlagNegative) != 0))
            {
                flags &= ~BigNumberFlags.FlagNegative;
                flags |= negative ? BigNumberFlags.FlagNegative : 0;
                return this.helper.CreateNewWithFlags(
                    this.helper.GetMantissa(val),
                    this.helper.GetExponent(val),
                    flags);
            }
            return val;
        }

        private T ExpInternalVeryCloseToZero(
          T thisValue,
          EInteger workingPrecision,
          EContext ctx)
        {
            // NOTE: Assumes 'thisValue' is very close to zero
            // and either positive or negative.
            // DebugUtility.Log("ExpInternalVeryCloseToZero");
            T zero = this.helper.ValueOf(0);
            int cmpZero = this.CompareTo(thisValue, zero);
            if (cmpZero == 0)
            {
                // NOTE: Should not happen here, because
                // the check for zero should have happened earlier
                throw new InvalidOperationException();
            }
            T one = this.helper.ValueOf(1);
            int precisionAdd = this.thisRadix == 2 ? 18 : 12;
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                workingPrecision + (EInteger)precisionAdd)
              .WithRounding(ERounding.HalfEven);
            var bigintN = (EInteger)2;
            EInteger facto = EInteger.One;
            T guess;
            // Guess starts with thisValue
            guess = thisValue;
            // DebugUtility.Log("startguess="+guess);
            T lastGuess = guess;
            T pow = thisValue;
            var more = true;
            var lastCompare = 0;
            var vacillations = 0;
            int maxvac = cmpZero < 0 ? 10 : 3;
            while (true)
            {
                lastGuess = guess;
                // Iterate by:
                // newGuess = guess + (thisValue^n/factorial(n))
                // (n starts at 2 and increases by 1 after
                // each iteration)
                pow = this.Multiply(pow, thisValue, ctxdiv);
                facto *= (EInteger)bigintN;
                T tmp = this.Divide(
                    pow,
                    this.helper.CreateNewWithFlags(facto, EInteger.Zero, 0),
                    ctxdiv);
                T newGuess = this.Add(guess, tmp, ctxdiv);
                // DebugUtility.Log("newguess " + newGuess);
                // DebugUtility.Log("newguessN " + NextPlus(newGuess,ctxdiv));
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    // DebugUtility.Log("guessCmp = " + guessCmp + ", vac=" + vacillations);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                      guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= maxvac ||
                          (cmpZero < 0 ? guessCmp >= 0 : guessCmp <= 0);
                    }
                    lastCompare = guessCmp;
                }
                if (more)
                {
                    bigintN += EInteger.One;
                    guess = newGuess;
                }
                else
                {
                    T ret = newGuess;
                    // Add 1 at end
                    ret = this.Add(one, ret, ctx);
                    return ret;
                }
            }
        }

        private T ExpInternal(
          T thisValue,
          EInteger workingPrecision,
          EContext ctx)
        {
            // DebugUtility.Log("ExpInternal " +(thisValue as
            // EDecimal)?.ToDouble()+", wp=" +workingPrecision);
            T zero = this.helper.ValueOf(0);
            if (this.CompareTo(thisValue, zero) == 0)
            {
                // NOTE: Should not happen here, because
                // the check for zero should have happened earlier
                throw new InvalidOperationException();
            }
            T one = this.helper.ValueOf(1);
            int precisionAdd = this.thisRadix == 2 ? 18 : 12;
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                workingPrecision + (EInteger)precisionAdd)
              .WithRounding(ERounding.HalfEven);
            var bigintN = (EInteger)2;
            EInteger facto = EInteger.One;

            T guess;
            // Guess starts with thisValue
            // guess = thisValue;
            // Guess starts with 1 + thisValue
            guess = this.Add(one, thisValue, ctxdiv);
            // DebugUtility.Log(ctxdiv.ToString());
            // DebugUtility.Log("tv="+(thisValue as EDecimal)?.ToDouble());
            // DebugUtility.Log("initial="+thisValue);
            // DebugUtility.Log("startguess="+guess);
            T lastGuess = guess;
            T pow = thisValue;
            var more = true;
            var lastCompare = 0;
            var vacillations = 0;
            while (true)
            {
                lastGuess = guess;
                // Iterate by:
                // newGuess = guess + (thisValue^n/factorial(n))
                // (n starts at 2 and increases by 1 after
                // each iteration)
                pow = this.Multiply(pow, thisValue, ctxdiv);
                facto *= (EInteger)bigintN;
                T tmp = this.Divide(
                    pow,
                    this.helper.CreateNewWithFlags(facto, EInteger.Zero, 0),
                    ctxdiv);
                T newGuess = this.Add(guess, tmp, ctxdiv);
                // DebugUtility.Log("newguess " +
                // this.helper.GetMantissa(newGuess));
                // DebugUtility.Log("newguessN " + NextPlus(newGuess,ctxdiv));
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    // DebugUtility.Log("guessCmp = " + guessCmp);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                      guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= 3 || guessCmp <= 0;
                    }
                    lastCompare = guessCmp;
                }
                if (more)
                {
                    bigintN += EInteger.One;
                    guess = newGuess;
                }
                else
                {
                    T ret = this.Add(guess, tmp, ctx);
                    // DebugUtility.Log("final... " + ret);
                    return ret;
                }
            }
        }

        private T ExtendPrecision(T thisValue, EContext ctx)
        {
            if (ctx == null || !ctx.HasMaxPrecision)
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            EInteger mant = this.helper.GetMantissa(thisValue);
            FastInteger digits = this.helper.GetDigitLength(mant);
            FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
            EInteger exponent = this.helper.GetExponent(thisValue);
            if (digits.CompareTo(fastPrecision) < 0)
            {
                fastPrecision.Subtract(digits);
                mant = this.TryMultiplyByRadixPower(mant, fastPrecision);
                if (mant == null)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Result requires too much memory");
                }
                EInteger bigPrec = fastPrecision.ToEInteger();
                exponent -= (EInteger)bigPrec;
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagRounded;
                ctx.Flags |= EContext.FlagInexact;
            }
            return this.RoundToPrecision(
                this.helper.CreateNewWithFlags(mant, exponent, 0),
                ctx);
        }

        private T HandleNotANumber(T thisValue, T other, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            // Check this value then the other value for signaling NaN
            if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            // Check this value then the other value for quiet NaN
            return ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(thisValue, ctx) : (((otherFlags &
                    BigNumberFlags.FlagQuietNaN) != 0) ? this.ReturnQuietNaN(
                      other,
                      ctx) : default(T));
        }

        private bool IsFinite(T val)
        {
            return (this.helper.GetFlags(val) & BigNumberFlags.FlagSpecial) == 0;
        }

        private bool IsNegative(T val)
        {
            return (this.helper.GetFlags(val) & BigNumberFlags.FlagNegative) != 0;
        }

        private bool IsWithinExponentRangeForPow(
          T thisValue,
          EContext ctx)
        {
            if (ctx == null || !ctx.HasExponentRange)
            {
                return true;
            }
            FastInteger digits = this.helper.GetDigitLength(
                this.helper.GetMantissa(thisValue));
            EInteger exp = this.helper.GetExponent(thisValue);
            FastInteger fi = FastInteger.FromBig(exp);
            if (ctx.AdjustExponent)
            {
                fi.Add(digits);
                fi.Decrement();
            }
            // DebugUtility.Log("" + exp + " -> " + fi);
            if (fi.Sign < 0)
            {
                fi.Negate().Divide(2).Negate();
                // DebugUtility.Log("" + exp + " II -> " + fi);
            }
            exp = fi.ToEInteger();
            return exp.CompareTo(ctx.EMin) >= 0 && exp.CompareTo(ctx.EMax) <= 0;
        }

        private T LnInternalCloseToOne2(
          T thisValue,
          EInteger workingPrecision,
          EContext ctx)
        {
            // Assumes 'thisValue' is close to 1
            var more = true;
            var lastCompare = 0;
            var vacillations = 0;
            string dbg = String.Empty;
            // if (thisValue is EDecimal) {
            // dbg="" + ((EDecimal)thisValue).ToDouble();
            // }
            // DebugUtility.Log("workingprec=" + workingPrecision);
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                workingPrecision + (EInteger)6).WithRounding(ERounding.HalfEven);
            T rzlo = this.Add(thisValue, this.helper.ValueOf(-1), null);
            T rzhi = this.Add(thisValue, this.helper.ValueOf(1), null);
            // (thisValue - 1) / (thisValue + 1)
            T rz = this.Divide(rzlo, rzhi, ctxdiv);
            // (thisValue - 1) * 2 / (thisValue + 1)
            T guess = this.Add(rz, rz, null);
            T rzterm = rz;
            T lastGuess = default(T);
            T lastDiff = default(T);
            var haveLastDiff = false;
            EInteger denom = EInteger.FromInt32(3);
            EInteger iterations = EInteger.Zero;
            while (more)
            {
                lastGuess = guess;
                rzterm = this.Multiply(rzterm, rz, ctxdiv);
                rzterm = this.Multiply(rzterm, rz, ctxdiv);
                T rd = this.Divide(
                    this.Multiply(rzterm, this.helper.ValueOf(2), ctxdiv),
                    this.helper.CreateNewWithFlags(denom, EInteger.Zero, 0),
                    ctxdiv);
                if (haveLastDiff && this.CompareTo(lastDiff, rd) == 0)
                {
                    // iterate is the same as before, so break
                    break;
                }
                T newGuess = this.Add(guess, rd, ctxdiv);
                int guessCmp = this.CompareTo(lastGuess, newGuess);
                bool overprec = iterations.CompareTo(workingPrecision) >= 0;
                if (guessCmp == 0)
                {
                    more = false;
                }
                else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                  guessCmp < 0))
                {
                    // Guesses are vacillating
                    ++vacillations;
                    more &= !overprec || vacillations <= 3 || guessCmp <= 0;
                }
                lastCompare = guessCmp;
                lastDiff = this.AbsRaw(rd);
                haveLastDiff = true;
                if (more)
                {
                    denom = denom.Add(2);
                    iterations += EInteger.One;
                    guess = newGuess;
                }
                else
                {
                    guess = this.Add(guess, rd, ctx);
                }
            }
            // DebugUtility.Log("iterations="+iterations+", "+dbg);
            return guess;
        }

        private T LnInternal(
          T thisValue,
          EInteger workingPrecision,
          EContext ctx)
        {
            var more = true;
            var lastCompare = 0;
            var vacillations = 0;
            EContext ctxdiv = SetPrecisionIfLimited(
                ctx,
                workingPrecision + (EInteger)6)
              .WithRounding(ERounding.HalfEven);
            T z = this.Add(
                this.NegateRaw(thisValue),
                this.helper.ValueOf(1),
                null);
            T zpow = this.Multiply(z, z, ctxdiv);
            T guess = this.NegateRaw(z);
            T lastGuess = default(T);
            var denom = (EInteger)2;
            while (more)
            {
                lastGuess = guess;
                T tmp = this.Divide(
                    zpow,
                    this.helper.CreateNewWithFlags(denom, EInteger.Zero, 0),
                    ctxdiv);
                T newGuess = this.Add(guess, this.NegateRaw(tmp), ctxdiv);
                {
                    int guessCmp = this.CompareTo(lastGuess, newGuess);
                    if (guessCmp == 0)
                    {
                        more = false;
                    }
                    else if ((guessCmp > 0 && lastCompare < 0) || (lastCompare > 0 &&
                      guessCmp < 0))
                    {
                        // Guesses are vacillating
                        ++vacillations;
                        more &= vacillations <= 3 || guessCmp <= 0;
                    }
                    lastCompare = guessCmp;
                }
                guess = newGuess;
                if (more)
                {
                    zpow = this.Multiply(zpow, z, ctxdiv);
                    denom += EInteger.One;
                }
            }
            return this.RoundToPrecision(guess, ctx);
        }

        private T MinMaxHandleSpecial(
          T thisValue,
          T otherValue,
          EContext ctx,
          bool isMinOp,
          bool compareAbs)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(otherValue);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                // Check this value then the other value for signaling NaN
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(thisValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(otherValue, ctx);
                }
                // Check this value then the other value for quiet NaN
                if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                    {
                        // both values are quiet NaN
                        return this.ReturnQuietNaN(thisValue, ctx);
                    }
                    // return "other" for being numeric
                    return this.RoundToPrecision(otherValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    // At this point, "thisValue" can't be NaN,
                    // return "thisValue" for being numeric
                    return this.RoundToPrecision(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if (compareAbs && (otherFlags & BigNumberFlags.FlagInfinity) == 0)
                    {
                        // treat this as larger
                        return isMinOp ? this.RoundToPrecision(otherValue, ctx) :
                          thisValue;
                    }
                    // This value is infinity
                    if (isMinOp)
                    {
                        // if negative, will be less than every other number
                        return ((thisFlags & BigNumberFlags.FlagNegative) != 0) ?
                          thisValue : this.RoundToPrecision(otherValue, ctx);
                        // if positive, will be greater
                    }
                    // if positive, will be greater than every other number
                    return ((thisFlags & BigNumberFlags.FlagNegative) == 0) ?
                      thisValue : this.RoundToPrecision(otherValue, ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    if (compareAbs)
                    {
                        // treat this as larger (the first value
                        // won't be infinity at this point
                        return isMinOp ? this.RoundToPrecision(thisValue, ctx) :
                          otherValue;
                    }
                    return isMinOp ? (((otherFlags & BigNumberFlags.FlagNegative) ==
                          0) ? this.RoundToPrecision(thisValue, ctx) :
                        otherValue) : (((otherFlags & BigNumberFlags.FlagNegative) !=
                          0) ? this.RoundToPrecision(thisValue, ctx) : otherValue);
                }
            }
            return default(T);
        }

        private T MultiplyAddHandleSpecial(
          T op1,
          T op2,
          T op3,
          EContext ctx)
        {
            int op1Flags = this.helper.GetFlags(op1);
            // Check operands in order for signaling NaN
            if ((op1Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(op1, ctx);
            }
            int op2Flags = this.helper.GetFlags(op2);
            if ((op2Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(op2, ctx);
            }
            int op3Flags = this.helper.GetFlags(op3);
            // Check operands in order for quiet NaN
            if ((op1Flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                if ((op3Flags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(op3, ctx);
                }
                else
                {
                    return this.ReturnQuietNaN(op1, ctx);
                }
            }
            if ((op2Flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                if ((op3Flags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(op3, ctx);
                }
                else
                {
                    return this.ReturnQuietNaN(op2, ctx);
                }
            }
            // Check multiplying infinity by 0 (important to check
            // now before checking third operand for quiet NaN because
            // this signals invalid operation and the operation starts
            // with multiplying only the first two operands)
            if ((op1Flags & BigNumberFlags.FlagInfinity) != 0)
            {
                // Attempt to multiply infinity by 0
                if ((op2Flags & BigNumberFlags.FlagSpecial) == 0 &&
                  this.helper.GetMantissa(op2).IsZero)
                {
                    return this.SignalInvalid(ctx);
                }
            }
            if ((op2Flags & BigNumberFlags.FlagInfinity) != 0)
            {
                // Attempt to multiply infinity by 0
                if ((op1Flags & BigNumberFlags.FlagSpecial) == 0 &&
                  this.helper.GetMantissa(op1).IsZero)
                {
                    return this.SignalInvalid(ctx);
                }
            }
            // Now check third operand for signaling NaN
            if ((op3Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(op3, ctx);
            }
            // Now check third operand for quiet NaN
            return ((op3Flags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(op3, ctx) : default(T);
        }

        private T NegateRaw(T val)
        {
            if (val == null)
            {
                return val;
            }
            int sign = this.helper.GetFlags(val) & BigNumberFlags.FlagNegative;
            return this.helper.CreateNewWithFlags(
                this.helper.GetMantissa(val),
                this.helper.GetExponent(val),
                sign == 0 ? BigNumberFlags.FlagNegative : 0);
        }

        private T PowerIntegral(
          T thisValue,
          EInteger powIntBig,
          EContext ctx)
        {
            int sign = powIntBig.Sign;
            T one = this.helper.ValueOf(1);
            if (sign == 0)
            {
                // however 0 to the power of 0 is undefined
                return this.RoundToPrecision(one, ctx);
            }
            if (powIntBig.Equals(EInteger.One))
            {
                return this.RoundToPrecision(thisValue, ctx);
            }
            if (powIntBig.CompareTo(2) == 0)
            {
                return this.Multiply(thisValue, thisValue, ctx);
            }
            if (powIntBig.CompareTo(3) == 0)
            {
                return this.Multiply(
                    thisValue,
                    this.Multiply(thisValue, thisValue, null),
                    ctx);
            }
            bool retvalNeg = this.IsNegative(thisValue) && !powIntBig.IsEven;
            FastInteger error = this.helper.GetDigitLength(powIntBig.Abs());
            error = error.Copy();
            error.AddInt(18);
            EInteger bigError = error.ToEInteger();
            /*DUL("thisValue=" + thisValue +
            " powInt=" + powIntBig);*/
            EContext ctxdiv = ctx == null ? ctx : SetPrecisionIfLimited(
                ctx,
                ctx.Precision + (EInteger)bigError)
              .WithRounding(ERounding.HalfEven).WithBlankFlags();
            if (sign < 0)
            {
                // Use the reciprocal for negative powers
                thisValue = this.Divide(one, thisValue, ctxdiv);
                // DebugUtility.Log("-->recip thisValue=" + thisValue +
                // " powInt=" + powIntBig + " flags=" + (ctxdiv == null ? -1 :
                // ctxdiv.Flags));
                if ((ctxdiv.Flags & EContext.FlagOverflow) != 0)
                {
                    return this.SignalOverflow(ctx, retvalNeg);
                }
                powIntBig = -powIntBig;
            }
            T r = one;
            while (!powIntBig.IsZero)
            {
                if (!powIntBig.IsEven)
                {
                    // DebugUtility.Log("-->RT thisValue=" + thisValue +
                    // " powInt=" + powIntBig + " flags=" +
                    // (ctxdiv == null ? -1 : ctxdiv.Flags));
                    r = this.Multiply(r, thisValue, ctxdiv);
                    if (ctxdiv != null && (ctxdiv.Flags & EContext.FlagOverflow) != 0)
                    {
                        return this.SignalOverflow(ctx, retvalNeg);
                    }
                }
                powIntBig >>= 1;
                if (!powIntBig.IsZero)
                {
                    if (ctxdiv != null)
                    {
                        ctxdiv.Flags &= ~EContext.FlagOverflow;
                    }
                    // DebugUtility.Log("-->TT thisValue=" + thisValue +
                    // " powInt=" + powIntBig + " flags=" +
                    // (ctxdiv == null ? -1 : ctxdiv.Flags));
                    T tmp = this.Multiply(thisValue, thisValue, ctxdiv);
                    if (ctxdiv != null && (ctxdiv.Flags & EContext.FlagOverflow) != 0)
                    {
                        // Avoid multiplying too huge numbers with
                        // limited exponent range
                        return this.SignalOverflow(ctx, retvalNeg);
                    }
                    thisValue = tmp;
                }
                // DebugUtility.Log("r="+r);
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= ctxdiv.Flags & (
                    EContext.FlagUnderflow |
                    EContext.FlagSubnormal | EContext.FlagInexact |
                    EContext.FlagRounded | EContext.FlagClamped);
            }
            return this.RoundToPrecision(r, ctx);
        }

        private T ReduceToPrecisionAndIdealExponent(
          T thisValue,
          EContext ctx,
          FastInteger precision,
          FastInteger idealExp)
        {
            T ret = this.RoundToPrecision(thisValue, ctx);
            if (ret != null && (this.helper.GetFlags(ret) &
                BigNumberFlags.FlagSpecial) == 0)
            {
                EInteger bigmant = this.helper.GetMantissa(ret);
                FastInteger exp = FastInteger.FromBig(this.helper.GetExponent(ret));
                int radix = this.thisRadix;
                if (bigmant.IsZero)
                {
                    exp = new FastInteger(0);
                }
                else
                {
                    FastInteger digits = (precision == null) ? null :
                      this.helper.GetDigitLength(bigmant);
                    bigmant = NumberUtility.ReduceTrailingZeros(
                        bigmant,
                        exp,
                        radix,
                        digits,
                        precision,
                        idealExp);
                }
                int flags = this.helper.GetFlags(thisValue);
                ret = this.helper.CreateNewWithFlags(
                    bigmant,
                    exp.ToEInteger(),
                    flags);
                if (ctx != null && ctx.ClampNormalExponents)
                {
                    EContext ctxtmp = ctx.WithBlankFlags();
                    ret = this.RoundToPrecision(ret, ctxtmp);
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= ctxtmp.Flags & ~EContext.FlagClamped;
                    }
                }
                ret = this.EnsureSign(ret, (flags & BigNumberFlags.FlagNegative) != 0);
            }
            return ret;
        }

        private T RemainderHandleSpecial(
          T thisValue,
          T other,
          EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            int otherFlags = this.helper.GetFlags(other);
            if (((thisFlags | otherFlags) & BigNumberFlags.FlagSpecial) != 0)
            {
                T result = this.HandleNotANumber(thisValue, other, ctx);
                if ((object)result != (object)default(T))
                {
                    return result;
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.SignalInvalid(ctx);
                }
                if ((otherFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return this.RoundToPrecision(thisValue, ctx);
                }
            }
            return this.helper.GetMantissa(other).IsZero ? this.SignalInvalid(ctx) :
              default(T);
        }

        private T ReturnQuietNaN(T thisValue, EContext ctx)
        {
            EInteger mant = this.helper.GetMantissa(thisValue);
            var mantChanged = false;
            if (!mant.IsZero && ctx != null && ctx.HasMaxPrecision)
            {
                FastInteger compPrecision = FastInteger.FromBig(ctx.Precision);
                if (this.helper.GetDigitLength(mant).CompareTo(compPrecision) >= 0)
                {
                    // Mant's precision is higher than the maximum precision
                    EInteger limit = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        compPrecision);
                    if (limit == null)
                    {
                        // Limit can't be allocated
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }
                    if (mant.CompareTo(limit) >= 0)
                    {
                        mant %= (EInteger)limit;
                        mantChanged = true;
                    }
                }
            }
            int flags = this.helper.GetFlags(thisValue);
            if (!mantChanged && (flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return thisValue;
            }
            flags &= BigNumberFlags.FlagNegative;
            flags |= BigNumberFlags.FlagQuietNaN;
            return this.helper.CreateNewWithFlags(mant, EInteger.Zero, flags);
        }

        private bool IsNullOrInt32FriendlyContext(EContext ctx)
        {
            return ctx == null || (
                (!ctx.HasFlags && ctx.Traps == 0) &&
                (!ctx.HasExponentRange ||
                  (ctx.EMin.CompareTo(-10) < 0 && ctx.EMax.Sign >= 0)) &&
                ctx.Rounding != ERounding.Floor && (!ctx.HasMaxPrecision ||
                  (this.thisRadix >= 10 && !ctx.IsPrecisionInBits &&
                    ctx.Precision.CompareTo(10) >= 0) ||
                  ((this.thisRadix >= 2 || ctx.IsPrecisionInBits) &&
                    ctx.Precision.CompareTo(32) >= 0)));
        }

        private bool RoundGivenAccum(
          IShiftAccumulator accum,
          ERounding rounding,
          bool neg)
        {
            var incremented = false;
            int radix = this.thisRadix;
            int lastDiscarded = accum.LastDiscardedDigit;
            int olderDiscarded = accum.OlderDiscardedDigits;
            // NOTE: HalfUp, HalfEven, and HalfDown care about
            // the identity of the last discarded digit
            if (rounding == ERounding.HalfUp)
            {
                incremented |= lastDiscarded >= (radix / 2);
            }
            else if (rounding == ERounding.HalfEven)
            {
                if (lastDiscarded >= (radix / 2))
                {
                    if (lastDiscarded > (radix / 2) || olderDiscarded != 0)
                    {
                        incremented = true;
                    }
                    else
                    {
                        incremented |= accum.ShiftedIntMod(2) == 1;
                    }
                }
            }
            else if (rounding == ERounding.HalfDown)
            {
                incremented |= lastDiscarded > (radix / 2) || (lastDiscarded ==
                    (radix / 2) && olderDiscarded != 0);
            }
            else if (rounding == ERounding.Ceiling)
            {
                incremented |= !neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Floor)
            {
                incremented |= neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Up)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Odd ||
            (rounding == ERounding.OddOrZeroFiveUp && radix == 2))
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0 &&
                  (accum.ShiftedIntMod(2) == 0);
            }
            else if (rounding == ERounding.ZeroFiveUp ||
            (rounding == ERounding.OddOrZeroFiveUp && radix != 2))
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    if (radix == 2)
                    {
                        incremented = true;
                    }
                    else
                    {
                        int lastDigit = accum.ShiftedIntMod(radix);
                        if (lastDigit == 0 || lastDigit == (radix / 2))
                        {
                            incremented = true;
                        }
                    }
                }
            }
            return incremented;
        }

        private bool RoundGivenDigits(
          int lastDiscarded,
          int olderDiscarded,
          ERounding rounding,
          bool neg,
          FastInteger fastNumber)
        {
            var incremented = false;
            int radix = this.thisRadix;
            // NOTE: HalfUp, HalfEven, and HalfDown care about
            // the identity of the last discarded digit
            if (rounding == ERounding.HalfUp)
            {
                incremented |= lastDiscarded >= (radix / 2);
            }
            else if (rounding == ERounding.HalfEven)
            {
                if (lastDiscarded >= (radix / 2))
                {
                    if (lastDiscarded > (radix / 2) || olderDiscarded != 0)
                    {
                        incremented = true;
                    }
                    else
                    {
                        incremented |= !fastNumber.IsEvenNumber;
                    }
                }
            }
            else if (rounding == ERounding.HalfDown)
            {
                incremented |= lastDiscarded > (radix / 2) || (lastDiscarded ==
                    (radix / 2) && olderDiscarded != 0);
            }
            else if (rounding == ERounding.Ceiling)
            {
                incremented |= !neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Floor)
            {
                incremented |= neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Up)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Odd ||
            (rounding == ERounding.OddOrZeroFiveUp && radix == 2))
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0 &&
                  fastNumber.IsEvenNumber;
            }
            else if (rounding == ERounding.ZeroFiveUp ||
            (rounding == ERounding.OddOrZeroFiveUp && radix != 2))
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    if (radix == 2)
                    {
                        incremented = true;
                    }
                    else
                    {
                        int lastDigit = FastIntegerFixed.FromFastInteger(
                            fastNumber).Mod(radix);
                        if (lastDigit == 0 || lastDigit == (radix / 2))
                        {
                            incremented = true;
                        }
                    }
                }
            }
            return incremented;
        }

        private bool RoundGivenDigits(
          int lastDiscarded,
          int olderDiscarded,
          ERounding rounding,
          bool neg,
          long longNumber)
        {
            var incremented = false;
            int radix = this.thisRadix;
            // NOTE: HalfUp, HalfEven, and HalfDown care about
            // the identity of the last discarded digit
            if (rounding == ERounding.HalfUp)
            {
                incremented |= lastDiscarded >= (radix / 2);
            }
            else if (rounding == ERounding.HalfEven)
            {
                if (lastDiscarded >= (radix / 2))
                {
                    if (lastDiscarded > (radix / 2) || olderDiscarded != 0)
                    {
                        incremented = true;
                    }
                    else
                    {
                        incremented |= (longNumber & 1) != 0;
                    }
                }
            }
            else if (rounding == ERounding.HalfDown)
            {
                incremented |= lastDiscarded > (radix / 2) || (lastDiscarded ==
                    (radix / 2) && olderDiscarded != 0);
            }
            else if (rounding == ERounding.Ceiling)
            {
                incremented |= !neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Floor)
            {
                incremented |= neg && (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Up)
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0;
            }
            else if (rounding == ERounding.Odd ||
            (rounding == ERounding.OddOrZeroFiveUp && radix == 2))
            {
                incremented |= (lastDiscarded | olderDiscarded) != 0 &&
                  ((longNumber & 1) == 0);
            }
            else if (rounding == ERounding.ZeroFiveUp ||
            (rounding == ERounding.OddOrZeroFiveUp && radix != 2))
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    if (radix == 2)
                    {
                        incremented = true;
                    }
                    else
                    {
                        var lastDigit = (int)(longNumber % radix);
                        if (lastDigit == 0 || lastDigit == (radix / 2))
                        {
                            incremented = true;
                        }
                    }
                }
            }
            return incremented;
        }

        private static readonly EContext DefaultUnlimited =
          EContext.UnlimitedHalfEven.WithRounding(ERounding.HalfEven);

        // private static int compareFast = 0;
        // private static int compareSlow = 0;
        // private static int compareNone = 0;
        private T RoundToPrecisionInternal(
          T thisValue,
          int lastDiscarded,
          int olderDiscarded,
          FastInteger shift,
          bool adjustNegativeZero,
          EContext ctx)
        {
            bool mantissaWasZero;
            bool nonHalfRounding;
            var finalizing = false;
            int flags;
            bool unlimitedPrecisionExp = ctx == null ||
              (!ctx.HasMaxPrecision && !ctx.HasExponentRange);
            int thisFlags = this.helper.GetFlags(thisValue);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    if (ctx != null && ctx.HasFlags)
                    {
                        ctx.Flags |= EContext.FlagInvalid;
                    }
                    return this.ReturnQuietNaN(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    return this.ReturnQuietNaN(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    return thisValue;
                }
            }
            // If context has unlimited precision and exponent range,
            // and no discarded digits or shifting
            if (unlimitedPrecisionExp && (lastDiscarded | olderDiscarded) == 0 &&
              (shift == null || shift.IsValueZero))
            {
                if (!(adjustNegativeZero &&
                    (thisFlags & BigNumberFlags.FlagNegative) != 0 &&
                    this.helper.GetMantissa(thisValue).IsZero))
                {
                    return thisValue;
                }
            }
            // If context has unlimited precision and exponent range,
            // and no flags, traps, or shifting
            if (unlimitedPrecisionExp && (ctx == null || !ctx.HasFlagsOrTraps) &&
              (shift == null || shift.IsValueZero))
            {
                ERounding er = (ctx == null) ? ERounding.HalfDown : ctx.Rounding;
                bool negative = (thisFlags & BigNumberFlags.FlagNegative) != 0;
                bool negzero = adjustNegativeZero && negative &&
                  this.helper.GetMantissa(thisValue).IsZero &&
                  (er != ERounding.Floor);
                if (!negzero)
                {
                    if (er == ERounding.Down)
                    {
                        return thisValue;
                    }
                    if (this.thisRadix == 10 && er == ERounding.HalfEven)
                    {
                        if (lastDiscarded < 5)
                        {
                            return thisValue;
                        }
                        else if (lastDiscarded > 5 || olderDiscarded != 0)
                        {
                            FastIntegerFixed bm = this.helper.GetMantissaFastInt(thisValue);
                            return this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.Add(bm, FastIntegerFixed.One),
                                this.helper.GetExponentFastInt(thisValue),
                                thisFlags);
                        }
                    }
                    if (this.thisRadix == 2 && (er == ERounding.HalfEven) &&
                      lastDiscarded == 0)
                    {
                        return thisValue;
                    }
                    if (!this.RoundGivenDigits(
                        lastDiscarded,
                        olderDiscarded,
                        er,
                        negative,
                        FastInteger.FromBig(this.helper.GetMantissa(thisValue))))
                    {
                        return thisValue;
                    }
                    else
                    {
                        FastIntegerFixed bm = this.helper.GetMantissaFastInt(thisValue);
                        return this.helper.CreateNewWithFlagsFastInt(
                            FastIntegerFixed.Add(bm, FastIntegerFixed.One),
                            this.helper.GetExponentFastInt(thisValue),
                            thisFlags);
                    }
                }
            }
            if ((lastDiscarded | olderDiscarded) == 0 &&
              (shift == null || shift.IsValueZero))
            {
                // DebugUtility.Log("fastpath for "+ctx+", "+thisValue);
                FastIntegerFixed expabs = this.helper.GetExponentFastInt(thisValue);
                if (expabs.IsValueZero && this.IsNullOrInt32FriendlyContext(ctx))
                {
                    FastIntegerFixed mantabs = this.helper.GetMantissaFastInt(thisValue);
                    if (mantabs.IsValueZero && adjustNegativeZero &&
                      (thisFlags & BigNumberFlags.FlagNegative) != 0)
                    {
                        return this.helper.ValueOf(0);
                    }
                    if (mantabs.CanFitInInt32())
                    {
                        // compareFast++;
                        return thisValue;
                    }
                }
            }
            ctx = ctx ?? DefaultUnlimited;
            ERounding rounding = ctx.Rounding;
            bool neg;
            // Check for common binary floating-point contexts, including those
            // covered by Binary32 and Binary64.
            // In the precision check below, no need to check if precision is
            // less than 0, since the EContext object should already ensure this
            if (this.thisRadix == 2 && ctx.HasMaxPrecision && ctx.HasExponentRange &&
              ctx.Precision.CompareTo(53) <= 0 && ctx.EMin.CompareTo(-2000) >= 0 &&
              ctx.EMax.CompareTo(2000) < 0 && (shift == null ||
                shift.CompareToInt(64) < 0))
            {
                int intPrecision = ctx.Precision.ToInt32Checked();
                int intEMax = ctx.EMax.ToInt32Checked();
                int intEMin = ctx.EMin.ToInt32Checked();
                int intShift = (shift == null) ? 0 : shift.ToInt32();
                FastIntegerFixed fmant = this.helper.GetMantissaFastInt(thisValue);
                FastIntegerFixed fexp = this.helper.GetExponentFastInt(thisValue);
                if (fmant.CanFitInInt64() && fexp.CanFitInInt32())
                {
                    long mantlong = fmant.ToInt64();
                    int explong = fexp.ToInt32();
                    int adjustedExp;
                    int normalMin;
                    int intDigitCount;
                    long origmant = mantlong;
                    // get the exponent range
                    // Fast path to check if rounding is necessary at all
                    // NOTE: At this point, the number won't be infinity or NaN
                    if (shift == null || shift.IsValueZero)
                    {
                        if (adjustNegativeZero && (thisFlags &
                            BigNumberFlags.FlagNegative) !=
                          0 && mantlong == 0 && (ctx.Rounding != ERounding.Floor))
                        {
                            // Change negative zero to positive zero
                            // except if the rounding mode is Floor
                            thisValue = this.EnsureSign(thisValue, false);
                            thisFlags = 0;
                        }
                        intDigitCount = NumberUtility.BitLength(mantlong);
                        if (intDigitCount < intPrecision)
                        {
                            var withRounding = false;
                            var stillWithinPrecision = false;
                            if (ctx.HasFlags && (lastDiscarded | olderDiscarded) != 0)
                            {
                                ctx.Flags |= EContext.FlagInexact | EContext.FlagRounded;
                            }
                            // NOTE: accum includes lastDiscarded and olderDiscarded
                            if (!this.RoundGivenDigits(
                                lastDiscarded,
                                olderDiscarded,
                                ctx.Rounding,
                                (thisFlags & BigNumberFlags.FlagNegative) != 0,
                                mantlong))
                            {
                                stillWithinPrecision = true;
                            }
                            else
                            {
                                withRounding = true;
                                ++mantlong;
                                intDigitCount = NumberUtility.BitLength(mantlong);
                                if (intDigitCount < intPrecision ||
                                  (intDigitCount == intPrecision && (this.thisRadix & 1) == 0 &&
                                    (mantlong & 1) != 0))
                                {
                                    stillWithinPrecision = true;
                                }
                                else
                                {
                                    long radixPower = 1L << intPrecision;
                                    stillWithinPrecision = mantlong < radixPower;
                                }
                            }
                            if (stillWithinPrecision)
                            {
                                if (!ctx.HasExponentRange)
                                {
                                    return withRounding ? this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt64(mantlong),
                                        this.helper.GetExponentFastInt(thisValue),
                                        thisFlags) : thisValue;
                                }
                                int bigexp = explong;
                                if (ctx == null || ctx.AdjustExponent)
                                {
                                    adjustedExp = bigexp + intPrecision - 1;
                                    normalMin = intEMin + intPrecision - 1;
                                }
                                else
                                {
                                    adjustedExp = bigexp;
                                    normalMin = intEMin;
                                }
                                if (adjustedExp <= intEMax && adjustedExp >= normalMin)
                                {
                                    return withRounding ? this.helper.CreateNewWithFlagsFastInt(
                                        FastIntegerFixed.FromInt64(mantlong),
                                        FastIntegerFixed.FromInt32(bigexp),
                                        thisFlags) : thisValue;
                                }
                            }
                        }
                    }
                    // Relatively slow path follows
                    // Console.WriteLine("slowpath mantexp="+mantlong+","+explong);
                    neg = (thisFlags & BigNumberFlags.FlagNegative) != 0;
                    if (adjustNegativeZero && neg && (ctx.Rounding != ERounding.Floor) &&
                      origmant == 0)
                    {
                        // Change negative zero to positive zero
                        // except if the rounding mode is Floor
                        thisValue = this.EnsureSign(thisValue, false);
                        thisFlags = 0;
                        neg = false;
                    }
                    mantissaWasZero = mantlong == 0 &&
                      (lastDiscarded | olderDiscarded) == 0;
                    flags = 0;
                    intDigitCount = NumberUtility.BitLength(mantlong);
                    nonHalfRounding = rounding != ERounding.HalfEven &&
                      rounding != ERounding.HalfUp && rounding != ERounding.HalfDown;
                    var intDiscardedBits = 0;
                    if (intDigitCount > intPrecision)
                    {
                        int bitShift = intDigitCount - intPrecision;
                        intDiscardedBits += bitShift;
                        olderDiscarded |= lastDiscarded;
                        // Get the bottommost shift minus 1 bits
                        olderDiscarded |= (bitShift > 1 && (mantlong <<
                              (64 - bitShift + 1)) != 0) ? 1 : 0;
                        // Get the bit just above that bit
                        lastDiscarded = (int)((mantlong >> (bitShift - 1)) & 0x01);
                        olderDiscarded = (olderDiscarded != 0) ? 1 : 0;
                        mantlong >>= bitShift;
                    }
                    else if (intShift > 0 && mantlong != 0)
                    {
                        olderDiscarded |= lastDiscarded;
                        if (intShift > intDigitCount)
                        {
                            olderDiscarded |= 1;
                            lastDiscarded = 0;
                            mantlong = 0;
                        }
                        else
                        {
                            // bottommost intShift minus 1 bits
                            olderDiscarded |= (intShift > 1 && (mantlong <<
                                  (64 - intShift + 1)) != 0) ? 1 : 0;
                            lastDiscarded = (int)((mantlong >> (intShift - 1)) & 0x01);
                            mantlong >>= intShift;
                        }
                        intDiscardedBits += intShift;
                    }
                    explong += intDiscardedBits;
                    long intFinalMantissa = 0;
                    var intFinalExponent = 0;
                    finalizing = false;
                    adjustedExp = explong;
                    if (ctx.AdjustExponent)
                    {
                        adjustedExp += NumberUtility.BitLength(mantlong) - 1;
                    }
                    if (adjustedExp > intEMax)
                    {
                        if (mantissaWasZero)
                        {
                            if (ctx.HasFlags)
                            {
                                ctx.Flags |= flags | EContext.FlagClamped;
                            }
                            if (ctx.ClampNormalExponents && ctx.AdjustExponent)
                            {
                                // Clamp exponents to eMax + 1 - precision
                                // if directed
                                intEMax = Math.Min(intEMax, intEMax + 1 - intPrecision);
                            }
                            return this.helper.CreateNewWithFlagsFastInt(
                                FastIntegerFixed.FromInt64(mantlong),
                                FastIntegerFixed.FromInt32(intEMax),
                                thisFlags);
                        }
                        return this.SignalOverflow(ctx, neg);
                    }
                    else if (adjustedExp < intEMin)
                    {
                        // Subnormal
                        int etiny = intEMin;
                        if (ctx.AdjustExponent)
                        {
                            etiny -= intPrecision - 1;
                        }
                        if (ctx.HasFlags && mantlong != 0)
                        {
                            int newAdjExponent = adjustedExp;
                            if (this.RoundGivenDigits(
                                lastDiscarded,
                                olderDiscarded,
                                rounding,
                                neg,
                                mantlong))
                            {
                                long intEarlyRounded = mantlong + 1;
                                if ((intEarlyRounded >> intPrecision) != 0)
                                {
                                    newAdjExponent = ctx.AdjustExponent ?
                                      explong + intPrecision - 1 : explong;
                                }
                                else
                                {
                                    newAdjExponent = ctx.AdjustExponent ?
                                      explong + NumberUtility.BitLength(intEarlyRounded) - 1 :
                                      explong;
                                }
                            }
                            if (newAdjExponent < intEMin)
                            {
                                flags |= EContext.FlagSubnormal;
                            }
                        }
                        int subExp = explong;
                        if (subExp < etiny)
                        {
                            int intExpDiff = etiny - subExp;
                            intDigitCount = NumberUtility.BitLength(mantlong);
                            if (mantlong != 0)
                            {
                                olderDiscarded |= lastDiscarded;
                                if (intExpDiff > intDigitCount)
                                {
                                    olderDiscarded |= 1;
                                    lastDiscarded = 0;
                                    mantlong = 0;
                                }
                                else
                                {
                                    // bottommost expdiff minus 1 bits
                                    olderDiscarded |= (intExpDiff > 1 && (mantlong <<
                                          (64 - intExpDiff + 1)) != 0) ? 1 : 0;
                                    lastDiscarded = (int)((mantlong >> (intExpDiff - 1)) & 0x01);
                                    mantlong >>= intExpDiff;
                                }
                                intDiscardedBits += intExpDiff;
                            }
                            /* DebugUtility.Log("mantlong now {0}, ld={1}, od={2} [ed={3},
                               flags={4}]",EInteger.FromInt64(mantlong).ToRadixString(2),
                               lastDiscarded,
                               olderDiscarded, expdiff, flags);
                            */
                            bool nonZeroDiscardedDigits = (lastDiscarded | olderDiscarded) !=
                              0;
                            if (intDiscardedBits > 0 || nonZeroDiscardedDigits)
                            {
                                if (!mantissaWasZero)
                                {
                                    flags |= EContext.FlagRounded;
                                }
                                if (nonZeroDiscardedDigits)
                                {
                                    flags |= EContext.FlagInexact | EContext.FlagRounded;

                                    if (rounding == ERounding.None)
                                    {
                                        return this.SignalInvalidWithMessage(
                                            ctx,
                                            "Rounding was required");
                                    }
                                }
                                if (this.RoundGivenDigits(
                                    lastDiscarded,
                                    olderDiscarded,
                                    rounding,
                                    neg,
                                    mantlong))
                                {
                                    ++mantlong;
                                }
                            }
                            if (ctx.HasFlags)
                            {
                                if (mantlong == 0)
                                {
                                    flags |= EContext.FlagClamped;
                                }
                                if ((flags & (EContext.FlagSubnormal |
                                      EContext.FlagInexact)) == (EContext.FlagSubnormal |
                                    EContext.FlagInexact))
                                {
                                    flags |= EContext.FlagUnderflow |
                                      EContext.FlagRounded;
                                }
                            }
                            // Finalize result of rounding operation
                            intFinalMantissa = mantlong;
                            intFinalExponent = etiny;
                            finalizing = true;
                        }
                    }
                    if (!finalizing)
                    {
                        var recheckOverflow = false;
                        bool doRounding = intDiscardedBits != 0 ||
                          (lastDiscarded | olderDiscarded) != 0;
                        if (doRounding)
                        {
                            if (mantlong != 0)
                            {
                                flags |= EContext.FlagRounded;
                            }
                            if ((lastDiscarded | olderDiscarded) != 0)
                            {
                                flags |= EContext.FlagInexact | EContext.FlagRounded;
                                if (rounding == ERounding.None)
                                {
                                    return this.SignalInvalidWithMessage(
                                        ctx,
                                        "Rounding was required");
                                }
                            }
                            if (this.RoundGivenDigits(
                                lastDiscarded,
                                olderDiscarded,
                                rounding,
                                neg,
                                mantlong))
                            {
                                ++mantlong;
                                // Check if mantissa's precision is now greater
                                // than the one set by the context
                                if ((mantlong >> intPrecision) != 0)
                                {
                                    mantlong >>= 1;
                                    ++explong;
                                    recheckOverflow = true;
                                }
                            }
                        }
                        if (recheckOverflow)
                        {
                            // Check for overflow again
                            adjustedExp = explong;
                            if (ctx.AdjustExponent)
                            {
                                adjustedExp += NumberUtility.BitLength(mantlong) - 1;
                            }
                            if (adjustedExp > intEMax)
                            {
                                return this.SignalOverflow(ctx, neg);
                            }
                        }
                        intFinalMantissa = mantlong;
                        intFinalExponent = explong;
                    }
                    if (ctx.ClampNormalExponents)
                    {
                        // Clamp exponents to eMax + 1 - precision
                        // if directed
                        int clampExp = intEMax;
                        if (ctx.AdjustExponent)
                        {
                            clampExp += intPrecision - 1;
                        }
                        if (intFinalExponent > clampExp)
                        {
                            if (intFinalMantissa != 0)
                            {
                                int expdiff = intFinalExponent - clampExp;
                                // DebugUtility.Log("Clamping " + exp + " to " + clampExp);
                                intFinalMantissa <<= expdiff;
                            }
                            if (ctx.HasFlags)
                            {
                                flags |= EContext.FlagClamped;
                            }
                            intFinalExponent = clampExp;
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= flags;
                    }
                    return this.helper.CreateNewWithFlagsFastInt(
                        FastIntegerFixed.FromInt64(intFinalMantissa),
                        FastIntegerFixed.FromInt64(intFinalExponent),
                        neg ? BigNumberFlags.FlagNegative : 0);
                }
            }

            // Binary precision of potentially non-binary numbers
            // binaryPrec means whether precision is the number of bits and not
            // digits
            bool binaryPrec = ctx.IsPrecisionInBits && this.thisRadix != 2 &&
              !ctx.Precision.IsZero;
            // get the precision
            FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
            IShiftAccumulator accum = null;
            FastInteger fastAdjustedExp;
            FastInteger fastNormalMin;
            FastInteger fastEMin = null;
            FastInteger fastEMax = null;
            FastIntegerFixed fastEMaxFixed = null;
            // get the exponent range
            if (ctx != null && ctx.HasExponentRange)
            {
                fastEMax = FastInteger.FromBig(ctx.EMax);
                fastEMaxFixed = FastIntegerFixed.FromBig(ctx.EMax);
                fastEMin = FastInteger.FromBig(ctx.EMin);
            }
            bool unlimitedPrec = !ctx.HasMaxPrecision;
            if (!binaryPrec)
            {
                // Fast path to check if rounding is necessary at all
                // NOTE: At this point, the number won't be infinity or NaN
                if (!unlimitedPrec && (shift == null || shift.IsValueZero))
                {
                    FastIntegerFixed mantabs = this.helper.GetMantissaFastInt(
                        thisValue);
                    if (adjustNegativeZero && (thisFlags & BigNumberFlags.FlagNegative) !=
                      0 && mantabs.IsValueZero && (ctx.Rounding != ERounding.Floor))
                    {
                        // Change negative zero to positive zero
                        // except if the rounding mode is Floor
                        thisValue = this.EnsureSign(thisValue, false);
                        thisFlags = 0;
                    }
                    accum = this.helper.CreateShiftAccumulatorWithDigitsFastInt(
                        mantabs,
                        lastDiscarded,
                        olderDiscarded);
                    FastInteger estDigitCount = accum.OverestimateDigitLength();
                    // NOTE: Overestimating the digit count will catch most,
                    // but not all, numbers that fit fastPrecision, and will not
                    // catch any numbers that don't fit fastPrecision
                    // DebugUtility.Log("estDigitCount=" + estDigitCount + ", " +
                    // fastPrecision);
                    if (estDigitCount.CompareTo(fastPrecision) <= 0)
                    {
                        var withRounding = false;
                        var stillWithinPrecision = false;
                        if (ctx.HasFlags && (lastDiscarded | olderDiscarded) != 0)
                        {
                            ctx.Flags |= EContext.FlagInexact | EContext.FlagRounded;
                        }
                        if (!this.RoundGivenAccum(
                            accum,
                            ctx.Rounding,
                            (thisFlags & BigNumberFlags.FlagNegative) != 0))
                        {
                            stillWithinPrecision = true;
                        }
                        else
                        {
                            withRounding = true;
                            mantabs = mantabs.Increment();
                            FastInteger digitCount = accum.GetDigitLength();
                            int precisionCmp = digitCount.CompareTo(fastPrecision);
                            if (precisionCmp < 0 ||
                              (precisionCmp == 0 && (this.thisRadix & 1) == 0 &&
                                !mantabs.IsEvenNumber))
                            {
                                stillWithinPrecision = true;
                            }
                            else
                            {
                                EInteger radixPower =
                                  this.TryMultiplyByRadixPower(EInteger.One, fastPrecision);
                                // DebugUtility.Log("now " + mantabs + "," + fastPrecision);
                                if (radixPower == null)
                                {
                                    return this.SignalInvalidWithMessage(
                                        ctx,
                                        "Result requires too much memory");
                                }
                                stillWithinPrecision = mantabs.CompareTo(radixPower) <
                                  0;
                            }
                        }
                        if (stillWithinPrecision)
                        {
                            if (!ctx.HasExponentRange)
                            {
                                return withRounding ? this.helper.CreateNewWithFlagsFastInt(
                                    mantabs,
                                    this.helper.GetExponentFastInt(thisValue),
                                    thisFlags) : thisValue;
                            }
                            FastIntegerFixed bigexp =
                              this.helper.GetExponentFastInt(thisValue);
                            if (ctx == null || ctx.AdjustExponent)
                            {
                                fastAdjustedExp = bigexp.ToFastInteger()
                                  .Add(fastPrecision).Decrement();
                                fastNormalMin = fastEMin.Copy()
                                  .Add(fastPrecision).Decrement();
                            }
                            else
                            {
                                fastAdjustedExp = bigexp.ToFastInteger();
                                fastNormalMin = fastEMin;
                            }
                            // DebugUtility.Log("{0}->{1},{2}"
                            // , fastAdjustedExp, fastEMax, fastNormalMin);
                            if (fastAdjustedExp.CompareTo(fastEMax) <= 0 &&
                              fastAdjustedExp.CompareTo(fastNormalMin) >= 0)
                            {
                                return withRounding ? this.helper.CreateNewWithFlagsFastInt(
                                    mantabs,
                                    bigexp,
                                    thisFlags) : thisValue;
                            }
                        }
                    }
                }
            }
            // compareSlow++;
            neg = (thisFlags & BigNumberFlags.FlagNegative) != 0;
            if (adjustNegativeZero && neg && (rounding != ERounding.Floor) &&
              this.helper.GetMantissa(thisValue).IsZero)
            {
                // Change negative zero to positive zero
                // except if the rounding mode is Floor
                thisValue = this.EnsureSign(thisValue, false);
                thisFlags = 0;
                neg = false;
            }
            FastIntegerFixed bigmantissa = this.helper.GetMantissaFastInt(thisValue);
            mantissaWasZero = bigmantissa.IsValueZero && (lastDiscarded |
                olderDiscarded) == 0;
            FastIntegerFixed expfixed = this.helper.GetExponentFastInt(thisValue);
            FastInteger exp = expfixed.ToFastInteger();
            flags = 0;
            if (accum == null)
            {
                accum = this.helper.CreateShiftAccumulatorWithDigitsFastInt(
                    bigmantissa,
                    lastDiscarded,
                    olderDiscarded);
            }
#if DEBUG
            if (!accum.DiscardedDigitCount.IsValueZero)
            {
                throw new ArgumentException(
                  "doesn't satisfy accum.DiscardedDigitCount.IsValueZero");
            }
#endif
            FastInteger bitLength = fastPrecision;
            if (binaryPrec)
            {
                fastPrecision =
                  this.DigitLengthUpperBoundForBitPrecision(fastPrecision);
            }
            nonHalfRounding = rounding != ERounding.HalfEven &&
              rounding != ERounding.HalfUp && rounding != ERounding.HalfDown;
            if (ctx != null && ctx.HasMaxPrecision &&
              ctx.HasExponentRange)
            {
                long estMantDigits = bigmantissa.CanFitInInt32() ?
                  10 : bigmantissa.ToEInteger().GetUnsignedBitLengthAsInt64();
                if (estMantDigits > 128)
                {
                    // Get bounds on stored precision
                    FastIntegerFixed[] bounds = NumberUtility.DigitLengthBoundsFixed(
                        this.helper,
                        bigmantissa);
                    FastIntegerFixed lowExpBound = expfixed;
                    if (ctx.AdjustExponent)
                    {
                        lowExpBound = lowExpBound.Add(bounds[0]).Subtract(2);
                    }
                    FastIntegerFixed highExpBound = expfixed;
                    highExpBound = highExpBound.Add(bounds[1]);
                    FastIntegerFixed fpf =
          FastIntegerFixed.FromFastInteger(fastPrecision);
                    /* string
          ch1=""+lowExpBound;ch1=ch1.Substring(0,Math.Min(12,ch1.Length));
                    string
          ch2=""+highExpBound;ch2=ch2.Substring(0,Math.Min(12,ch2.Length));
                    DebugUtility.Log("exp="+expfixed);
                    DebugUtility.Log("bounds="+ch1+"/"+ch2+"/"+fastEMax+
                      " fpf="+fastPrecision + " highexp=" +highExpBound.Add(fpf).Add(4));
                    */
                    if (lowExpBound.CompareTo(fastEMax) > 0)
                    {
                        // Overflow.
                        return this.SignalOverflow(ctx, neg);
                    }
                    FastIntegerFixed underflowBound = highExpBound.Add(fpf).Add(4);
                    // FastIntegerFixed underflowBound2 = highExpBound.Add(bounds[1]).Add(4);
                    // if (underflowBound2.CompareTo(underflowBound) > 0) {
                    // underflowBound = underflowBound2;
                    // }
                    // DebugUtility.Log("underflowBound="+underflowBound);
                    if (underflowBound.CompareTo(fastEMin) < 0)
                    {
                        // Underflow.
                        // NOTE: Due to estMantDigits check
                        // above, we know significand is neither zero nor 1(
                        // SignalUnderflow will pass significands of 0 or 1 to
                        // RoundToPrecision).
                        return this.SignalUnderflow(ctx, neg, false);
                    }
                    /*
                     DebugUtility.Log("mantbits=" +
                         bigmantissa.ToEInteger().GetUnsignedBitLengthAsInt64() +
                         " shift=" + shift + " fastprec=" + fastPrecision +
                         " expbits=" + exp.ToEInteger().GetUnsignedBitLengthAsInt64() +
                         " expsign=" + exp.ToEInteger().CompareTo(0)); */
                }
            }
            if (!unlimitedPrec)
            {
                accum.ShiftToDigits(fastPrecision, shift, nonHalfRounding);
            }
            else
            {
                if (shift != null && shift.Sign != 0)
                {
                    accum.TruncateOrShiftRight(shift, nonHalfRounding);
                }
                fastPrecision = accum.GetDigitLength();
            }
            if (binaryPrec)
            {
                while (bitLength.CompareTo(
                    accum.ShiftedInt.GetUnsignedBitLengthAsEInteger()) < 0)
                {
                    accum.ShiftRightInt(1);
                }
            }
            FastInteger discardedBits = accum.DiscardedDigitCount.Copy();
            exp.Add(discardedBits);
            FastIntegerFixed finalMantissa = null;
            FastIntegerFixed finalExponent = null;
            finalizing = false;
            FastInteger adjExponent;
            adjExponent = ctx.AdjustExponent ?
              exp.Copy().Add(accum.GetDigitLength()).Decrement() : exp.Copy();
            if (binaryPrec)
            {
                // NOTE: Binary precision case only
                if (fastEMax != null && adjExponent.CompareTo(fastEMax) == 0)
                {
                    // May or may not be an overflow depending on the mantissa
                    FastInteger expdiff =
                      fastPrecision.Copy().Subtract(accum.GetDigitLength());
                    EInteger currMantissa = accum.ShiftedInt;
                    currMantissa = this.TryMultiplyByRadixPower(currMantissa, expdiff);
                    if (currMantissa == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }

                    if (bitLength.CompareTo(
                        currMantissa.GetUnsignedBitLengthAsEInteger()) < 0)
                    {
                        // Mantissa too high, treat as overflow
                        adjExponent.Increment();
                    }
                }
            }
            if (fastEMax != null && adjExponent.CompareTo(fastEMax) > 0)
            {
                if (mantissaWasZero)
                {
                    if (ctx.HasFlags)
                    {
                        ctx.Flags |= flags | EContext.FlagClamped;
                    }
                    if (ctx.ClampNormalExponents && ctx.AdjustExponent)
                    {
                        // Clamp exponents to eMax + 1 - precision
                        // if directed
                        FastInteger clampExp = fastEMax.Copy();
                        clampExp.Increment().Subtract(fastPrecision);
                        if (fastEMax.CompareTo(clampExp) > 0)
                        {
                            fastEMax = clampExp;
                        }
                    }
                    return this.helper.CreateNewWithFlagsFastInt(
                        bigmantissa,
                        FastIntegerFixed.FromFastInteger(fastEMax),
                        thisFlags);
                }
                return this.SignalOverflow(ctx, neg);
            }
            else if (fastEMin != null && adjExponent.CompareTo(fastEMin) < 0)
            {
                // Subnormal
                FastInteger fastETiny = fastEMin;
                if (ctx.AdjustExponent)
                {
                    fastETiny = fastETiny.Copy().Subtract(fastPrecision).Increment();
                }
                if (ctx.HasFlags && !accum.ShiftedInt.IsZero)
                {
                    FastInteger newAdjExponent = adjExponent;
                    if (this.RoundGivenAccum(accum, rounding, neg))
                    {
                        EInteger earlyRounded = accum.ShiftedInt + EInteger.One;
                        if (!unlimitedPrec && (earlyRounded.IsEven ||
                            (this.thisRadix & 1) != 0))
                        {
                            FastInteger newDigitLength =
                              this.helper.GetDigitLength(earlyRounded);
                            // Ensure newDigitLength doesn't exceed precision
                            if (binaryPrec || newDigitLength.CompareTo(fastPrecision) >
                              0)
                            {
                                newDigitLength = fastPrecision.Copy();
                            }
                            newAdjExponent = ctx.AdjustExponent ?
                              exp.Copy().Add(newDigitLength).Decrement() : exp;
                        }
                    }
                    if (newAdjExponent.CompareTo(fastEMin) < 0)
                    {
                        // DebugUtility.Log("subnormal");
                        flags |= EContext.FlagSubnormal;
                    }
                }
                // DebugUtility.Log("exp=" + exp + " eTiny=" + fastETiny);
                FastInteger subExp = exp.Copy();
                // DebugUtility.Log("exp=" + subExp + " eTiny=" + fastETiny);
                if (subExp.CompareTo(fastETiny) < 0)
                {
                    // DebugUtility.Log("Less than ETiny");
                    FastInteger expdiff = fastETiny.Copy().Subtract(subExp);
                    // DebugUtility.Log("<ETiny: " + (accum.ShiftedInt));
                    accum.TruncateOrShiftRight(
                      expdiff,
                      nonHalfRounding);
                    // DebugUtility.Log("<ETiny2: " + (accum.ShiftedInt));
                    FastInteger newmantissa = accum.ShiftedIntFast;
                    bool nonZeroDiscardedDigits = (accum.LastDiscardedDigit |
                        accum.OlderDiscardedDigits) != 0;
                    // if (rounding == ERounding.None) {
                    // DebugUtility.Log("<nzdd= " + nonZeroDiscardedDigits);
                    // }
                    if (accum.DiscardedDigitCount.Sign != 0 || nonZeroDiscardedDigits)
                    {
                        if (!mantissaWasZero)
                        {
                            flags |= EContext.FlagRounded;
                        }
                        if (nonZeroDiscardedDigits)
                        {
                            flags |= EContext.FlagInexact | EContext.FlagRounded;
                            if (rounding == ERounding.None)
                            {
                                return this.SignalInvalidWithMessage(
                                    ctx,
                                    "Rounding was required");
                            }
                        }

                        if (this.RoundGivenAccum(accum, rounding, neg))
                        {
                            newmantissa.Increment();
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        if (newmantissa.IsValueZero)
                        {
                            flags |= EContext.FlagClamped;
                        }
                        if ((flags & (EContext.FlagSubnormal |
                              EContext.FlagInexact)) == (EContext.FlagSubnormal |
                            EContext.FlagInexact))
                        {
                            flags |= EContext.FlagUnderflow |
                              EContext.FlagRounded;
                        }
                    }
                    // Finalize result of rounding operation
                    finalMantissa = FastIntegerFixed.FromFastInteger(newmantissa);
                    finalExponent = FastIntegerFixed.FromFastInteger(fastETiny);
                    finalizing = true;
                }
            }
            if (!finalizing)
            {
                // DebugUtility.Log("" + accum.ShiftedInt + ", exp=" +
                // adjExponent + "/" + fastEMin);
                var recheckOverflow = false;
                bool doRounding = accum.DiscardedDigitCount.Sign != 0 ||
                  (accum.LastDiscardedDigit | accum.OlderDiscardedDigits) != 0;
                EInteger bigmantissaEInteger = accum.ShiftedInt;
                if (doRounding)
                {
                    if (!bigmantissaEInteger.IsZero)
                    {
                        flags |= EContext.FlagRounded;
                    }
                    if ((accum.LastDiscardedDigit | accum.OlderDiscardedDigits) != 0)
                    {
                        flags |= EContext.FlagInexact | EContext.FlagRounded;
                        if (rounding == ERounding.None)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Rounding was required");
                        }
                    }
                    if (this.RoundGivenAccum(accum, rounding, neg))
                    {
                        // DebugUtility.Log("recheck overflow {0} {1} / {2} [prec={3}]"
                        // , adjExponent, fastEMax, accum.ShiftedInt, fastPrecision);
                        bigmantissaEInteger = bigmantissaEInteger.Add(1);
                        recheckOverflow |= binaryPrec;
                        // Check if mantissa's precision is now greater
                        // than the one set by the context
                        if (!unlimitedPrec &&
                          (bigmantissaEInteger.IsEven || (this.thisRadix & 1) != 0) &&
                          (binaryPrec || accum.GetDigitLength().CompareTo(fastPrecision) >=

                            0))
                        {
                            accum = this.helper.CreateShiftAccumulatorWithDigits(
                                bigmantissaEInteger,
                                0,
                                0);
                            FastInteger newDigitLength = accum.GetDigitLength();
                            if (binaryPrec || newDigitLength.CompareTo(fastPrecision) > 0)
                            {
                                FastInteger neededShift =
                                  newDigitLength.Copy().Subtract(fastPrecision);
                                accum.TruncateOrShiftRight(
                                  neededShift,
                                  nonHalfRounding);
                                if (binaryPrec)
                                {
                                    while (bitLength.CompareTo(
                                        accum.ShiftedInt.GetUnsignedBitLengthAsEInteger()) < 0)
                                    {
                                        accum.ShiftRightInt(1);
                                    }
                                }
                                if (accum.DiscardedDigitCount.Sign != 0)
                                {
                                    exp.Add(accum.DiscardedDigitCount);
                                    discardedBits.Add(accum.DiscardedDigitCount);
                                    bigmantissaEInteger = accum.ShiftedInt;
                                    recheckOverflow |= !binaryPrec;
                                }
                            }
                        }
                    }
                }
                if (fastEMax != null && recheckOverflow)
                {
                    // Check for overflow again
                    // DebugUtility.Log("recheck overflow2 {0} {1} / {2}"
                    // , adjExponent, fastEMax, accum.ShiftedInt);
                    adjExponent = exp.Copy();
                    if (ctx.AdjustExponent)
                    {
                        adjExponent.Add(accum.GetDigitLength()).Decrement();
                    }
                    if (binaryPrec && fastEMax != null &&
                      adjExponent.CompareTo(fastEMax) == 0)
                    {
                        // May or may not be an overflow depending on the mantissa
                        // (uses accumulator from previous steps, including the check
                        // if the mantissa now exceeded the precision)
                        FastInteger expdiff =
                          fastPrecision.Copy().Subtract(accum.GetDigitLength());
                        EInteger currMantissa = accum.ShiftedInt;
                        currMantissa = this.TryMultiplyByRadixPower(currMantissa, expdiff);
                        if (currMantissa == null)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Result requires too much memory");
                        }
                        if (bitLength.CompareTo(
                            currMantissa.GetUnsignedBitLengthAsEInteger()) < 0)
                        {
                            // Mantissa too high, treat as overflow
                            adjExponent.Increment();
                        }
                    }
                    if (adjExponent.CompareTo(fastEMax) > 0)
                    {
                        return this.SignalOverflow(ctx, neg);
                    }
                }
                finalMantissa = FastIntegerFixed.FromBig(bigmantissaEInteger);
                finalExponent = FastIntegerFixed.FromFastInteger(exp);
            }
            // Finalize the result of the rounding operation
            if (ctx.ClampNormalExponents)
            {
                // Clamp exponents to eMax + 1 - precision
                // if directed
                FastInteger clampExp = fastEMax.Copy();
                if (ctx.AdjustExponent)
                {
                    clampExp.Increment().Subtract(fastPrecision);
                }
                if (exp.CompareTo(clampExp) > 0)
                {
                    if (!finalMantissa.IsValueZero)
                    {
                        FastIntegerFixed expdiff = FastIntegerFixed.Subtract(
                            finalExponent,
                            FastIntegerFixed.FromFastInteger(clampExp));
                        // DebugUtility.Log("Clamping " + exp + " to " + clampExp);
                        finalMantissa = this.TryMultiplyByRadixPowerFastInt(
                            finalMantissa,
                            expdiff);
                        if (finalMantissa == null)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Result requires too much memory");
                        }
                    }
                    if (ctx.HasFlags)
                    {
                        flags |= EContext.FlagClamped;
                    }
                    finalExponent = FastIntegerFixed.FromFastInteger(clampExp);
                }
            }
            if (ctx.HasFlags)
            {
                ctx.Flags |= flags;
            }
            return this.helper.CreateNewWithFlagsFastInt(
                finalMantissa,
                finalExponent,
                neg ? BigNumberFlags.FlagNegative : 0);
        }

        // Compare bigLeft with half of toCompareWith, while avoiding
        // the need to compute half of toCompareWith in many cases.
        // Assumes both inputs are positive.
        private static int CompareToHalf(EInteger bigLeft, EInteger toCompareWith)
        {
#if DEBUG
            if (!(bigLeft.Sign > 0 && toCompareWith.Sign > 0))
            {
                throw new ArgumentException("doesn't satisfy bigLeft.Sign > 0 && " +
                  "toCompareWith.Sign > 0");
            }
#endif
            long a = bigLeft.GetUnsignedBitLengthAsInt64();
            long b = toCompareWith.GetUnsignedBitLengthAsInt64();
            if (a != Int64.MaxValue && b != Int64.MaxValue)
            {
                if (b - 1 > a)
                {
                    return -1;
                }
                if (a - 1 > b)
                {
                    return 1;
                }
            }
            int cmp = bigLeft.CompareTo(toCompareWith.ShiftRight(1));
            return (cmp == 0 && !toCompareWith.IsEven) ? -1 : cmp;
        }

        private T RoundToScale(
          EInteger mantissa,
          EInteger remainder,
          EInteger divisor,
          EInteger desiredExponent,
          FastInteger shift,
          bool neg,
          EContext ctx)
        {
#if DEBUG
            if (mantissa.Sign < 0)
            {
                throw new ArgumentException("doesn't satisfy mantissa.Sign>= 0");
            }
            if (remainder.Sign < 0)
            {
                throw new ArgumentException("doesn't satisfy remainder.Sign>= 0");
            }
            if (divisor.Sign < 0)
            {
                throw new ArgumentException("doesn't satisfy divisor.Sign>= 0");
            }
#endif
            ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
            var lastDiscarded = 0;
            var olderDiscarded = 0;
            if (!remainder.IsZero)
            {
                if (rounding == ERounding.HalfDown || rounding == ERounding.HalfUp ||
                  rounding == ERounding.HalfEven)
                {
                    int cmpHalf = CompareToHalf(remainder, divisor);
                    if (cmpHalf == 0)
                    {
                        // remainder is exactly half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 0;
                    }
                    else if (cmpHalf > 0)
                    {
                        // remainder is greater than half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 1;
                    }
                    else
                    {
                        // remainder is less than half
                        lastDiscarded = 0;
                        olderDiscarded = 1;
                    }
                }
                else
                {
                    // Rounding mode doesn't care about
                    // whether remainder is exactly half
                    if (rounding == ERounding.None)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Rounding was required");
                    }
                    lastDiscarded = 1;
                    olderDiscarded = 1;
                }
            }
            var flags = 0;
            EInteger newmantissa = mantissa;
            if (shift.IsValueZero)
            {
                if ((lastDiscarded | olderDiscarded) != 0)
                {
                    flags |= EContext.FlagInexact | EContext.FlagRounded;
                    if (rounding == ERounding.None)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Rounding was required");
                    }
                    FastInteger fastNewMantissa = FastInteger.FromBig(newmantissa);
                    if (
                      this.RoundGivenDigits(
                        lastDiscarded,
                        olderDiscarded,
                        rounding,
                        neg,
                        fastNewMantissa))
                    {
                        newmantissa += EInteger.One;
                    }
                }
            }
            else
            {
                IShiftAccumulator accum = this.helper.CreateShiftAccumulatorWithDigits(
                    mantissa,
                    lastDiscarded,
                    olderDiscarded);
                accum.TruncateOrShiftRight(
                  shift,
                  false);
                newmantissa = accum.ShiftedInt;
                if (accum.DiscardedDigitCount.Sign != 0 ||
                  (accum.LastDiscardedDigit | accum.OlderDiscardedDigits) !=
                  0)
                {
                    if (!mantissa.IsZero)
                    {
                        flags |= EContext.FlagRounded;
                    }
                    if ((accum.LastDiscardedDigit | accum.OlderDiscardedDigits) != 0)
                    {
                        flags |= EContext.FlagInexact | EContext.FlagRounded;
                        if (rounding == ERounding.None)
                        {
                            return this.SignalInvalidWithMessage(
                                ctx,
                                "Rounding was required");
                        }
                    }
                    if (this.RoundGivenAccum(accum, rounding, neg))
                    {
                        newmantissa += EInteger.One;
                    }
                }
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= flags;
            }
            return this.helper.CreateNewWithFlags(
                newmantissa,
                desiredExponent,
                neg ? BigNumberFlags.FlagNegative : 0);
        }

        private int[] RoundToScaleStatus(
          EInteger remainder,
          EInteger divisor,
          EContext ctx)
        {
            ERounding rounding = (ctx == null) ? ERounding.HalfEven : ctx.Rounding;
            var lastDiscarded = 0;
            var olderDiscarded = 0;
            if (!remainder.IsZero)
            {
                if (rounding == ERounding.HalfDown || rounding == ERounding.HalfUp ||
                  rounding == ERounding.HalfEven)
                {
                    int cmpHalf = CompareToHalf(remainder, divisor);
                    if (cmpHalf == 0)
                    {
                        // remainder is exactly half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 0;
                    }
                    else if (cmpHalf > 0)
                    {
                        // remainder is greater than half
                        lastDiscarded = this.thisRadix / 2;
                        olderDiscarded = 1;
                    }
                    else
                    {
                        // remainder is less than half
                        lastDiscarded = 0;
                        olderDiscarded = 1;
                    }
                }
                else
                {
                    // Rounding mode doesn't care about
                    // whether remainder is exactly half
                    if (rounding == ERounding.None)
                    {
                        // Rounding was required
                        return null;
                    }
                    lastDiscarded = 1;
                    olderDiscarded = 1;
                }
            }
            return new[] { lastDiscarded, olderDiscarded };
        }

        private T SignalDivideByZero(EContext ctx, bool neg)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagDivideByZero;
            }
            if (this.support == BigNumberFlags.FiniteOnly)
            {
                throw new DivideByZeroException("Division by zero");
            }
            int flags = BigNumberFlags.FlagInfinity |
              (neg ? BigNumberFlags.FlagNegative : 0);
            return this.helper.CreateNewWithFlags(
                EInteger.Zero,
                EInteger.Zero,
                flags);
        }

        private T SignalingNaNInvalid(T value, EContext ctx)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            return this.ReturnQuietNaN(value, ctx);
        }

        private T SignalInvalid(EContext ctx)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            if (this.support == BigNumberFlags.FiniteOnly)
            {
                throw new ArithmeticException("Invalid operation");
            }
            return this.helper.CreateNewWithFlags(
                EInteger.Zero,
                EInteger.Zero,
                BigNumberFlags.FlagQuietNaN);
        }

        private T SignalInvalidWithMessage(EContext ctx, string str)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            if (this.support == BigNumberFlags.FiniteOnly)
            {
                throw new ArithmeticException(str);
            }
            // if (str.IndexOf("Rounding was") < 0) {
            // throw new ArithmeticException(str);
            // } else {
            // DebugUtility.Log(str);
            // }
            return this.helper.CreateNewWithFlags(
                EInteger.Zero,
                EInteger.Zero,
                BigNumberFlags.FlagQuietNaN);
        }

        public T SignalOverflow(EContext ctx, bool neg)
        {
            if (ctx != null)
            {
                ERounding roundingOnOverflow = ctx.Rounding;
                if (ctx.HasFlags)
                {
                    ctx.Flags |= EContext.FlagOverflow |
                      EContext.FlagInexact | EContext.FlagRounded;
                }
                if (roundingOnOverflow == ERounding.None)
                {
                    return this.SignalInvalidWithMessage(
                        ctx,
                        "Rounding was required");
                }
                if (ctx.HasMaxPrecision && ctx.HasExponentRange &&
                  (roundingOnOverflow == ERounding.Down ||
                    roundingOnOverflow == ERounding.ZeroFiveUp ||
                    roundingOnOverflow == ERounding.OddOrZeroFiveUp ||
                    roundingOnOverflow == ERounding.Odd ||
                    (roundingOnOverflow == ERounding.Ceiling && neg) ||
                    (roundingOnOverflow == ERounding.Floor && !neg)))
                {
                    // Set to the highest possible value for
                    // the given precision
                    EInteger overflowMant = EInteger.Zero;
                    FastInteger fastPrecision = FastInteger.FromBig(ctx.Precision);
                    overflowMant = this.TryMultiplyByRadixPower(
                        EInteger.One,
                        fastPrecision);
                    if (overflowMant == null)
                    {
                        return this.SignalInvalidWithMessage(
                            ctx,
                            "Result requires too much memory");
                    }
                    overflowMant -= EInteger.One;
                    FastInteger clamp = FastInteger.FromBig(ctx.EMax);
                    if (ctx.AdjustExponent)
                    {
                        clamp.Increment().Subtract(fastPrecision);
                    }
                    return this.helper.CreateNewWithFlags(
                        overflowMant,
                        clamp.ToEInteger(),
                        neg ? BigNumberFlags.FlagNegative : 0);
                }
            }
            return this.support == BigNumberFlags.FiniteOnly ? default(T) :
              this.helper.CreateNewWithFlags(
                EInteger.Zero,
                EInteger.Zero,
                (neg ? BigNumberFlags.FlagNegative : 0) | BigNumberFlags.FlagInfinity);
        }

        private T SquareRootHandleSpecial(T thisValue, EContext ctx)
        {
            int thisFlags = this.helper.GetFlags(thisValue);
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
                {
                    return this.SignalingNaNInvalid(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0)
                {
                    return this.ReturnQuietNaN(thisValue, ctx);
                }
                if ((thisFlags & BigNumberFlags.FlagInfinity) != 0)
                {
                    // Square root of infinity
                    return ((thisFlags & BigNumberFlags.FlagNegative) != 0) ?
                      this.SignalInvalid(ctx) : thisValue;
                }
            }
            int sign = this.helper.GetSign(thisValue);
            return (sign < 0) ? this.SignalInvalid(ctx) : default(T);
        }

        private EInteger TryMultiplyByRadixPower(
          EInteger bi,
          int radixPowerInt)
        {
            if (bi.IsZero || radixPowerInt == 0)
            {
                return bi;
            }
            return this.helper.MultiplyByRadixPower(bi,
                new FastInteger(radixPowerInt));
        }

        private EInteger TryMultiplyByRadixPower(
          EInteger bi,
          FastInteger radixPower)
        {
            if (bi.IsZero)
            {
                return bi;
            }
            if (!radixPower.CanFitInInt32())
            {
                // NOTE: For radix 10, each digit fits less than 1 byte; the
                // supported byte length is thus less than the maximum value
                // of a 32-bit integer (2GB).
                FastInteger fastBI = FastInteger.FromBig(valueMaxDigits);
                if (this.thisRadix != 10 || radixPower.CompareTo(fastBI) > 0)
                {
                    return null;
                }
            }
            return this.helper.MultiplyByRadixPower(bi, radixPower);
        }

        private FastIntegerFixed TryMultiplyByRadixPowerFastInt(
          FastIntegerFixed bi,
          FastIntegerFixed radixPower)
        {
            if (bi.IsValueZero)
            {
                return bi;
            }
            if (!radixPower.CanFitInInt32())
            {
                // NOTE: For radix 10, each digit fits less than 1 byte; the
                // supported byte length is thus less than the maximum value
                // of a 32-bit integer (2GB).
                FastIntegerFixed fastBI = FastIntegerFixed.FromBig(valueMaxDigits);
                if (this.thisRadix != 10 || radixPower.CompareTo(fastBI) > 0)
                {
                    return null;
                }
                return FastIntegerFixed.FromBig(this.helper.MultiplyByRadixPower(
                      bi.ToEInteger(),
                      FastInteger.FromBig(radixPower.ToEInteger())));
            }
            else
            {
                return FastIntegerFixed.FromBig(this.helper.MultiplyByRadixPower(
                      bi.ToEInteger(),
                      new FastInteger(radixPower.ToInt32())));
            }
        }

        private FastIntegerFixed TryMultiplyByRadixPowerFastInt(
          FastIntegerFixed bi,
          FastInteger radixPower)
        {
            if (bi.IsValueZero)
            {
                return bi;
            }
            if (!radixPower.CanFitInInt32())
            {
                // NOTE: For radix 10, each digit fits less than 1 byte; the
                // supported byte length is thus less than the maximum value
                // of a 32-bit integer (2GB).
                FastInteger fastBI = FastInteger.FromBig(valueMaxDigits);
                if (this.thisRadix != 10 || radixPower.CompareTo(fastBI) > 0)
                {
                    return null;
                }
            }
            return FastIntegerFixed.FromBig(this.helper.MultiplyByRadixPower(
                  bi.ToEInteger(),
                  radixPower));
        }

        private T ValueOf(int value, EContext ctx)
        {
            return (ctx == null || !ctx.HasExponentRange ||
                ctx.ExponentWithinRange(EInteger.Zero)) ?
              this.helper.ValueOf(value) :
              this.RoundToPrecision(this.helper.ValueOf(value), ctx);
        }
    }

    internal sealed class SimpleRadixMath<T> : IRadixMath<T>
    {
        private readonly IRadixMath<T> wrapper;

        public SimpleRadixMath(IRadixMath<T> wrapper)
        {
            this.wrapper = wrapper;
        }

        private static EContext GetContextWithFlags(EContext ctx)
        {
            return (ctx == null) ? ctx : ctx.WithBlankFlags();
        }

        private T SignalInvalid(EContext ctx)
        {
            if (this.GetHelper().GetArithmeticSupport() ==
              BigNumberFlags.FiniteOnly)
            {
                throw new ArithmeticException("Invalid operation");
            }
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            return this.GetHelper().CreateNewWithFlags(
              EInteger.Zero,
              EInteger.Zero,
              BigNumberFlags.FlagQuietNaN);
        }

        private T PostProcess(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc)
        {
            return this.PostProcessEx(thisValue, ctxDest, ctxSrc, false, false);
        }

        private T PostProcessAfterDivision(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc)
        {
            return this.PostProcessEx(thisValue, ctxDest, ctxSrc, true, false);
        }

        private T PostProcessAfterQuantize(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc)
        {
            return this.PostProcessEx(thisValue, ctxDest, ctxSrc, false, true);
        }

        private T PostProcessEx(
          T thisValue,
          EContext ctxDest,
          EContext ctxSrc,
          bool afterDivision,
          bool afterQuantize)
        {
            int thisFlags = this.GetHelper().GetFlags(thisValue);
            if (ctxDest != null && ctxSrc != null)
            {
                if (ctxDest.HasFlags)
                {
                    if (!ctxSrc.ClampNormalExponents)
                    {
                        ctxSrc.Flags &= ~EContext.FlagClamped;
                    }
                    ctxDest.Flags |= ctxSrc.Flags;
                    if ((ctxSrc.Flags & EContext.FlagSubnormal) != 0)
                    {
                        // Treat subnormal numbers as underflows
                        ctxDest.Flags |= EContext.FlagUnderflow |
            EContext.FlagSubnormal | EContext.FlagInexact | EContext.FlagRounded;
                    }
                }
            }
            if ((thisFlags & BigNumberFlags.FlagSpecial) != 0)
            {
                return (ctxDest.Flags == 0) ? this.SignalInvalid(ctxDest) : thisValue;
            }
            EInteger mant = this.GetHelper().GetMantissa(thisValue).Abs();
            if (mant.IsZero)
            {
                return afterQuantize ? this.GetHelper().CreateNewWithFlags(
                    mant,
                    this.GetHelper().GetExponent(thisValue),
                    0) : this.wrapper.RoundToPrecision(
                    this.GetHelper().ValueOf(0),
                    ctxDest);
            }
            if (afterQuantize)
            {
                return thisValue;
            }
            EInteger exp = this.GetHelper().GetExponent(thisValue);
            if (exp.Sign > 0)
            {
                FastInteger fastExp = FastInteger.FromBig(exp);
                if (ctxDest == null || !ctxDest.HasMaxPrecision)
                {
                    mant = this.GetHelper().MultiplyByRadixPower(mant, fastExp);
                    return this.GetHelper().CreateNewWithFlags(
                      mant,
                      EInteger.Zero,
                      thisFlags);
                }
                if (!ctxDest.ExponentWithinRange(exp))
                {
                    return thisValue;
                }
                FastInteger prec = FastInteger.FromBig(ctxDest.Precision);
                FastInteger digits = this.GetHelper().GetDigitLength(mant);
                prec.Subtract(digits);
                if (prec.Sign > 0 && prec.CompareTo(fastExp) >= 0)
                {
                    mant = this.GetHelper().MultiplyByRadixPower(mant, fastExp);
                    return this.GetHelper().CreateNewWithFlags(
                      mant,
                      EInteger.Zero,
                      thisFlags);
                }
                if (afterDivision)
                {
                    int radix = this.GetHelper().GetRadix();
                    mant = NumberUtility.ReduceTrailingZeros(
                      mant,
                      fastExp,
                      radix,
                      null,
                      null,
                      null);
                    thisValue = this.GetHelper().CreateNewWithFlags(
                        mant,
                        fastExp.ToEInteger(),
                        thisFlags);
                }
            }
            else if (afterDivision && exp.Sign < 0)
            {
                FastInteger fastExp = FastInteger.FromBig(exp);
                int radix = this.GetHelper().GetRadix();
                mant = NumberUtility.ReduceTrailingZeros(
                    mant, fastExp, radix, null, null, new FastInteger(0));
                thisValue = this.GetHelper().CreateNewWithFlags(
                    mant,
                    fastExp.ToEInteger(),
                    thisFlags);
            }
            return thisValue;
        }

        private T ReturnQuietNaN(T thisValue, EContext ctx)
        {
            EInteger mant = this.GetHelper().GetMantissa(thisValue).Abs();
            var mantChanged = false;
            if (!mant.IsZero && ctx != null && ctx.HasMaxPrecision)
            {
                EInteger limit = this.GetHelper().MultiplyByRadixPower(
                    EInteger.One,
                    FastInteger.FromBig(ctx.Precision));
                if (mant.CompareTo(limit) >= 0)
                {
                    mant %= (EInteger)limit;
                    mantChanged = true;
                }
            }
            int flags = this.GetHelper().GetFlags(thisValue);
            if (!mantChanged && (flags & BigNumberFlags.FlagQuietNaN) != 0)
            {
                return thisValue;
            }
            flags &= BigNumberFlags.FlagNegative;
            flags |= BigNumberFlags.FlagQuietNaN;
            return this.GetHelper().CreateNewWithFlags(mant, EInteger.Zero, flags);
        }

        private T HandleNotANumber(T thisValue, T other, EContext ctx)
        {
            int thisFlags = this.GetHelper().GetFlags(thisValue);
            int otherFlags = this.GetHelper().GetFlags(other);
            // Check this value then the other value for signaling NaN
            if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            // Check this value then the other value for quiet NaN
            return ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(thisValue, ctx) : (((otherFlags &
                    BigNumberFlags.FlagQuietNaN) != 0) ? this.ReturnQuietNaN(
                      other,
                      ctx) : default(T));
        }

        private T CheckNotANumber3(
          T thisValue,
          T other,
          T other2,
          EContext ctx)
        {
            int thisFlags = this.GetHelper().GetFlags(thisValue);
            int otherFlags = this.GetHelper().GetFlags(other);
            int other2Flags = this.GetHelper().GetFlags(other2);
            // Check this value then the other value for signaling NaN
            if ((thisFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(thisValue, ctx);
            }
            if ((otherFlags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            if ((other2Flags & BigNumberFlags.FlagSignalingNaN) != 0)
            {
                return this.SignalingNaNInvalid(other, ctx);
            }
            // Check this value then the other value for quiet NaN
            return ((thisFlags & BigNumberFlags.FlagQuietNaN) != 0) ?
              this.ReturnQuietNaN(thisValue, ctx) : (((otherFlags &
                    BigNumberFlags.FlagQuietNaN) != 0) ? this.ReturnQuietNaN(
                      other,
                      ctx) :
                (((other2Flags & BigNumberFlags.FlagQuietNaN) !=
                    0) ? this.ReturnQuietNaN(other, ctx) : default(T)));
        }

        private T SignalingNaNInvalid(T value, EContext ctx)
        {
            if (ctx != null && ctx.HasFlags)
            {
                ctx.Flags |= EContext.FlagInvalid;
            }
            return this.ReturnQuietNaN(value, ctx);
        }

        private T CheckNotANumber1(T val, EContext ctx)
        {
            return this.HandleNotANumber(val, val, ctx);
        }

        private T CheckNotANumber2(T val, T val2, EContext ctx)
        {
            return this.HandleNotANumber(val, val2, ctx);
        }

        private T PreRound(T val, EContext ctx)
        {
            return NumberUtility.PreRound(val, ctx, this.wrapper);
        }

        public T DivideToIntegerNaturalScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            divisor = this.PreRound(divisor, ctx2);
            thisValue = this.wrapper.DivideToIntegerNaturalScale(
              thisValue,
              divisor,
              ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        public T DivideToIntegerZeroScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            divisor = this.PreRound(divisor, ctx2);
            thisValue = this.wrapper.DivideToIntegerZeroScale(
              thisValue,
              divisor,
              ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        public T Abs(T value, EContext ctx)
        {
            T ret = this.CheckNotANumber1(value, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            value = this.PreRound(value, ctx2);
            value = this.wrapper.Abs(value, ctx2);
            return this.PostProcess(value, ctx, ctx2);
        }

        public T Negate(T value, EContext ctx)
        {
            T ret = this.CheckNotANumber1(value, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            value = this.PreRound(value, ctx2);
            value = this.wrapper.Negate(value, ctx2);
            return this.PostProcess(value, ctx, ctx2);
        }

        public T Remainder(
          T thisValue,
          T divisor,
          EContext ctx,
          bool roundAfterDivide)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            divisor = this.PreRound(divisor, ctx2);
            thisValue = this.wrapper.Remainder(
              thisValue,
              divisor,
              ctx2,
              roundAfterDivide);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            divisor = this.PreRound(divisor, ctx2);
            thisValue = this.wrapper.RemainderNear(thisValue, divisor, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Pi(EContext ctx)
        {
            return this.wrapper.Pi(ctx);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, pow, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("op was " + thisValue + ", "+pow);
            thisValue = this.PreRound(thisValue, ctx2);
            pow = this.PreRound(pow, ctx2);
            // Console.WriteLine("op now " + thisValue + ", "+pow);
            int powSign = this.GetHelper().GetSign(pow);
            thisValue = (powSign == 0 && this.GetHelper().GetSign(thisValue) == 0) ?
              this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(1), ctx2) :
              this.wrapper.Power(thisValue, pow, ctx2);
            // Console.WriteLine("was " + thisValue);
            thisValue = this.PostProcessAfterDivision(thisValue, ctx, ctx2);
            // Console.WriteLine("now " + thisValue);
            return thisValue;
        }

        public T Ln(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.Ln(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public IRadixMathHelper<T> GetHelper()
        {
            return this.wrapper.GetHelper();
        }

        public T Exp(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.Exp(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("op was " + thisValue);
            thisValue = this.PreRound(thisValue, ctx2);
            // Console.WriteLine("op now " + thisValue);
            thisValue = this.wrapper.SquareRoot(thisValue, ctx2);
            // Console.WriteLine("result was " + thisValue);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.NextMinus(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, otherValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            otherValue = this.PreRound(otherValue, ctx2);
            thisValue = this.wrapper.NextToward(thisValue, otherValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.NextPlus(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T DivideToExponent(
          T thisValue,
          T divisor,
          EInteger desiredExponent,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            divisor = this.PreRound(divisor, ctx2);
            thisValue = this.wrapper.DivideToExponent(
              thisValue,
              divisor,
              desiredExponent,
              ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        // <summary>Divides two T objects.</summary>
        // <param name='thisValue'></param>
        // <summary>Divides two T objects.</summary>
        // <param name='thisValue'></param>
        // <param name='divisor'></param>
        // <param name='ctx'> (3).</param>
        // <returns>The quotient of the two objects.</returns>
        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, divisor, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            divisor = this.PreRound(divisor, ctx2);
            thisValue = this.wrapper.Divide(thisValue, divisor, ctx2);
            return this.PostProcessAfterDivision(thisValue, ctx, ctx2);
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.PreRound(a, ctx2);
            b = this.PreRound(b, ctx2);
            a = this.wrapper.MinMagnitude(a, b, ctx2);
            return this.PostProcess(a, ctx, ctx2);
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.PreRound(a, ctx2);
            b = this.PreRound(b, ctx2);
            a = this.wrapper.MaxMagnitude(a, b, ctx2);
            return this.PostProcess(a, ctx, ctx2);
        }

        public T Max(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.PreRound(a, ctx2);
            b = this.PreRound(b, ctx2);
            // choose the left operand if both are equal
            a = (this.CompareTo(a, b) >= 0) ? a : b;
            return this.PostProcess(a, ctx, ctx2);
        }

        public T Min(T a, T b, EContext ctx)
        {
            T ret = this.CheckNotANumber2(a, b, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            a = this.PreRound(a, ctx2);
            b = this.PreRound(b, ctx2);
            // choose the left operand if both are equal
            a = (this.CompareTo(a, b) <= 0) ? a : b;
            return this.PostProcess(a, ctx, ctx2);
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, other, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            other = this.PreRound(other, ctx2);
            thisValue = this.wrapper.Multiply(thisValue, other, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T MultiplyAndAdd(
          T thisValue,
          T multiplicand,
          T augend,
          EContext ctx)
        {
            T ret = this.CheckNotANumber3(thisValue, multiplicand, augend, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            multiplicand = this.PreRound(multiplicand, ctx2);
            augend = this.PreRound(augend, ctx2);
            // the only time the first operand to the addition can be
            // 0 is if either thisValue rounded or multiplicand
            // rounded is 0
            bool zeroA = this.GetHelper().GetSign(thisValue) == 0 ||
              this.GetHelper().GetSign(multiplicand) == 0;
            bool zeroB = this.GetHelper().GetSign(augend) == 0;
            if (zeroA)
            {
                thisValue = zeroB ?
                  this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(0), ctx2) :
                  augend;
                thisValue = this.RoundToPrecision(thisValue, ctx2);
            }
            else
            {
                thisValue = !zeroB ? this.wrapper.MultiplyAndAdd(
                  thisValue,
                  multiplicand,
                  augend,
                  ctx2) : this.wrapper.Multiply(thisValue, multiplicand, ctx2);
            }
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Plus(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.Plus(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T RoundToPrecision(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.RoundToPrecision(thisValue, ctx2);
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            // Console.WriteLine("was: "+thisValue+", "+otherValue);
            thisValue = this.PreRound(thisValue, ctx2);
            // Console.WriteLine("now: "+thisValue+", "+otherValue);
            otherValue = this.PreRound(otherValue, ctx2);
            // Apparently, subnormal values of "otherValue" raise
            // an invalid operation flag, according to the test cases
            EContext ctx3 = ctx2 == null ? null : ctx2.WithBlankFlags();
            this.wrapper.RoundToPrecision(otherValue, ctx3);
            if (ctx3 != null && (ctx3.Flags & EContext.FlagSubnormal) != 0)
            {
                return this.SignalInvalid(ctx);
            }
            thisValue = this.wrapper.Quantize(thisValue, otherValue, ctx2);
            // Console.WriteLine("result: "+thisValue);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundToExponentExact(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.RoundToExponentExact(thisValue, expOther, ctx);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundToExponentSimple(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.RoundToExponentSimple(
              thisValue,
              expOther,
              ctx2);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundToExponentNoRoundedFlag(
          T thisValue,
          EInteger exponent,
          EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.RoundToExponentNoRoundedFlag(
              thisValue,
              exponent,
              ctx);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            thisValue = this.wrapper.Reduce(thisValue, ctx);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, other, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.PreRound(thisValue, ctx2);
            other = this.PreRound(other, ctx2);
            bool zeroA = this.GetHelper().GetSign(thisValue) == 0;
            bool zeroB = this.GetHelper().GetSign(other) == 0;
            if (zeroA)
            {
                thisValue = zeroB ?
                  this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(0), ctx2) :
                  other;
                thisValue = this.RoundToPrecision(thisValue, ctx2);
            }
            else
            {
                thisValue = (!zeroB) ? this.wrapper.AddEx(
                  thisValue,
                  other,
                  ctx2,
                  true) :
                  this.RoundToPrecision(thisValue, ctx2);
            }
            return this.PostProcess(thisValue, ctx, ctx2);
        }

        public T AddEx(
          T thisValue,
          T other,
          EContext ctx,
          bool roundToOperandPrecision)
        {
            // NOTE: Ignores roundToOperandPrecision
            return this.Add(thisValue, other, ctx);
        }

        public T CompareToWithContext(
          T thisValue,
          T otherValue,
          bool treatQuietNansAsSignaling,
          EContext ctx)
        {
            T ret = this.CheckNotANumber2(thisValue, otherValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            thisValue = this.PreRound(thisValue, ctx);
            otherValue = this.PreRound(otherValue, ctx);
            return this.wrapper.CompareToWithContext(
              thisValue,
              otherValue,
              treatQuietNansAsSignaling,
              ctx);
        }

        public int CompareTo(T thisValue, T otherValue)
        {
            return this.wrapper.CompareTo(thisValue, otherValue);
        }

        public T SignalOverflow(EContext ctx, bool neg)
        {
            EContext ctx2 = GetContextWithFlags(ctx);
            T thisValue = this.wrapper.SignalOverflow(ctx, neg);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            T ret = this.CheckNotANumber1(thisValue, ctx);
            if ((object)ret != (object)default(T))
            {
                return ret;
            }
            if (this.GetHelper().GetSign(thisValue) == 0)
            {
                return this.wrapper.RoundToPrecision(this.GetHelper().ValueOf(0),
          ctx);
            }
            EContext ctx2 = GetContextWithFlags(ctx);
            thisValue = this.wrapper.RoundToPrecision(thisValue, ctx2);
            return this.PostProcessAfterQuantize(thisValue, ctx, ctx2);
        }
    }

    internal class TrappableRadixMath<T> : IRadixMath<T>
    {
        private readonly IRadixMath<T> math;

        public TrappableRadixMath(IRadixMath<T> math)
        {
#if DEBUG
            if (math == null)
            {
                throw new ArgumentNullException(nameof(math));
            }
#endif
            this.math = math;
        }

        public T DivideToIntegerNaturalScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.DivideToIntegerNaturalScale(
              thisValue,
              divisor,
              tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T DivideToIntegerZeroScale(
          T thisValue,
          T divisor,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.DivideToIntegerZeroScale(thisValue, divisor, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Abs(T value, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Abs(value, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Negate(T value, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Negate(value, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Remainder(
          T thisValue,
          T divisor,
          EContext ctx,
          bool roundAfterDivide)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Remainder(
              thisValue,
              divisor,
              tctx,
              roundAfterDivide);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public IRadixMathHelper<T> GetHelper()
        {
            return this.math.GetHelper();
        }

        public T RemainderNear(T thisValue, T divisor, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.RemainderNear(thisValue, divisor, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Pi(EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Pi(tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Power(T thisValue, T pow, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Power(thisValue, pow, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Ln(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Ln(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Exp(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Exp(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T SquareRoot(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.SquareRoot(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T NextMinus(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.NextMinus(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T NextToward(T thisValue, T otherValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.NextToward(thisValue, otherValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T NextPlus(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.NextPlus(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T DivideToExponent(
          T thisValue,
          T divisor,
          EInteger desiredExponent,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.DivideToExponent(
              thisValue,
              divisor,
              desiredExponent,
              tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Divide(T thisValue, T divisor, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Divide(thisValue, divisor, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T MinMagnitude(T a, T b, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.MinMagnitude(a, b, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T MaxMagnitude(T a, T b, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.MaxMagnitude(a, b, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Max(T a, T b, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Max(a, b, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Min(T a, T b, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Min(a, b, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Multiply(T thisValue, T other, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Multiply(thisValue, other, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T MultiplyAndAdd(
          T thisValue,
          T multiplicand,
          T augend,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.MultiplyAndAdd(
              thisValue,
              multiplicand,
              augend,
              tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Plus(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Plus(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T RoundToPrecision(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.RoundToPrecision(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Quantize(T thisValue, T otherValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Quantize(thisValue, otherValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T RoundToExponentExact(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.RoundToExponentExact(thisValue, expOther, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T RoundToExponentSimple(
          T thisValue,
          EInteger expOther,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.RoundToExponentSimple(thisValue, expOther, ctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T RoundToExponentNoRoundedFlag(
          T thisValue,
          EInteger exponent,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.RoundToExponentNoRoundedFlag(
              thisValue,
              exponent,
              ctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Reduce(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Reduce(thisValue, ctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T Add(T thisValue, T other, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.Add(thisValue, other, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T CompareToWithContext(
          T thisValue,
          T otherValue,
          bool treatQuietNansAsSignaling,
          EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.CompareToWithContext(
              thisValue,
              otherValue,
              treatQuietNansAsSignaling,
              tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        // <summary>Compares a T object with this instance.</summary>
        // <param name='thisValue'></param>
        // <returns>Zero if the values are equal; a negative number if this
        // instance is less, or a positive number if this instance is
        // greater.</returns>
        public int CompareTo(T thisValue, T otherValue)
        {
            return this.math.CompareTo(thisValue, otherValue);
        }

        public T RoundAfterConversion(T thisValue, EContext ctx)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.RoundAfterConversion(thisValue, tctx);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T SignalOverflow(EContext ctx, bool neg)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.SignalOverflow(tctx, neg);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }

        public T AddEx(
          T thisValue,
          T other,
          EContext ctx,
          bool roundToOperandPrecision)
        {
            EContext tctx = (ctx == null) ? ctx : ctx.GetNontrapping();
            T result = this.math.AddEx(
              thisValue,
              other,
              ctx,
              roundToOperandPrecision);
            return ctx == null ? result : ctx.TriggerTraps(result, tctx);
        }
    }

    internal sealed class OptionsParser
    {
        private readonly IDictionary<string, string> dict = new
        Dictionary<string, string>();

        private static string[] SplitAt(string str, string delimiter)
        {
            if (delimiter == null)
            {
                throw new ArgumentNullException(nameof(delimiter));
            }
            if (delimiter.Length == 0)
            {
                throw new ArgumentException("delimiter is empty.");
            }
            if (String.IsNullOrEmpty(str))
            {
                return new[] { String.Empty };
            }
            var index = 0;
            var first = true;
            List<string> strings = null;
            int delimLength = delimiter.Length;
            while (true)
            {
                int index2 = str.IndexOf(
                  delimiter,
                  index,
                  StringComparison.Ordinal);
                if (index2 < 0)
                {
                    if (first)
                    {
                        var strret = new string[1];
                        strret[0] = str;
                        return strret;
                    }
                    strings = strings ?? new List<string>();
                    strings.Add(str.Substring(index));
                    break;
                }
                else
                {
                    first = false;
                    string newstr = str.Substring(index, index2 - index);
                    strings = strings ?? new List<string>();
                    strings.Add(newstr);
                    index = index2 + delimLength;
                }
            }
            return (string[])strings.ToArray();
        }

        public OptionsParser(string options)
        {
            if (options == null)
            {
                throw new ArgumentNullException(nameof(options));
            }
            if (options.Length > 0)
            {
                string[] optionsArray = SplitAt(options, ";");
                foreach (string opt in optionsArray)
                {
                    int index = opt.IndexOf('=');
                    if (index < 0)
                    {
                        throw new ArgumentException("Invalid options string: " +
                          options);
                    }
                    string key = DataUtilities.ToLowerCaseAscii(opt.Substring(0,
                          index));
                    string value = opt.Substring(index + 1);
                    this.dict[key] = value;
                }
            }
        }

        public string GetLCString(string key, string defaultValue)
        {
            string lckey = DataUtilities.ToLowerCaseAscii(key);
            if (this.dict.ContainsKey(lckey))
            {
                string lcvalue = DataUtilities.ToLowerCaseAscii(this.dict[lckey]);
                return lcvalue;
            }
            return defaultValue;
        }

        public bool GetBoolean(string key, bool defaultValue)
        {
            string lckey = DataUtilities.ToLowerCaseAscii(key);
            if (this.dict.ContainsKey(lckey))
            {
                string lcvalue = DataUtilities.ToLowerCaseAscii(this.dict[lckey]);
                return lcvalue.Equals("1", StringComparison.Ordinal) ||
                  lcvalue.Equals("yes", StringComparison.Ordinal) ||
                  lcvalue.Equals("on", StringComparison.Ordinal) ||
                  lcvalue.Equals("true", StringComparison.Ordinal);
            }
            return defaultValue;
        }
    }

    

    
}
